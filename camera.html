<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>SComputers - Api Reference</title>
        <link rel="icon" href="favicon.ico">
        <link rel="stylesheet" href="style.css">
        <link href="highlight.css" rel="stylesheet">
        <script src="highlight.js"></script>
        <script>
			hljs.highlightAll();
		</script>
    </head>
    <body>
        <a class="text" href="index.html">main page</a>
        <br/>
        <a class="text" href="api.html#docsel">main page - api reference</a>
        <br/>
        <a class="text" href="components.html">main page - components</a>

        <br/>
        <p class="text">
            the camera allows you to get a picture from the world and display it on the screen (or process it inside the program)<br/>
            please note that rendering methods may receive not the real display, but the "virtual" one you created. 3 methods should be implemented in the virtual screen: getWidth, getHeight, drawPixel<br/>
            please note that when transmitting a virtual display, the camera returns colors in string format, which slows down its operation. this is done for compatibility with old software. however, if your code is ready to accept objects with the Color type, then add the "noCameraEncode" field to the table of your virtual display equal to true. The vdisplay library does this by default. in cases where CustomDraw is used with this flag, your virtual display will receive the actual value from the renderer<br/>
            this can be used, for example, to save an image to disk (methods for this are already implemented in the <a href="image.html" class="hyper">image library</a>)<br/>
            however, if you are just going to display the image on the displays, then provide the camera with a REAL DISPLAY. since transferring the virtual display disables very important camera optimizations<br/>
            to connect the camera via the antenna, use <a href="cameraTunnel.html" class="hyper">cameraTunnel component</a>
        </p>

        <p class="text">methods:</p>
        <ul class="list">
            <p class="text">advanced render settings (default / false):</p>
            <p class="text">
                <pre>
                    <code class="language-lua" style="width: fit-content;">{
    lampLighting = true,
    shadows = true,
    smoothingTerrain = true,
    simpleShadows = true,
    sun = true, --is the solar disk being rendered
    fog = true,
    reduceAccuracy = true, --allows you to use fewer display effects in fog and simpleShadows, which increases performance in some cases

    constDayLightValue = nil, --you can make a constant time of day
    shadowMultiplier = 0.6,
    sunPercentage = 0.003, --this value is the percentage of the sun from the size of the sky
    simpleShadowMin = 0.3, --the minimum brightness of an object that a simple shadow can give
    simpleShadowMax = 1, --the maximum brightness of an object that a simple shadow can give

    customWaterColor = nil,
    customChemicalColor = nil,
    customOilColor = nil,

    constColor = nil, --allows you to make all objects in one color
    constSkyColor = nil, --by default, it depends on the time of day
    customSunColor = nil, --you can change the color of the sun
    constShapeColor = nil,
    customLiftColor = nil,
    constTerrainColor = nil, --you can make the whole terrain one color, even blue
    constCharacterColor = nil,
    constJointColor = nil,
    constHarvestableColor = nil, --allows all Harvestables to be the same color, instead of their real color
    constAssetsColor = nil, --you can set the constant color of assets so that it is always 1 and is not determined by the material

    customTerrainColor_dirt = nil,
    customTerrainColor_grass = nil,
    customTerrainColor_sand = nil,
    customTerrainColor_stone = nil,
}</code>
                </pre>
            </p>

            <p class="text">advanced render settings (true / fastmode):</p>
            <p class="text">
                <pre>
                    <code class="language-lua" style="width: fit-content;">{
    lampLighting = false,
    shadows = false,
    smoothingTerrain = false,
    simpleShadows = true,
    sun = true, --is the solar disk being rendered
    fog = true,
    reduceAccuracy = true, --allows you to use fewer display effects in fog and simpleShadows, which increases performance in some cases

    constDayLightValue = nil, --you can make a constant time of day
    shadowMultiplier = 0.6,
    sunPercentage = 0.003, --this value is the percentage of the sun from the size of the sky
    simpleShadowMin = 0.3, --the minimum brightness of an object that a simple shadow can give
    simpleShadowMax = 1, --the maximum brightness of an object that a simple shadow can give

    customWaterColor = nil,
    customChemicalColor = nil,
    customOilColor = nil,

    constColor = nil, --allows you to make all objects in one color
    constSkyColor = nil, --by default, it depends on the time of day
    customSunColor = nil, --you can change the color of the sun
    constShapeColor = nil,
    customLiftColor = nil,
    constTerrainColor = nil, --you can make the whole terrain one color, even blue
    constCharacterColor = nil,
    constJointColor = nil,
    constHarvestableColor = nil, --allows all Harvestables to be the same color, instead of their real color
    constAssetsColor = nil, --you can set the constant color of assets so that it is always 1 and is not determined by the material

    customTerrainColor_dirt = nil,
    customTerrainColor_grass = nil,
    customTerrainColor_sand = nil,
    customTerrainColor_stone = nil,
}</code>
                </pre>
            </p>

            <br/>
            <li><span>drawAdvanced(display, settings:table|boolean|nil) - it gives the best picture for the camera at the moment. supports the sun, the change of day and night, shadows, lamp lighting, the color of the earth</span></li>
            <li><span>drawColorWithDepth(display, noCollideColor, terrainColor, unitsColor) - a fairly simple display mode</span></li>
            <li><span>drawColor(display, noCollideColor, terrainColor, unitsColor) - the fastest display mode. it gives a picture of not the best quality</span></li>
            <li><span>drawDepth(display, baseColor, noCollideColor, unitsColor) - It doesn't give a very pretty picture</span></li>
            <li><span>drawCustom(display, drawer, ...) - allows you to make your own display mode. it is suitable for creating various kinds of thermal imagers, etc. however, this mode is very laggy (especially in multiplayer)</span></li>
            <li><span>setStep(number) - sets the number of pixels that the camera will render per tick (maximum 4096)</span></li>
            <li><span>getStep():number - returns the number of pixels that the camera will render in tick</span></li>
            <li><span>setDistance(number) - sets the drawing distance for the camera in meters (maximum 2048)</span></li>
            <li><span>getDistance():number - returns the camera's drawing distance</span></li>
            <li><span>setFov(number) - sets the fov for the camera by X and by Y (maximum 165, minimum 1)</span></li>
            <li><span>setNonSquareFov(number, number) - sets a non-square FOV for the camera, ideal for non-square displays (maximum 165, minimum 1)</span></li>
            <li><span>getFovX():number - returns the camera's fov by X</span></li>
            <li><span>getFovY():number - returns the camera's fov by Y</span></li>
            <li><span>getFov():number - returns the camera's fov. if the fov is not square it returns the maximum value</span></li>
            <li><span>getNextPixel():number - returns the current value of the counter</span></li>
            <li><span>setNextPixel(number) - sets the value of the pixel counter</span></li>
            <li><span>resetCounter() - resets the camera pixel counter (starts rendering the screen first)</span></li>
            <li><span>rawRay(xAngle:number, yAngle:number, distance:number):table - ray shoots from the camera and gives out a table {color = smcolor, distance = distance, fraction = (distance / maxdist), uuid = uuid, type = character/shape/harvestable/lift/joint/terrain/asset/limiter, normalWorld=some of the information from raycast}. maxdist is the maximum distance for raycast in meters. please note that the angle can be set from -82.5 to 82.5 degrees, it is transmitted in radians. limiter is the wall of the world. please note that not all types of objects have the "uuid" field. please note that getting the uuid of a block only works if it is no further than 4 meters (16 blocks) from the camera(this is done to maintain a balance)</span></li>
            <li><span>setViewport(x, y, sizeX, sizeY) - you can specify the frame inside which the camera will display the image on the display. to reset you need call without arguments</span></li>
            <li><span>getViewport():x, y, sizeX, sizeY - returns what was set using setViewport</span></li>
            <li><span>resetDetectableObjects() - selects all the objects that the camera will see</span></li>
            <li><span>setDetectableObjects({<br/>
                liquids = boolean,<br/>
                dynamicBody = boolean,<br/>
                staticBody = boolean,<br/>
                characters = boolean,<br/>
                joints = boolean,<br/>
                terrain = boolean,<br/>
                assets = boolean,<br/>
                harvestable = boolean<br/>
            }) - sets the list of objects that the camera will see, by default, all are selected</span></li>
            <li><span>getDetectableObjects():table - returns a reference to the last table passed to setDetectableObjects. However, if you edit it, you must send it to setDetectableObjects again so that the camera can see the changes.</span></li>
        </ul>

        <br/>
        <p class="text">
            if you just want to get a picture on the screen, then use this code
            <pre>
                <code class="language-lua" style="width: fit-content;">local fastmode = false
                    
local display = getComponent("display")
display.reset()
display.clear()
display.setSkipAtNotSight(true) --in order for the picture not to be updated for those who do not look at the screen

local camera = getComponent("camera")
local fov = math.rad(60)
camera.setNonSquareFov(fov * (display.getWidth() / display.getHeight()), fov)
camera.setStep(512)

local renderSettings = {
    lampLighting = not fastmode,
    shadows = not fastmode,
    smoothingTerrain = not fastmode,
    simpleShadows = true,
    sun = true, --is the solar disk being rendered
    fog = true,
    reduceAccuracy = true, --allows you to use fewer display effects in fog and simpleShadows, which increases performance in some cases

    constDayLightValue = nil, --you can make a constant time of day
    shadowMultiplier = 0.6,
    sunPercentage = 0.003, --this value is the percentage of the sun from the size of the sky
    simpleShadowMin = 0.3, --the minimum brightness of an object that a simple shadow can give
    simpleShadowMax = 1, --the maximum brightness of an object that a simple shadow can give

    customWaterColor = nil,
    customChemicalColor = nil,
    customOilColor = nil,

    constColor = nil, --allows you to make all objects in one color
    constSkyColor = nil, --by default, it depends on the time of day
    customSunColor = nil, --you can change the color of the sun
    constShapeColor = nil,
    customLiftColor = nil,
    constTerrainColor = nil, --you can make the whole terrain one color, even blue
    constCharacterColor = nil,
    constJointColor = nil,
    constHarvestableColor = nil, --allows all Harvestables to be the same color, instead of their real color
    constAssetsColor = nil, --you can set the constant color of assets so that it is always 1 and is not determined by the material

    customTerrainColor_dirt = nil,
    customTerrainColor_grass = nil,
    customTerrainColor_sand = nil,
    customTerrainColor_stone = nil,
}

function callback_loop()
    if _endtick then
        display.clear()
        display.forceFlush()
        return
    end

    if display.getAudience() > 0 then --if no one is looking at the screen at all, then the camera will not work
        camera.drawAdvanced(display, renderSettings)
        display.flush()
    end
end</code>
            </pre>
        </p>

        <br/>
        <p class="text">
            render under mushrooms
            <pre>
                <code class="language-lua" style="width: fit-content;">--this type of render does not have an optimization that transfers the render to the client, which leads to a strong ping in multiplayer
--in general, custom render is about 35% slower than the built-in similar options
--in addition, it does not have access to some of the data that advanced render uses
--in multiplayer, this code will run about 200% slower

local colors = require("colors")

local display = getComponents("display")[1]
display.reset()
display.clear()
display.setSkipAtNotSight(true) --in order for the picture not to be updated for those who do not look at the screen

local camera = getComponents("camera")[1]
local fov = math.rad(60)
camera.setNonSquareFov(fov * (display.getWidth() / display.getHeight()), fov)
camera.setStep(512)

function callback_loop()
    if _endtick then
        display.clear()
        display.forceFlush()
        return
    end

    if display.getAudience() > 0 then
        camera.drawCustom(display, function (x, y, raydata)
            if not raydata then
                return sm.color.new(0, math.random(), math.random())
            elseif raydata.type == "limiter" then
                return sm.color.new(math.random(), math.random(), math.random())
            elseif raydata.type == "terrain" then
                return sm.color.new(0, math.random(), 0)
            elseif raydata.type == "asset" then
                return sm.color.new(math.random(), 0, 0)
            end
            return sm.color.new(colors.hsvToRgb(((x + y) / 32) % 1, 1, 1)) * (raydata.color or sm.color.new(1, 1, 1))
        end)
        display.flush()
    end
end</code>
            </pre>
        </p>

        <br/>
        <p class="text">
            It's like a thermal imager.
            <pre>
                <code class="language-lua" style="width: fit-content;">--this type of render does not have an optimization that transfers the render to the client, which leads to a strong ping in multiplayer
--in general, custom render is about 35% slower than the built-in similar options
--in addition, it does not have access to some of the data that advanced render uses
--in multiplayer, this code will run about 200% slower

local display = getComponents("display")[1]
display.reset()
display.clear()
display.setSkipAtNotSight(true) --in order for the picture not to be updated for those who do not look at the screen

local camera = getComponents("camera")[1]
local fov = math.rad(60)
camera.setNonSquareFov(fov * (display.getWidth() / display.getHeight()), fov)
camera.setStep(512)

function callback_loop()
    if _endtick then
        display.clear()
        display.forceFlush()
        return
    end

    if display.getAudience() > 0 then
        camera.drawCustom(display, function (x, y, raydata)
            if not raydata or raydata.type == "limiter" then
                return 0x000000
            elseif raydata.type == "terrain" then
                return 0x00164e
            elseif raydata.type == "asset" then
                return 0x003554
            elseif raydata.type == "character" then
                return 0x880200
            elseif raydata.type == "shape" then
                return 0x875100
            end
            return 0
        end)
        display.flush()
    end
end</code>
        </pre>
        </p>

    

        <br/>
        <p class="text">
            saving an image from the camera to disk<br/>
            the saving takes place in the scimg8 format, which has an 8-bit palette<br/>
            saving takes place using the <a href="image.html" class="hyper">image library</a>
            <pre>
                <code class="language-lua" style="width: fit-content;">--this simplest camera demonstrates the operation of the "image" library
--red button - make photo
--green button - show photo

local image = require("image")
local colors = require("colors")

local imagePath = "/image.scimg8"

local display = getComponent("display")
local disk = getComponent("disk")
local camera = getComponent("camera")

if input(colors.sm.Red[2]) then
    disk.clear()

    local img = image.new(display.getWidth(), display.getHeight(), sm.color.new(0, 0, 0))
    img:fromCameraAll(camera, "drawAdvanced")
    img:save8(disk, imagePath)

    display.clear("0000ff")
    display.drawText(1, 1, "photo maked!")
    display.forceFlush()
elseif input(colors.sm.Green[2]) then
    if disk.hasFile(imagePath) then
        local img = image.load(disk, imagePath)
        display.clear()
        img:draw(display)
        display.forceFlush()
    else
        display.clear("0000ff")
        display.drawText(1, 1, "no photo")
        display.forceFlush()
    end
end

function callback_loop()
    if _endtick then
        display.clear()
        display.forceFlush()
    end
end</code>
            </pre>
        </p>

    </body>
</html>