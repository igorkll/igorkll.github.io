<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>SComputers - Api Reference</title>
        <link rel="icon" href="favicon.ico">
        <link rel="stylesheet" href="style.css">
        <link href="highlight.css" rel="stylesheet">
        <script src="highlight.js"></script>
        <script>
            hljs.highlightAll();
        </script>
    </head>
    <body>
        <p class="text">
            usage: require("gui")<br/>
            this is probably the most useful library in SComputers<br/>
            it makes it easy to create graphical interfaces and even windows<br/>
            the library supports automatic calculation of the size and position of elements<br/>
            the library supports only the basic objects, but you are not restricted by them! you can create your own objects and add them to the GUI<br/>
            there is also an <a href="objs.html" class="hyper">objs library</a> in the mod that contains ready-made additional GUI objects<br/>
            there is also a <a href="styles.html" class="hyper">styles library</a> in mod that contains styles for objects that can be applied to any object and its drawer callback will be replaced with a style<br/>
        </p>

        <br/>
        <p class="text">methods:</p>
        <ul class="list">
            <li><span>gui.new(display):guiinstance - creates a new gui instance for a display</span></li>
            <li><span>gui.calculateSizeByText(object):number|nil, number|nil - automatically calculates the size of the element based on the text. adds padding, which is 2 pixels by default (use setDefaultPadding to change).</span></li>
            <li><span>gui.calculateSizeByImage(object):number|nil, number|nil - calculates the size of the element based on the size of the image</span></li>
        </ul>

        <br/>
        <p class="text">constants:</p>
        <ul class="list">
            <li><span>gui.intersectionMode.disabled - 0</span></li>
            <li><span>gui.intersectionMode.windows - 1</span></li>
            <li><span>gui.intersectionMode.fullcheck - 2</span></li>
            <li><span>gui.intersectionMode.auto - 3</span></li>
            <li><span>gui.intersectionMode.advanced - 4</span></li>
            <br/>
            <li><span>gui.layerMode.auto - 0</span></li>
            <li><span>gui.layerMode.static - 1</span></li>
            <li><span>gui.layerMode.topLayer - 2</span></li>
            <li><span>gui.layerMode.bottomLayer - 3</span></li>
        </ul>

        <br/>
        <p class="text">guiinstance methods:</p>
        <ul class="list">
            <li><span>guiinstance:createScene(nil|color|function(guiscene), nil|backgroundTouchDetector(guiscene, click)):guiscene - creates a new scene on the current gui instance.<br/>
            now, instead of backgroundTouchDetector, you can use guiscene:onBackgroundClick, which also provides the ability to process clicks within an objects</span></li>
            <li><span>guiinstance:tick() - call each tick (in callback_loop / onTick)</span></li>
            <li><span>guiinstance:needFlush():boolean - returns true if you need to call gui:draw() and display.flush()</span></li>
            <li><span>guiinstance:draw() - redraws the scene if necessary (it is better to do the check using needFlush anyway)</span></li>
            <li><span>guiinstance:drawForce() - forcibly redraws the scene. this makes sense if you need to redraw the background (for example, the camera is working on it)</span></li>
        </ul>

        <br/>
        <p class="text">guiscene methods:</p>
        <ul class="list">
            <li><span>guiscene:setObjectIntersectionMode(number|boolean) - sets the mode for checking the intersection of objects (default: 3)</span></li>
            <div class="cool-text" style="background-color: var(--color-note);">
                the intersection check can work in three modes:<br>
                <ul>
                    <li>0/false. disabled - it is not suitable if you use draggable windows and you don't use gui:drawForce()</li>
                    <li>1. windows - the check with all windows</li>
                    <li>2. fullcheck - the check with all objects on scene (very laggy)</li>
                    <li>3/true. auto - enables mode 1 if at least one window is created, and mode 0 if there are no windows</li>
                    <li>4. advanced - the check with all windows and all the objects on in the same container</li>
                </ul>
            </div>
            <li><span>guiscene:setAlwaysRedraw(boolean) - enable it so that the scene constantly redraws all objects. it makes sense if the camera is working in the background (default: false)</span></li>
            <li><span>guiscene:isAlwaysRedraw():boolean - returns the value set using guiscene:setAlwaysRedraw (default: false)</span></li>
            <li><span>guiscene:select() - makes the current scene active</span></li>
            <li><span>guiscene:update() - tells the library to redraw the scene</span></li>
        </ul>

        <br/>
        <p class="text">any object callbacks (you can implement this in the object after creation):</p>
        <ul class="list">
            <li><span>guiobject:onTick(click:table|nil) - every tick is called while your scene is selected. you also get a click table, as the display returns it</span></li>
            <li><span>guiobject:onTickIfVisible(click:table|nil) - each tick is called, but only if the object is visible</span></li>
            <li><span>guiobject:onDestroy() - called when deleting an object</span></li>
            <li><span>guiobject:onClick(click:table|nil, localX:number, localY:number) - it is called when clicking on an object. you also get a click table, as the display returns it</span></li>
            <li><span>guiobject:onDrop(click:table|nil, localX:number, localY:number) - called when the user releases the object. it will be called even if the user has moved the cursor away from the object</span></li>
            <li><span>guiobject:onDropInZone(click:table|nil, localX:number, localY:number) - called when the user releases the object. it is called only when the click is released within the object</span></li>
            <li><span>guiobject:onDrag(click:table|nil, localX:number, localY:number) - called when swiping on an object. it will be called even if the user has moved the cursor away from the object</span></li>
            <li><span>guiobject:onDragInZone(click:table|nil, localX:number, localY:number) - called when swiping on an object. it is called only when the swipe does not go beyond the boundary of the object</span></li>
            <li><span>guiobject:onTickIfPressed(click:table|nil, localX:number, localY:number) - each tick is triggered while the object is pressed</span></li>
        </ul>

        <br/>
        <p class="text">scene callbacks (you can implement this in the object after creation):</p>
        <ul class="list">
            <li><span>guiscene:onUnselect() - called when this scene is no longer selected</span></li>
            <li><span>guiscene:onSelect() - called when the scene is selected</span></li>
            <li><span>guiscene:onBackgroundClick(click:table, elementCapture:boolean) - it is called when clicking on the background. It is a more actual replacement for backgroundTouchDetector. you get all the clicks, and if you want to process only those that fall on the background (and not on any object), make the conditions that elementCapture is false</span></li>
        </ul>

        <br/>
        <p class="text">window callbacks (you can implement this in the object after creation):</p>
        <ul class="list">
            <li><span>guiwindow:onMinimize() - called when the window is minimized (it is not called when calling the guiwindow:minimize() method)</span></li>
            <li><span>guiwindow:onMaximize() - called when the window is maximized (it is not called when calling the guiwindow:minimize() method)</span></li>
            <li><span>guiwindow:onTickIfOpen(click:table|nil) - each tick is called, but only if the window is maximized. if this window is nested, then all the parent windows must also be maximized in order for this to work</span></li>
            <li><span>guiwindow:onDragging() - called when this window is drag</span></li>
        </ul>

        <br/>
        <p class="text">scene/window callbacks (you can implement this in the object after creation):</p>
        <ul class="list">
            <li><span>guiscene:onWindowDragging() - it is called when any window on this scene/window is drag. it is not called when moving windows nested in windows on this scene/window</span></li>
            <li><span>guiscene:onWindowMinimize() - it is called when the user minimizes any window on this scene/window (it is not called when calling the guiwindow:minimize() method)</span></li>
            <li><span>guiscene:onWindowMaximize() - it is called when the user maximizes any window on this scene/window (it is not called when calling the guiwindow:minimize() method)</span></li>
            <li><span>guiscene:onTick(click:table|nil) - every tick is called while your scene is selected. you also get a click table, as the display returns it</span></li>
        </ul>

        <br/>
        <p class="text">button callbacks (you can implement this in the object after creation):</p>
        <ul class="list">
            <li><span>guiobject:onToggle(state:boolean) - it is designed to get the current state of toggle button, but it also works for non-toggle buttons</span></li>
        </ul>

        <br/>
        <p class="text">scene/window methods:</p>
        <ul class="list">
            <li><span>guiscene:updateChildrenRule() - updates the placement of all children in this container according to the rule set via guiscene:setDefaultSet or via guiobject:set</span></li>
            <li><span>guiscene:realUpdateChildrenRule() - performs the same action as guiscene:updateChildrenRule() but does it right now. It is not recommended for use as it does not make sense in most tasks.</span></li>
            <li><span>guiscene:setDefaultSet(function(guiobject, previousElement|nil, container) end) - sets the default auto-placement function for all new objects in this container</span></li>
            <li><span>guiscene:getChildrenCount():number - returns the number of objects per scene/window</span></li>
            <li><span>guiscene:getContainerSize():number, number - returns the size of the container (the display resolution for the scene and the window size for the window)</span></li>
            <li><span>guiscene:setDefaultOffset(offsetX (default: 1), offsetY|nil (default: 1)) - sets the indentation of objects from each other by default when placed relative to each other using setLeft, setDown, and so on<br/>
            if you do not specify offsetY, it will have the same value as offsetX<br/>
            also note that this parameter is inherited when creating child windows</span></li>
            <li><span>guiscene:setDefaultPadding(paddingX (default: 2), paddingY|nil (default: 2)) - sets the default padding, which is used by some functions to automatically calculate the size.<br/>
            if you do not specify paddingY, it will have the same value as paddingX<br/>
            also note that this parameter is inherited when creating child windows</span></li>
            <li><span>guiscene:isScene():boolean - returns true if it is a scene and false otherwise</span></li>
            <li><span>guiscene:isSelected():boolean - returns true if the current scene is selected. in cases with the window returns true if the scene where the window is located is selected</span></li>
            <li><span>guiscene:createButton(x, y, sizeX(pass nil so that the size is calculated automatically based on the length of the text), sizeY(pass nil so that the height is calculated automatically based on the height of the font), toggle:boolean, text:string, bg:color(default: while), fg:color(default: black), bg_press:color(default: fg), fg_press:color(default: bg)):guiobject - creates a button</span></li>
            <li><span>guiscene:createImage(x, y, img):guiobject - creates an image object from the <a href="image.html" class="hyper">image library</a></span></li>
            <li><span>guiscene:createText(x, y, text, fg:color):guiobject - creates text without a border and background, has no width and height</span></li>
            <li><span>guiscene:createLabel(x, y, sizeX, sizeY, text, bg, fg):guiobject - creates a label</span></li>
            <li><span>guiscene:createTextBox(x, y, sizeX, sizeY, text, bg(optional), fg, centerX, centerY, spacingY, autoNewline, tool):guiobject - creates a textbox(the layer above the graphic.textBox)</span></li>
            <li><span>guiscene:createCustom(x, y, sizeX, sizeY, objectClass:table, ...):guiobject - creates a custom object with your class and arguments</span></li>
            <li><span>guiscene:createWindow(x, y, sizeX, sizeY, nil|color|function(guiwindow)):guiwindow - creates a window. you can create objects on it just like on a scene. by default, it does not move and does not have an upper panel</span></li>
        </ul>

        <br/>
        <p class="text">window object methods:</p>
        <ul class="list">
            <li><span>guiwindow:setDraggable(boolean) - set to true if you want your window to be able to be moved</span></li>
            <li><span>guiwindow:setAutoViewport(boolean) - if you call this with the true argument, then all objects inside the window cannot be rendered outside the window</span></li>
            <li><span>guiwindow:setColor(color|function(guiwindow)) - sets the background color of the window. it can be a drawer function</span></li>
            <li><span>guiwindow:upPanel(color, textcolor, title:string, collapsibility:boolean) - configures the top panel of the window</span></li>
            <li><span>guiwindow:panelButton(sizeX:number|nil, toggle:boolean, title, bg, fg, bg_press, fg_press) - adds a button to the top window panel. if you pass nil instead of sizeX, the button will be square</span></li>
            <li><span>guiwindow:panelObject(contructorname:string, sizeX:number|nil, ...) - it works the same way as panelButton, but it allows you to create any object: window:panelObject("createCustom", nil, class, ...)</span></li>
            <li><span>guiwindow:minimize(state:boolean) - minimizes or expands the window</span></li>
        </ul>

        <br/>
        <p class="text">button object methods:</p>
        <ul class="list">
            <li><span>guiobject:getState():boolean - returns the state of the button</span></li>
            <li><span>guiobject:setState(boolean) - sets the status of the button</span></li>
            <li><span>guiobject:isPress():boolean - returns true once when clicked</span></li>
            <li><span>guiobject:isReleased():boolean - returns true once when the button is released</span></li>
            <li><span>guiobject:attachCallback(function(guiobject, state:boolean, inZone:boolean)) - (legacy, use any object callbacks) connects the callback to the button. if you call twice, the last callback will be setted. call it without an argument to disable the callback</span></li>
            <li><span>guiobject:setSceneSwitch(guiscene) - sets the scene that will be selected when the button is clicked. note that the action will only work when the button is released and only if the user's cursor is within the button</span></li>
            <li><span>guiobject:setText(text:string) - sets text</span></li>
            <li><span>guiobject:setBgColor(color) - sets the background color</span></li>
            <li><span>guiobject:setFgColor(color) - sets the text color</span></li>
            <li><span>guiobject:setPbgColor(color) - sets the background color when clicked</span></li>
            <li><span>guiobject:setPfgColor(color) - sets the text color when clicked</span></li>
            <li><span>guiobject:setPstColor(color) - sets the stroke color when clicked</span></li>
            <li><span>guiobject:setIbgColor(color) - sets the color at the moment of interaction. it makes sense for toggle buttons, otherwise it will just replace pressed color</span></li>
            <li><span>guiobject:setIfgColor(color) - sets the color at the moment of interaction. it makes sense for toggle buttons, otherwise it will just replace pressed color</span></li>
            <li><span>guiobject:setIstColor(color) - sets the stroke color at the moment of interaction. it makes sense for toggle buttons, otherwise it will just replace pressed color</span></li>
            
        </ul>

        <br/>
        <p class="text">image object methods:</p>
        <ul class="list">
            <li><span>guiobject:updateImage(img) - sets a different image for the object and redraws the object. if you transfer the same image, the object will still be redrawn, this is done because you can change the image</span></li>
        </ul>

        <br/>
        <p class="text">label object methods:</p>
        <ul class="list">
            <li><span>guiobject:setText(text:string) - sets text</span></li>
            <li><span>guiobject:setBgColor(color) - sets the background color</span></li>
            <li><span>guiobject:setFgColor(color) - sets the text color</span></li>
            <li><span>guiobject:setStColor(color) - sets the stroke color</span></li>
            <li><span>guiobject:setIbgColor(color) - sets the color at the moment of interaction</span></li>
            <li><span>guiobject:setIfgColor(color) - sets the color at the moment of interaction</span></li>
            <li><span>guiobject:setIstColor(color) - sets the stroke color at the moment of interaction</span></li>
        </ul>

        <br/>
        <p class="text">text object methods:</p>
        <ul class="list">
            <li><span>guiobject:setText(text:string) - sets text</span></li>
            <li><span>guiobject:setFgColor(color) - sets the text color</span></li>
            <li><span>guiobject:setIfgColor(color) - sets the color at the moment of interaction</span></li>
        </ul>

        <br/>
        <p class="text">textbox object methods:</p>
        <ul class="list">
            <li><span>guiobject:setText(text:string) - sets text</span></li>
            <li><span>guiobject:setBgColor(color(optionally, there may be nil for transparency)) - sets the background color</span></li>
            <li><span>guiobject:setFgColor(color) - sets the text color</span></li>
            <li><span>guiobject:setStColor(color) - sets the stroke color</span></li>
            <li><span>guiobject:setIbgColor(color) - sets the color at the moment of interaction</span></li>
            <li><span>guiobject:setIfgColor(color) - sets the color at the moment of interaction</span></li>
            <li><span>guiobject:setIstColor(color) - sets the stroke color at the moment of interaction</span></li>
        </ul>

        <br/>
        <p class="text">any object methods (these methods are relevant for any type of object, including custom and window):</p>
        <ul class="list">
            <li><span>guiobject:destroy() - deletes an object. after calling this method, do not use the handle of this object</span></li>
            <li><span>guiobject:getLastInteractionType():number or nil - returns the type of the last interaction(1-E 2-U)</span></li>
            <li><span>guiobject:getLastNickname():string or nil - returns the nickname of the last player who interacted with the object</span></li>
            <li><span>guiobject:update() - forced redrawing of the object will occur at the next gui.draw call. forces needDraw to return true. use it when you have changed some parameter of the object bypassing the control methods. also, call it for self in the custom object code if it needs to be redrawn</span></li>
            <li><span>guiobject:realUpdate() - triggers the update action now. It is not recommended for use</span></li>
            <li><span>guiobject:clear(color, minWidth:number|nil, minHeight:number|nil) - clears the place where the object is located with the selected color, if the color is not passed, the color of the scene will be used (if there is one). you can specify the minimum area to fill in, in case you have reduced the size of the object and want to cover the old content</span></li>
            <li><span>guiobject:setCustomStyle(function(gobj) ) - sets the function that will be used to draw the object instead of the standard one</span></li>
            <li><span>guiobject:setDisabled(disabled:boolean) - pass true so that the object stops being interactive, pass true so that the object becomes interactive again</span></li>
            <li><span>guiobject:setInvisible(invisible:boolean) - pass true so that the object is not drawn, pass false so that the object becomes visible again</span></li>
            <li><span>guiobject:setFontParameters(font:table|nil, sizeX:number|nil, sizeY:number|nil, textSpacing:number|nil) - sets the font and its size for a specific object</span></li>
            <li><span>guiobject:redraw() - redraw an object right now</span></li>
            <li><span>guiobject:setBottomLayer() - moves the object to the lowest layer</span></li>
            <li><span>guiobject:setTopLayer() - moves the object to the topmost layer</span></li>
            <li><span>guiobject:getDisplaySize():number, number - returns the size of the block that the object occupies on the display</span></li>
            <li><span>guiobject:isVisible():boolean - returns true if the "invisible" flag is not set for the object and the window on which it is located is not minimized (it is taken into account that windows can be nested and the object can be created on the window header)</span></li>
            <li><span>guiobject:updateParent() - updates the parent object of this object</span></li>
            <li><span>guiobject:getParent():guiobject/guiscene - returns the parent object (guiwindow/guiscene)</span></li>
            <li><span>guiobject:getLayer():number - returns the layer where the object is located</span></li>
            <li><span>guiobject:setLayer(number) - changes the layer on which the object is located</span></li>
            <li><span>guiobject:setLayerMode(mode:number) - sets the layer mode for the object (default: 0 for window, 1 for other objects)</span></li>
            <div class="cool-text" style="background-color: var(--color-note);">
                layer mode options:<br>
                <ul>
                    <li>0. automatic transition to the top level during interaction (default)</li>
                    <li>1. without auto-change</li>
                    <li>2. always top layer</li>
                    <li>3. always bottom layer</li>
                </ul>
            </div>
            <li><span>guiobject:updateLayer() - moves an object to a layer according to the rule set via setLayerMode, this usually happens automatically, so you don't have to use this function</span></li>
        </ul>

        <br/>
        <p class="text">functions for specifying the position of objects:</p>
        <ul class="list">
            <li><span>guiobject:set(function(guiobject, previousElement|nil, container) end) - this function is used to specify the auto-positioning rules for an element</span></li>

            <br/>
            <li><span>guiobject:setCenter(offsetX:number, offsetY:number, guiobject(optional, it will be used as a reference point)) - sets the object to the center of the scene (or other object), you can set the offset</span></li>
            <li><span>guiobject:setCenterX(offsetX:number, guiobject(optional, it will be used as a reference point)) - sets the object to the center of the scene (or other object) by x, you can set the offset</span></li>
            <li><span>guiobject:setCenterY(offsetY:number, guiobject(optional, it will be used as a reference point)) - sets the object to the center of the scene (or other object) by y, you can set the offset</span></li>
            <li><span>guiobject:setPosition(x:number, y:number) - changes the position of the object</span></li>
            <li><span>guiobject:setPositionX(x:number) - changes the position of the object by X</span></li>
            <li><span>guiobject:setPositionY(y:number) - changes the position of the object by Y</span></li>
            <li><span>guiobject:setOffsetPosition(guiobject, offsetX:number, offsetY:number) - sets the position of one object relative to the position of another object</span></li>
            <li><span>guiobject:setOffsetPositionX(guiobject, offsetX:number) - sets the position of one object relative to the position of another object</span></li>
            <li><span>guiobject:setOffsetPositionY(guiobject, offsetY:number) - sets the position of one object relative to the position of another object</span></li>
            <li><span>guiobject:setSize(width:number, height:number) - sets the size of the object. if you omit one or both parameters, they will be calculated automatically based on the internal rules of the object and the settings of the scene/window</span></li>

            <br/>
            <li><span>guiobject:setCenterLeft(guiobject, offset (default: 1)) - sets the position of one object relative to the position of another object. centers on a different coordinate</span></li>
            <li><span>guiobject:setCenterRight(guiobject, offset (default: 1)) - sets the position of one object relative to the position of another object. centers on a different coordinate</span></li>
            <li><span>guiobject:setCenterUp(guiobject, offset (default: 1)) - sets the position of one object relative to the position of another object. centers on a different coordinate</span></li>
            <li><span>guiobject:setCenterDown(guiobject, offset (default: 1)) - sets the position of one object relative to the position of another object. centers on a different coordinate</span></li>

            <br/>
            <li><span>guiobject:setLeft(guiobject, offset (default: 1)) - sets the position of one object relative to the position of another object. the object will be shifted to a different coordinate in the direction of its decrease</span></li>
            <li><span>guiobject:setRight(guiobject, offset (default: 1)) - sets the position of one object relative to the position of another object. the object will be shifted to a different coordinate in the direction of its decrease</span></li>
            <li><span>guiobject:setUp(guiobject, offset (default: 1)) - sets the position of one object relative to the position of another object. the object will be shifted to a different coordinate in the direction of its decrease</span></li>
            <li><span>guiobject:setDown(guiobject, offset (default: 1)) - sets the position of one object relative to the position of another object. the object will be shifted to a different coordinate in the direction of its decrease</span></li>

            <br/>
            <li><span>guiobject:setShiftedLeft(guiobject, offset (default: 1)) - sets the position of one object relative to the position of another object. the object will be shifted to a different coordinate in the direction of its increase</span></li>
            <li><span>guiobject:setShiftedRight(guiobject, offset (default: 1)) - sets the position of one object relative to the position of another object. the object will be shifted to a different coordinate in the direction of its increase</span></li>
            <li><span>guiobject:setShiftedUp(guiobject, offset (default: 1)) - sets the position of one object relative to the position of another object. the object will be shifted to a different coordinate in the direction of its increase</span></li>
            <li><span>guiobject:setShiftedDown(guiobject, offset (default: 1)) - sets the position of one object relative to the position of another object. the object will be shifted to a different coordinate in the direction of its increase</span></li>

            <br/>
            <li><span>guiobject:setBorderLeft(offset (default: 1)) - presses your object against the border</span></li>
            <li><span>guiobject:setBorderRight(offset (default: 1)) - presses your object against the border</span></li>
            <li><span>guiobject:setBorderUp(offset (default: 1)) - presses your object against the border</span></li>
            <li><span>guiobject:setBorderDown(offset (default: 1)) - presses your object against the border</span></li>
        </ul>

        <br/>
        <div class="cool-text" style="background-color: var(--color-note);">
            you can place objects not by absolute positions, but relative to others using the functions listed above<br/>
            you can also set a rule function (use: guiobject:set() or guiscene/guiwindow:setDefaultSet()) for your objects that will contain instructions for automatic placement and size setting<br/>
            next, set a rule for the placement of elements inside this function<br/>
        </div>

        <br/>
        <div class="cool-text" style="background-color: var(--color-note);">
            if you are changing the position of an object in real time, you will need to call obj:updateParent() to update the scene or window where it is located<br>
            alternatively, you can first call obj:clear() to fill in the space behind the object, and after changing the position, call obj:update() to update only the object itself, but this method will not always work (for example, if the object is located on an object where the background is a image)<br>
            i recommend trying both of these methods and comparing the performance in your situation
        </div>

        <br/>
        <div class="cool-text" style="background-color: var(--color-note);">
            by default, the gui library has enabled object intersection checking (if at least one window has been created) to redraw the objects that are above automatically<br>
            this allows you to change the contents of the objects below the windows without worrying that it will overlap the content above<br>
            the intersection check can work in three modes:<br>
            <ul>
                <li>0/false. disabled - it is not suitable if you use draggable windows and you don't use gui:drawForce()</li>
                <li>1. windows - the check with all windows</li>
                <li>2. fullcheck - the check with all objects on scene (very laggy)</li>
                <li>3/true. auto - enables mode 1 if at least one window is created, and mode 0 if there are no windows</li>
                <li>4. advanced - the check with all windows and all the objects on in the same container</li>
            </ul>
            if you don't use object overlay, then it makes sense to disable this feature to save performance. use to do this: scene:setObjectIntersectionMode(false) or scene:setObjectIntersectionMode(0)<br>
            also, if you use gui:drawForce(), then you don't need the intersection check function to make everything work correctly.<br>
        </div>

        <br/>
        <h2 class="text">gui tabs:</h2>
        <pre>
            <code class="language-lua" style="width: fit-content;">--example for display 128x128
local display = getComponents("display")[1]
display.reset()
display.clearClicks()
display.setClicksAllowed(true)
local rx, ry = display.getWidth(), display.getHeight()

local gui = require("gui").new(display)
local styles = require("styles")
local objs = require("objs")
local scene = gui:createScene("777777")

local horizontalTabBar = scene:createCustom(0, 0, rx, 8, objs.tabbar, 0x444444, false, nil, 3)

for ix = 1, 4 do
    local window = horizontalTabBar:createOtherspaceWindow()
    local verticleTabBar = window:createCustom(0, 0, 26, ry - horizontalTabBar.sizeY, objs.tabbar, 0x444444, true, nil, 3)
    for iy = 1, 4 do
        local window2 = verticleTabBar:createOtherspaceWindow()
        verticleTabBar:addTab("VTAB" .. iy, window2)

        window2:createLabel(0, 0, window2.sizeX, window2.sizeY, "HTAB: " .. ix .. "\n" .. "VTAB: " .. iy, 0x000088, 0xffffff)
    end
    horizontalTabBar:addTab("HTAB" .. ix, window)
end

function callback_loop()
    if _endtick then
        display.clear()
        display.flush()
        return
    end

    gui:tick()
    if gui:needFlush() then
        gui:draw()
        display.flush()
    end
end</code>
        </pre>

        <br/>
        <h2 class="text">custom object class example:</h2>
        <pre>
            <code class="language-lua" style="width: fit-content;">{
    useWindow = false, --by default, false, if set to true, your object will be created as a window, which will allow you to create child objects on it
    layerMode = 1, --default layerMode. by default 1
    autoViewport = false, --the default is false, but you can set this to true to limit your object rendering to the border of your object
    handlerLocalPosition = false, --by default, this is false, but you can set this to true so that the values in the "handler" are local to the object
    handlerAllClicks = false, --by default, false. if set to true, your handler will receive all clicks in general, even if they are in no way related to your object
    handlerOutsideDrag = false, --by default, false. if set to true, you will receive drag events, including outside your object, if the first click was inside your object
    --It makes sense to enable this flag even if you are using handlerAllClicks, as this will tell the gui library that your object remains "grappable" even when the user removes the cursor but does not release the button.
    init = function(self, ...) --you can execute code when creating an object, and you can also receive arguments
        local args = {...}
        --carefully create parameters in yourself to avoid conflicts with the gui library itself.
        --for example, names like "state" and "touchX" are already occupied, which may not be obvious
        --to avoid conflicts for sure, it's better to create a separate table in self to store the parameters of your object
        self.myVars = {creationArgs = args, example = 1, color = 0xff0000}
    end,
    drawer = function(self) --implement the rendering of your object here
        self.display.fillRect(self.x, self.y, self.sizeX, self.sizeY, self.myVars.color) --example
    end,
    handler = function(self, x, y, clickType, button, nickname, inZone, elementCapture) --handles item touches. please note that by default you get the global coordinates of the display!
        --please note that you may receive parameters: -1, -1, "released", -1, "unknown"
        --this happens if the object was activated during scene switching
        --you can also get a position outside of your object during "released" in cases where the user clicked on the object and released the touch outside the object, you will still receive an event, but it will be outside the object
        --if you have the handlerOutsideDrag flag set, you will receive drag events outside your object if the first click was inside your object
        --inZone is set to true if the click occurs inside the object, it works independently of handlerLocalPosition and handlerAllClicks
        --elementCapture is a flag that is used if your custom object is running in useWindow mode, it is set to true if it is currently interacting with a child object
        if clickType == "pressed" then
            self.myVars.color = math.random(0, 0xffffff)
            self:update() --you can return true from this function instead of explicitly calling self:update()
        end
    end,
    destroyHandler = function(self) --called when your object is deleted
        
    end,
    calculateSize = function(self) --you can define this function to automatically calculate the size of your object. you can write it yourself or use a ready-made function from gui library
        return 16, 16
    end,
    methods = { --you can implement custom functions for your component here

    }
}</code>
        </pre>

        <br/>
        <h2 class="text">an example for autoViewport:</h2>
        <pre>
            <code class="language-lua" style="width: fit-content;">local display = getComponent("display")
display.reset()
display.clearClicks()
display.setClicksAllowed(true)
local rx, ry = display.getWidth(), display.getHeight()

local gui = require("gui").new(display)
local scene = gui:createScene(0x0000ff)
local object = scene:createCustom(nil, nil, 64, 64, {
    autoViewport = true, --set the render to the size of the object
    handlerLocalPosition = true,
    init = function(self)
        self.myVars = {creationArgs = args, example = 1, color = 0xff0000}
    end,
    drawer = function(self)
        self.display.fillCircle(self.x, self.y, self.sizeX, self.myVars.color)
    end,
    handler = function(self, x, y, clickType, button, nickname)
        if clickType == "pressed" then
            self.myVars.color = math.random(0, 0xffffff)
            self:update()
        end
    end
})
object:setCenter()

function callback_loop()
    if _endtick then
        display.clear()
        display.flush()
        return
    end

    gui:tick()
    if gui:needFlush() then
        gui:draw()
        display.flush()
    end
end</code>
        </pre>

        <br/>
        <h2 class="text">demonstration of the intersection check:</h2>
        <pre>
            <code class="language-lua" style="width: fit-content;">--the example was created for a 128x128 screen
local display = getComponents("display")[1]
display.reset()
display.clearClicks()
display.setClicksAllowed(true)
local rx, ry = display.getWidth(), display.getHeight()

local gui = require("gui").new(display)
local styles = require("styles")
local scene = gui:createScene("777777")

local function addWindow()
    local window = scene:createWindow(16, 16, 64, 64, "2d2d2d")
    window:upPanel("058db8", "ffffff", "test window", true)
    window:setDraggable(true)
    
    local closeButton = window:panelButton(7, false, "X", "00a2d5", "0054a1", "00c2ff", "0085ff")
    closeButton:attachCallback(function(self, state, inZone)
        if not state and inZone then
            window:destroy()
        end
    end)
    
    local oldText
    for i = 1, 4 do
        local text = window:createText(nil, nil, "switch " .. i .. ": ")
        if oldText then text:setDown(oldText) end
        local switch = window:createButton(nil, nil, 8, 4, true, nil, "444444", "ffffff", "44b300", "ffffff")
        switch:setCustomStyle(styles.switch)
        switch:setRight(text)
        oldText = text
    end
    
    local window2 = window:createWindow(nil, nil, 32, 16, "333377")
    window2:setDown(oldText)
    window2:upPanel("058db8", "ffffff", "test", true)
    window2:minimize(true)
    local switch = window2:createButton(nil, nil, 14, 8, true, nil, "444444", "ffffff", "44b300", "ffffff")
    switch:setCustomStyle(styles.switch)
    
    function switch:onTick()
        switch:setBgColor(math.random(0, 0xffffff))
    end
end

local addWindowButton = scene:createButton(nil, nil, 32, 32, false, "WINDOW")
addWindowButton:attachCallback(function(self, state, inZone)
    if state then
        addWindow()
    end
end)

function scene:onTick()
    addWindowButton:setBgColor(math.random(0, 0xffffff))
end

function callback_loop()
    if _endtick then
        display.clear()
        display.flush()
        out(false)
        return
    end
    
    gui:tick()
    if gui:needFlush() then
        gui:draw()
        display.flush()
    end
end</code>
        </pre>

        <br/>
        <h2 class="text">custom object example:</h2>
        <pre>
            <code class="language-lua" style="width: fit-content;">--example for display 64x64

local display = getComponent("display")

local width, height = display.getSize()
display.reset()
display.clearClicks()
display.setClicksAllowed(true)
display.clear()
display.flush()

local gui = require("gui").new(display)
local scene = gui:createScene(0x444444)

local rgbButtons = {
    init = function(self, partsX, partsY)
        self.colors = {}
        self.partsX = partsX
        self.partsY = partsY
        self.partSizeX = math.floor((self.sizeX / partsX) + 0.5)
        self.partSizeY = math.floor((self.sizeY / partsY) + 0.5)
        for ix = 0, partsX - 1 do
            self.colors[ix] = {}
            for iy = 0, partsY - 1 do
                self.colors[ix][iy] = 0
            end
        end
    end,
    drawer = function(self)
        self:clear(0x000000)
        for ix = 0, self.partsX - 1 do
            for iy = 0, self.partsY - 1 do
                local color
                local colorIdx = self.colors[ix][iy]
                if colorIdx == 0 then
                    color = 0xff0000
                elseif colorIdx == 1 then
                    color = 0x00ff00
                elseif colorIdx == 2 then
                    color = 0x0000ff
                end
                self.display.fillRect(self.x + (ix * self.partSizeX) + 1, self.y + (iy * self.partSizeY) + 1, self.partSizeX - 1, self.partSizeY - 1, color)
            end
        end
    end,
    handlerLocalPosition = true, --tells the library that you would like to get the click position relative to your object
    handler = function(self, x, y, action, button) -- if the object was clicked and then the scene switched, the method will be called with the parameters: self, -1, -1, "released", -1
        if action == "pressed" then
            self:togglePartIndex(math.floor(x / self.partSizeX), math.floor(y / self.partSizeY))
            self:update()
        end
    end,
    methods = { --here you can implement your own methods that the user of the component can call
        togglePartIndex = function(self, x, y)
            local colorIdx = self:getPartIndex(x, y)
            if not colorIdx then return end
            colorIdx = colorIdx + 1
            if colorIdx > 2 then
                colorIdx = 0
            end
            self:setPartIndex(x, y, colorIdx)
        end,
        setPartIndex = function(self, x, y, colorIdx)
            self.colors[x][y] = colorIdx
        end,
        getPartIndex = function(self, x, y)
            if not self.colors[x] then
                return
            end
            return self.colors[x][y]
        end
    }
}

--creating 4 instances of custom "rgbButtons" objects
local sizeX, sizeY = (width / 2) - 3, (height / 2) - 3
local rgbButtons1 = scene:createCustom(2, 2, sizeX, sizeY, rgbButtons, 4, 4)
local rgbButtons2 = scene:createCustom(nil, nil, sizeX, sizeY, rgbButtons, 4, 4)
rgbButtons2:setRight(rgbButtons1, 2)
local rgbButtons3 = scene:createCustom(nil, nil, sizeX, sizeY, rgbButtons, 4, 4)
rgbButtons3:setDown(rgbButtons1, 2)
local rgbButtons4 = scene:createCustom(nil, nil, sizeX, sizeY, rgbButtons, 4, 4)
rgbButtons4:setRight(rgbButtons3, 2)

rgbButtons2:setPartIndex(2, 2, 1)
rgbButtons4:setPartIndex(1, 1, 2)

scene:select()

function callback_loop()
    if _endtick then
        display.clear()
        display.flush()
        return
    end

    gui:tick()

    if gui:needFlush() then
        gui:draw()
        display.flush()
    end
end</code>
        </pre>

        <br/>
        <h2 class="text">gui & camera example:</h2>
        <pre>
            <code class="language-lua" style="width: fit-content;">--example for display 128x128

local display = getComponent("display")
local camera = getComponent("camera")

local width, height = display.getSize()
display.reset()
display.clearClicks()
display.setClicksAllowed(true)
display.clear()
display.flush()

local gui = require("gui").new(display)
local scene = gui:createScene(function()
    camera.drawAdvanced(display, true)
end)

local rgbButtons = {
    init = function(self, partsX, partsY)
        self.colors = {}
        self.partsX = partsX
        self.partsY = partsY
        self.partSizeX = math.floor((self.sizeX / partsX) + 0.5)
        self.partSizeY = math.floor((self.sizeY / partsY) + 0.5)
        for ix = 0, partsX - 1 do
            self.colors[ix] = {}
            for iy = 0, partsY - 1 do
                self.colors[ix][iy] = 0
            end
        end
    end,
    drawer = function(self)
        self:clear(0x000000)
        for ix = 0, self.partsX - 1 do
            for iy = 0, self.partsY - 1 do
                local color
                local colorIdx = self.colors[ix][iy]
                if colorIdx == 0 then
                    color = 0xff0000
                elseif colorIdx == 1 then
                    color = 0x00ff00
                elseif colorIdx == 2 then
                    color = 0x0000ff
                end
                self.display.fillRect(self.x + (ix * self.partSizeX) + 1, self.y + (iy * self.partSizeY) + 1, self.partSizeX - 1, self.partSizeY - 1, color)
            end
        end
    end,
    handlerLocalPosition = true, --tells the library that you would like to get the click position relative to your object
    handler = function(self, x, y, action, button) -- if the object was clicked and then the scene switched, the method will be called with the parameters: self, -1, -1, "released", -1
        if action == "pressed" then
            self:togglePartIndex(math.floor(x / self.partSizeX), math.floor(y / self.partSizeY))
            self:update()
        end
    end,
    methods = { --here you can implement your own methods that the user of the component can call
        togglePartIndex = function(self, x, y)
            local colorIdx = self:getPartIndex(x, y)
            if not colorIdx then return end
            colorIdx = colorIdx + 1
            if colorIdx > 2 then
                colorIdx = 0
            end
            self:setPartIndex(x, y, colorIdx)
        end,
        setPartIndex = function(self, x, y, colorIdx)
            self.colors[x][y] = colorIdx
        end,
        getPartIndex = function(self, x, y)
            if not self.colors[x] then
                return
            end
            return self.colors[x][y]
        end
    }
}

local rgbButtons1 = scene:createCustom(2, 2, 29, 29, rgbButtons, 4, 4)

scene:select()

function callback_loop()
    if _endtick then
        display.clear()
        display.flush()
        return
    end

    gui:tick()
    gui:drawForce()
    display.flush()
end</code>
        </pre>

        <h2 class="text">example of large fonts (world cleaner code):</h2>
        <pre>
            <code class="language-lua" style="width: fit-content;">--example for a 256x256 display

local fonts = require("fonts")
local display = getComponent("display")

display.reset()
display.clearClicks()
display.setClicksAllowed(true)
display.setFont(fonts.impact_32)
local width, height = display.getWidth(), display.getHeight()
local fwidth, fheight = display.getFontWidth(), display.getFontHeight()

local gui = require("gui").new(display)

------------------------------------------

local acceptCode

local acceptScene = gui:createScene(sm.color.new("#e530ff"))

local acceptLabel = acceptScene:createLabel(4, 4, width - 8, fheight * 1.2, nil, 0x000000, 0xff0000)

local accept = acceptScene:createButton(nil, nil, width - 8, fheight * 1.4, false, "accept")
accept:setDown(acceptLabel, 4)
accept:attachCallback(function (_, newstate, isZone)
    if not newstate and isZone then
        acceptCode()
        mainScene:select()
    end
end)

local cancel = acceptScene:createButton(nil, nil, width - 8, fheight * 1.4, false, "cancel")
cancel:setDown(accept, 4)
cancel:attachCallback(function (_, newstate, isZone)
    if not newstate and isZone then
        mainScene:select()
    end
end)

------------------------------------------

mainScene = gui:createScene(sm.color.new("#03a4ff"))

local label = mainScene:createLabel(4, 4, width - 8, fheight * 1.2, "what to delete?", 0x000000, 0xff0000)

local action1 = mainScene:createButton(nil, nil, width - 8, fheight * 1.4, false, "all bodies")
action1:setDown(label, 4)
action1:attachCallback(function (_, newstate, isZone)
    if global and not newstate and isZone then
        acceptLabel.text = "del all bodies"
        acceptCode = function()
            for _, body in ipairs(sm.body.getAllBodies()) do
                for _, shape in ipairs(body:getShapes()) do
                    shape:destroyShape()
                end
            end
        end
        acceptScene:select()
    end
end)

local action2 = mainScene:createButton(nil, nil, width - 8, fheight * 1.4, false, "loose bodies")
action2:setDown(action1, 4)
action2:attachCallback(function (_, newstate, isZone)
    if global and not newstate and isZone then
        acceptLabel.text = "del loose bodies"
        acceptCode = function()
            for _, body in ipairs(sm.body.getAllBodies()) do
                if body:isDynamic() then
                    for _, shape in ipairs(body:getShapes()) do
                        shape:destroyShape()
                    end
                end
            end
        end
        acceptScene:select()
    end
end)

local action3 = mainScene:createButton(nil, nil, width - 8, fheight * 1.4, false, "units")
action3:setDown(action2, 4)
action3:attachCallback(function (_, newstate, isZone)
    if global and not newstate and isZone then
        acceptLabel.text = "del units"
        acceptCode = function()
            for _, unit in ipairs(sm.unit.getAllUnits()) do
                unit:destroy()
            end
        end
        acceptScene:select()
    end
end)

------------------------------------------

local needUnsafeMode = gui:createScene(sm.color.new("#ff9d03"))
needUnsafeMode:createLabel(4, 4, width - 8, height - 8, "to use it, you need to activate unsafe mode", 0x000000, 0xffffff)

local _globalState
local function checkUnsafeMode()
    local globalState = not not global
    if globalState ~= _globalState then
        if globalState then
            mainScene:select()
        else
            needUnsafeMode:select()
        end
    end
    _globalState = globalState
end

checkUnsafeMode()

function callback_loop()
    if _endtick then
        display.clear()
        display.flush()
        return
    end

    checkUnsafeMode()

    gui:tick()
    if gui:needFlush() then
        gui:draw()
        display.flush()
    end
end</code>
        </pre>

        <h2 class="text">switch example:</h2>
        <pre>
            <code class="language-lua" style="width: fit-content;">local display = getComponent("display")
display.reset()
display.clearClicks()
display.setSkipAtLags(false)
display.setClicksAllowed(true)
local rx, ry = display.getWidth(), display.getHeight()

local gui = require("gui").new(display)
local styles = require("styles")

local scene = gui:createScene("0000ff")
local switch = scene:createButton(4, (ry / 2) - 16, rx - 8, 32, true, nil, "444444", "ffffff", "44b300", "ffffff")
switch:setCustomStyle(styles.switch)
scene:select()

function callback_loop()
    if _endtick then
        display.clear()
        display.flush()
        out(false)
        return
    end

    gui:tick()

    out(switch:getState())

    if gui:needFlush() then
        gui:draw()
        display.flush()
    end
end</code>
        </pre>

        <h2 class="text">window example:</h2>
        <pre>
            <code class="language-lua" style="width: fit-content;">--the example was created for a 128x128 screen
local display = getComponent("display")
display.reset()
display.clearClicks()
display.setSkipAtLags(false)
display.setClicksAllowed(true)
local rx, ry = display.getWidth(), display.getHeight()

local gui = require("gui").new(display)
local styles = require("styles")
local scene = gui:createScene("777777")

local function addWindow()
    local window = scene:createWindow(16, 16, 64, 64, "2d2d2d")
    window:upPanel("058db8", "ffffff", "test window", true)
    window:setDraggable(true)

    local closeButton = window:panelButton(7, false, "X", "00a2d5", "0054a1", "00c2ff", "0085ff")
    closeButton:attachCallback(function(self, state, inZone)
        if not state and inZone then
            window:destroy()
        end
    end)

    local oldText
    for i = 1, 4 do
        local text = window:createText(nil, nil, "switch " .. i .. ": ")
        if oldText then text:setDown(oldText) end
        local switch = window:createButton(nil, nil, 8, 4, true, nil, "444444", "ffffff", "44b300", "ffffff")
        switch:setCustomStyle(styles.switch)
        switch:setRight(text)
        oldText = text
    end

    local window2 = window:createWindow(nil, nil, 32, 16, "333377")
    window2:setDown(oldText)
    window2:upPanel("058db8", "ffffff", "test", true)
    window2:minimize(true)
    local switch = window2:createButton(nil, nil, 14, 8, true, nil, "444444", "ffffff", "44b300", "ffffff")
    switch:setCustomStyle(styles.switch)
end

local addWindowButton = scene:createButton(nil, nil, 32, 32, false, "WINDOW")
addWindowButton:attachCallback(function(self, state, inZone)
    if state then
        addWindow()
    end
end)

function callback_loop()
    if _endtick then
        display.clear()
        display.flush()
        out(false)
        return
    end

    gui:tick()
    if gui:needFlush() then
        gui:draw()
        display.flush()
    end
end</code>
        </pre>
    
        <script src="main.js"></script>
    </body>
</html>