--scmframework is a SComputers-based framework for creating scripts for mods
--this file was generated automatically. You can find the utility for generating it in the SComputers files in the directory: USER/documentation/scmframework
--to run the build, run the script in luajit on Windows and specify the path to the SComputers Scripts folder as an argument
--this framework is an official part of SComputers and is freely distributed
--you can embed it in your mods and use it in your scripts when saving this text
--the author's web page: https://igorkll.github.io/logichub/
--SComputers documentation: https://igorkll.github.io/SComputers/
--SComputers in steam: https://steamcommunity.com/sharedfiles/filedetails/?id=2949350596

--The MIT License (MIT)
--Copyright © 2025 BananaPen
--
--Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
--
--The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
--
--THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

scmframework_filepathHash={_VERSION="md5.lua 1.1.0",_DESCRIPTION="MD5 computation in Lua (5.1-3, LuaJIT)",_URL="https://github.com/kikito/md5.lua",_LICENSE=[[MIT LICENSE

Copyright (c) 2013 Enrique García Cota + Adam Baldwin + hanzao + Equi 4 Software

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.]]}local a,b,c,d,e=string.char,string.byte,string.format,string.rep,string.sub;local f,g,h,i,j,k;local l,m=pcall(require,"bit")local n,o=pcall(require,"ffi")if l then f,g,h,i,j,k=m.bor,m.band,m.bnot,m.bxor,m.rshift,m.lshift else l,m=pcall(require,"bit32")if l then h=m.bnot;local p=function(q)return q<=0x7fffffff and q or-(h(q)+1)end;local r=function(s)return function(t,u)return p(s(p(t),p(u)))end end;f,g,i=r(m.bor),r(m.band),r(m.bxor)j,k=r(m.rshift),r(m.lshift)else local function v(w)local x=0;local y=1;for z=1,#w do x=x+w[z]*y;y=y*2 end;return x end;local function A(B,C)local D,E=B,C;if#D<#E then D,E=E,D end;for z=#E+1,#D do E[z]=0 end end;local F;h=function(q)local w=F(q)local G=math.max(#w,32)for z=1,G do if w[z]==1 then w[z]=0 else w[z]=1 end end;return v(w)end;F=function(q)if q<0 then return F(h(math.abs(q))+1)end;local w={}local H=1;local I;while q>0 do I=q%2;w[H]=I;q=(q-I)/2;H=H+1 end;return w end;f=function(J,q)local K=F(J)local L=F(q)A(K,L)local w={}for z=1,#K do if K[z]==0 and L[z]==0 then w[z]=0 else w[z]=1 end end;return v(w)end;g=function(J,q)local K=F(J)local L=F(q)A(K,L)local w={}for z=1,#K do if K[z]==0 or L[z]==0 then w[z]=0 else w[z]=1 end end;return v(w)end;i=function(J,q)local K=F(J)local L=F(q)A(K,L)local w={}for z=1,#K do if K[z]~=L[z]then w[z]=1 else w[z]=0 end end;return v(w)end;j=function(q,M)local N=0;if q<0 then q=h(math.abs(q))+1;N=0x80000000 end;local O=math.floor;for z=1,M do q=q/2;q=f(O(q),N)end;return O(q)end;k=function(q,M)if q<0 then q=h(math.abs(q))+1 end;for z=1,M do q=q*2 end;return g(q,0xFFFFFFFF)end end end;local P;if n then local Q=o.typeof("int[1]")P=function(z)return o.string(Q(z),4)end else P=function(z)local s=function(R)return a(g(j(z,R),255))end;return s(0)..s(8)..s(16)..s(24)end end;local function S(R)local T=0;for z=1,#R do T=T*256+b(R,z)end;return T end;local U;if n then local V=o.typeof("const char*")local W=o.typeof("const int*")U=function(R)local X=V(R)return o.cast(W,X)[0]end else U=function(R)local T=0;for z=#R,1,-1 do T=T*256+b(R,z)end;return T end end;local function Y(R)return{U(e(R,1,4)),U(e(R,5,8)),U(e(R,9,12)),U(e(R,13,16)),U(e(R,17,20)),U(e(R,21,24)),U(e(R,25,28)),U(e(R,29,32)),U(e(R,33,36)),U(e(R,37,40)),U(e(R,41,44)),U(e(R,45,48)),U(e(R,49,52)),U(e(R,53,56)),U(e(R,57,60)),U(e(R,61,64))}end;local Z={0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee,0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be,0x6b901122,0xfd987193,0xa679438e,0x49b40821,0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa,0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8,0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a,0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c,0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70,0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05,0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,0xf4292244,0x432aff97,0xab9423a7,0xfc93a039,0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1,0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1,0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391,0x67452301,0xefcdab89,0x98badcfe,0x10325476}local s=function(_,a0,a1)return f(g(_,a0),g(-_-1,a1))end;local a2=function(_,a0,a1)return f(g(_,a1),g(a0,-a1-1))end;local a3=function(_,a0,a1)return i(_,i(a0,a1))end;local z=function(_,a0,a1)return i(a0,f(_,-a1-1))end;local a1=function(a4,t,u,a5,a6,_,R,a7)t=g(t+a4(u,a5,a6)+_+a7,0xFFFFFFFF)return f(k(g(t,j(0xFFFFFFFF,R)),R),j(t,32-R))+u end;local function a8(a9,aa,ab,ac,ad)local t,u,a5,a6=a9,aa,ab,ac;local ae=Z;t=a1(s,t,u,a5,a6,ad[0],7,ae[1])a6=a1(s,a6,t,u,a5,ad[1],12,ae[2])a5=a1(s,a5,a6,t,u,ad[2],17,ae[3])u=a1(s,u,a5,a6,t,ad[3],22,ae[4])t=a1(s,t,u,a5,a6,ad[4],7,ae[5])a6=a1(s,a6,t,u,a5,ad[5],12,ae[6])a5=a1(s,a5,a6,t,u,ad[6],17,ae[7])u=a1(s,u,a5,a6,t,ad[7],22,ae[8])t=a1(s,t,u,a5,a6,ad[8],7,ae[9])a6=a1(s,a6,t,u,a5,ad[9],12,ae[10])a5=a1(s,a5,a6,t,u,ad[10],17,ae[11])u=a1(s,u,a5,a6,t,ad[11],22,ae[12])t=a1(s,t,u,a5,a6,ad[12],7,ae[13])a6=a1(s,a6,t,u,a5,ad[13],12,ae[14])a5=a1(s,a5,a6,t,u,ad[14],17,ae[15])u=a1(s,u,a5,a6,t,ad[15],22,ae[16])t=a1(a2,t,u,a5,a6,ad[1],5,ae[17])a6=a1(a2,a6,t,u,a5,ad[6],9,ae[18])a5=a1(a2,a5,a6,t,u,ad[11],14,ae[19])u=a1(a2,u,a5,a6,t,ad[0],20,ae[20])t=a1(a2,t,u,a5,a6,ad[5],5,ae[21])a6=a1(a2,a6,t,u,a5,ad[10],9,ae[22])a5=a1(a2,a5,a6,t,u,ad[15],14,ae[23])u=a1(a2,u,a5,a6,t,ad[4],20,ae[24])t=a1(a2,t,u,a5,a6,ad[9],5,ae[25])a6=a1(a2,a6,t,u,a5,ad[14],9,ae[26])a5=a1(a2,a5,a6,t,u,ad[3],14,ae[27])u=a1(a2,u,a5,a6,t,ad[8],20,ae[28])t=a1(a2,t,u,a5,a6,ad[13],5,ae[29])a6=a1(a2,a6,t,u,a5,ad[2],9,ae[30])a5=a1(a2,a5,a6,t,u,ad[7],14,ae[31])u=a1(a2,u,a5,a6,t,ad[12],20,ae[32])t=a1(a3,t,u,a5,a6,ad[5],4,ae[33])a6=a1(a3,a6,t,u,a5,ad[8],11,ae[34])a5=a1(a3,a5,a6,t,u,ad[11],16,ae[35])u=a1(a3,u,a5,a6,t,ad[14],23,ae[36])t=a1(a3,t,u,a5,a6,ad[1],4,ae[37])a6=a1(a3,a6,t,u,a5,ad[4],11,ae[38])a5=a1(a3,a5,a6,t,u,ad[7],16,ae[39])u=a1(a3,u,a5,a6,t,ad[10],23,ae[40])t=a1(a3,t,u,a5,a6,ad[13],4,ae[41])a6=a1(a3,a6,t,u,a5,ad[0],11,ae[42])a5=a1(a3,a5,a6,t,u,ad[3],16,ae[43])u=a1(a3,u,a5,a6,t,ad[6],23,ae[44])t=a1(a3,t,u,a5,a6,ad[9],4,ae[45])a6=a1(a3,a6,t,u,a5,ad[12],11,ae[46])a5=a1(a3,a5,a6,t,u,ad[15],16,ae[47])u=a1(a3,u,a5,a6,t,ad[2],23,ae[48])t=a1(z,t,u,a5,a6,ad[0],6,ae[49])a6=a1(z,a6,t,u,a5,ad[7],10,ae[50])a5=a1(z,a5,a6,t,u,ad[14],15,ae[51])u=a1(z,u,a5,a6,t,ad[5],21,ae[52])t=a1(z,t,u,a5,a6,ad[12],6,ae[53])a6=a1(z,a6,t,u,a5,ad[3],10,ae[54])a5=a1(z,a5,a6,t,u,ad[10],15,ae[55])u=a1(z,u,a5,a6,t,ad[1],21,ae[56])t=a1(z,t,u,a5,a6,ad[8],6,ae[57])a6=a1(z,a6,t,u,a5,ad[15],10,ae[58])a5=a1(z,a5,a6,t,u,ad[6],15,ae[59])u=a1(z,u,a5,a6,t,ad[13],21,ae[60])t=a1(z,t,u,a5,a6,ad[4],6,ae[61])a6=a1(z,a6,t,u,a5,ad[11],10,ae[62])a5=a1(z,a5,a6,t,u,ad[2],15,ae[63])u=a1(z,u,a5,a6,t,ad[9],21,ae[64])return g(a9+t,0xFFFFFFFF),g(aa+u,0xFFFFFFFF),g(ab+a5,0xFFFFFFFF),g(ac+a6,0xFFFFFFFF)end;local function af(self,R)self.pos=self.pos+#R;R=self.buf..R;for ag=1,#R-63,64 do local ad=Y(e(R,ag,ag+63))assert(#ad==16)ad[0]=table.remove(ad,1)self.a,self.b,self.c,self.d=a8(self.a,self.b,self.c,self.d,ad)end;self.buf=e(R,math.floor(#R/64)*64+1,#R)return self end;local function ah(self)local ai=self.pos;local aj=56-ai%64;if ai%64>56 then aj=aj+64 end;if aj==0 then aj=64 end;local R=a(128)..d(a(0),aj-1)..P(g(8*ai,0xFFFFFFFF))..P(math.floor(ai/0x20000000))af(self,R)assert(self.pos%64==0)return P(self.a)..P(self.b)..P(self.c)..P(self.d)end;function scmframework_filepathHash.new()return{a=Z[65],b=Z[66],c=Z[67],d=Z[68],pos=0,buf="",update=af,finish=ah}end;function scmframework_filepathHash.tohex(R)return c("%08x%08x%08x%08x",S(e(R,1,4)),S(e(R,5,8)),S(e(R,9,12)),S(e(R,13,16)))end;function scmframework_filepathHash.sum(R)return scmframework_filepathHash.new():update(R):finish()end;function scmframework_filepathHash.sumhexa(R)return scmframework_filepathHash.tohex(scmframework_filepathHash.sum(R))end
if not __SCMFRAMEWORK then
__SCMFRAMEWORK = true

local strtool = string

local _better = better
local better
if _better and _better.isAvailable() then
    better = _better
else
    __SCMFRAMEWORK_NO_GETAPI = true
end

local _setmetatable, _getmetatable = setmetatable, getmetatable
local setmetatable, getmetatable
if pcall(_setmetatable, {}, {}) then
    setmetatable = _setmetatable
end
if pcall(_getmetatable, {}) then
    getmetatable = _getmetatable
end

local function formatPathWithoutSlash(path)
    path = path:gsub("\\", "/")
    if path:sub(#path, #path) == "/" then
        path = path:sub(1, #path - 1)
    end
    return path
end

local function formatPathWithSlash(path)
    path = path:gsub("\\", "/")
    if path:sub(#path, #path) ~= "/" then
        path = path .. "/"
    end
    return path
end

local function _strSplit(tool, str, seps)
    if type(seps) ~= "table" then
        seps = {seps}
    end

    local parts = {{}}
    local index = 1
    local strlen = tool.len(str)
    while index <= strlen do
        for _ = 0, strlen * 2 do
            local isBreak
            for i, sep in ipairs(seps) do
                sep = tostring(sep)
                if sep ~= "" and tool.sub(str, index, index + (tool.len(sep) - 1)) == sep then
                    table.insert(parts, {})
                    index = index + tool.len(sep)
                    isBreak = true
                    break
                end
            end
            if not isBreak then break end
        end

        table.insert(parts[#parts], tool.sub(str, index, index))
        index = index + 1
    end

    for i, part in ipairs(parts) do
        parts[i] = table.concat(part)
    end

    return parts
end

local function vfs_resolve(...)
    local elementsList = {...}
    local newElements = {}
    for _, elements in ipairs(elementsList) do
        for _, element in ipairs(elements) do
            if element == "." then
            elseif element == ".." then
                if newElements[#newElements] ~= "" then
                    table.remove(newElements)
                end
            elseif element == "" then
                newElements = {""}
            else
                table.insert(newElements, element)
            end
        end
    end
    if #newElements == 1 and newElements[1] == "" then
        return "/"
    end
    return table.concat(newElements, "/")
end

local function vfs_elements(path)
    path = formatPathWithoutSlash(path)

    local elements = {}
    for i, element in ipairs(_strSplit(strtool, path, "/")) do
        elements[i] = element
    end
    return elements
end

local function vfs_path(path)
    local elements = vfs_elements(path)
    table.remove(elements)
    return vfs_resolve(elements)
end

local function vfs_name(path)
    local elements = vfs_elements(path)
    return table.remove(elements)
end

local function vfs_concat(...)
    local paths = {...}
    for i, path in ipairs(paths) do
        paths[i] = vfs_elements(path)
    end
    return vfs_resolve(unpack(paths))
end

local _orig_dofile = dofile
local workingDirectory
local frameworkLoadedParts = {}
local changePrefixPath = "$CONTENT_3aeb81c2-71b9-45a1-9479-1f48f1e8ff21/"
local changePrefixPath2 = "$CONTENT_" .. sm.json.open("$CONTENT_DATA/description.json").localId .. "/"
local function dofile(path)
    if workingDirectory and path:sub(1, 1) ~= "$" then
        path = vfs_concat(workingDirectory, path)
    end
    print("scmframework> ", path)
    pcall(_orig_dofile, path)

    if path:sub(1, #changePrefixPath) == changePrefixPath then
        local oldPath = path
        path = "$CONTENT_DATA/" .. path:sub(#changePrefixPath + 1, #path)
        print("change path (1): ", oldPath, " > ", path)
    elseif path:sub(1, #changePrefixPath2) == changePrefixPath2 then
        local oldPath = path
        path = "$CONTENT_DATA/" .. path:sub(#changePrefixPath2 + 1, #path)
        print("change path (2): ", oldPath, " > ", path)
    end

    if not frameworkLoadedParts[path] then
        frameworkLoadedParts[path] = true
        local old_workingDirectory = workingDirectory
        workingDirectory = vfs_path(path)
        local func = _G["scmframework_" .. scmframework_filepathHash.sumhexa(path)]
        if func then
            print("loaded from framework!")
            func()
        end
        workingDirectory = old_workingDirectory
    end
end
scmframework_dofile = dofile
__SCMFRAMEWORK_NOFONTS = true
function scmframework_bfad31699b1d1bc64a58bc9aee79b817() --$CONTENT_DATA/Scripts/ai.lua
if not better or not better.isAvailable() then return end

local ai_prompt = better.filesystem.readFile(sc.modPrefix .. "/ROM/chatGPTprompt.txt")
local baseCode = [[_enableCallbacks = true]]
local allowedChars = {}

for i = 33, 126 do
    allowedChars[string.char(i)] = true
end

local function simpleFind(str, test)
    for i = 1, #str do
        local endf = i + (#test - 1)
        if str:sub(i, endf) == test then
            return i, endf
        end
    end
end

local function trim(text)
    while true do
        if #text == 0 then
            break
        end
        local firstChar = text:sub(1, 1)
        if not allowedChars[firstChar] then
            text = text:sub(2, #text)
        else
            local lastChar = text:sub(#text, #text)
            if not allowedChars[lastChar] then
                text = text:sub(1, #text - 1)
            else
                break
            end
        end
    end
    return text
end

function ai_codeGen(prompt)
    local startpos = select(2, simpleFind(prompt, "--[[")) or 0
    local endpos = simpleFind(prompt, "]]") or (#prompt + 1)
    prompt = prompt:sub(startpos + 1, endpos - 1)
    while true do
        local firstChar = prompt:sub(1, 1)
        if firstChar == "\n" then
            prompt = prompt:sub(2, #prompt)
        else
            local lastChar = prompt:sub(#prompt, #prompt)
            if lastChar == "\n" then
                prompt = prompt:sub(1, #prompt - 1)
            else
                break
            end
        end
    end

    local async = better.openAI.textRequest(nil, nil, ai_prompt, prompt)

    return function ()
        local str = async()
        if str then
            local startpos = select(2, str:find("```lua")) or select(2, str:find("```")) or 0
            local endpos = str:find("```", startpos + 1) or (#str + 1)
            local code = trim(str:sub(startpos + 1, endpos - 1))
            local preCode = trim(str:sub(1, startpos - 6))
            local postCode = trim(str:sub(endpos + 6, #str))
            local selfPrompt = "--ai code-gen prompt:\n--[[\n" .. prompt .. "\n]]\n\n"
            if #code > 0 and load_code(nil, code) then
                return selfPrompt .. code .. "\n\n" .. baseCode .. "\n\n--[[\n" .. preCode .. "\n\n" .. postCode .. "\n]]", true
            else
                return selfPrompt .. str, false
            end
        end
    end
end
end
function scmframework_a3ad343aad414134eec9db57b5c71cc8() --$CONTENT_DATA/Scripts/base64.lua
base64 = {}

local table_concat = table.concat
local string_find = string.find
local string_gsub = string.gsub
local string_sub = string.sub
local string_char = string.char

local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' -- You will need this for encoding/decoding
local b2 = '%d%d%d?%d?%d?%d?%d?%d?'
local b3 = '%d%d%d?%d?%d?%d?'
local n0, n1 = '0', '1'

local cache2 = {}
function base64.encode(data, needYield)
    if better and better.algorithm then
        return better.algorithm.base64_encode(data)
    end

    local cache1 = {}

    local function yield()
        if needYield then
            sc.smartYield()
        end
    end

    return ((data:gsub('.', function(x) 
        if not cache1[x] then
            local r,b='',x:byte()
            for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and n1 or n0) yield() end
            cache1[x] = r
        end
        return cache1[x]
    end)..'0000'):gsub(b3, function(x)
        if (#x < 6) then return '' end
        if not cache2[x] then
            local c=0
            for i=1,6 do c=c+(x:sub(i,i)==n1 and 2^(6-i) or 0) yield() end
            cache2[x] = b:sub(c+1,c+1)
        end
        return cache2[x]
    end)..({ '', '==', '=' })[#data%3+1])
end

local cache3 = {}
function base64.decode(data, needYield)
    if better and better.algorithm then
        return better.algorithm.base64_decode(data)
    end

    local cache4 = {}

    local function yield()
        if needYield then
            sc.smartYield()
        end
    end

    data = string_gsub(data, '[^'..b..'=]', '')
    local c, f, t, ti
    return string_gsub(string_gsub(data, '.', function(x)
        if (x == '=') then return '' end
        if not cache4[x] then
            f, t, ti= string_find(b,x)-1, {}, 1
            for i=6,1,-1 do t[ti] = f%2^i-f%2^(i-1)>0 and n1 or n0 ti = ti + 1 yield() end
            cache4[x] = table_concat(t)
        end
        return cache4[x]
    end), b2, function(x)
        if (#x ~= 8) then return '' end
        if not cache3[x] then
            c=0
            for i=1,8 do c=c+(string_sub(x,i,i)==n1 and 2^(8-i) or 0) yield() end
            cache3[x] = string_char(c)
        end
        return cache3[x]
    end)
end 
end
function scmframework_839c7dcd5ee05ef416dba0414175892a() --$CONTENT_DATA/Scripts/cameraControl.lua
dofile("$CONTENT_DATA/Scripts/Config.lua")
cameraControl = class()
cameraControl.maxParentCount = 1
cameraControl.maxChildCount = 1
cameraControl.connectionInput = sm.interactable.connectionType.power
cameraControl.connectionOutput = sm.interactable.connectionType.composite
cameraControl.colorNormal = sm.color.new("#1bae07")
cameraControl.colorHighlight = sm.color.new("#27e30e")
cameraControl.componentType = "cameraControl"
cameraControl.nearbyMaxDistance = 16

local function rotateVector3D(vector, radiansX, radiansY, radiansZ)
    -- Матрица поворота вокруг оси X
    local rotationX = {
        {1, 0, 0},
        {0, math.cos(radiansX), -math.sin(radiansX)},
        {0, math.sin(radiansX), math.cos(radiansX)}
    }

    -- Матрица поворота вокруг оси Y
    local rotationY = {
        {math.cos(radiansY), 0, math.sin(radiansY)},
        {0, 1, 0},
        {-math.sin(radiansY), 0, math.cos(radiansY)}
    }

    -- Матрица поворота вокруг оси Z
    local rotationZ = {
        {math.cos(radiansZ), -math.sin(radiansZ), 0},
        {math.sin(radiansZ), math.cos(radiansZ), 0},
        {0, 0, 1}
    }

    -- Функция для умножения матрицы на вектор
    local function multiplyMatrixVector(matrix, vector)
        return sm.vec3.new(
            matrix[1][1] * vector.x + matrix[1][2] * vector.y + matrix[1][3] * vector.z,
            matrix[2][1] * vector.x + matrix[2][2] * vector.y + matrix[2][3] * vector.z,
            matrix[3][1] * vector.x + matrix[3][2] * vector.y + matrix[3][3] * vector.z
        )
    end

    -- Применяем повороты
    local rotatedVector = multiplyMatrixVector(rotationX, vector)
    rotatedVector = multiplyMatrixVector(rotationY, rotatedVector)
    rotatedVector = multiplyMatrixVector(rotationZ, rotatedVector)

    return rotatedVector
end

function cameraControl:server_onCreate()
    self.interactable.publicData = {
        sc_component = {
            type = cameraControl.componentType,
            api = {
                getDirection = function(nearby)
                    return self:sv_getCameraInfoValue(nearby, "direction")
                end,
                --[[
                getLocalDirection = function(nearby)
                    local rotation = toEuler(self.shape.worldRotation)
                    local newX = math.rad(90) - rotation.x
                    print(rotation, math.deg(newX))

                    local direction = self:sv_getCameraInfoValue(nearby, "direction")
                    if not direction then return end
                    return rotateVector3D(direction, -rotation.x, -rotation.y, -rotation.z)
                end,
                ]]
                getPosition = function(nearby)
                    return self:sv_getCameraInfoValue(nearby, "position")
                end,
                getRotation = function(nearby)
                    return self:sv_getCameraInfoValue(nearby, "rotation")
                end,
                getFov = function(nearby)
                    return self:sv_getCameraInfoValue(nearby, "fov")
                end,
                getUp = function(nearby)
                    return self:sv_getCameraInfoValue(nearby, "up")
                end,
                getRight = function(nearby)
                    return self:sv_getCameraInfoValue(nearby, "right")
                end,
                getCameraDistance = function(nearby)
                    local position = self:sv_getCameraInfoValue(nearby, "position")
                    if position then
                        return mathDist(self.shape.worldPosition, position)
                    end
                end,
                getPlayerDistance = function(nearby)
                    local playerPosition = self:sv_getCameraInfoValue(nearby, "playerPosition")
                    if playerPosition then
                        return mathDist(self.shape.worldPosition, playerPosition)
                    end
                end,
                getPlayerCameraDistance = function(nearby)
                    local info = self:sv_getCameraInfoValue(nearby)
                    if info then
                        return mathDist(info.position, info.playerPosition)
                    end
                end
            }
        }
    }

    self.cameraInfo = {}
end

function cameraControl:sv_getCameraInfoValue(nearby, key)
    local info
    local oldDist
    for _, cameraInfo in pairs(self.cameraInfo) do
        if nearby then
            if not cameraInfo.seated then --if you use the "nearby" flag, you will not be able to receive values from the player who is sitting in the seat
                local dist = mathDist(self.shape.worldPosition, cameraInfo.playerPosition)
                if dist <= cameraControl.nearbyMaxDistance and (not info or dist < oldDist) then
                    info = cameraInfo
                    oldDist = dist
                end
            end
        elseif cameraInfo.seated then
            info = cameraInfo
            break
        end
    end
    if info then
        if key then
            return info[key]
        end
        return info
    end
end

function cameraControl:server_onFixedUpdate()
    local parent = self.interactable:getSingleParent()
    if parent then
        self.seated = parent:isActive()
    end

    if self.seated ~= self.old_active then
        self.old_active = self.seated
        self.network:sendToClients("cl_setActive", self.old_active)
    end

    local IDs = {}
    for _, player in ipairs(sm.player.getAllPlayers()) do
        IDs[player.id] = true
    end
    for id in pairs(self.cameraInfo) do
        if not IDs[id] then
            self.cameraInfo[id] = nil
        end
    end
end

function cameraControl:sv_dataRequest()
    self.old_active = nil
end

function cameraControl:sv_updateCameraInfo(cameraInfo)
    self.cameraInfo[cameraInfo.playerId] = cameraInfo
end

function cameraControl:client_onCreate()
    self.network:sendToServer("sv_dataRequest")
end

function cameraControl:client_onFixedUpdate()
    local seated = false
    for k, v in pairs(self.interactable:getParents()) do
        if v:isActive() then
            seated = true
        end
    end
    
    local player = sm.localPlayer.getPlayer()
    local cameraInfo = {
        direction = sm.camera.getDirection(),
        position = sm.camera.getPosition(),
        rotation = sm.camera.getRotation(),
        fov = sm.camera.getFov(),
        up = sm.camera.getUp(),
        right = sm.camera.getRight(),
        seated = seated,
        playerPosition = player.character.worldPosition,
        playerId = player.id
    }

    self.network:sendToServer("sv_updateCameraInfo", cameraInfo)
end

function cameraControl:cl_setActive(active)
    self.interactable:setUvFrameIndex(active and 6 or 0)
end
end
function scmframework_64aeb019eda52cc1552855d4570b5977() --$CONTENT_DATA/Scripts/canvasAPI/backup/canvas_backup1.lua
--[[
this file belongs to logic/bananaPen and was completely written by me alone(logic/bananaPen)
it was the most technically difficult project in my life O_o
writing a canvas for scrap mechanic that should work quickly turned out to be VERY DIFFICULT
I know that display optimization is still far from ideal, but I will work hard on it.
]]

print("> canvas.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/luajit.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/font.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/fontsLoad.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/utf8.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/canvasService.lua")

local debugMode = true
local canvasAPI = {
    draw = {
        clear = 0,
        set   = 1,
        fill  = 2,
        rect  = 3,
        text  = 4,
        line  = 5,
        circle  = 6,
        circleF = 7,
        circleE = 8,
        circleVE = 9,
        poly = 10,
        polyF = 11
    },
    material = {
        classic = sm.uuid.new("64d41b06-9b71-4e19-9f87-1e7e63845e59"),
        glass = sm.uuid.new("a683f897-5b8a-4c96-9c46-7b9fbc76d186")
    },
    multi_layer = {}
}
canvasAPI.multi_layer[tostring(canvasAPI.material.classic)] = true
canvasAPI.version = 30

canvasAPI.directList = {
    get = true,
    getCurrent = true,
    getBuffer = true,
    
    clear = true,
    drawPixel = true,
    drawRect = true,
    fillRect = true,
    drawText = true,
    drawLine = true,
    drawCircle = true,
    fillCircle = true,
    drawCircleEvenly = true,
    drawCircleVeryEvenly = true,
    drawPoly = true,
    drawWidePoly = true,
    fillPoly = true,
    fillWidePoly = true,
    getWidth = true,
    getHeight = true,
    getSize = true,

    isAllow = true,
    setFontScale = true,
    setFontSize = true,
    getFontScale = true,
    setTextSpacing = true,
    getTextSpacing = true,
    calcTextBox = true,
    calcCharsSize = true,
    calcDecreasingTextSizes = true,
    setUtf8Support = true,
    getUtf8Support = true,
    setRenderAtDistance = true,
    getRenderAtDistance = true,
    setRotation = true,
    getRotation = true,
    setFont = true,
    getFont = true,
    getFontWidth = true,
    getFontHeight = true,
    getRealFontWidth = true,
    getRealFontHeight = true,
    setSkipAtNotSight = true,
    getSkipAtNotSight = true,
    isMonospacedFont = true,
    setBrightness = true,
    getBrightness = true,
    reset = true,
    setClicksAllowed = true,
    getClicksAllowed = true,
    clearClicks = true,
    setMaxClicks = true,
    getMaxClicks = true,
    getClick = true,
    setOptimizationLevel = true,
    getOptimizationLevel = true,

    setViewport = true,
    setInlineViewport = true,
    getViewport = true
}

local MAX_DRAW_TIME = 2 --protecting the world from crashing using the display
local FONT_SIZE_LIMIT = 256
local DEFAULT_ALPHA_VALUE = 180

local fonts = fonts
local fontsOptimized = fontsOptimized
local spaceCharCode = string.byte(" ")

local huge = math.huge
local string_len = string.len
local bit = bit or bit32
local bit_rshift = bit.rshift
local bit_lshift = bit.lshift
local utf8 = utf8
local string = string
local table_sort = table.sort
local font = font
local type = type
local math_ceil = math.ceil
local math_max = math.max
local string_format = string.format
local table_insert = table.insert
local table_remove = table.remove
local math_floor = math.floor
local vec3_new = sm.vec3.new
local color_new = sm.color.new
local quat_fromEuler = sm.quat.fromEuler
local ipairs = ipairs
local pairs = pairs
local string_byte = string.byte
local defaultError = font.optimized.error
local tostring = tostring
local math_abs = math.abs
local math_min = math.min
local string_sub = string.sub
local table_concat = table.concat
local tonumber = tonumber
local utf8_len = utf8.len
local utf8_sub = utf8.sub
local sm_localPlayer_getPlayer = sm.localPlayer.getPlayer
local os_clock = os.clock
local math_sqrt = math.sqrt

local black = color_new(0, 0, 0)
local white = color_new(1, 1, 1)
local blackNumber = 0x000000ff
local whiteNumber = 0xffffffff
local blackSmallNumber = 0x000000
local whiteSmallNumber = 0xffffff

local getEffectName
do
    local currentEffect = 1
    local effectsNames = {}

    for i = 0, 255 do
        table_insert(effectsNames, "ShapeRenderable" .. tostring(i))
    end

    function getEffectName()
        local name = effectsNames[currentEffect]
        currentEffect = currentEffect + 1
        if currentEffect > #effectsNames then
            currentEffect = 1
        end
        return name
    end
end

--[[
local sm_effect_createEffect = sm.effect.withoutHook_createEffect or sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local withoutHookEmptyEffect = emptyEffect
local whook = "withoutHook_"
if better and better.version >= 24 and better.isAvailable() then
    local mt = getmetatable(emptyEffect)
    local newMt = {}
    for k, v in pairs(mt) do
        newMt[k] = v
    end
    for k, v in pairs(mt) do
        if k:sub(1, #whook) == whook then
            newMt[k:sub(#whook + 1, #k)] = v
        end
    end
    withoutHookEmptyEffect = setmetatable({}, newMt)
end
local effect_setParameter = withoutHookEmptyEffect.setParameter
local effect_stop = withoutHookEmptyEffect.stop
local effect_destroy = withoutHookEmptyEffect.destroy
local effect_start = withoutHookEmptyEffect.start
local effect_isDone = withoutHookEmptyEffect.isDone
local effect_isPlaying = withoutHookEmptyEffect.isPlaying
local effect_setScale = withoutHookEmptyEffect.setScale
local effect_setOffsetPosition = withoutHookEmptyEffect.setOffsetPosition
local effect_setOffsetRotation = withoutHookEmptyEffect.setOffsetRotation
effect_destroy(emptyEffect)
]]

local sm_effect_createEffect = sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local effect_setParameter = emptyEffect.setParameter
local effect_stop = emptyEffect.stop
local effect_destroy = emptyEffect.destroy
local effect_start = emptyEffect.start
local effect_isDone = emptyEffect.isDone
local effect_isPlaying = emptyEffect.isPlaying
local effect_setScale = emptyEffect.setScale
local effect_setOffsetPosition = emptyEffect.setOffsetPosition
local effect_setOffsetRotation = emptyEffect.setOffsetRotation
effect_destroy(emptyEffect)

local function round(number)
    return math_floor(number + 0.5)
end

local function checkFont(lfont)
	if type(lfont) ~= "table" then
		error("the font should be a table", 3)
    end

    if lfont.mono or lfont.mono == nil then
        if type(lfont.chars) ~= "table" or (type(lfont.width) ~= "number") or (type(lfont.height) ~= "number") then
            error("font failed integrity check", 3)
        end
        
        if lfont.width > FONT_SIZE_LIMIT then
            error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
        elseif lfont.height > FONT_SIZE_LIMIT then
            error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
        end

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data ~= lfont.height then
                error("font failed integrity check", 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" or #line ~= lfont.width then
                    error("font failed integrity check", 3)
                end
            end
        end
    else
        if type(lfont.chars) ~= "table" then
            error("font failed integrity check", 3)
        end

        local oFont = font.optimizeFont(lfont)
        lfont.spaceSize = oFont.spaceSize
        lfont.width = oFont.width
        lfont.height = oFont.height

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data > FONT_SIZE_LIMIT then
                error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" or #line > FONT_SIZE_LIMIT then
                    error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
                end
            end
        end
    end
end

local function tableClone(tbl)
    local newtbl = {}
    for k, v in pairs(tbl) do
        newtbl[k] = v
    end
    return newtbl
end

local function stackChecksum(stack)
    local num = -#stack
    local t, v
    for i = 1, #stack do
        v = stack[i]
        t = type(v)
        num = num - i
        if t == "number" then
            num = num + ((v * i) + v + i + (v / i))
        elseif t == "Color" then
            num = num + ((i * (v.r / i) * -4) + v.g)
            num = num - ((i * (v.g + i) * 5) + v.b)
            num = num + ((i * (v.b - i) * 8) + v.r)
        elseif t == "string" then
            for i3 = 1, #v do
                num = num + (i * (-i3 - (string_byte(v, i3) * i3)))
            end
        end
    end
    return num
end

local function checkArg(n, have, ...)
	have = type(have)
	local tbl = {...}
	for _, t in ipairs(tbl) do
		if have == t then
			return
		end
	end
	error(string_format("bad argument #%d (%s expected, got %s)", n, table_concat(tbl, " or "), have), 3)
end

local function simpleRemathRect(x, y, w, h, maxX, maxY)
    local x2, y2 = x + (w - 1), y + (h - 1)
    if x < 0 then
        x = 0
    elseif x > maxX then
        --x = maxX
        return
    end
    if y < 0 then
        y = 0
    elseif y > maxY then
        --y = maxY
        return
    end
    if x2 < 0 then
        --x2 = 0
        return
    elseif x2 > maxX then
        x2 = maxX
    end
    if y2 < 0 then
        --y2 = 0
        return
    elseif y2 > maxY then
        y2 = maxY
    end
    return x, y, x2, y2, w, h
end

local function remathRect(offset, stack, maxX, maxY)
    return simpleRemathRect(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], maxX, maxY)
end

local function posCheck(width, height, x, y)
    return x >= 0 and y >= 0 and x < width and y < height
end

local hashChar = string.byte("#")
local bit = bit or bit32
local band = bit.band
local rshift = bit.rshift
local function hexToRGB(color)
    return band(rshift(color, 16), 0xFF) / 255, band(rshift(color, 8), 0xFF) / 255, band(color, 0xFF) / 255
end

local function hexToRGB256(color)
    return band(rshift(color, 16), 0xFF), band(rshift(color, 8), 0xFF), band(color, 0xFF)
end

local function optimizationLevelToValue(level)
    return (level / 255) * 0.25
end

local function formatColor(color, default)
    local t = type(color)
    if t == "Color" then
        return color
    elseif t == "string" then
        return color_new(color)
    elseif t == "number" then
        return color_new(hexToRGB(color))
    end

    return default
end

local redMul = 256 * 256 * 256
local greenMul = 256 * 256
local blueMul = 256
local function formatColorToNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * redMul) + (math_floor(color.g * 255) * greenMul) + (math_floor(color.b * 255) * blueMul) + math_floor(color.a * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return val
        end
        return (val * 256) + 255
    elseif t == "number" then
        return (color * 256) + 255
    end

    return default or 0
end

local function formatColorToSmallNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * greenMul) + (math_floor(color.g * 255) * blueMul) + math_floor(color.b * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return math_floor(val / 256)
        end
        return val
    elseif t == "number" then
        return color
    end

    return default or 0
end

local function color_new_fromSmallNumber(number, alpha)
    return color_new((number * 256) + (alpha or 255))
end

local function mathDist(pos1, pos2)
    return math.sqrt(((pos1.x - pos2.x) ^ 2) + ((pos1.y - pos2.y) ^ 2) + ((pos1.z - pos2.z) ^ 2))
end

local function needPushStack(canvas, dataTunnel, dt) --returns true if the rendering stack should be applied
    return dataTunnel.display_forceFlush or not ((dataTunnel.skipAtNotSight and not canvas.isRendering()))
end

local resetViewportCodeID = -23124
local dataSizes = {
    [resetViewportCodeID] = 1,
    [-1] = 5,
    [0] = 2,
    3,
    6,
    7,
    9, --text
    7, --line
    5,
    5,
    5,
    6,

    4, --drawPoly
    4 --fillPoly
}

local userCalls = {}

canvasAPI.yield = function() end

function canvasAPI.createDrawer(sizeX, sizeY, callback, callbackBefore, directArg, direct_clear, direct_fill, direct_set, updatedList)
    local obj = {}
    local oldStackSum
    local rSizeX, rSizeY = sizeX, sizeY
    local maxX, maxY = sizeX - 1, sizeY - 1
    local newBuffer, newBufferBase = {}, 0
    local realBuffer = {}
    local maxBuffer = maxX + (maxY * sizeX)
    local currentFont = font.optimized
    local fontWidth, fontHeight = font.width, font.height
    local rotation = 0
    local utf8Support = false
    local updated = false
    local clearOnly = false
    local maxLineSize = sizeX + sizeY
    local bigSide = math_max(sizeX, sizeY)
    local drawerData = {}
    local changes = {}
    local _changes = {}
    local changesIndex, changesCount = {}, 0

    local bufferChangedFrom = huge
    local bufferChangedTo = -huge

    local function bufferRangeUpdate(index)
        if index < bufferChangedFrom then bufferChangedFrom = index end
        if index > bufferChangedTo then bufferChangedTo = index end
    end

    local viewportEnable = false
    local brightnessEnable = false
    local brightness = 1
    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local function setDot(px, py, col)
        if viewportEnable and (px < viewport_x or py < viewport_y or px >= (viewport_x + viewport_sx) or py >= (viewport_y + viewport_sy)) then
            return
        end

        --[[
        if rotation == 0 then
            index = px + (py * rSizeX)
        elseif rotation == 1 then
            index = (rSizeX - py - 1) + (px * rSizeX)
        elseif rotation == 2 then
            index = (rSizeX - px - 1) + ((rSizeY - py - 1) * rSizeX)
        else
            index = py + ((rSizeY - px - 1) * rSizeX)
        end
        ]]

        if brightnessEnable then
            local r = math_floor(col / 256 / 256) % 256
            local g = math_floor(col / 256) % 256
            local b = col % 256
            col = (math_min(255, math_floor(r * brightness)) * 256 * 256) + (math_min(255, math_floor(g * brightness)) * 256) + math_min(255, math_floor(b * brightness))
        end

        local index
        if rotation == 0 then
            index = py + (px * rSizeY)
        elseif rotation == 1 then
            index = px + ((rSizeX - py - 1) * rSizeY)
        elseif rotation == 2 then
            index = (rSizeY - py - 1) + ((rSizeX - px - 1) * rSizeY)
        else
            index = (rSizeY - px - 1) + (py * rSizeY)
        end

        if updatedList and not changes[index] then
            changes[index] = true
            changesCount = changesCount + 1
            changesIndex[changesCount] = index
        end

        if direct_set then
            newBuffer[index] = col
            direct_set(directArg, math_floor(index / rSizeY), index % rSizeY, col)
            return true
        elseif newBuffer[index] ~= col then
            bufferRangeUpdate(index)
            newBuffer[index] = col
            return true
        end
    end

    local function check(px, py)
        return px >= 0 and py >= 0 and px < sizeX and py < sizeY
    end

    local function checkSetDot(px, py, col)
        if check(px, py) then
            setDot(px, py, col)
            return true
        end
        return false
    end

    function obj.drawerReset()
    end

    function obj.setSoftwareRotation(_rotation)
        rotation = _rotation
        if rotation == 1 or rotation == 3 then
            sizeX = rSizeY
            sizeY = rSizeX
        else
            sizeX = rSizeX
            sizeY = rSizeY
        end
        maxX, maxY = sizeX - 1, sizeY - 1
    end

    function obj.setUtf8Support(state)
        utf8Support = not not state
    end

    function obj.setFont(customFont)
        if customFont then
            currentFont = customFont
            fontWidth, fontHeight = customFont.width, customFont.height
        else
            currentFont = font.optimized
            fontWidth, fontHeight = font.width, font.height
        end
    end

    local old_rotation
    local old_utf8support
    local old_customFont
    function obj.pushDataTunnelParams(params)
        brightness = params.brightness
        brightnessEnable = brightness ~= 1

        if params.rotation ~= old_rotation then
            obj.setSoftwareRotation(params.rotation)
            old_rotation = params.rotation
        end
        if params.utf8support ~= old_utf8support then
            obj.setUtf8Support(params.utf8support)
            old_utf8support = params.utf8support
        end
        if params.customFont ~= old_customFont then
            obj.setFont(params.customFont)
            old_customFont = params.customFont
        end
    end

    ------------------------------------------
    
    local function rasterize_fill(x, y, sx, sy, col)
        local x, y, x2, y2 = simpleRemathRect(x, y, sx, sy, maxX, maxY)
        if not x then return end
        for ix = x, x2 do
            for iy = y, y2 do
                setDot(ix, iy, col)
            end
        end
    end

    local function rasterize_circleF(px, py, r, col)
        local chr = r*r
        local sx, sy, tempInt, tempBool

        if r < bigSide and px >= 0 and py >= 0 and px < sizeX and py < sizeY then --now only a quarter of the circle is rendered
            for iy = 0, r do
                sy = iy + 0.5
                tempBool = false
                for ix = r, 0, -1 do
                    sx = ix + 0.5
                    if tempBool or (sx * sx) + (sy * sy) <= chr then
                        tempBool = true
                        checkSetDot(px + ix, py + iy, col)
                        checkSetDot(px - ix - 1, py + iy, col)
                        checkSetDot(px + ix, py - iy - 1, col)
                        checkSetDot(px - ix - 1, py - iy - 1, col)
                    end
                end
            end
        else
            for ix = math_max(-r, -px), math_min(r, (sizeX - px) - 1) do --if the starting point is not within the screen or the circle is too large, then will have to check every pixel
                sx = ix + 0.5
                for iy = math_max(-r, -py), math_min(r, (sizeY - py) - 1) do
                    sy = iy + 0.5
                    if (sx * sx) + (sy * sy) <= chr then
                        setDot(px + ix, py + iy, col)
                    end
                end
            end
        end
    end

    local function rasterize_line(px, py, px2, py2, col, width, linesInfo)
        local dx = math_abs(px2 - px)
        local dy = math_abs(py2 - py)
        local sx = (px < px2) and 1 or -1
        local sy = (py < py2) and 1 or -1
        local err = dx - dy
        local e2
        if width == -1 or width == 0 or width == 1 then
            for _ = 1, maxLineSize do
                checkSetDot(px, py, col)
                if px == px2 and py == py2 then
                    break
                end
                e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        elseif width < 0 then
            width = math_ceil((-width) / 2)
            if width < 1 then
                width = 1
            end
            for _ = 1, maxLineSize do
                rasterize_circleF(px, py, width, col)
                if px == px2 and py == py2 then
                    break
                end
                e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        else
            local offsetFill = math_floor(width / 2)
            for _ = 1, maxLineSize do
                rasterize_fill(px - offsetFill, py - offsetFill, width, width, col)
                if px == px2 and py == py2 then
                    break
                end
                e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        end
    end

    ------------------------------------------

    local function render_fill(stack, offset)
        local col = stack[offset+4]
        if direct_fill then
            direct_fill(directArg, stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
        else
            local x, y, x2, y2 = remathRect(offset, stack, maxX, maxY)
            if not x then return end
            --[[
            for ix = x, x2 do
                for iy = y, y2 do
                    setDot(ix, iy, col)
                end
            end
            ]]
            local ix, iy = x, y
            for _ = 1, ((y2 - y) + 1) * ((x2 - x) + 1) do
                setDot(ix, iy, col)
                iy = iy + 1
                if iy > y2 then
                    iy = y
                    ix = ix + 1
                end
            end
        end
    end

    local function render_rect(stack, offset)
        local x, y, x2, y2, w, h = remathRect(offset, stack, maxX, maxY)
        if not x then return end
        local col = stack[offset+4]
        local lineWidth = stack[offset+5]
        if lineWidth == 1 then
            for ix = x, x2 do
                setDot(ix, y, col)
                setDot(ix, y2, col)
            end

            for iy = y + 1, y2 - 1 do
                setDot(x, iy, col)
                setDot(x2, iy, col)
            end
        else
            local _y, _y2, _x, _x2
            for ioff = 0, math_min(lineWidth, math_max(w, h) / 2) - 1 do
                _y = y + ioff
                _y2 = y2 - ioff
                for ix = x + ioff, x2 - ioff do
                    setDot(ix, _y, col)
                    setDot(ix, _y2, col)
                end

                _x = x + ioff
                _x2 = x2 - ioff
                for iy = y + 1 + ioff, y2 - (1 + ioff) do
                    setDot(_x, iy, col)
                    setDot(_x2, iy, col)
                end
            end
        end
    end

    local function render_text(stack, offset)
        local tx, ty = stack[offset], stack[offset+1]
        local text = stack[offset+2]
        local col = stack[offset+3]
        local scaleX = stack[offset+4]
        local scaleY = stack[offset+5]
        local spacing = stack[offset+6]
        local fontIndex = stack[offset+7]
        local chrdata

        local localFont = currentFont
        local localFontWidth = fontWidth
        if fontIndex > 0 and fontsOptimized[fontIndex] then
            localFont = fontsOptimized[fontIndex]
            localFontWidth = localFont.width
        end

        local px, py
        local len, sep
        if utf8Support then
            len, sep = utf8_len, utf8_sub
        else
            len, sep = string_len, string_byte
        end
        local lposX, lposY
        local char, charOffset
        local setPosX
        local scaledFontWidth = math_ceil(localFontWidth * scaleX)
        if localFont.mono then
            for i = 1, len(text) do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    charOffset = (i - 1) * (scaledFontWidth + spacing)
                    for i2 = 1, #chrdata, 2 do
                        px, py = chrdata[i2], chrdata[i2 + 1]
                        lposX, lposY = round(px * scaleX), round(py * scaleY)
                        for ix = 0, math_min(sizeX, round((px + 1) * scaleX) - lposX - 1) do
                            setPosX = tx + ix + lposX + charOffset
                            for iy = 0, math_min(sizeY, round((py + 1) * scaleY) - lposY - 1) do
                                checkSetDot(setPosX, ty + iy + lposY, col)
                            end
                        end
                    end
                end
            end
        else
            charOffset = 0
            local charPos
            local startDrawTime = os_clock()
            for i = 1, len(text) do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    charPos = tx + charOffset
                    if not chrdata[0] or charPos + round(chrdata[0] * scaleX) > 0 then
                        if charPos > maxX then
                            goto endDraw
                        end
                        for i2 = 1, #chrdata, 2 do
                            px, py = chrdata[i2], chrdata[i2 + 1]
                            lposX, lposY = round(px * scaleX), round(py * scaleY)
                            for ix = 0, math_min(sizeX, round((px + 1) * scaleX) - lposX - 1) do
                                setPosX = tx + ix + lposX + charOffset
                                for iy = 0, math_min(sizeY, round((py + 1) * scaleY) - lposY - 1) do
                                    checkSetDot(setPosX, ty + iy + lposY, col)
                                end
                            end
                        end
                    end
                    charOffset = charOffset + (chrdata[0] and math_ceil(chrdata[0] * scaleX) or 0) + spacing
                else
                    charOffset = charOffset + (localFont.spaceSize or localFontWidth) + spacing
                end
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
        end
        ::endDraw::
    end

    local function render_line(stack, offset)
        rasterize_line(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4], stack[offset+5])
    end

    local function render_circle(stack, offset) --Michener’s Algorithm
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx, py + dy, col)
            checkSetDot(px + dy, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy, col)
            checkSetDot(px + dy, py - dx, col)
            checkSetDot(px + dx, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleE(stack, offset)
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx - 1, py + dy - 1, col)
            checkSetDot(px + dy - 1, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy - 1, col)
            checkSetDot(px + dy - 1, py - dx, col)
            checkSetDot(px + dx - 1, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleF(stack, offset)
        rasterize_circleF(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3])
    end

    local function render_circleVE(stack, offset) --drawCircleVeryEvenly
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local chr = e2*e2
        local col = stack[offset+3]
        local sx, sy, tempInt, tempBool

        e2 = math_min(e2, bigSide)
        for iy = 0, e2 do
            sy = iy + 0.5
            tempInt = stack[offset+4]
            for ix = e2, 0, -1 do
                sx = ix + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
        for ix = 0, e2 do
            sx = ix + 0.5
            tempInt = stack[offset+4]
            for iy = e2, 0, -1 do
                sy = iy + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
    end

    local function render_drawPoly(stack, offset, linesInfo)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local startDrawTime = os_clock()
        local _px = stack[offset+3]
        local _py = stack[offset+4]
        local px, py
        for i = 3, points, 2 do
            px = stack[offset+2+i]
            py = stack[offset+3+i]
            rasterize_line(_px, _py, px, py, col, width, linesInfo)
            _px = px
            _py = py
            if os_clock() - startDrawTime > MAX_DRAW_TIME then
                goto endDraw
            end
        end
        rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width, linesInfo)

        ::endDraw::
        return points
    end

    local function render_fillPoly(stack, offset)
        local linesInfo = {}
        local points = render_drawPoly(stack, offset, linesInfo)

        return points
    end

    function obj.pushStack(stack)
        local offset = 2
        local actionNum
        local addValue = 0
        local startDrawTime = os_clock()
        local idx
        while stack[offset] do
            actionNum = stack[offset-1]
            clearOnly = actionNum == 0
            addValue = 0

            if actionNum == 0 then
                newBufferBase = stack[offset]
                newBuffer = {}
                if direct_clear then
                    direct_clear(directArg, newBufferBase, changes)
                else
                    bufferChangedFrom = 0
                    bufferChangedTo = maxBuffer
                end
                updated = true
            elseif actionNum == resetViewportCodeID then
                viewportEnable = false
            elseif actionNum == -1 then
                viewportEnable = true
                viewport_x = stack[offset]
                viewport_y = stack[offset+1]
                viewport_sx = stack[offset+2]
                viewport_sy = stack[offset+3]
            elseif actionNum == 1 then
                idx = stack[offset]
                setDot(idx % rSizeX, math_floor(idx / rSizeX), stack[offset+1])
                updated = true
            elseif actionNum == 2 then
                render_fill(stack, offset)
                updated = true
            elseif actionNum == 3 then
                render_rect(stack, offset)
                updated = true
            elseif actionNum == 4 then
                render_text(stack, offset)
                updated = true
            elseif actionNum == 5 then
                render_line(stack, offset)
                updated = true
            elseif actionNum == 6 then
                render_circle(stack, offset)
                updated = true
            elseif actionNum == 8 then
                render_circleE(stack, offset)
                updated = true
            elseif actionNum == 7 then
                render_circleF(stack, offset)
                updated = true
            elseif actionNum == 9 then
                render_circleVE(stack, offset)
                updated = true
            elseif actionNum == 10 then
                addValue = render_drawPoly(stack, offset)
                updated = true
            elseif actionNum == 11 then
                addValue = render_fillPoly(stack, offset)
                updated = true
            elseif userCalls[actionNum] then
                if userCalls[actionNum](newBuffer, rotation, rSizeX, rSizeY, sizeX, sizeY, stack, offset, drawerData, bufferRangeUpdate, setDot, checkSetDot) then
                    updated = true
                end
            end

            if os_clock() - startDrawTime > MAX_DRAW_TIME then
                goto endDraw
            end

            offset = offset + dataSizes[actionNum] + addValue
        end

        ::endDraw::
    end

    function obj.flush(force)
        if not obj.wait and (updated or force) then
            if force then
                bufferChangedFrom = 0
                bufferChangedTo = maxBuffer
            end
            if callbackBefore then
                if callbackBefore(newBufferBase, clearOnly, maxBuffer, force, newBuffer, realBuffer, bufferChangedFrom, bufferChangedTo, changes, changesIndex, changesCount, _changes) then
                    realBuffer = {}
                end
            end
            if callback then
                local color, px, py
                for i = bufferChangedFrom, bufferChangedTo do
                    color = newBuffer[i] or newBufferBase
                    if color ~= realBuffer[i] or force then
                        px = math_floor(i / rSizeY)
                        py = i % rSizeY
                        callback(px, py, color, newBufferBase)
                        realBuffer[i] = color
                    end
                end
            end
            bufferChangedFrom = huge
            bufferChangedTo = -huge
            updated = false
            if updatedList then
                changes = {}
                changesIndex = {}
                changesCount = 0
            end
        end
    end

    function obj.setWait(state)
        obj.wait = state
        if not state then
            obj.flush()
        end
    end

    function obj.getNewBuffer(i)
        return newBuffer[i] or newBufferBase
    end

    function obj.getRealBuffer(i)
        return realBuffer[i]
    end

    function obj.getChanges()
        return changes
    end

    function obj.fullRefresh()
        changesCount = 0
        changesIndex = {}
        for i = 0, (sizeX * sizeY) - 1 do
            changes[i] = true
            changesCount = changesCount + 1
            changesIndex[changesCount] = i
        end
    end

    function obj.flushOldChanges()
        _changes = changes
    end

    function obj.clearChangesBuffer()
        _changes = {}
        changes = {}
    end

    return obj
end

if better and better.isAvailable() and better.canvas and better.version >= 40 then
    local better_canvas_clear = better.canvas.clear
    local better_canvas_fill = better.canvas.fill
    local better_canvas_set = better.canvas.set

    function canvasAPI.createBetterCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation)
        local obj = {sizeX = sizeX, sizeY = sizeY}
        local maxX, maxY = sizeX - 1, sizeY - 1
        local maxEffectArrayBuffer = maxX + (maxY * sizeX)
        local dist
        local needOptimize = false
        local showState = false
        local disable = false
        local flushedDefault = false

        local betterCanvas = better.canvas.create(sizeX, sizeY)

        local drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, nil, betterCanvas, better_canvas_clear, better_canvas_fill, better_canvas_set)
        drawer.setWait(true)

        local function getSelfPos()
            local pt = type(parent)
            if pt == "Interactable" then
                return parent.shape.worldPosition
            elseif pt == "Character" then
                return parent.worldPosition
            end
        end

        function obj.isRendering()
            return showState
        end

        function obj.disable(state)
            disable = state
        end

        function obj.setRenderDistance(_dist)
            dist = _dist
        end

        function obj.update()
            local newShowState = true
            local selfPosition
            if disable then
                newShowState = false
            elseif dist then
                if not pcall(function()
                    selfPosition = getSelfPos()
                    newShowState = mathDist(selfPosition, sm_localPlayer_getPlayer().character.worldPosition) <= dist
                end) then
                    selfPosition = selfPosition or vec3_new(0, 0, 0)
                    newShowState = false
                end
            end

            if newShowState ~= showState then
                showState = newShowState
                if newShowState then
                    drawer.setWait(false)
                    if not flushedDefault then
                        drawer.flush(true)
                        flushedDefault = true
                    end
                else
                    drawer.setWait(true)
                    better.canvas.stopUpdate(betterCanvas)
                end
            end

            if newShowState then
                better.canvas.update_3d(betterCanvas, selfPosition + (rotation * offset), -sm.quat.getRight(rotation), -sm.quat.getUp(rotation), (pixelSize.x * sizeX) / 2, (pixelSize.y * sizeY) / 2)
            end
        end

        function obj.setPixelSize(_pixelSize)
            pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
            if type(pixelSize) == "number" then
                if pixelSize < 0 then
                    pixelSize = math_abs(pixelSize)
                    local vec = vec3_new(pixelSize, pixelSize, 0)
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                else
                    local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                end
            end
        end

        function obj.setOffset(_offset)
            offset = _offset
        end

        function obj.setCanvasRotation(_rotation)
            rotation = _rotation
        end

        function obj.destroy()
            better.canvas.destroy(betterCanvas)
        end

        ---------------------------------------

        obj.setPixelSize(pixelSize)
        obj.setCanvasRotation(rotation or quat_fromEuler(vec3_new(0, 0, 0)))
        obj.setOffset(offset or vec3_new(0, 0, 0))

        --[[
        local c = 0xff0000
        local seffect = createEffect(5, 5, 16, 16, c)
        local idx = 5 + (5 * sizeX)
        for i = 0, 16 - 1 do
            effects[idx + i] = {
                seffect,
                c,
                i,
                16,
                idx,
                5,
                5,
                1, --8. sizeY
                0 --9. indexY
            }
        end
        ]]

        ---------------------------------------

        obj.drawer = drawer
        for k, v in pairs(drawer) do
            obj[k] = v
        end

        return obj
    end
end

--low level display api
function canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material, scaleAddValue)
    local hiddenOffset = vec3_new(1000000, 1000000, 1000000)
    local obj = {sizeX = sizeX, sizeY = sizeY}
    local maxX, maxY = sizeX - 1, sizeY - 1
    local maxEffectArrayBuffer = maxX + (maxY * sizeX)
    local dist
    local needOptimize = false
    local showState = false
    local disable = false
    local colorCache = {}

    material = material or canvasAPI.material.classic
    local autoScaleAddValue = false
    if not scaleAddValue then
        autoScaleAddValue = true
    end

    local flushedDefault = false
    local oldBackplateColor
    local backplate
    if canvasAPI.multi_layer[tostring(material)] then
        oldBackplateColor = 0
        backplate = sm_effect_createEffect(getEffectName(), parent)
        effect_setParameter(backplate, "uuid", material)
        effect_setParameter(backplate, "color", black)
    end

    local effects = {}
    local nodeEffects = {}
    local effectDatas = {}
    local effectDataLen = 5

    local bufferedEffects = {}
    local bufferedEffectsIndex = 0
    local lastDrawTickTime
    local optimizationLevel = 16
    local optimizationValue = optimizationLevelToValue(optimizationLevel)
    local alpha = DEFAULT_ALPHA_VALUE

    local function getEIndex(index)
        return index * effectDataLen
    end

    local function fromEIndex(index)
        return index / effectDataLen
    end

    local function setEffectDataParams(index)
        local effect = nodeEffects[index]
        local eindex = getEIndex(index)
        local posX, posY, lSizeX, lSizeY = effectDatas[eindex+1], effectDatas[eindex+2], effectDatas[eindex+3], effectDatas[eindex+4]

        posX = posX + ((lSizeX - 1) * 0.5)
        posY = posY + ((lSizeY - 1) * 0.5)
        effect_setOffsetPosition(effect, rotation * (offset + vec3_new(((posX + 0.5) - (sizeX / 2)) * pixelSize.x, ((posY + 0.5) - (sizeY / 2)) * -pixelSize.y, backplate and (debugMode and 0.05 or 0.001) or 0)))

        local localScaleAddValue = debugMode and -(pixelSize.x / 2) or scaleAddValue
        local vec = pixelSize * 1
        vec.x = (pixelSize.x * lSizeX) + localScaleAddValue
        vec.y = (pixelSize.y * lSizeY) + localScaleAddValue
        effect_setScale(effect, vec)
    end

    local function createEffect()
        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            effect_setOffsetRotation(effect, rotation)
        end
        return effect
    end

    local function clearBufferedEffects()
        for i = 1, bufferedEffectsIndex do
            effect_destroy(bufferedEffects[i])
        end
        bufferedEffects = {}
        bufferedEffectsIndex = 0
    end

    local lastNewBuffer, lastBase

    local lastPopularColorTick, lastPopularColor
    local lastPopularColorUpdatePerTick = (sizeX * sizeY) / 256
    local function mathPopularColor()
        local oldLastPopularColor = lastPopularColor

        local colorUsesTable = {}
        local colorUses = 0
        local oldColorUses = 0
        local colorSum = 0
        for index in pairs(nodeEffects) do
            local eindex = getEIndex(index)
            local color = effectDatas[eindex]
            local colorSize = effectDatas[eindex+3] * effectDatas[eindex+4]
            colorUsesTable[color] = (colorUsesTable[color] or 0) + colorSize
            colorSum = colorSum + colorSize
            colorUses = colorUsesTable[color]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = color
            end
        end

        if oldBackplateColor then
            local colorSize = (sizeX * sizeY) - colorSum
            colorUsesTable[oldBackplateColor] = (colorUsesTable[oldBackplateColor] or 0) + colorSize
            colorUses = colorUsesTable[oldBackplateColor]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = oldBackplateColor
            end
        end

        if oldLastPopularColor and colorUses < 32 then
            lastPopularColor = oldLastPopularColor
        else
            lastPopularColorTick = sm.game.getCurrentTick()
        end
    end

    local function effectIndexAtPos(px, py)
        return py + (px * sizeY)
    end

    local function getRootEIndexAtPos(px, py)
        local index = effects[effectIndexAtPos(px, py)]
        return index and getEIndex(index), index
    end

    local function clearEffectFromBuffer(index)
        local eindex = getEIndex(index)
        local six, ix, iy = effectDatas[eindex+1], effectDatas[eindex+1], effectDatas[eindex+2]
        local sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        nodeEffects[index] = nil
        for i = 0, 4 do
            effectDatas[eindex+i] = nil
        end
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix >= six + sizeX then
                ix = six
                iy = iy + 1
            end
        end
    end

    local function hideEffect(effect, hideList)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        if hideList then
            hideList[effect.id] = effect
        else
            effect_setOffsetPosition(effect, hiddenOffset)
        end
    end

    local function hideEffectData(index, hideList)
        hideEffect(nodeEffects[index], hideList)
        clearEffectFromBuffer(index)
    end

    local function hideEffectsWithColor(color)
        for index in pairs(nodeEffects) do
            if effectDatas[getEIndex(index)] == color then
                hideEffectData(index)
            end
        end
    end

    local function delAllEffects()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        effects = {}
        nodeEffects = {}
    end

    --[[
    local function forceRecreateNodeEffects()
        nodeEffects = {}
        for i, effectData in pairs(effects) do
            if effectData[7] == i then
                nodeEffects[i] = effectData
            end
        end
    end
    ]]

    local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
    local function colorEquals_smart(color1, color2)
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    local function extractVerticleLine(changedList, changedColorList, index, px, py, saveExtractionPixel)
        local effectData = effects[index]
        local lx = px - effectData[3]
        local rpx, rpy = effectData[3], effectData[4]
        if lx == 0 then --extract first line
            if saveExtractionPixel then
                local newEffectData = {
                    createEffect(),
                    effectData[2],
                    rpx,
                    rpy,
                    1,
                    effectData[6],
                    effectData[7]
                }
                for i = 0, newEffectData[6] - 1 do
                    effects[newEffectData[7] + i] = newEffectData
                end
                nodeEffects[newEffectData[7]] = newEffectData
                changedList[newEffectData] = true
                changedColorList[newEffectData[1]] = newEffectData
            else
                for i = 0, effectData[6] - 1 do
                    effects[effectData[7] + i] = nil
                end
                nodeEffects[effectData[7]] = nil
            end

            effectData[7] = effectData[7] + sizeY
            nodeEffects[effectData[7]] = effectData
            effectData[3] = effectData[3] + 1
            effectData[5] = effectData[5] - 1
            changedList[effectData] = true
        elseif lx == effectData[5] - 1 then --extract last line
            local rootIndex = effectIndexAtPos(px, rpy)
            if saveExtractionPixel then
                local newEffectData = {
                    createEffect(),
                    effectData[2],
                    px,
                    rpy,
                    1,
                    effectData[6],
                    rootIndex
                }
                nodeEffects[rootIndex] = newEffectData
                for i = 0, newEffectData[6] - 1 do
                    effects[rootIndex + i] = newEffectData
                end
                changedList[newEffectData] = true
                changedColorList[newEffectData[1]] = newEffectData
            else
                for i = 0, effectData[6] - 1 do
                    effects[rootIndex + i] = nil
                end
            end

            effectData[5] = effectData[5] - 1
            changedList[effectData] = true
        else --extract center line
            local endPartIndex = px + 1
            local newEffectData = { --end part
                createEffect(),
                effectData[2],
                endPartIndex,
                rpy,
                effectData[5] - lx - 1,
                effectData[6],
                effectIndexAtPos(endPartIndex, rpy)
            }
            nodeEffects[newEffectData[7]] = newEffectData
            local ix, iy = 0, 0
            local sizeX, sizeY = newEffectData[5], newEffectData[6]
            for _ = 1, sizeX * sizeY do
                effects[effectIndexAtPos(endPartIndex + ix, rpy + iy)] = newEffectData
                ix = ix + 1
                if ix >= sizeX then
                    ix = 0
                    iy = iy + 1
                end
            end
            --[[
            for iy = 0, newEffectData[6] - 1 do
                for i = 0, newEffectData[5] - 1 do
                    effects[effectIndexAtPos(endPartIndex + i, rpy + iy)] = newEffectData
                end
            end
            ]]
            changedList[newEffectData] = true
            changedColorList[newEffectData[1]] = newEffectData

            effectData[5] = lx --first part
            changedList[effectData] = true

            local rootIndex = effectIndexAtPos(px, rpy)
            if saveExtractionPixel then
                newEffectData = { --center part
                    createEffect(),
                    effectData[2],
                    px,
                    rpy,
                    1,
                    effectData[6],
                    rootIndex
                }
                nodeEffects[rootIndex] = newEffectData
                for i = 0, newEffectData[6] - 1 do
                    effects[rootIndex + i] = newEffectData
                end
                changedList[newEffectData] = true
                changedColorList[newEffectData[1]] = newEffectData
            else
                for i = 0, effectData[6] - 1 do
                    effects[rootIndex + i] = nil
                end
            end
        end
    end

    local function extractVerticlePixel(changedList, changedColorList, index, px, py, saveExtractionPixel)
        local effectData = effects[index]
        local ly = py - effectData[4]
        if ly == 0 then --extract first pixel
            if saveExtractionPixel then
                local newEffectData = {
                    createEffect(),
                    nil,
                    px,
                    py,
                    1,
                    1,
                    effectData[7]
                }
                effects[newEffectData[7]] = newEffectData
                nodeEffects[newEffectData[7]] = newEffectData
                changedList[newEffectData] = true
            else
                effects[effectData[7]] = nil
                nodeEffects[effectData[7]] = nil
            end

            effectData[7] = effectData[7] + 1
            effectData[4] = effectData[4] + 1
            effectData[6] = effectData[6] - 1
            nodeEffects[effectData[7]] = effectData
            changedList[effectData] = true
        elseif ly == effectData[6] - 1 then --extract last pixel
            local rootIndex = effectData[7] + ly
            if saveExtractionPixel then
                local newEffectData = {
                    createEffect(),
                    nil,
                    px,
                    py,
                    1,
                    1,
                    rootIndex
                }
                effects[rootIndex] = newEffectData
                nodeEffects[rootIndex] = newEffectData
                changedList[newEffectData] = true
            else
                effects[rootIndex] = nil
                nodeEffects[rootIndex] = nil
            end

            effectData[6] = effectData[6] - 1
            changedList[effectData] = true
        else --extract center pixel
            local newEffectData = { --end part
                createEffect(),
                effectData[2],
                px,
                py + 1,
                1,
                effectData[6] - ly - 1,
                effectIndexAtPos(px, py + 1)
            }
            nodeEffects[newEffectData[7]] = newEffectData
            for i = 1, newEffectData[6] do
                effects[effectData[7] + ly + i] = newEffectData
            end
            changedList[newEffectData] = true
            changedColorList[newEffectData[1]] = newEffectData

            effectData[6] = ly --first part
            changedList[effectData] = true

            local rootIndex = effectData[7] + ly
            if saveExtractionPixel then
                newEffectData = { --center part
                    createEffect(),
                    nil,
                    px,
                    py,
                    1,
                    1,
                    rootIndex
                }
                effects[rootIndex] = newEffectData
                nodeEffects[rootIndex] = newEffectData
                changedList[newEffectData] = true
            else
                effects[rootIndex] = nil
                nodeEffects[rootIndex] = nil
            end
        end
    end

    local function tryAttach(changedList, changedColorList, index, px, py, color, hideList)
        --[[
        local attached

        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        if origIndex then
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end

        local fillX1, fillX2, fillY1, fillY2 = px, px, py, py
        local function updateFillbox(x, y)
            if x < fillX1 then
                fillX1 = x
            elseif x > fillX2 then
                fillX2 = x
            end

            if y < fillY1 then
                fillY1 = y
            elseif y > fillY2 then
                fillY2 = y
            end
        end

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local downParentE, downParent = getRootEIndexAtPos(px, py + sizeY)
        local upAvailable = upParentE and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)
        local downAvailable = downParentE and effectDatas[downParentE+1] == px and effectDatas[downParentE+3] == sizeX and colorEquals(effectDatas[downParentE], color)

        if upAvailable and downAvailable and false then
            nodeEffects[index] = nil
            nodeEffects[downParent] = nil

            hideEffect(nodeEffects[downParent], hideList)
            changedList[downParent] = nil
            changedColorList[downParent] = nil

            local add = sizeY + effectDatas[downParentE+4]
            effectDatas[upParentE+4] = effectDatas[upParentE+4] + add
            updateFillbox(px + (sizeX - 1), py + (add - 1))
            attached = upParentE
        elseif upAvailable and false then
            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            updateFillbox(px + (sizeX - 1), py + (sizeY - 1))
            attached = upParentE
        elseif downAvailable then
            changedList[downParent] = nil
            changedColorList[downParent] = nil

            changedList[index] = true
            changedColorList[index] = true

            nodeEffects[index] = nodeEffects[downParent]
            nodeEffects[downParent] = nil

            effectDatas[index] = effectDatas[downParentE]
            effectDatas[index+1] = effectDatas[downParentE+1]
            effectDatas[index+2] = py
            effectDatas[index+3] = effectDatas[downParentE+3]
            effectDatas[index+4] = effectDatas[downParentE+4] + sizeY

            for i = 0, effectDataLen - 1 do
                effectDatas[downParentE+i] = nil
            end
            
            updateFillbox(px + (sizeX - 1), py + (sizeY - 1))
            attached = index
        end

        if attached and false then
            index, px, py = attached, effectDatas[attached+1], effectDatas[attached+2]
            sizeX, sizeY = effectDatas[attached+3], effectDatas[attached+4]
        end

        local leftParent = getRootEIndexAtPos(px - 1, py)
        local rightParent = getRootEIndexAtPos(px + sizeX, py)
        local leftAvailable = leftParent and effectDatas[leftParent+2] == py and effectDatas[leftParent+4] == sizeY and colorEquals(effectDatas[leftParent], color)
        local rightAvailable = rightParent and effectDatas[rightParent+2] == py and effectDatas[rightParent+4] == sizeY and colorEquals(effectDatas[rightParent], color)
        
        if leftAvailable and rightAvailable and false then
            if attached then
                hideEffect(nodeEffects[attached], hideList)
                changedList[attached] = nil
                changedColorList[attached] = nil
            end
            
            nodeEffects[index] = nil
            
            hideEffect(nodeEffects[rightParent], hideList)
            changedList[rightParent] = nil

            nodeEffects[rightParent] = nil

            leftParent[5] = leftParent[5] + sizeX + rightParent[5]
            updateFillbox(px, py)
            updateFillbox(px + ((sizeX + rightParent[5]) - 1), py + (sizeY - 1))
            attached = leftParent
        elseif leftAvailable and false then
            if attached then
                hideEffect(nodeEffects[attached], hideList)
                changedList[attached] = nil
                changedColorList[attached] = nil
            end
            nodeEffects[index] = nil
            leftParent[5] = leftParent[5] + sizeX
            updateFillbox(px, py)
            updateFillbox(px + (sizeX - 1), py + (sizeY - 1))
            attached = leftParent
        elseif rightAvailable and false then
            if attached then
                hideEffect(nodeEffects[attached], hideList)
                changedList[attached] = nil
                changedColorList[attached] = nil
            end
            nodeEffects[rightParent] = nil
            rightParent[3] = rightParent[3] - sizeX
            rightParent[5] = rightParent[5] + sizeX
            rightParent[7] = effectIndexAtPos(rightParent[3], rightParent[4])
            updateFillbox(px, py)
            updateFillbox(px + (sizeX - 1), py + (sizeY - 1))
            nodeEffects[index] = rightParent
            attached = rightParent
        end

        if attached then
            --print("Q", changedList[attached])
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = attached
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            if origIndex then
                hideEffect(nodeEffects[origIndex], hideList)
                changedList[origIndex] = nil
                changedColorList[origIndex] = nil
            end
        end

        return attached
        ]]

        local attached = false

        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        local origEffect
        if origIndex then
            origEffect = nodeEffects[origIndex]
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end

        local fillX1, fillX2, fillY1, fillY2 = px, px, py, py
        local function updateFillbox(x, y)
            if x < fillX1 then
                fillX1 = x
            elseif x > fillX2 then
                fillX2 = x
            end

            if y < fillY1 then
                fillY1 = y
            elseif y > fillY2 then
                fillY2 = y
            end
        end

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local downParentE, downParent = getRootEIndexAtPos(px, py + sizeY)
        local upAvailable = upParentE and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)
        local downAvailable = downParentE and effectDatas[downParentE+1] == px and effectDatas[downParentE+3] == sizeX and colorEquals(effectDatas[downParentE], color)

        local newIndex, newEIndex
        local fillVal
        if upAvailable and downAvailable then
            local addSizeY = sizeY + effectDatas[downParentE+4]

            hideEffect(nodeEffects[downParent], hideList)
            changedList[downParent] = nil
            changedColorList[downParent] = nil
            for i = 0, effectDataLen - 1 do
                effectDatas[downParentE+i] = nil
            end

            if nodeEffects[index] then
                changedList[index] = nil
                changedColorList[index] = nil
                local eindex = getEIndex(index)
                for i = 0, effectDataLen - 1 do
                    effectDatas[eindex+i] = nil
                end
            end

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + addSizeY
            updateFillbox(px + (sizeX - 1), py + (addSizeY - 1))
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
            attached = true
        elseif upAvailable then
            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            updateFillbox(px + (sizeX - 1), py + (sizeY - 1))
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
            attached = true
        elseif downAvailable then
            changedList[downParent] = nil
            changedColorList[downParent] = nil

            changedList[index] = true
            changedColorList[index] = true

            nodeEffects[index] = nodeEffects[downParent]
            nodeEffects[downParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[downParentE]
            effectDatas[eindex+1] = effectDatas[downParentE+1]
            effectDatas[eindex+2] = py
            effectDatas[eindex+3] = effectDatas[downParentE+3]
            effectDatas[eindex+4] = effectDatas[downParentE+4] + sizeY

            for i = 0, effectDataLen - 1 do
                effectDatas[downParentE+i] = nil
            end
            
            updateFillbox(px + (sizeX - 1), py + (sizeY - 1))
            newIndex, newEIndex = index, eindex
            fillVal = index
            attached = true
        end

        if attached then
            index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
            sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
        end

        local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
        local rightParentE, rightParent = getRootEIndexAtPos(px + sizeX, py)
        local leftAvailable = leftParentE and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
        local rightAvailable = rightParentE and effectDatas[rightParentE+2] == py and effectDatas[rightParentE+4] == sizeY and colorEquals(effectDatas[rightParentE], color)

        if leftAvailable and rightAvailable then
            local addSizeX = sizeX + effectDatas[rightParentE+3]

            hideEffect(nodeEffects[rightParent], hideList)
            changedList[rightParent] = nil
            changedColorList[rightParent] = nil
            for i = 0, effectDataLen - 1 do
                effectDatas[rightParentE+i] = nil
            end

            if nodeEffects[index] then
                changedList[index] = nil
                changedColorList[index] = nil
                local eindex = getEIndex(index)
                for i = 0, effectDataLen - 1 do
                    effectDatas[eindex+i] = nil
                end
            end

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + addSizeX
            updateFillbox(px + (addSizeX - 1), py + (sizeY - 1))
            fillVal = leftParent
            attached = true
        elseif leftAvailable then
            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
            updateFillbox(px + (sizeX - 1), py + (sizeY - 1))
            fillVal = leftParent
            attached = true
        elseif rightAvailable then
            changedList[rightParent] = nil
            changedColorList[rightParent] = nil

            changedList[index] = true
            changedColorList[index] = true

            nodeEffects[index] = nodeEffects[rightParent]
            nodeEffects[rightParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[rightParentE]
            effectDatas[eindex+1] = px
            effectDatas[eindex+2] = effectDatas[rightParentE+2]
            effectDatas[eindex+3] = effectDatas[rightParentE+3] + sizeX
            effectDatas[eindex+4] = effectDatas[rightParentE+4]

            for i = 0, effectDataLen - 1 do
                effectDatas[rightParentE+i] = nil
            end
            
            updateFillbox(px + (sizeX - 1), py + (sizeY - 1))
            fillVal = index
            attached = true
        end

        local ix, iy = fillX1, fillY1
        for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
            effects[effectIndexAtPos(ix, iy)] = fillVal
            ix = ix + 1
            if ix > fillX2 then
                ix = fillX1
                iy = iy + 1
            end
        end

        if origEffect then
            hideEffect(origEffect, hideList)
        end

        return attached
    end

    local function fillEmptySpace(color)
        local px, py, effect, effectData
        local changedList = {}
        local changedColorList = {}
        
        for i = 0, maxEffectArrayBuffer do
            px = math_floor(i / sizeY)
            py = i % sizeY
            if not effects[i] and not tryAttach(changedList, i, px, py, color) then
                effect = createEffect()
                effectData = {
                    effect,
                    color,
                    px, --3. root pos x
                    py, --4. root pos Y
                    1,  --5. sizeX
                    1,  --6. sizeY
                    i   --7. root index
                }
                effects[i] = effectData
                changedList[effectData] = true
                changedColorList[effect] = effectData
            end
        end

        for effectData in pairs(changedList) do
            setEffectDataParams(effectData)
        end

        local color
        for _, effectData in pairs(changedColorList) do
            color = effectData[2]
            if not colorCache[color] then
                colorCache[color] = color_new_fromSmallNumber(color, alpha)
            end
            effect_setParameter(effectData[1], "color", colorCache[color])
        end
    end

    local clearBackplate = false
    local drawer
    drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, function (base, clearOnly, maxBuffer, force, newBuffer, realBuffer, bufferChangedFrom, bufferChangedTo, changes, changesIndex, changesCount, _changes)
        lastNewBuffer, lastBase = newBuffer, base
        lastDrawTickTime = sm.game.getCurrentTick()

        if clearOnly then
            delAllEffects()
            clearBufferedEffects()
            drawer.clearChangesBuffer()
            return
        end

        local changedList = {}
        local changedColorList = {}
        local hideList = {}

        if clearBackplate then
            for index in pairs(_changes) do
                if not changes[index] then
                    changesCount = changesCount + 1
                    changesIndex[changesCount] = index
                end
            end
        end

        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            if effects[index] then
                if not colorEquals(effectDatas[index], color) then
                    local px = math_floor(index / sizeY)
                    local py = index % sizeY
                    local eindex = getEIndex(effects[index])
                    local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
                    if color == oldBackplateColor then
                        if aSizeX and aSizeY then
                            extractVerticleLine(changedList, changedColorList, index, px, py, true)
                            extractVerticlePixel(changedList, changedColorList, index, px, py)
                        elseif aSizeX then
                            extractVerticleLine(changedList, changedColorList, index, px, py)
                        elseif aSizeY then
                            extractVerticlePixel(changedList, changedColorList, index, px, py)
                        else
                            changedList[index] = nil
                            hideEffectData(index)
                        end
                    else
                        _changes[index] = true
                        if aSizeX > 1 then
                            extractVerticleLine(changedList, changedColorList, index, px, py, true)
                        end
                        if aSizeY > 1 then
                            extractVerticlePixel(changedList, changedColorList, index, px, py, true)
                        end
                        if not tryAttach(changedList, changedColorList, index, px, py, color, hideList) then
                            effectDatas[eindex] = color
                            changedColorList[index] = true
                        end
                    end
                end
            elseif color ~= oldBackplateColor then
                _changes[index] = true
                local px = math_floor(index / sizeY)
                local py = index % sizeY
                if not tryAttach(changedList, changedColorList, index, px, py, color, hideList) then
                    local effect = createEffect()

                    nodeEffects[index] = effect
                    effects[index] = index

                    local eindex = getEIndex(index)
                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = 1
                    effectDatas[eindex+4] = 1
                    
                    changedList[index] = true
                    changedColorList[index] = true
                    hideList[effect.id] = nil
                end
            end
        end

        for _, effect in pairs(hideList) do
            effect_setOffsetPosition(effect, hiddenOffset)
        end

        for index in pairs(changedList) do
            setEffectDataParams(index)
        end

        local color
        for index in pairs(changedColorList) do
            color = effectDatas[getEIndex(index)]
            if not colorCache[color] then
                colorCache[color] = color_new_fromSmallNumber(color, alpha)
            end
            effect_setParameter(nodeEffects[index], "color", colorCache[color])
        end

        if clearBackplate then
            drawer.flushOldChanges()
            clearBackplate = false
        end

        needOptimize = true
    end, nil, function (_, color, changes)
        if backplate then
            oldBackplateColor = color
            effect_setParameter(backplate, "color", color_new_fromSmallNumber(color, alpha))
            clearBackplate = true
        else
            drawer.fullRefresh()
        end
    end, nil, nil, true)

    if not backplate then
        drawer.fullRefresh()
    end

    drawer.setWait(true)


    local function getSelfPos()
        local pt = type(parent)
        if pt == "Interactable" then
            return parent.shape.worldPosition
        elseif pt == "Character" then
            return parent.worldPosition
        end
    end

    local reoptimizeCanvas = sizeX * sizeY <= (256 * 256)
    if debugMode then
        print("reoptimizeCanvas", sizeX, sizeY, reoptimizeCanvas)
    end

    local function optimize()
        do return end

        if debugMode then
            local usedEffects = 0
            local addedList = {}
            for k, v in pairs(effects) do
                if not addedList[v[1]] then
                    usedEffects = usedEffects + 1
                    addedList[v[1]] = true
                end
            end
            print("effect info:")
            print("used effects: ", usedEffects)
            print("buffered effects: ", bufferedEffectsIndex)
        end

        ------------------------------------------

        if reoptimizeCanvas then
            if debugMode then
                print("reoptimize canvas")
            end

            if backplate then
                mathPopularColor()
                if lastPopularColor ~= oldBackplateColor then
                    effect_setParameter(backplate, "color", color_new_fromSmallNumber(lastPopularColor, alpha))
                    oldBackplateColor = lastPopularColor
                end
            end
            
            for i, effectData in pairs(nodeEffects) do
                hideEffect(effectData[1])
            end
            effects = {}
            nodeEffects = {}

            local changedList = {}
            local changedColorList = {}
            local i = 0
            while i <= maxEffectArrayBuffer do
                local color = lastNewBuffer[i] or lastBase
                local px = math_floor(i / sizeY)
                local py = i % sizeY
                if color ~= oldBackplateColor and not tryAttach(changedList, i, px, py, color) then
                    local effect = createEffect()
                    local effectData = {
                        effect,
                        color,
                        px, --3. root pos x
                        py, --4. root pos Y
                        1,  --5. sizeX
                        1,  --6. sizeY
                        i   --7. root index
                    }
                    effects[i] = effectData
                    nodeEffects[i] = effectData
                    changedList[effectData] = true
                    changedColorList[effect] = effectData
                end
                i = i + 1
            end

            for effectData in pairs(changedList) do
                setEffectDataParams(effectData)
            end

            local color
            for _, effectData in pairs(changedColorList) do
                color = effectData[2]
                if not colorCache[color] then
                    colorCache[color] = color_new_fromSmallNumber(color, alpha)
                end
                effect_setParameter(effectData[1], "color", colorCache[color])
            end
        end

        ------------------------------------------

        if bufferedEffectsIndex > 1024 then
            if debugMode then
                print("stoping buffered effects")
            end

            for i = 1, bufferedEffectsIndex - 1024 do
                effect_stop(bufferedEffects[i])
            end

            --[[
            if bufferedEffectsIndex > 3000 then
                if debugMode then
                    print("destroy buffered effects")
                end

                for i = 3001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                end
                bufferedEffectsIndex = 3000
            end
            ]]
        end
    end

    function obj.setAlpha(_alpha)
        alpha = _alpha
        for _, effectData in pairs(nodeEffects) do
            effect_setParameter(effectData[1], "color", color_new_fromSmallNumber(effectData[2], alpha))
        end
    end

    function obj.setOptimizationLevel(value)
        optimizationLevel = value
        if value == 0 then
            colorEquals = colorEquals_raw
        else
            colorEquals = colorEquals_smart
        end
        optimizationValue = optimizationLevelToValue(optimizationLevel)
    end

    function obj.isRendering()
        return showState
    end

    function obj.disable(state)
        disable = state
    end

    function obj.setRenderDistance(_dist)
        dist = _dist
    end

    local oldOptimizeTime
    function obj.update()
        local newShowState = true
        if disable then
            newShowState = false
        elseif dist then
            if not pcall(function()
                newShowState = mathDist(getSelfPos(), sm_localPlayer_getPlayer().character.worldPosition) <= dist
            end) then
                newShowState = false
            end
        end

        if newShowState ~= showState then
            showState = newShowState
            if newShowState then
                drawer.setWait(false)
                if not backplate and not flushedDefault then
                    drawer.flush(true)
                    flushedDefault = true
                end
                for _, effect in pairs(nodeEffects) do
                    if not effect_isPlaying(effect[1]) then
                        effect_start(effect[1])
                    end
                end
                if backplate then
                    effect_start(backplate)
                end
            else
                for _, effect in pairs(nodeEffects) do
                    effect_stop(effect[1])
                end
                for i = 1, bufferedEffectsIndex do
                    effect_stop(bufferedEffects[i])
                end
                if backplate then
                    effect_stop(backplate)
                end
                drawer.setWait(true)
            end
        end

        local ctick = sm.game.getCurrentTick()
        local optimizePeer = 40
        if lastDrawTickTime and ctick - lastDrawTickTime < 20 then
            optimizePeer = 80
        end

        if newShowState and needOptimize and (not oldOptimizeTime or ctick - oldOptimizeTime >= optimizePeer) then
            needOptimize = false
            oldOptimizeTime = ctick
            optimize()
        end
    end

    function obj.setPixelSize(_pixelSize)
        pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
        if type(pixelSize) == "number" then
            if pixelSize < 0 then
                pixelSize = math_abs(pixelSize)
                local vec = vec3_new(pixelSize, pixelSize, 0)
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            else
                local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            end
        end
        if backplate then
            effect_setScale(backplate, vec3_new((pixelSize.x * sizeX) - 0.00005, (pixelSize.y * sizeY) - 0.00005, pixelSize.z))
        end
        if autoScaleAddValue then
            scaleAddValue = (pixelSize.x + pixelSize.y + pixelSize.z) / 50
        end
        --scaleAddValue = -0.003
    end

    function obj.setOffset(_offset)
        offset = _offset
        if backplate then
            effect_setOffsetPosition(backplate, rotation * offset)
        end
        for index in pairs(nodeEffects) do
            setEffectDataParams(index)
        end
    end

    function obj.setCanvasRotation(_rotation)
        rotation = _rotation
        if backplate then
            effect_setOffsetRotation(backplate, rotation)
        end
        for index, effect in pairs(nodeEffects) do
            effect_setOffsetRotation(effect, rotation)
            setEffectDataParams(index)
        end
    end

    function obj.destroy()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        if backplate then
            effect_destroy(backplate)
        end
    end

    ---------------------------------------

    obj.setPixelSize(pixelSize)
    obj.setCanvasRotation(rotation or quat_fromEuler(vec3_new(0, 0, 0)))
    obj.setOffset(offset or vec3_new(0, 0, 0))

    ---------------------------------------

    obj.drawer = drawer
    for k, v in pairs(drawer) do
        obj[k] = v
    end

    function obj.pushDataTunnelParams(dataTunnel)
        obj.setOptimizationLevel(dataTunnel.optimizationLevel)
        obj.setAlpha(dataTunnel.light)
        drawer.pushDataTunnelParams(dataTunnel)
    end

    return obj
end

--simulates the API of screens from SComputers on the client side of your parts
function canvasAPI.createClientScriptableCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local dataTunnel = {}
    local canvas = canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local api = canvasAPI.createScriptableApi(sizeX, sizeY, dataTunnel, nil, canvas.drawer)
    api.registerClick = canvasAPI.addTouch(api, dataTunnel)
    api.dataTunnel = dataTunnel
    api.canvas = canvas

    local renderDistance = 15

    for k, v in pairs(canvas) do
        if k ~= "flush" then
            api[k] = v
        end
    end

    function api.getAudience()
        return canvas.isRendering() and 1 or 0
    end

    function api.update(dt)
        canvas.disable(not api.isAllow())
        if dataTunnel.renderAtDistance then
            canvas.setRenderDistance()
        else
            canvas.setRenderDistance(renderDistance)
        end
        canvas.pushDataTunnelParams(dataTunnel)
        canvas.update()
        dataTunnel.scriptableApi_update()

        if dataTunnel.display_reset then
            canvas.drawerReset()
            dataTunnel.display_reset = nil
        end

        if dataTunnel.display_flush then
            if needPushStack(canvas, dataTunnel, dt) then
                canvas.pushStack(dataTunnel.display_stack)
                canvas.flush()
            end
            
            dataTunnel.display_flush()
            dataTunnel.display_stack = nil
            dataTunnel.display_flush = nil
            dataTunnel.display_forceFlush = nil
        end
    end

    function api.setRenderDistance(dist)
        renderDistance = dist
    end

    return api
end

local customFontIndexesCache = {}
local checkedFonts = {}

--simulates the SComputers API, does not implement data transfer
function canvasAPI.createScriptableApi(width, height, dataTunnel, flushCallback, drawer)
    dataTunnel = dataTunnel or {}
    dataTunnel.rotation = 0
    dataTunnel.brightness = 1
    dataTunnel.light = DEFAULT_ALPHA_VALUE
    dataTunnel.skipAtNotSight = false
    dataTunnel.utf8support = false
    dataTunnel.renderAtDistance = false
    dataTunnel.display_forceFlush = true
    dataTunnel.dataUpdated = true
    dataTunnel.optimizationLevel = 16

    local stack = {}
    local stackIndex = 1
    local pixelsCache = {} --optimizations for cameras
    local pixelsCacheExists = false
    local oldStackSum, oldDataSum, oldStack, oldStackIndex
    local forceFlag = false

    local function clearStackForce()
        stack = {}
        stackIndex = 1
    end

    local function clearStack()
        if dataTunnel.display_stack == stack then
            clearStackForce()
        end
    end

    local function setForceFrame()
        if pixelsCacheExists then
            pixelsCache = {}
            pixelsCacheExists = false
        end
        forceFlag = true
        dataTunnel.display_forceFlush = true
    end

    local oldPlayersCount = #sm.player.getAllPlayers()
    function dataTunnel.scriptableApi_update()
        local playersCount = #sm.player.getAllPlayers()
        --local force = sm.game.getCurrentTick() % 80 == 0
        local force = false
        if oldPlayersCount ~= playersCount or force then
            --dataTunnel.display_forceForceFlush = force
            setForceFrame()
            oldPlayersCount = playersCount
        end
    end

    local rwidth, rheight = width, height
    local rmwidth, rmheight = width - 1, height - 1
    local utf8support = false
    local monoFont = true
    local newDataFlag = false
    local spacing = 1
    local fontIndex = 0
    local lastPixelX, lastPixelY, lastPixelColor
    local currentSettedFont

    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local dFontX, dFontY = font.width, font.height
    local fontX, fontY
    local mFontX, mFontY
    local xFontX, xFontY
    local sFontX, sFontY
    local fontScaleX, fontScaleY = 1, 1
    local function updateFontSize()
        fontX, fontY = math_ceil(dFontX * fontScaleX), math_ceil(dFontY * fontScaleY)
        mFontX, mFontY = fontX - 1, fontY - 1
        xFontX, xFontY = fontX + 1, fontY + 1
        sFontX, sFontY = fontX + spacing, fontY + 1
    end
    updateFontSize()

    local api
    local api_flush
    api = {
        --[[
        getBuffer = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,
        getCurrent = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getRealBuffer(x + (y * rwidth))
        end,
        ]]
        get = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,

        -- not implemented (implement it yourself if necessary)
        isAllow = function()
            return true
        end,
        getAudience = function()
            return 1
        end,

        setOptimizationLevel = function(value)
            checkArg(1, value, "number")
            value = round(value)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.optimizationLevel ~= value then
                dataTunnel.optimizationLevel = value
                dataTunnel.dataUpdated = true
            end
        end,
        getOptimizationLevel = function()
            return dataTunnel.optimizationLevel
        end,


        -- stubs (outdated methods)
        optimize = function() end,
        setFrameCheck = function () end,
        getFrameCheck = function () return false end,
        setSkipAtLags = function() end,
        getSkipAtLags = function() return false end,


        -- main
        setFontScale = function(scaleX, scaleY)
            checkArg(1, scaleX, "number")
            checkArg(2, scaleY, "number")
            if scaleX < 0 then scaleX = 0 end
            if scaleY < 0 then scaleY = 0 end
            fontScaleX, fontScaleY = scaleX, scaleY
            updateFontSize()
        end,
        getFontScale = function()
            return fontScaleX, fontScaleY
        end,
        setTextSpacing = function(_spacing)
            if _spacing < 0 then _spacing = 0 end
            spacing = _spacing
            updateFontSize()
        end,
        setFontSize = function(_width, _height)
            api.setFontScale(_width / dFontX, _height / dFontY)
        end,
        getTextSpacing = function()
            return spacing
        end,
        calcTextBox = function(text) --it will return two numbers, this will be the size of the box that your text will occupy with this font and this scale
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local totalSize = 0
            if monoFont then
                totalSize = ((textLen - 1) * (fontX + spacing)) + fontX
            else
                local localFontWidth = dFontX
                local localFont = dataTunnel.customFont or font.optimized
                if fontIndex > 0 and fontsOptimized[fontIndex] then
                    localFont = fontsOptimized[fontIndex]
                    localFontWidth = localFont.width
                end

                local char, chrdata
                for i = 1, textLen do
                    char = sep(text, i, i)
                    if char ~= " " and char ~= spaceCharCode then
                        chrdata = localFont[char] or localFont.error or defaultError
                        totalSize = totalSize + (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                    else
                        totalSize = totalSize + (localFont.spaceSize or localFontWidth) + spacing
                    end
                    canvasAPI.yield()
                end
            end

            return totalSize - spacing, fontY
        end,
        calcCharsSize = function(text) --calculates the length of each character in a string, taking into account its spacing from the next character, and returns a table with these values
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    table_insert(lens, (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing)
                else
                    table_insert(lens, (localFont.spaceSize or localFontWidth) + spacing)
                end
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        calcDecreasingTextSizes = function(text) --it works almost like calcCharsSize. however, each value contains all the previous ones. this is used in the graphic.textBox function, but probably not applicable to any other
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}
            local otherVals = 0

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                local val
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    val = (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                else
                    val = (localFont.spaceSize or localFontWidth) + spacing
                end
                otherVals = otherVals + val
                table_insert(lens, otherVals)
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        isMonospacedFont = function()
            return not not monoFont
        end,

        getWidth = function()
            return rwidth
        end,
        getHeight = function()
            return rheight
        end,
        getSize = function()
            return rwidth, rheight
        end,

        clear = function(color)
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end

            clearStackForce()
            stackIndex = 4
            stack[1] = resetViewportCodeID
            stack[2] = 0
            stack[3] = formatColorToSmallNumber(color, blackSmallNumber)
            
            --[[
            for i = 3, stackIndex - 1 do
                stack[i] = nil
            end
            stackIndex = 3
            ]]
        end,
        drawPixel = function(x, y, color)
            x, y = round(x), round(y)
            if x < 0 or x >= width or y < 0 or y >= height then return end
            local index = x + (y * rwidth)
            color = color or false
            if pixelsCache[index] ~= color then
                if false and pixelsCacheExists and x == lastPixelX + 1 then
                    
                else
                    --[[
                    stack[stackIndex] = -index - 20
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                    stackIndex = stackIndex + 1
                    ]]
                    stack[stackIndex] = 1
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = index
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                    stackIndex = stackIndex + 1
                end

                lastPixelX, lastPixelY, lastPixelColor = x, y, color

                pixelsCache[index] = color
                pixelsCacheExists = true
            end
        end,
        fillRect = function(x, y, sizeX, sizeY, color)
            stack[stackIndex] = 2
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawRect = function(x, y, sizeX, sizeY, color, lineWidth)
            lineWidth = round(lineWidth or 1)
            if lineWidth < 1 then
                lineWidth = 1
            end

            stack[stackIndex] = 3
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = lineWidth
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawText = function(x, y, text, color)
            if y > rmheight or y + mFontY < 0 or fontScaleX <= 0 or fontScaleY <= 0 then return end
            text = tostring(text)

            if monoFont then
                local maxTextLen = math_ceil((width - x) / sFontX)
                if maxTextLen <= 0 then return end
                local startTextFrom = math_max(1, math_floor(-x / sFontX) + 1)

                if utf8support then
                    if utf8.len(text) > maxTextLen or startTextFrom > 1 then
                        text = utf8.sub(text, startTextFrom, maxTextLen)
                    end
                else
                    if #text > maxTextLen or startTextFrom > 1 then
                        text = text:sub(startTextFrom, maxTextLen)
                    end
                end

                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x) + ((startTextFrom - 1) * sFontX)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            else
                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawLine = function(x, y, x2, y2, color, width, roundFlag)
            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            stack[stackIndex] = 5
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = width
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 6
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end
            
            stack[stackIndex] = 7
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleEvenly = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 8
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleVeryEvenly = function (x, y, r, color, stroke)
            if r > 1024 then r = 1024 end
            if not stroke or stroke < 1 then stroke = 1 end

            stack[stackIndex] = 9
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(stroke)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawPoly = function(color, ...)
            api.drawWidePoly(color, 1, false, ...)
        end,
        drawWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 10
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillPoly = function(color, ...)
            api.fillWidePoly(color, 1, false, ...)
        end,
        fillWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 11
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        flush = function()
            api.setViewport()

            if dataTunnel.display_flush and dataTunnel.display_stack == stack then
                return
            end

            local needFlush = forceFlag
            --print("--------------------------- FLUSH 1", needFlush, stack, stackChecksum(stack), stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel)))

            if not needFlush and stackIndex ~= oldStackIndex then
                --print("FLUSH 2", stackIndex, oldStackIndex)
                needFlush = true
            end

            if not needFlush and newDataFlag then
                local dataSum = stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel))
                if dataSum ~= oldDataSum then
                    --print("FLUSH 3")
                    needFlush = true
                    oldDataSum = dataSum
                end
            end

            if not needFlush and stack ~= oldStack then
                for i = 1, stackIndex - 1 do
                    if stack[i] ~= oldStack[i] then
                        needFlush = true
                        --print("FLUSH 4", oldStack)
                        break
                    end
                end
            end

            --[[
            if needFlush then
                oldStackSum = nil
            else
                local stachSum = stackChecksum(stack)
                if stachSum ~= oldStackSum then
                    --print("FLUSH 5")
                    needFlush = true
                    oldStackSum = stachSum
                end
            end
            ]]
            
            if needFlush then
                --print("FLUSH ACTION")
                oldStack = stack
                oldStackIndex = stackIndex

                dataTunnel.display_stack = stack
                dataTunnel.display_flush = clearStack
                
                if flushCallback then
                    flushCallback()
                end
            else
                clearStackForce()
            end

            forceFlag = false
            newDataFlag = false
        end,
        forceFlush = function()
            api_flush()
            dataTunnel.display_forceFlush = true
        end,

        -- settings
        setUtf8Support = function (state)
            if type(state) == "boolean" then
                if dataTunnel.utf8support ~= state then
                    dataTunnel.utf8support = state
                    dataTunnel.dataUpdated = true
                    newDataFlag = true
                    utf8support = state
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getUtf8Support = function () return dataTunnel.utf8support end,

        setRenderAtDistance = function (c)
            if type(c) == "boolean" then
                if dataTunnel.renderAtDistance ~= c then
                    dataTunnel.renderAtDistance = c
                    dataTunnel.dataUpdated = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getRenderAtDistance = function () return dataTunnel.renderAtDistance end,

        setRotation = function (rotation)
            if type(rotation) == "number" and rotation % 1 == 0 and rotation >= 0 and rotation <= 3 then
                if rotation ~= dataTunnel.rotation then
                    dataTunnel.rotation = rotation
                    dataTunnel.dataUpdated = true
                    newDataFlag = true

                    if pixelsCacheExists then
                        pixelsCache = {}
                        pixelsCacheExists = false
                    end

                    if rotation == 1 or rotation == 3 then
                        rwidth = height
                        rheight = width
                    else
                        rwidth = width
                        rheight = height
                    end
                    rmheight = rheight - 1
                    rmwidth = rwidth - 1
                end
            else
                error("integer must be in [0; 3]", 2)
            end
        end,
        getRotation = function () return dataTunnel.rotation end,

        setFont = function (customFont)
            checkArg(1, customFont, "table", "nil")
            currentSettedFont = customFont
            fontIndex = 0
            if dataTunnel.customFont then
                dataTunnel.dataUpdated = true
                dataTunnel.customFont = nil
            end
            if customFont then
                if not checkedFonts[customFont] then
                    checkFont(customFont)
                    checkedFonts[customFont] = true
                end
                dFontX, dFontY = customFont.width, customFont.height
                fontIndex = customFontIndexesCache[customFont]
                if not fontIndex then
                    fontIndex = 0
                    for _, v in pairs(fonts) do
                        if v == customFont then
                            fontIndex = v.index
                        end
                    end
                    customFontIndexesCache[customFont] = fontIndex
                end
                if fontIndex == 0 then
                    dataTunnel.customFont = font.optimizeFont(customFont)
                    dataTunnel.dataUpdated = true
                end
                monoFont = customFont.mono or customFont.mono == nil
            else
                dFontX, dFontY = font.width, font.height
                monoFont = true
            end
            updateFontSize()
            newDataFlag = true
        end,
        getFont = function()
            return currentSettedFont
        end,

        getFontWidth = function ()
            return fontX
        end,
        getFontHeight = function ()
            return fontY
        end,
        getRealFontWidth = function ()
            return dFontX
        end,
        getRealFontHeight = function ()
            return dFontY
        end,

        setSkipAtNotSight = function (state)
            checkArg(1, state, "boolean")
            if dataTunnel.skipAtNotSight ~= state then
                dataTunnel.skipAtNotSight = state
                dataTunnel.dataUpdated = true
            end
        end,
        getSkipAtNotSight = function () return dataTunnel.skipAtNotSight end,

        getViewport = function()
            return viewport_x, viewport_y, viewport_sx, viewport_sy
        end,
        setViewport = function(x, y, sizeX, sizeY)
            if x or y or sizeX or sizeY then
                viewport_x, viewport_y, viewport_sx, viewport_sy = x or 0, y or 0, sizeX or api.getWidth(), sizeY or api.getHeight()
                stack[stackIndex] = -1
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sx)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sy)
                stackIndex = stackIndex + 1
            else
                viewport_x, viewport_y, viewport_sx, viewport_sy = nil, nil, nil, nil
                stack[stackIndex] = resetViewportCodeID
                stackIndex = stackIndex + 1
            end
        end,
        setInlineViewport = function(x, y, sizeX, sizeY)
            if viewport_x then
                local x2 = x + (sizeX - 1)
                local y2 = y + (sizeY - 1)
                local px2 = viewport_x + (viewport_sx - 1)
                local py2 = viewport_y + (viewport_sy - 1)
                if x < viewport_x then x = viewport_x elseif x > px2 then x = px2 end
                if y < viewport_y then y = viewport_y elseif y > py2 then y = py2 end
                if x2 < viewport_x then x2 = viewport_x elseif x2 > px2 then x2 = px2 end
                if y2 < viewport_y then y2 = viewport_y elseif y2 > py2 then y2 = py2 end
                api.setViewport(x, y, (x2 - x) + 1, (y2 - y) + 1)
            else
                api.setViewport(x, y, sizeX, sizeY)
            end
        end,

        setBrightness = function(value) --float from 0
            checkArg(1, value, "number")
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.brightness ~= value then
                dataTunnel.brightness = value
                dataTunnel.dataUpdated = true
            end
        end,
        getBrightness = function(value)
            return dataTunnel.brightness
        end,

        setLight = function(value)
            checkArg(1, value, "number")
            value = math_floor(value + 0.5)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.light ~= value then
                dataTunnel.light = value
                dataTunnel.dataUpdated = true
            end
        end,
        getLight = function(value)
            return dataTunnel.light
        end,

        reset = function()
            if api.setFontScale then api.setFontScale(1, 1) end
            if api.setTextSpacing then api.setTextSpacing(1) end
            if api.setFont then api.setFont() end
            if api.setRotation then api.setRotation(0) end
            if api.setUtf8Support then api.setUtf8Support(false) end
            if api.setClicksAllowed then api.setClicksAllowed(false) end
            if api.setMaxClicks then api.setMaxClicks(16) end
            if api.clearClicks then api.clearClicks() end
            if api.setSkipAtNotSight then api.setSkipAtNotSight(false) end
            if api.setRenderAtDistance then api.setRenderAtDistance(false) end
            if api.setViewport then api.setViewport() end
            if api.setBrightness then api.setBrightness(1) end
            if api.setLight then api.setLight(DEFAULT_ALPHA_VALUE) end
            if api.setOptimizationLevel then api.setOptimizationLevel(16) end
            dataTunnel.display_reset = true
        end
    }

    api.update = api.flush
    api.getBuffer = api.get
    api.getCurrent = api.get
    api_flush = api.flush

    local internal = {
        rawPush = function(tbl)
            for i = 1, #tbl do
                stack[stackIndex] = tbl[i]
                stackIndex = stackIndex + 1
            end
        end
    }

    return api, internal
end

--adds a touch screen API (does not implement click processing)
function canvasAPI.addTouch(api, dataTunnel)
    dataTunnel = dataTunnel or {}
    dataTunnel.clicksAllowed = false
    dataTunnel.maxClicks = 16
    dataTunnel.clickData = {}

    api.getClick = function ()
        return (table_remove(dataTunnel.clickData, 1))
    end

    api.setMaxClicks = function (c)
        if type(c) == "number" and c % 1 == 0 and c > 0 and c <= 16 then
            dataTunnel.maxClicks = c
        else
            error("integer must be in [1; 16]", 2)
        end
    end

    api.getMaxClicks = function ()
        return dataTunnel.maxClicks
    end

    api.clearClicks = function ()
        dataTunnel.clickData = {}
    end

    api.setClicksAllowed = function (c)
        if type(c) == "boolean" then
            if dataTunnel.clicksAllowed ~= c then
                dataTunnel.clicksAllowed = c
                dataTunnel.dataUpdated = true
            end
        else
            error("Type must be boolean", 2)
        end
    end

    api.getClicksAllowed = function ()
        return dataTunnel.clicksAllowed
    end

    return function (tbl)
        tbl.x = tbl[1] or tbl.x
        tbl.y = tbl[2] or tbl.y
        tbl.state = tbl[3] or tbl.state
        tbl.button = tbl[4] or tbl.button
        tbl.nickname = tbl[5] or tbl.nickname
        tbl[1] = tbl.x or tbl[1]
        tbl[2] = tbl.y or tbl[2]
        tbl[3] = tbl.state or tbl[3]
        tbl[4] = tbl.button or tbl[4]
        tbl[5] = tbl.nickname or tbl[5]
        table_insert(dataTunnel.clickData, tbl)
    end
end

--leaves only those tunnel fields that are needed for transmission over the network
function canvasAPI.minimizeDataTunnel(dataTunnel)
    return {
        clicksAllowed = dataTunnel.clicksAllowed,
        rotation = dataTunnel.rotation,
        renderAtDistance = dataTunnel.renderAtDistance,
        skipAtNotSight = dataTunnel.skipAtNotSight,
        utf8support = dataTunnel.utf8support,
        customFont = dataTunnel.customFont,
        display_reset = dataTunnel.display_reset,
        brightness = dataTunnel.brightness,
        optimizationLevel = dataTunnel.optimizationLevel,
        light = dataTunnel.light
    }
end

-------- additional
canvasAPI.stackChecksum = stackChecksum
canvasAPI.formatColor = formatColor
canvasAPI.formatColorToNumber = formatColorToNumber
canvasAPI.formatColorToSmallNumber = formatColorToSmallNumber
canvasAPI.checkFont = checkFont
canvasAPI.simpleRemathRect = simpleRemathRect
canvasAPI.remathRect = remathRect
canvasAPI.hexToRGB = hexToRGB
canvasAPI.hexToRGB256 = hexToRGB256
canvasAPI.posCheck = posCheck
canvasAPI.mathDist = mathDist
canvasAPI.needPushStack = needPushStack
canvasAPI.font = font
canvasAPI.tableClone = tableClone
canvasAPI.canvasService = canvasService
canvasAPI.userCalls = userCalls
canvasAPI.dataSizes = dataSizes
canvasAPI.color_new_fromSmallNumber = color_new_fromSmallNumber
canvasAPI.getEffectName = getEffectName
canvasAPI.fonts = fonts
canvasAPI.utf8 = utf8

function canvasAPI.pushData(stack, ...)
    for i, v in ipairs({...}) do
        table.insert(stack, v)
    end
end

_G.canvasAPI = canvasAPI
end
function scmframework_fb94b55f7056000d91dce90dc6cef66c() --$CONTENT_DATA/Scripts/canvasAPI/backup/canvas_best1.lua
print("> canvas.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/luajit.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/load.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/utf8.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/canvasService.lua")

local debugMode = false
local profileMode = false

local canvasAPI = {
	draw = {
		clear = 0,
		set   = 1,
		fill  = 2,
		rect  = 3,
		text  = 4,
		line  = 5,
		circle  = 6,
		circleF = 7,
		circleE = 8,
		circleVE = 9,
		poly = 10,
		polyF = 11,

		copyNX = 12,
		copyPX = 13,
		copyNY = 14,
		copyPY = 15,
		setI = 16
	},
	material = {
		classic = sm.uuid.new("64d41b06-9b71-4e19-9f87-1e7e63845e59"),
		glass = sm.uuid.new("a683f897-5b8a-4c96-9c46-7b9fbc76d186"),
		plastic = sm.uuid.new("82d2da58-6597-4ffa-9b53-1af3b707fa7a"),
		smoothed = sm.uuid.new("a23a4ea2-96da-4bb2-a723-af8c27de2511"),
		glowing = sm.uuid.new("b46ae32a-9037-4360-9f98-3bef1cd4f366")
	},
	multi_layer = {}
}

canvasAPI.multi_layer[tostring(canvasAPI.material.classic)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.plastic)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.smoothed)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.glowing)] = true
canvasAPI.version = 46

canvasAPI.materialList = {
	[0] = canvasAPI.material.glass,
	canvasAPI.material.classic,
	canvasAPI.material.plastic,
	canvasAPI.material.smoothed,
	canvasAPI.material.glowing
}

canvasAPI.materialListWithoutGlass = {
	[0] = true,
	canvasAPI.material.classic,
	canvasAPI.material.plastic,
	canvasAPI.material.smoothed,
	canvasAPI.material.glowing
}

canvasAPI.directList = {
	get = true,
	getCurrent = true,
	getBuffer = true,
	
	clear = true,
	drawPixel = true,
	drawRect = true,
	fillRect = true,
	drawText = true,
	drawLine = true,
	drawCircle = true,
	fillCircle = true,
	drawCircleEvenly = true,
	drawCircleVeryEvenly = true,
	drawPoly = true,
	drawWidePoly = true,
	fillPoly = true,
	fillWidePoly = true,
	drawTriangle = true,
	fillTriangle = true,

	getWidth = true,
	getHeight = true,
	getSize = true,

	isAllow = true,
	setFontScale = true,
	setFontSize = true,
	getFontScale = true,
	setTextSpacing = true,
	getTextSpacing = true,
	calcTextBox = true,
	calcCharsSize = true,
	calcDecreasingTextSizes = true,
	setUtf8Support = true,
	getUtf8Support = true,
	setRenderAtDistance = true,
	getRenderAtDistance = true,
	setRotation = true,
	getRotation = true,
	setFont = true,
	getFont = true,
	getFontWidth = true,
	getFontHeight = true,
	getFontSize = true,
	getRealFontWidth = true,
	getRealFontHeight = true,
	getRealFontSize = true,
	setSkipAtNotSight = true,
	getSkipAtNotSight = true,
	isMonospacedFont = true,
	setBrightness = true,
	getBrightness = true,
	reset = true,
	setClicksAllowed = true,
	getClicksAllowed = true,
	clearClicks = true,
	setMaxClicks = true,
	getMaxClicks = true,
	getClick = true,
	setOptimizationLevel = true,
	getOptimizationLevel = true,

	setViewport = true,
	setInlineViewport = true,
	getViewport = true
}

local MAX_DRAW_TIME = 2 --protecting the world from crashing using the display
local FONT_SIZE_LIMIT = 256
local DEFAULT_ALPHA_VALUE = 180
canvasAPI.DEFAULT_ALPHA_VALUE = DEFAULT_ALPHA_VALUE

local font = font
local defaultFont = font.default
local fonts = font.fonts
local fontsOptimized = font.fontsOptimized
local spaceCharCode = string.byte(" ")

local huge = math.huge
local string_len = string.len
local bit = bit or bit32
local bit_rshift = bit.rshift
local bit_lshift = bit.lshift
local utf8 = utf8
local string = string
local table_sort = table.sort
local type = type
local math_ceil = math.ceil
local math_max = math.max
local string_format = string.format
local table_insert = table.insert
local table_remove = table.remove
local math_floor = math.floor
local vec3_new = sm.vec3.new
local color_new = sm.color.new
local quat_fromEuler = sm.quat.fromEuler
local ipairs = ipairs
local pairs = pairs
local string_byte = string.byte
local defaultError = font.optimized.error
local tostring = tostring
local math_abs = math.abs
local math_min = math.min
local string_sub = string.sub
local table_concat = table.concat
local tonumber = tonumber
local utf8_len = utf8.len
local utf8_sub = utf8.sub
local sm_localPlayer_getPlayer = sm.localPlayer.getPlayer
local os_clock = os.clock
local math_sqrt = math.sqrt
local quat_new = sm.quat.new

local black = color_new(0, 0, 0)
local white = color_new(1, 1, 1)
local blackNumber = 0x000000ff
local whiteNumber = 0xffffffff
local blackSmallNumber = 0x000000
local whiteSmallNumber = 0xffffff

local getEffectName
do
	local currentEffect = 1
	local effectsNames = {}

	for i = 0, 255 do
		table_insert(effectsNames, "ShapeRenderable" .. tostring(i))
	end

	function getEffectName()
		local name = effectsNames[currentEffect]
		currentEffect = currentEffect + 1
		if currentEffect > #effectsNames then
			currentEffect = 1
		end
		return name
	end
end

local function profillerPrint(name, execTime)
	local t = execTime * 1000
	if profileMode and t > 0 then
		print("profiller", name, t)
	end
end

local function profiller(name, startTime)
	profillerPrint(name, os_clock() - startTime)
end

--[[
local sm_effect_createEffect = sm.effect.withoutHook_createEffect or sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local withoutHookEmptyEffect = emptyEffect
local whook = "withoutHook_"
if better and better.version >= 45 and better.isAvailable() then
	local mt = getmetatable(emptyEffect)
	local newMt = {}
	for k, v in pairs(mt) do
		newMt[k] = v
	end
	for k, v in pairs(mt) do
		if k:sub(1, #whook) == whook then
			newMt[k:sub(#whook + 1, #k)] = v
		end
	end
	withoutHookEmptyEffect = setmetatable({}, newMt)
end
local effect_setParameter = withoutHookEmptyEffect.setParameter
local effect_stop = withoutHookEmptyEffect.stop
local effect_destroy = withoutHookEmptyEffect.destroy
local effect_start = withoutHookEmptyEffect.start
local effect_isDone = withoutHookEmptyEffect.isDone
local effect_isPlaying = withoutHookEmptyEffect.isPlaying
local effect_setScale = withoutHookEmptyEffect.setScale
local effect_setOffsetPosition = withoutHookEmptyEffect.setOffsetPosition
local effect_setOffsetRotation = withoutHookEmptyEffect.setOffsetRotation
effect_destroy(emptyEffect)
]]

local sm_effect_createEffect = sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local effect_setParameter = emptyEffect.setParameter
local effect_stop = emptyEffect.stop
local effect_destroy = emptyEffect.destroy
local effect_start = emptyEffect.start
local effect_isDone = emptyEffect.isDone
local effect_isPlaying = emptyEffect.isPlaying
local effect_setScale = emptyEffect.setScale
local effect_setOffsetPosition = emptyEffect.setOffsetPosition
local effect_setOffsetRotation = emptyEffect.setOffsetRotation
local effect_setPosition = emptyEffect.setPosition
local effect_setRotation = emptyEffect.setRotation
effect_destroy(emptyEffect)

local function round(number)
	return math_floor(number + 0.5)
end

local function checkFont(lfont)
	if type(lfont) ~= "table" then
		error("the font should be a table", 3)
	end

	if lfont.mono or lfont.mono == nil then
		if type(lfont.chars) ~= "table" or (type(lfont.width) ~= "number") or (type(lfont.height) ~= "number") then
			error("invalid basic char data", 3)
		end
		
		if lfont.width > FONT_SIZE_LIMIT then
			error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
		elseif lfont.height > FONT_SIZE_LIMIT then
			error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
		end

		for char, data in pairs(lfont.chars) do
			if type(char) ~= "string" or type(data) ~= "table" or #data ~= lfont.height then
				error("font failed integrity check", 3)
			end
			for _, line in ipairs(data) do
				if type(line) ~= "string" then
					error("the char string has the wrong type", 3)
				elseif #line ~= lfont.width then
					print(char, #line, data)
					error("the char string has the wrong lenght", 3)
				end
			end
		end
	else
		if type(lfont.chars) ~= "table" then
			error("font failed integrity check", 3)
		end

		local oFont = font.optimizeFont(lfont)
		lfont.spaceSize = oFont.spaceSize
		lfont.width = oFont.width
		lfont.height = oFont.height

		for char, data in pairs(lfont.chars) do
			if type(char) ~= "string" or type(data) ~= "table" or #data > FONT_SIZE_LIMIT then
				error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
			end
			for _, line in ipairs(data) do
				if type(line) ~= "string" or #line > FONT_SIZE_LIMIT then
					error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
				end
			end
		end
	end
end

local function doQuat(x, y, z, w)
	local sin = math.sin(w / 2)
	return quat_new(sin * x, sin * y, sin * z, math.cos(w / 2))
end

local function custom_fromEulerYEnd(x, y, z) --custom implementation
	return doQuat(1, 0, 0, x) * doQuat(0, 0, 1, z) * doQuat(0, 1, 0, y)
end

local function tableClone(tbl)
	local newtbl = {}
	for k, v in pairs(tbl) do
		newtbl[k] = v
	end
	return newtbl
end

local function stackChecksum(stack)
	local num = -#stack
	local t, v
	for i = 1, #stack do
		v = stack[i]
		t = type(v)
		num = num - i
		if t == "number" then
			num = num + ((v * i) + v + i + (v / i))
		elseif t == "Color" then
			num = num + ((i * (v.r / i) * -4) + v.g)
			num = num - ((i * (v.g + i) * 5) + v.b)
			num = num + ((i * (v.b - i) * 8) + v.r)
		elseif t == "string" then
			for i3 = 1, #v do
				num = num + (i * (-i3 - (string_byte(v, i3) * i3)))
			end
		end
	end
	return num
end

local function checkArg(n, have, ...)
	have = type(have)
	local tbl = {...}
	for _, t in ipairs(tbl) do
		if have == t then
			return
		end
	end
	error(string_format("bad argument #%d (%s expected, got %s)", n, table_concat(tbl, " or "), have), 3)
end

local function simpleRemathRect(x, y, w, h, maxX, maxY)
	local x2, y2 = x + (w - 1), y + (h - 1)
	if x < 0 then
		x = 0
	elseif x > maxX then
		--x = maxX
		return
	end
	if y < 0 then
		y = 0
	elseif y > maxY then
		--y = maxY
		return
	end
	if x2 < 0 then
		--x2 = 0
		return
	elseif x2 > maxX then
		x2 = maxX
	end
	if y2 < 0 then
		--y2 = 0
		return
	elseif y2 > maxY then
		y2 = maxY
	end
	return x, y, x2, y2, w, h
end

local function remathRect(offset, stack, maxX, maxY)
	return simpleRemathRect(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], maxX, maxY)
end

local function posCheck(width, height, x, y)
	return x >= 0 and y >= 0 and x < width and y < height
end

local hashChar = string.byte("#")
local bit = bit or bit32
local band = bit.band
local rshift = bit.rshift
local function hexToRGB(color)
	return math_floor(color / 256 / 256) / 255, (math_floor(color / 256) % 256) / 255, (color % 256) / 255
end

local function hexToRGB256(color)
	return math_floor(color / 256 / 256), math_floor(color / 256) % 256, color % 256
end

local function optimizationLevelToValue(level)
	return (level / 255) * 0.25
end

local function formatColor(color, default)
	local t = type(color)
	if t == "Color" then
		return color
	elseif t == "string" then
		return color_new(color)
	elseif t == "number" then
		return color_new(hexToRGB(color))
	end

	return default
end

local redMul = 256 * 256 * 256
local greenMul = 256 * 256
local blueMul = 256
local function formatColorToNumber(color, default)
	local t = type(color)
	if t == "Color" then
		return (math_floor(color.r * 255) * redMul) + (math_floor(color.g * 255) * greenMul) + (math_floor(color.b * 255) * blueMul) + math_floor(color.a * 255)
	elseif t == "string" then
		local val
		if string_byte(color) == hashChar then
			val = tonumber(string_sub(color, 2, -1), 16) or 0
		else
			val = tonumber(color, 16) or 0
		end
		if #color > 7 then
			return val
		end
		return (val * 256) + 255
	elseif t == "number" then
		return (color * 256) + 255
	end

	return default or 0
end

local function formatColorToSmallNumber(color, default)
	local t = type(color)
	if t == "Color" then
		return (math_floor(color.r * 255) * greenMul) + (math_floor(color.g * 255) * blueMul) + math_floor(color.b * 255)
	elseif t == "string" then
		local val
		if string_byte(color) == hashChar then
			val = tonumber(string_sub(color, 2, -1), 16) or 0
		else
			val = tonumber(color, 16) or 0
		end
		if #color > 7 then
			return math_floor(val / 256)
		end
		return val
	elseif t == "number" then
		return color
	end

	return default or 0
end

local function color_new_fromSmallNumber(number, alpha)
	return color_new((number * 256) + (alpha or 255))
end

local function mathDist(pos1, pos2)
	return math.sqrt(((pos1.x - pos2.x) ^ 2) + ((pos1.y - pos2.y) ^ 2) + ((pos1.z - pos2.z) ^ 2))
end

local function needPushStack(canvas, dataTunnel) --returns true if the rendering stack should be applied
	return dataTunnel.display_forceFlush or not ((dataTunnel.skipAtNotSight and not canvas.isRendering()))
end

local resetViewportCodeID = -23124
local dataSizes = {
	[resetViewportCodeID] = 1,
	[-1] = 5,
	[0] = 2,
	4,
	6,
	7,
	9, --text
	7, --line
	5,
	5,
	5,
	6,

	4, --drawPoly
	4, --fillPoly

	2,
	2,
	2,
	2,
	3
}

local userCalls = {}

canvasAPI.yield = function() end

function canvasAPI.createDrawer(sizeX, sizeY, callback, callbackBefore, directArg, direct_clear, direct_fill, direct_set, updatedList)
	local obj = {}
	local oldStackSum
	local rSizeX, rSizeY = sizeX, sizeY
	local maxX, maxY = sizeX - 1, sizeY - 1
	local newBuffer, newBufferBase = {}, 0
	local realBuffer = {}
	local maxBuffer = maxX + (maxY * sizeX)
	local currentFont = font.optimized
	local fontWidth, fontHeight = defaultFont.width, defaultFont.height
	local rotation = 0
	local utf8Support = false
	local updated = false
	local clearOnly = false
	local clearBackplate = false
	local maxLineSize = sizeX + sizeY
	local bigSide = math_max(sizeX, sizeY)
	local drawerData = {}
	local _oldBufferBase
	local changes = {}
	local _changes = {}
	local changesIndex, changesCount = {}, 0

	local viewportEnable = false
	local brightnessEnable = false
	local brightness = 1
	local viewport_x, viewport_y, viewport_sx, viewport_sy

	local function bufferRangeUpdate() end

	local function setDot(px, py, col)
		if viewportEnable and (px < viewport_x or py < viewport_y or px >= (viewport_x + viewport_sx) or py >= (viewport_y + viewport_sy)) then
			return
		end

		--[[
		if rotation == 0 then
			index = px + (py * rSizeX)
		elseif rotation == 1 then
			index = (rSizeX - py - 1) + (px * rSizeX)
		elseif rotation == 2 then
			index = (rSizeX - px - 1) + ((rSizeY - py - 1) * rSizeX)
		else
			index = py + ((rSizeY - px - 1) * rSizeX)
		end
		]]

		if brightnessEnable then
			local r = math_floor(col / 256 / 256) % 256
			local g = math_floor(col / 256) % 256
			local b = col % 256
			col = (math_min(255, math_floor(r * brightness)) * 256 * 256) + (math_min(255, math_floor(g * brightness)) * 256) + math_min(255, math_floor(b * brightness))
		end

		local index
		if rotation == 0 then
			index = py + (px * rSizeY)
		elseif rotation == 1 then
			index = px + ((rSizeX - py - 1) * rSizeY)
		elseif rotation == 2 then
			index = (rSizeY - py - 1) + ((rSizeX - px - 1) * rSizeY)
		else
			index = (rSizeY - px - 1) + (py * rSizeY)
		end

		if direct_set then
			newBuffer[index] = col
			direct_set(directArg, math_floor(index / rSizeY), index % rSizeY, col)
			return true
		elseif newBuffer[index] ~= col then
			if updatedList and not changes[index] then
				changes[index] = true
				changesCount = changesCount + 1
				changesIndex[changesCount] = index
			end

			newBuffer[index] = col
			return true
		end
	end

	local function check(px, py)
		return px >= 0 and py >= 0 and px < sizeX and py < sizeY
	end

	local function checkSetDot(px, py, col)
		if check(px, py) then
			setDot(px, py, col)
			return true
		end
		return false
	end

	function obj.drawerReset()
	end

	function obj.drawer_setRotation(_rotation)
		rotation = _rotation
		if rotation == 1 or rotation == 3 then
			sizeX = rSizeY
			sizeY = rSizeX
		else
			sizeX = rSizeX
			sizeY = rSizeY
		end
		maxX, maxY = sizeX - 1, sizeY - 1
	end

	function obj.drawer_setUtf8Support(state)
		utf8Support = not not state
	end

	function obj.drawer_setFont(customFont)
		if customFont then
			currentFont = customFont
			fontWidth, fontHeight = customFont.width, customFont.height
		else
			currentFont = font.optimized
			fontWidth, fontHeight = defaultFont.width, defaultFont.height
		end
	end

	local old_rotation
	local old_utf8support
	local old_customFont
	function obj.pushDataTunnelParams(params)
		if params.res_x ~= rSizeX or params.res_y ~= rSizeY then
			rSizeX, rSizeY = params.res_x, params.res_y
			obj.drawer_setRotation(rotation)
			newBuffer, newBufferBase = {}, 0
			realBuffer = {}
			maxBuffer = maxX + (maxY * sizeX)
			maxLineSize = sizeX + sizeY
			bigSide = math_max(sizeX, sizeY)
			changes = {}
			_changes = {}
			changesIndex, changesCount = {}, 0
			oldStackSum = nil
		end

		brightness = params.brightness
		brightnessEnable = brightness ~= 1

		if params.rotation ~= old_rotation then
			obj.drawer_setRotation(params.rotation)
			old_rotation = params.rotation
		end
		if params.utf8support ~= old_utf8support then
			obj.drawer_setUtf8Support(params.utf8support)
			old_utf8support = params.utf8support
		end
		if params.customFont ~= old_customFont then
			obj.drawer_setFont(params.customFont)
			old_customFont = params.customFont
		end
	end

	------------------------------------------
	
	local function rasterize_fill(x, y, sx, sy, col)
		local x, y, x2, y2 = simpleRemathRect(x, y, sx, sy, maxX, maxY)
		if not x then return end

		local ix, iy = x, y
		for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
			setDot(ix, iy, col)
			iy = iy + 1
			if iy > y2 then
				iy = y
				ix = ix + 1
			end
		end

		--[[
		local ix, iy = x, y
		for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
			setDot(ix, iy, col)
			ix = ix + 1
			if ix > x2 then
				ix = x
				iy = iy + 1
			end
		end
		]]

		--[[
		local ix, iy = x2, y2
		for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
			setDot(ix, iy, col)
			iy = iy - 1
			if iy < y then
				iy = y2
				ix = ix - 1
			end
		end
		]]

		--[[
		local ix, iy = x2, y
		for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
			setDot(ix, iy, col)
			iy = iy + 1
			if iy > y2 then
				iy = y
				ix = ix - 1
			end
		end
		]]
	end

	local function rasterize_circleF(px, py, r, col)
		local chr = r*r
		local sx, sy, tempInt, tempBool

		if r < bigSide and px >= 0 and py >= 0 and px < sizeX and py < sizeY then --now only a quarter of the circle is rendered
			for iy = 0, r do
				sy = iy + 0.5
				tempBool = false
				for ix = r, 0, -1 do
					sx = ix + 0.5
					if tempBool or (sx * sx) + (sy * sy) <= chr then
						tempBool = true
						checkSetDot(px + ix, py + iy, col)
						checkSetDot(px - ix - 1, py + iy, col)
						checkSetDot(px + ix, py - iy - 1, col)
						checkSetDot(px - ix - 1, py - iy - 1, col)
					end
				end
			end
		else
			for ix = math_max(-r, -px), math_min(r, (sizeX - px) - 1) do --if the starting point is not within the screen or the circle is too large, then will have to check every pixel
				sx = ix + 0.5
				for iy = math_max(-r, -py), math_min(r, (sizeY - py) - 1) do
					sy = iy + 0.5
					if (sx * sx) + (sy * sy) <= chr then
						setDot(px + ix, py + iy, col)
					end
				end
			end
		end
	end

	local function rasterize_line(px, py, px2, py2, col, width, linesInfo)
		if px2 < px or py2 < py then
			local _px, _py = px, py
			px, py = px2, py2
			px2, py2 = _px, _py
		end
		local dx = math_abs(px2 - px)
		local dy = math_abs(py2 - py)
		local sx = (px < px2) and 1 or -1
		local sy = (py < py2) and 1 or -1
		local err = dx - dy
		if width == -1 or width == 0 or width == 1 then
			local drawAllowed = false
			for _ = 1, maxLineSize do
				if check(px, py) then
					setDot(px, py, col)
					drawAllowed = true
				elseif drawAllowed then
					break
				end
				if px == px2 and py == py2 then
					break
				end
				local e2 = bit_lshift(err, 1)
				if e2 > -dy then
					err = err - dy
					px = px + sx
				end
				if e2 < dx then
					err = err + dx
					py = py + sy
				end
			end
		elseif width < 0 then
			width = math_ceil((-width) / 2)
			if width < 1 then
				width = 1
			end
			for _ = 1, maxLineSize do
				rasterize_circleF(px, py, width, col)
				if px == px2 and py == py2 then
					break
				end
				local e2 = bit_lshift(err, 1)
				if e2 > -dy then
					err = err - dy
					px = px + sx
				end
				if e2 < dx then
					err = err + dx
					py = py + sy
				end
			end
		else
			local offsetFill = math_floor(width / 2)
			for _ = 1, maxLineSize do
				rasterize_fill(px - offsetFill, py - offsetFill, width, width, col)
				if px == px2 and py == py2 then
					break
				end
				local e2 = bit_lshift(err, 1)
				if e2 > -dy then
					err = err - dy
					px = px + sx
				end
				if e2 < dx then
					err = err + dx
					py = py + sy
				end
			end
		end
	end

	------------------------------------------

	local function render_fill(stack, offset)
		local col = stack[offset+4]
		if direct_fill then
			direct_fill(directArg, stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
		else
			rasterize_fill(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
		end
	end

	local function render_rect(stack, offset)
		local x, y, x2, y2, w, h = remathRect(offset, stack, maxX, maxY)
		if not x then return end
		local col = stack[offset+4]
		local lineWidth = stack[offset+5]
		if lineWidth == 1 then
			for ix = x, x2 do
				setDot(ix, y, col)
				setDot(ix, y2, col)
			end

			for iy = y + 1, y2 - 1 do
				setDot(x, iy, col)
				setDot(x2, iy, col)
			end
		else
			local _y, _y2, _x, _x2
			for ioff = 0, math_min(lineWidth, math_max(w, h) / 2) - 1 do
				_y = y + ioff
				_y2 = y2 - ioff
				for ix = x + ioff, x2 - ioff do
					setDot(ix, _y, col)
					setDot(ix, _y2, col)
				end

				_x = x + ioff
				_x2 = x2 - ioff
				for iy = y + 1 + ioff, y2 - (1 + ioff) do
					setDot(_x, iy, col)
					setDot(_x2, iy, col)
				end
			end
		end
	end

	local function render_text(stack, offset)
		local tx, ty = stack[offset], stack[offset+1]
		local text = stack[offset+2]
		local col = stack[offset+3]
		local scaleX = stack[offset+4]
		local scaleY = stack[offset+5]
		local spacing = stack[offset+6]
		local fontIndex = stack[offset+7]

		local localFont = currentFont
		local localFontWidth = fontWidth
		if fontIndex > 0 and fontsOptimized[fontIndex] then
			localFont = fontsOptimized[fontIndex]
			localFontWidth = localFont.width
		end

		local len, sep
		if utf8Support then
			len, sep = utf8_len, utf8_sub
		else
			len, sep = string_len, string_byte
		end
		local scaledFontWidth = math_ceil(localFontWidth * scaleX)
		if localFont.mono then
			for i = len(text), 1, -1 do
				local char = sep(text, i, i)
				if char ~= " " and char ~= spaceCharCode then
					local chrdata = localFont[char] or localFont.error or defaultError
					local charOffset = (i - 1) * (scaledFontWidth + spacing)
					for i2 = 1, #chrdata, 2 do
						local px, py = chrdata[i2], chrdata[i2 + 1]
						local lposX, lposY = round(px * scaleX), round(py * scaleY)
						for ix = math_min(sizeX, round((px + 1) * scaleX) - lposX - 1), 0, -1 do
							local setPosX = tx + ix + lposX + charOffset
							for iy = math_min(sizeY, round((py + 1) * scaleY) - lposY - 1), 0, -1 do
								checkSetDot(setPosX, ty + iy + lposY, col)
							end
						end
					end
				end
			end
		else
			local charOffset = 0
			local startDrawTime = os_clock()
			for i = 1, len(text) do
				local char = sep(text, i, i)
				if char ~= " " and char ~= spaceCharCode then
					local chrdata = localFont[char] or localFont.error or defaultError
					local charPos = tx + charOffset
					if not chrdata[0] or charPos + round(chrdata[0] * scaleX) > 0 then
						if charPos > maxX then
							goto endDraw
						end
						for i2 = 1, #chrdata, 2 do
							local px, py = chrdata[i2], chrdata[i2 + 1]
							local lposX, lposY = round(px * scaleX), round(py * scaleY)
							for ix = 0, math_min(sizeX, round((px + 1) * scaleX) - lposX - 1) do
								local setPosX = tx + ix + lposX + charOffset
								for iy = 0, math_min(sizeY, round((py + 1) * scaleY) - lposY - 1) do
									checkSetDot(setPosX, ty + iy + lposY, col)
								end
							end
						end
					end
					charOffset = charOffset + (chrdata[0] and math_ceil(chrdata[0] * scaleX) or 0) + spacing
				else
					charOffset = charOffset + (math_ceil(localFont.spaceSize * scaleX) or localFontWidth) + spacing
				end
				if os_clock() - startDrawTime > MAX_DRAW_TIME then
					goto endDraw
				end
			end
		end
		::endDraw::
	end

	local function render_line(stack, offset)
		rasterize_line(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4], stack[offset+5])
	end

	local function render_circle(stack, offset) --Michener’s Algorithm
		local px = stack[offset]
		local py = stack[offset+1]
		local e2 = stack[offset+2]
		local col = stack[offset+3]
		local dx = 0
		local dy = e2
		local chr = 3 - 2 * e2

		while dx <= dy do
			checkSetDot(px + dx, py + dy, col)
			checkSetDot(px + dy, py + dx, col)
			checkSetDot(px - dy, py + dx, col)
			checkSetDot(px - dx, py + dy, col)
			checkSetDot(px + dy, py - dx, col)
			checkSetDot(px + dx, py - dy, col)
			checkSetDot(px - dy, py - dx, col)
			checkSetDot(px - dx, py - dy, col)

			if chr < 0 then
				chr = chr + 4 * dx + 6
			else
				chr = chr + 4 * (dx - dy) + 10
				dy = dy - 1
			end
			dx = dx + 1
		end
	end

	local function render_circleE(stack, offset)
		local px = stack[offset]
		local py = stack[offset+1]
		local e2 = stack[offset+2]
		local col = stack[offset+3]
		local dx = 0
		local dy = e2
		local chr = 3 - 2 * e2

		while dx <= dy do
			checkSetDot(px + dx - 1, py + dy - 1, col)
			checkSetDot(px + dy - 1, py + dx, col)
			checkSetDot(px - dy, py + dx, col)
			checkSetDot(px - dx, py + dy - 1, col)
			checkSetDot(px + dy - 1, py - dx, col)
			checkSetDot(px + dx - 1, py - dy, col)
			checkSetDot(px - dy, py - dx, col)
			checkSetDot(px - dx, py - dy, col)

			if chr < 0 then
				chr = chr + 4 * dx + 6
			else
				chr = chr + 4 * (dx - dy) + 10
				dy = dy - 1
			end
			dx = dx + 1
		end
	end

	local function render_circleF(stack, offset)
		rasterize_circleF(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3])
	end

	local function render_circleVE(stack, offset) --drawCircleVeryEvenly
		local px = stack[offset]
		local py = stack[offset+1]
		local e2 = stack[offset+2]
		local chr = e2*e2
		local col = stack[offset+3]
		local sx, sy, tempInt, tempBool

		e2 = math_min(e2, bigSide)
		for iy = 0, e2 do
			sy = iy + 0.5
			tempInt = stack[offset+4]
			for ix = e2, 0, -1 do
				sx = ix + 0.5
				if (sx * sx) + (sy * sy) <= chr then
					checkSetDot(px + ix, py + iy, col)
					checkSetDot(px - ix - 1, py + iy, col)
					checkSetDot(px + ix, py - iy - 1, col)
					checkSetDot(px - ix - 1, py - iy - 1, col)

					tempInt = tempInt - 1
					if tempInt == 0 then
						break
					end
				end
			end
		end
		for ix = 0, e2 do
			sx = ix + 0.5
			tempInt = stack[offset+4]
			for iy = e2, 0, -1 do
				sy = iy + 0.5
				if (sx * sx) + (sy * sy) <= chr then
					checkSetDot(px + ix, py + iy, col)
					checkSetDot(px - ix - 1, py + iy, col)
					checkSetDot(px + ix, py - iy - 1, col)
					checkSetDot(px - ix - 1, py - iy - 1, col)

					tempInt = tempInt - 1
					if tempInt == 0 then
						break
					end
				end
			end
		end
	end

	local function render_drawPoly(stack, offset, getFillInfo)
		local col = stack[offset]
		local points = stack[offset+1]
		local width = stack[offset+2]

		local startDrawTime = os_clock()
		local _px = stack[offset+3]
		local _py = stack[offset+4]
		local px, py
		local pointsPos
		if getFillInfo then
			pointsPos = {}

			local _setDot = setDot
			setDot = function(px, py, col)
				if not pointsPos[py] then
					pointsPos[py] = {px, px}
				else
					local data = pointsPos[py]
					if px < data[1] then data[1] = px end
					if px > data[2] then data[2] = px end
				end
			end
			
			for i = 3, points, 2 do
				px = stack[offset+2+i]
				py = stack[offset+3+i]
				rasterize_line(_px, _py, px, py, col, width)
				_px = px
				_py = py
				if os_clock() - startDrawTime > MAX_DRAW_TIME then
					goto endDraw
				end
			end
			rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width)

			setDot = _setDot
		else
			for i = 3, points, 2 do
				px = stack[offset+2+i]
				py = stack[offset+3+i]
				rasterize_line(_px, _py, px, py, col, width)
				_px = px
				_py = py
				if os_clock() - startDrawTime > MAX_DRAW_TIME then
					goto endDraw
				end
			end
			rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width)
		end
		
		::endDraw::
		return points, pointsPos
	end

	local function render_fillPoly(stack, offset)
		local col = stack[offset]
		local points = stack[offset+1]
		local width = stack[offset+2]

		local gpoints = points
		for ii = 0, points / 2, 2 do
			local i = ii * 2
			local _, pointsPos = render_drawPoly({col, math_min(6, gpoints), width, stack[offset+3+i], stack[offset+4+i], stack[offset+5+i], stack[offset+6+i], stack[offset+7+i], stack[offset+8+i]}, 1, true)
			local startDrawTime = os_clock()
			for posY, v in pairs(pointsPos) do
				for i = v[1], v[2] do
					setDot(i, posY, col)
				end

				if os_clock() - startDrawTime > MAX_DRAW_TIME then
					goto endDraw
				end
			end
			gpoints = gpoints - 4
			if gpoints <= 0 then
				break
			end
		end

		::endDraw::
		return points
	end

	local lastPixelX, lastPixelY, lastPixelColor
	function obj.pushStack(stack)
		local offset = 2
		local actionNum
		local addValue = 0
		local startDrawTime = os_clock()
		local idx
		while stack[offset] do
			actionNum = stack[offset-1]
			clearOnly = actionNum == 0
			addValue = 0

			if actionNum == 0 then
				newBufferBase = stack[offset]
				newBuffer = {}
				if direct_clear then
					direct_clear(directArg, newBufferBase, changes)
				end
				updated = true
				clearBackplate = true
				if callback and newBufferBase ~= _oldBufferBase then
					obj.fullRefresh()
					_oldBufferBase = newBufferBase
				end
			elseif actionNum == resetViewportCodeID then
				viewportEnable = false
			elseif actionNum == -1 then
				viewportEnable = true
				viewport_x = stack[offset]
				viewport_y = stack[offset+1]
				viewport_sx = stack[offset+2]
				viewport_sy = stack[offset+3]
			elseif actionNum == 1 then
				setDot(stack[offset], stack[offset+1], stack[offset+2])
				updated = true
			elseif actionNum == 2 then
				render_fill(stack, offset)
				updated = true
			elseif actionNum == 3 then
				render_rect(stack, offset)
				updated = true
			elseif actionNum == 4 then
				render_text(stack, offset)
				updated = true
			elseif actionNum == 5 then
				render_line(stack, offset)
				updated = true
			elseif actionNum == 6 then
				render_circle(stack, offset)
				updated = true
			elseif actionNum == 8 then
				render_circleE(stack, offset)
				updated = true
			elseif actionNum == 7 then
				render_circleF(stack, offset)
				updated = true
			elseif actionNum == 9 then
				render_circleVE(stack, offset)
				updated = true
			elseif actionNum == 10 then
				addValue = render_drawPoly(stack, offset)
				updated = true
			elseif actionNum == 11 then
				addValue = render_fillPoly(stack, offset)
				updated = true
			elseif actionNum == 12 then
				for _ = 1, stack[offset] do
					lastPixelX = lastPixelX + 1
					setDot(lastPixelX, lastPixelY, lastPixelColor)
				end
				updated = true
			elseif actionNum == 13 then
				for _ = 1, stack[offset] do
					lastPixelX = lastPixelX - 1
					setDot(lastPixelX, lastPixelY, lastPixelColor)
				end
				updated = true
			elseif actionNum == 14 then
				for _ = 1, stack[offset] do
					lastPixelY = lastPixelY + 1
					setDot(lastPixelX, lastPixelY, lastPixelColor)
				end
				updated = true
			elseif actionNum == 15 then
				for _ = 1, stack[offset] do
					lastPixelY = lastPixelY - 1
					setDot(lastPixelX, lastPixelY, lastPixelColor)
				end
				updated = true
			elseif actionNum == 16 then
				idx = stack[offset]
				lastPixelX, lastPixelY, lastPixelColor = idx % rSizeX, math_floor(idx / rSizeX), stack[offset+1]
				setDot(lastPixelX, lastPixelY, lastPixelColor)
				updated = true
			elseif userCalls[actionNum] then
				if userCalls[actionNum](newBuffer, rotation, rSizeX, rSizeY, sizeX, sizeY, stack, offset, drawerData, bufferRangeUpdate, setDot, checkSetDot) then
					updated = true
				end
			end

			if os_clock() - startDrawTime > MAX_DRAW_TIME then
				goto endDraw
			end

			offset = offset + dataSizes[actionNum] + addValue
		end

		::endDraw::
	end

	function obj.flush(force)
		if not obj.wait and (updated or force) then
			if callbackBefore and callbackBefore(newBufferBase, clearOnly, maxBuffer, force, newBuffer, realBuffer, nil, nil, changes, changesIndex, changesCount, _changes, clearBackplate) then
				realBuffer = {}
			end

			if callback then
				--[[
				local color, px, py
				for i = bufferChangedFrom, bufferChangedTo do
					color = newBuffer[i] or newBufferBase
					if color ~= realBuffer[i] or force then
						px = math_floor(i / rSizeY)
						py = i % rSizeY
						callback(px, py, color, newBufferBase)
						realBuffer[i] = color
					end
				end
				]]

				local oldChanges
				if clearBackplate then
					oldChanges = {}
					for index in pairs(changes) do
						oldChanges[index] = true
					end

					for index in pairs(_changes) do
						if not changes[index] then
							changesCount = changesCount + 1
							changesIndex[changesCount] = index
							changes[index] = true
						end
					end
				end
		
				for i2 = 1, changesCount do
					local index = changesIndex[i2]
					--if changes[index] then
						callback(math_floor(index / sizeY), index % sizeY, newBuffer[index] or newBufferBase, newBufferBase)
						_changes[index] = true
					--end
				end

				if clearBackplate then
					obj.setOldChanges(oldChanges)
				end
			end

			updated = false
			clearBackplate = false
			if updatedList then
				changes = {}
				changesIndex = {}
				changesCount = 0
			end
		end
	end

	function obj.setWait(state)
		obj.wait = state
		if not state then
			obj.flush()
		end
	end

	function obj.getNewBuffer(i)
		return newBuffer[i] or newBufferBase
	end

	function obj.getRealBuffer(i)
		return realBuffer[i]
	end

	function obj.getChanges()
		return changes
	end

	function obj.fullRefresh()
		changesCount = 0
		changesIndex = {}
		for i = 0, (sizeX * sizeY) - 1 do
			changes[i] = true
			changesCount = changesCount + 1
			changesIndex[changesCount] = i
		end
	end

	--[[
	function obj.flushOldChanges()
		_changes = changes
	end
	]]

	function obj.setOldChanges(oldChanges)
		_changes = oldChanges
	end

	function obj.clearChangesBuffer()
		_changes = {}
		changes = {}
	end

	return obj
end

if better and better.isAvailable() and better.canvas and better.version >= 40 then
	local better_canvas_clear = better.canvas.clear
	local better_canvas_fill = better.canvas.fill
	local better_canvas_set = better.canvas.set

	function canvasAPI.createBetterCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation)
		local obj = {sizeX = sizeX, sizeY = sizeY}
		local maxX, maxY = sizeX - 1, sizeY - 1
		local maxEffectArrayBuffer = maxX + (maxY * sizeX)
		local dist
		local needOptimize = false
		local showState = false
		local disable = false
		local flushedDefault = false

		local betterCanvas = better.canvas.create(sizeX, sizeY)

		local drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, nil, betterCanvas, better_canvas_clear, better_canvas_fill, better_canvas_set)
		drawer.setWait(true)

		local defaultPosition = vec3_new(0, 0, 0)
		local function getSelfPos()
			local pt = type(parent)
			if pt == "Interactable" then
				return parent.shape.worldPosition
			elseif pt == "Character" then
				return parent.worldPosition
			end
			return defaultPosition
		end

		function obj.isRendering()
			return showState
		end

		function obj.disable(state)
			disable = state
		end

		function obj.setRenderDistance(_dist)
			dist = _dist
		end

		function obj.update()
			local newShowState = true
			local selfPosition
			if disable then
				newShowState = false
			elseif dist then
				if not pcall(function()
					selfPosition = getSelfPos()
					newShowState = mathDist(selfPosition, sm_localPlayer_getPlayer().character.worldPosition) <= dist
				end) then
					selfPosition = selfPosition or vec3_new(0, 0, 0)
					newShowState = false
				end
			end

			if newShowState ~= showState then
				showState = newShowState
				if newShowState then
					drawer.setWait(false)
					if not flushedDefault then
						drawer.flush(true)
						flushedDefault = true
					end
				else
					drawer.setWait(true)
					better.canvas.stopUpdate(betterCanvas)
				end
			end

			if newShowState then
				better.canvas.update_3d(betterCanvas, selfPosition + (rotation * offset), -sm.quat.getRight(rotation), -sm.quat.getUp(rotation), (pixelSize.x * sizeX) / 2, (pixelSize.y * sizeY) / 2)
			end
		end

		function obj.setPixelSize(_pixelSize)
			pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
			if type(pixelSize) == "number" then
				if pixelSize < 0 then
					pixelSize = math_abs(pixelSize)
					local vec = vec3_new(pixelSize, pixelSize, 0)
					vec.z = 0.00025
					obj.setPixelSize(vec)
				else
					local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
					vec.z = 0.00025
					obj.setPixelSize(vec)
				end
			end
		end

		function obj.setOffset(_offset)
			offset = _offset
		end

		function obj.setCanvasRotation(_rotation)
			rotation = _rotation
		end

		function obj.destroy()
			better.canvas.destroy(betterCanvas)
		end

		---------------------------------------

		obj.setPixelSize(pixelSize)
		obj.setCanvasRotation(rotation or quat_fromEuler(vec3_new(0, 0, 0)))
		obj.setOffset(offset or vec3_new(0, 0, 0))

		--[[
		local c = 0xff0000
		local seffect = createEffect(5, 5, 16, 16, c)
		local idx = 5 + (5 * sizeX)
		for i = 0, 16 - 1 do
			effects[idx + i] = {
				seffect,
				c,
				i,
				16,
				idx,
				5,
				5,
				1, --8. sizeY
				0 --9. indexY
			}
		end
		]]

		---------------------------------------

		obj.drawer = drawer
		for k, v in pairs(drawer) do
			obj[k] = v
		end

		return obj
	end
end

--low level display api
function canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material, scaleAddValue, altFromEuler, autoLayerDistance)
	local hiddenOffset = vec3_new(1000000, 1000000, 1000000)
	local defaultSizeX, defaultSizeY = sizeX, sizeY
	local pixelScaleX, pixelScaleY = 1, 1
	local obj = {sizeX = sizeX, sizeY = sizeY}
	local maxX, maxY = sizeX - 1, sizeY - 1
	local maxEffectArrayBuffer = maxX + (maxY * sizeX)
	local dist
	local needOptimize = false
	local showState = false
	local disable = false

	local _setPosition, _setRotation
	if parent then
		_setPosition, _setRotation = effect_setOffsetPosition, effect_setOffsetRotation
	else
		_setPosition, _setRotation = effect_setPosition, effect_setRotation
	end

	material = material or canvasAPI.material.classic
	local autoScaleAddValue = false
	if not scaleAddValue then
		autoScaleAddValue = true
	end

	local flushedDefault = false
	local oldBackplateColor
	local backplate
	if canvasAPI.multi_layer[tostring(material)] then
		oldBackplateColor = 0
		backplate = sm_effect_createEffect(getEffectName(), parent)
		effect_setParameter(backplate, "uuid", material)
		effect_setParameter(backplate, "color", black)
	end

	local additionalLayer
	local function updateAdditionalLayer()
		if material == canvasAPI.material.smoothed then
			if not additionalLayer then
				additionalLayer = sm_effect_createEffect(getEffectName(), parent)
				effect_setParameter(additionalLayer, "uuid", canvasAPI.material.glass)
				effect_setParameter(additionalLayer, "color", black)
				effect_start(additionalLayer)
				return true
			end
		elseif additionalLayer then
			effect_destroy(additionalLayer)
			additionalLayer = nil
		end
	end
	updateAdditionalLayer()

	local layerDistance
	local function updateLayerDistance(distance)
		layerDistance = math.max(0.001, autoLayerDistance and distance or 0)
	end
	updateLayerDistance()

	local effects = {}
	local nodeEffects = {}
	local effectDatas = {}
	local effectDataLen = 5

	local bufferedEffects = {}
	local bufferedEffectsIndex = 0
	local lastDrawTickTime
	local optimizationLevel = 16
	local optimizationValue = optimizationLevelToValue(optimizationLevel)
	local alpha = DEFAULT_ALPHA_VALUE

	local oldHardwareParams = {
		offset_x = 0,
		offset_y = 0,
		offset_z = 0,
		
		rotation_x = 0,
		rotation_y = 0,
		rotation_z = 0,

		scale_x = 1,
		scale_y = 1
	}

	local function getEIndex(index)
		return index * effectDataLen
	end

	local function fromEIndex(index)
		return index / effectDataLen
	end

	local function setEffectDataParams(index)
		local effect = nodeEffects[index]
		local eindex = getEIndex(index)
		local posX, posY, lSizeX, lSizeY = effectDatas[eindex+1], effectDatas[eindex+2], effectDatas[eindex+3], effectDatas[eindex+4]

		posX = posX + ((lSizeX - 1) * 0.5)
		posY = posY + ((lSizeY - 1) * 0.5)
		_setPosition(effect, rotation * (offset + vec3_new(((posX + 0.5) - (sizeX / 2)) * pixelSize.x, ((posY + 0.5) - (sizeY / 2)) * -pixelSize.y, backplate and (debugMode and 0.05 or layerDistance) or 0)))

		local localScaleAddValue = debugMode and -(pixelSize.x / 2) or scaleAddValue
		local vec = pixelSize * 1
		vec.x = (pixelSize.x * lSizeX) + localScaleAddValue
		vec.y = (pixelSize.y * lSizeY) + localScaleAddValue
		effect_setScale(effect, vec)
	end

	local function createEffect()
		local effect
		if bufferedEffectsIndex > 0 then
			effect = bufferedEffects[bufferedEffectsIndex]
			bufferedEffectsIndex = bufferedEffectsIndex - 1
			if not effect_isPlaying(effect) then
				effect_start(effect)
			end
		else
			effect = sm_effect_createEffect(getEffectName(), parent)
			effect_setParameter(effect, "uuid", material)
			if showState then
				effect_start(effect)
			end
			_setRotation(effect, rotation)
		end
		return effect
	end

	local function createEffectUnhide(hideList)
		local effect
		if bufferedEffectsIndex > 0 then
			effect = bufferedEffects[bufferedEffectsIndex]
			hideList[effect] = nil
			bufferedEffectsIndex = bufferedEffectsIndex - 1
			if not effect_isPlaying(effect) then
				effect_start(effect)
			end
		else
			effect = sm_effect_createEffect(getEffectName(), parent)
			effect_setParameter(effect, "uuid", material)
			if showState then
				effect_start(effect)
			end
			_setRotation(effect, rotation)
		end
		return effect
	end

	local function clearBufferedEffects()
		for i = 1, bufferedEffectsIndex do
			effect_destroy(bufferedEffects[i])
		end
		bufferedEffects = {}
		bufferedEffectsIndex = 0
	end

	local lastNewBuffer, lastBase

	local lastPopularColor
	local function mathPopularColor()
		local colorUsesTable = {}
		local colorUses = 0
		local oldColorUses = 0
		local colorSum = 0
		for index in pairs(nodeEffects) do
			local eindex = getEIndex(index)
			local color = effectDatas[eindex]
			local colorSize = effectDatas[eindex+3] * effectDatas[eindex+4]
			colorUsesTable[color] = (colorUsesTable[color] or 0) + colorSize
			colorSum = colorSum + colorSize
			colorUses = colorUsesTable[color]
			if colorUses > oldColorUses then
				oldColorUses = colorUses
				lastPopularColor = color
			end
		end

		if oldBackplateColor then
			local colorSize = (sizeX * sizeY) - colorSum
			colorUsesTable[oldBackplateColor] = (colorUsesTable[oldBackplateColor] or 0) + colorSize
			colorUses = colorUsesTable[oldBackplateColor]
			if colorUses > oldColorUses then
				oldColorUses = colorUses
				lastPopularColor = oldBackplateColor
			end
		end
	end

	local function effectIndexAtPos(px, py)
		return py + (px * sizeY)
	end

	local function getRootEIndexAtPos(px, py)
		if py < 0 or py >= sizeY then return end
		local index = effects[effectIndexAtPos(px, py)]
		return index and getEIndex(index), index
	end

	local function clearEffectFromBuffer(index)
		local eindex = getEIndex(index)
		local six, ix, iy = effectDatas[eindex+1], effectDatas[eindex+1], effectDatas[eindex+2]
		local sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
		nodeEffects[index] = nil
		for _ = 1, sizeX * sizeY do
			effects[effectIndexAtPos(ix, iy)] = nil
			ix = ix + 1
			if ix >= six + sizeX then
				ix = six
				iy = iy + 1
			end
		end
	end

	local function hideEffect(effect)
		bufferedEffectsIndex = bufferedEffectsIndex + 1
		bufferedEffects[bufferedEffectsIndex] = effect
		_setPosition(effect, hiddenOffset)
	end

	local function hideEffectData(index)
		hideEffect(nodeEffects[index])
		clearEffectFromBuffer(index)
	end

	local function hideEffectLater(effect, hideList)
		bufferedEffectsIndex = bufferedEffectsIndex + 1
		bufferedEffects[bufferedEffectsIndex] = effect
		hideList[effect] = true
		--_setPosition(effect, hiddenOffset)
	end

	local function hideEffectDataLater(index, hideList)
		hideEffectLater(nodeEffects[index], hideList)
		clearEffectFromBuffer(index)
	end	
	
	local function hideEffectsWithColor(color)
		for index in pairs(nodeEffects) do
			if effectDatas[getEIndex(index)] == color then
				hideEffectData(index)
			end
		end
	end

	local function delAllEffects()
		for _, effect in pairs(nodeEffects) do
			effect_destroy(effect)
		end
		effects = {}
		nodeEffects = {}
	end

	--[[
	local function forceRecreateNodeEffects()
		nodeEffects = {}
		for i, effectData in pairs(effects) do
			if effectData[7] == i then
				nodeEffects[i] = effectData
			end
		end
	end
	]]

	--local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
	local function colorEquals_smart(color1, color2)
		if color1 == color2 then return true end
		local rVal, gVal, bVal = hexToRGB256(color1)
		local rVal2, gVal2, bVal2 = hexToRGB256(color2)
		--return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
		return ((math_abs(rVal - rVal2) + math_abs(gVal - gVal2) + math_abs(bVal - bVal2)) / 1024) <= optimizationValue
	end

	local colorEquals = colorEquals_smart

	local function colorEquals_raw(color1, color2)
		return color1 == color2
	end

	local function getFillZone(eindex)
		local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
		return fillX1, fillY1, fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
	end

	local sumAttachTime = 0
	local sumAttachFillTime = 0
	local function tryLongAttach(changedList, changedColorList, hideList, index, px, py, color, sizeX, sizeY)
		local startTime = os_clock()

		--[[
		local origIndex = effects[index]
		local sizeX, sizeY = 1, 1
		local origEffect
		if origIndex then
			origEffect = nodeEffects[origIndex]
			local eindex = getEIndex(origIndex)
			index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
			sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
		end
		]]

		local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
		local downParentE, downParent = getRootEIndexAtPos(px, py + sizeY)
		local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)
		local downAvailable = downParentE and nodeEffects[downParent] and effectDatas[downParentE+1] == px and effectDatas[downParentE+3] == sizeX and colorEquals(effectDatas[downParentE], color)

		local fillOptional = false
		local fillX1, fillY1, fillX2, fillY2
		local fill2X1, fill2Y1, fill2X2, fill2Y2

		--[[
		if origEffect and (upAvailable or downAvailable) then
			hideEffectLater(origEffect, hideList)
			changedList[origIndex] = nil
			changedColorList[origIndex] = nil
			nodeEffects[origIndex] = nil
		end
		]]

		local newIndex, newEIndex
		local fillVal
		if upAvailable and downAvailable then
			fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
			fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

			local addSizeY = sizeY + effectDatas[downParentE+4]

			hideEffectLater(nodeEffects[downParent], hideList)
			changedList[downParent] = nil
			changedColorList[downParent] = nil
			nodeEffects[downParent] = nil

			effectDatas[upParentE+4] = effectDatas[upParentE+4] + addSizeY
			newIndex, newEIndex = upParent, upParentE
			fillVal = upParent
		elseif upAvailable then
			fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

			effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
			newIndex, newEIndex = upParent, upParentE
			fillVal = upParent
		elseif downAvailable then
			fillOptional = true
			fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
			fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

			changedList[downParent] = nil
			changedColorList[downParent] = nil

			nodeEffects[index] = nodeEffects[downParent]
			nodeEffects[downParent] = nil

			local eindex = getEIndex(index)
			effectDatas[eindex] = effectDatas[downParentE]
			effectDatas[eindex+1] = effectDatas[downParentE+1]
			effectDatas[eindex+2] = py
			effectDatas[eindex+3] = effectDatas[downParentE+3]
			effectDatas[eindex+4] = effectDatas[downParentE+4] + sizeY
			
			newIndex, newEIndex = index, eindex
			fillVal = index
		end

		if fillVal then
			index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
			sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
		end

		local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
		local rightParentE, rightParent = getRootEIndexAtPos(px + sizeX, py)
		local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
		local rightAvailable = rightParentE and nodeEffects[rightParent] and effectDatas[rightParentE+2] == py and effectDatas[rightParentE+4] == sizeY and colorEquals(effectDatas[rightParentE], color)

		if nodeEffects[index] and (leftAvailable or rightAvailable) then
			hideEffectLater(nodeEffects[index], hideList)
			changedList[index] = nil
			changedColorList[index] = nil
			nodeEffects[index] = nil
		end

		if leftAvailable and rightAvailable then
			fillOptional = false
			fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
			fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

			local addSizeX = sizeX + effectDatas[rightParentE+3]

			hideEffectLater(nodeEffects[rightParent], hideList)
			changedList[rightParent] = nil
			changedColorList[rightParent] = nil
			nodeEffects[rightParent] = nil

			effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + addSizeX
			fillVal = leftParent
		elseif leftAvailable then
			fillOptional = false
			fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
			fill2X1, fill2Y1, fill2X2, fill2Y2 = nil, nil, nil, nil

			effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
			fillVal = leftParent
		elseif rightAvailable then
			fillOptional = not upAvailable and not downAvailable
			fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
			fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

			changedList[rightParent] = nil
			changedColorList[rightParent] = nil

			nodeEffects[index] = nodeEffects[rightParent]
			nodeEffects[rightParent] = nil

			local eindex = getEIndex(index)
			effectDatas[eindex] = effectDatas[rightParentE]
			effectDatas[eindex+1] = px
			effectDatas[eindex+2] = effectDatas[rightParentE+2]
			effectDatas[eindex+3] = sizeX + effectDatas[rightParentE+3]
			effectDatas[eindex+4] = effectDatas[rightParentE+4]
			
			fillVal = index
		end

		sumAttachTime = sumAttachTime + (os_clock() - startTime)

		if fillVal then
			changedList[fillVal] = true
			changedColorList[fillVal] = true

			--[[
			local eindex = getEIndex(fillVal)
			local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
			local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
			local ix, iy = fillX1, fillY1
			for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
				effects[effectIndexAtPos(ix, iy)] = fillVal
				ix = ix + 1
				if ix > fillX2 then
					ix = fillX1
					iy = iy + 1
				end
			end
			]]

			startTime = os_clock()

			--fillOptional = false
			--if not fillOptional or not origEffect then
				local ix, iy = fillX1, fillY1
				for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
					effects[effectIndexAtPos(ix, iy)] = fillVal
					ix = ix + 1
					if ix > fillX2 then
						ix = fillX1
						iy = iy + 1
					end
				end
			--[[else
				local ix, iy = fillX1, fillY1
				for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
					if fillVal ~= effects[effectIndexAtPos(ix, iy)] then
						print("WTTT", fillVal, effects[effectIndexAtPos(ix, iy)])
					end
					ix = ix + 1
					if ix > fillX2 then
						ix = fillX1
						iy = iy + 1
					end
				end
				]]
			--end

			if fill2X1 then
				local ix, iy = fill2X1, fill2Y1
				for _ = 1, ((fill2X2 - fill2X1) + 1) * ((fill2Y2 - fill2Y1) + 1) do
					effects[effectIndexAtPos(ix, iy)] = fillVal
					ix = ix + 1
					if ix > fill2X2 then
						ix = fill2X1
						iy = iy + 1
					end
				end
			end

			sumAttachFillTime = sumAttachFillTime + (os_clock() - startTime)

			--fillVal = tryAttach(changedList, changedColorList, index, px, py, color) or fillVal
		end

		return fillVal
	end

	local function tryAttach(changedList, changedColorList, hideList, index, px, py, color, sizeX, sizeY)
		local startTime = os_clock()

		--[[
		local origIndex = effects[index]
		local sizeX, sizeY = 1, 1
		local origEffect
		if origIndex then
			origEffect = nodeEffects[origIndex]
			local eindex = getEIndex(origIndex)
			index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
			sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
		end
		]]

		local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
		local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)

		local fillX1, fillY1, fillX2, fillY2
		local newIndex, newEIndex, fillVal
		if upAvailable then
			--[[
			if origEffect then
				hideEffectLater(origEffect, hideList)
				changedList[origIndex] = nil
				changedColorList[origIndex] = nil
				nodeEffects[origIndex] = nil
			end
			]]

			fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

			effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
			newIndex, newEIndex = upParent, upParentE
			fillVal = upParent

			index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
			sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
		end

		local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
		local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
		if leftAvailable then
			if nodeEffects[index] then
				hideEffectLater(nodeEffects[index], hideList)
				changedList[index] = nil
				changedColorList[index] = nil
				nodeEffects[index] = nil
			end

			fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
			effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
			fillVal = leftParent
		end

		sumAttachTime = sumAttachTime + (os_clock() - startTime)

		if fillVal then
			changedList[fillVal] = true
			changedColorList[fillVal] = true

			startTime = os_clock()
			local ix, iy = fillX1, fillY1
			for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
				effects[effectIndexAtPos(ix, iy)] = fillVal
				ix = ix + 1
				if ix > fillX2 then
					ix = fillX1
					iy = iy + 1
				end
			end
			sumAttachFillTime = sumAttachFillTime + (os_clock() - startTime)
		end

		return fillVal
	end

	local sumFillTime = 0
	local function fillBlock(x, y, sx, sy, changedList, changedColorList, hideList, color, iterate, effect)
		if sx <= 0 or sy <= 0 then
			return
		end

		local newRIndex = effectIndexAtPos(x, y)
		nodeEffects[newRIndex] = effect or createEffectUnhide(hideList)
		changedList[newRIndex] = true
		changedColorList[newRIndex] = true

		local newEIndex = getEIndex(newRIndex)
		effectDatas[newEIndex] = color
		effectDatas[newEIndex+1] = x
		effectDatas[newEIndex+2] = y
		effectDatas[newEIndex+3] = sx
		effectDatas[newEIndex+4] = sy

		if not iterate then
			return true
		end
		
		local startTime = os_clock()
		local ix, iy = x, y
		local six = ix
		local mix = six + sx
		for _ = 1, sx * sy do
			effects[effectIndexAtPos(ix, iy)] = newRIndex
			ix = ix + 1
			if ix >= mix then
				ix = six
				iy = iy + 1
			end
		end
		sumFillTime = sumFillTime + (os_clock() - startTime)

		return true
	end

	local sumExtractTime = 0
	local function extractPixel(changedList, changedColorList, hideList, index, px, py, sizeX, sizeY)
		local startTime = os_clock()

		local rindex = effects[index]
		local eindex = getEIndex(rindex)
		local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
		local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
		local lx = px - rpx
		local ly = py - rpy

		local effect = nodeEffects[rindex]
		changedList[rindex] = nil
		changedColorList[rindex] = nil
		nodeEffects[rindex] = nil

		local color = effectDatas[eindex]
		--local block1, block2, block3, block4 = false, false, false, false
		if fillBlock(rpx, rpy, lx, rsy, changedList, changedColorList, hideList, color, false, effect) then --[[block1 = true]] effect = nil end
		if fillBlock(rpx + lx + sizeX, rpy, rsx - lx - sizeX, rsy, changedList, changedColorList, hideList, color, true, effect) then --[[block2 = true]] effect = nil end
		if fillBlock(rpx + lx, rpy, sizeX, ly, changedList, changedColorList, hideList, color, true, effect) then --[[block3 = true]] effect = nil end
		if fillBlock(rpx + lx, rpy + ly + sizeY, sizeX, rsy - ly - sizeY, changedList, changedColorList, hideList, color, true, effect) then --[[block4 = true]] effect = nil end

		local ix, iy, endX = px, py, px + (sizeX - 1)
		for _ = 1, sizeX * sizeY do
			effects[effectIndexAtPos(ix, iy)] = nil
			ix = ix + 1
			if ix > endX then
				ix = px
				iy = iy + 1
			end
		end

		if effect then
			hideEffectLater(effect, hideList)
		end

		sumExtractTime = sumExtractTime + (os_clock() - startTime)

		--if block1 then tryAttach(changedList, changedColorList, effectIndexAtPos(rpx, rpy), rpx, rpy, color) end
		--if block2 then tryAttach(changedList, changedColorList, effectIndexAtPos(block2X, rpy), block2X, rpy, color) end
		--if block3 then tryAttach(changedList, changedColorList, effectIndexAtPos(block3X, rpy), block3X, rpy, color) end
		--if block4 then tryAttach(changedList, changedColorList, effectIndexAtPos(block4X, block4Y), block4X, block4Y, color) end
	end

	--[[
	local function extractXLine(changedList, changedColorList, hideList, index, px, py)
		local rindex = effects[index]
		local eindex = getEIndex(rindex)
		local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
		local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
		local ly = py - rpy

		local effect = nodeEffects[rindex]
		changedList[rindex] = nil
		changedColorList[rindex] = nil
		nodeEffects[rindex] = nil
		effects[index] = nil

		local color = effectDatas[eindex]
		if fillBlock(rpx, rpy, rsx, ly, changedList, changedColorList, hideList, color, false, effect) then effect = nil end
		if fillBlock(rpx, rpy + ly + 1, rsx, rsy - ly - 1, changedList, changedColorList, hideList, color, true, effect) then effect = nil end

		if effect then
			hideEffectLater(effect, hideList)
		end
	end
	]]

	local function fillEffectsLinks(index, px, py, sizeX, sizeY)
		local ix, iy, endX = px, py, px + (sizeX - 1)
		for _ = 1, sizeX * sizeY do
			effects[effectIndexAtPos(ix, iy)] = index
			ix = ix + 1
			if ix > endX then
				ix = px
				iy = iy + 1
			end
		end
	end

	--[[
	local sumIsFullChangeTime = 0
	local function isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, forDestroy)
		local effectID = nodeEffects[rindex].id
		if fullChecked[effectID] then
			return false
		end
		fullChecked[effectID] = true


		local startTime = os_clock()

		local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
		local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
		local baseColor = lastNewBuffer[effectIndexAtPos(fillX1, fillY1)] or lastBase

		local ix, iy = fillX1 + 1, fillY1
		if ix > fillX2 then
			ix = fillX1
			iy = iy + 1
		end
		for _ = 2, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
			local color = lastNewBuffer[effectIndexAtPos(ix, iy)] or lastBase
			if color ~= baseColor then
				sumIsFullChangeTime = sumIsFullChangeTime + (os_clock() - startTime)
				return false
			end
			ix = ix + 1
			if ix > fillX2 then
				ix = fillX1
				iy = iy + 1
			end
		end

		ix, iy = fillX1, fillY1
		if not forDestroy then
			for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
				local index = effectIndexAtPos(ix, iy)
				_changes[index] = true
				ix = ix + 1
				if ix > fillX2 then
					ix = fillX1
					iy = iy + 1
				end
			end
		end

		sumIsFullChangeTime = sumIsFullChangeTime + (os_clock() - startTime)
		return true
	end
	]]

	--[[
	local function getBlockSize(rindex, index, px, py, color)
		local sizeX = 1
		--local sizeY = 1
		--[[
		for i = 1, maxY - py do
			if rindex ~= effects[index+i] or (lastNewBuffer[index+i] or lastBase) ~= color then
				break
			end
			sizeY = sizeY + 1
		end
		] ]
		for i = 1, maxX - px do
			local lindex = effectIndexAtPos(px+i, py)
			if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
				break
			end
			sizeX = sizeX + 1
		end

		local ix, iy, endX = 0, 1, sizeX - 1
		for _ = 1, sizeX * (maxY - py) do
			local lindex = effectIndexAtPos(px+ix, py+iy)
			if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
				break
			end
			
			ix = ix + 1
			if ix > endX then
				ix = 0
				iy = iy + 1
				--sizeY = sizeY + 1
			end
		end

		--[[
		for iy = 1, maxY - py do
			local multibrake = false
			for ix = 0, sizeX - 1 do
				local lindex = effectIndexAtPos(px+ix, py+iy)
				if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
					multibrake = true
					break
				end
			end
			if multibrake then
				break
			end
			sizeY = sizeY + 1
		end
		] ]

		return sizeX, iy
	end
	]]

	local function getBlockSize(index, px, py, color)
		local sizeX = 1

		for i = 1, maxX - px do
			local lindex = effectIndexAtPos(px+i, py)
			if effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
				break
			end
			sizeX = sizeX + 1
		end

		local ix, iy, endX = 0, 1, sizeX - 1
		for _ = 1, sizeX * (maxY - py) do
			local lindex = effectIndexAtPos(px+ix, py+iy)
			if effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
				break
			end
			
			ix = ix + 1
			if ix > endX then
				ix = 0
				iy = iy + 1
			end
		end

		return sizeX, iy
	end

	local function getBlockSizeOptimization(index, px, py, color)
		local sizeX = 1

		for i = 1, maxX - px do
			local lindex = effectIndexAtPos(px+i, py)
			if effects[lindex] or not colorEquals(lastNewBuffer[lindex] or lastBase, color) then
				break
			end
			sizeX = sizeX + 1
		end

		local ix, iy, endX = 0, 1, sizeX - 1
		for _ = 1, sizeX * (maxY - py) do
			local lindex = effectIndexAtPos(px+ix, py+iy)
			if effects[lindex] or not colorEquals(lastNewBuffer[lindex] or lastBase, color) then
				break
			end
			
			ix = ix + 1
			if ix > endX then
				ix = 0
				iy = iy + 1
			end
		end

		return sizeX, iy
	end

	local function getChangesBlockSize(rindex, index, changes, px, py, color)
		local sizeX = 1

		for i = 1, maxX - px do
			local lindex = effectIndexAtPos(px+i, py)
			if rindex ~= effects[lindex] or not changes[lindex] then
				break
			end
			sizeX = sizeX + 1
		end

		local ix, iy, endX = 0, 1, sizeX - 1
		for _ = 1, sizeX * (maxY - py) do
			local lindex = effectIndexAtPos(px+ix, py+iy)
			if rindex ~= effects[lindex] or not changes[lindex] then
				break
			end
			
			ix = ix + 1
			if ix > endX then
				ix = 0
				iy = iy + 1
			end
		end

		return sizeX, iy
	end

	local _oldVirtualBackplateColor
	local drawer
	drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, function (base, clearOnly, maxBuffer, force, newBuffer, realBuffer, _, _, changes, changesIndex, changesCount, _changes, clearBackplate)
		lastNewBuffer, lastBase = newBuffer, base
		lastDrawTickTime = sm.game.getCurrentTick()

		if clearOnly and backplate then
			clearBufferedEffects()
			drawer.clearChangesBuffer()
			delAllEffects()
			return
		end

		local changedList = {}
		local changedColorList = {}
		local hideList = {}
		--local fullChecked = {}

		--print("changesCount 1", changesCount)

		local oldChanges
		if clearBackplate then
			local startTime = os_clock()

			oldChanges = {}
			for index in pairs(changes) do
				oldChanges[index] = true
			end

			for index in pairs(_changes) do
				if not changes[index] then
					changesCount = changesCount + 1
					changesIndex[changesCount] = index
					changes[index] = true
				end
			end

			profiller("clear-loop", startTime)
		end

		--[[
		local _changesSize = 0
		for k, v in pairs(_changes) do
			_changesSize = _changesSize + 1
		end
		print(tostring(_changes), _changesSize)
		]]

		--print("changesCount 2", changesCount)

		--[[
		local startTime = os_clock()
		table_sort(changesIndex, function (a, b)
			return a < b
		end)
		profiller("stack-sort", startTime)
		]]

		--[[
		local startTime = os_clock()
		for i2 = 1, changesCount do
			local index = changesIndex[i2]
			local color = newBuffer[index] or base
			local rindex = effects[index]
			if rindex then
				local eindex = getEIndex(rindex)
				if not colorEquals(effectDatas[eindex], color) then
					local px = math_floor(index / sizeY)
					local py = index % sizeY
					local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
					local backplateColor = color == oldBackplateColor
					if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, backplateColor) then
						if backplateColor then
							changedList[rindex] = nil
							changedColorList[rindex] = nil
							hideEffectDataLater(rindex, hideList)
						elseif not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
							effectDatas[eindex] = color
							changedColorList[rindex] = true
						end
					elseif backplateColor then
						if aSizeX or aSizeY then
							extractPixel(changedList, changedColorList, hideList, index, px, py)
						else
							changedList[rindex] = nil
							changedColorList[rindex] = nil
							hideEffectDataLater(rindex, hideList)
						end
					else
						_changes[index] = true

						if aSizeX or aSizeY then
							extractPixel(changedList, changedColorList, hideList, index, px, py)
						end

						if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
							local eindex = getEIndex(index)

							if not nodeEffects[index] then
								local effect = createEffectUnhide(hideList)

								local bSizeX, bSizeY = 1, 1
								effectDatas[eindex+1] = px
								effectDatas[eindex+2] = py
								effectDatas[eindex+3] = bSizeX
								effectDatas[eindex+4] = bSizeY
								fillEffectsLinks(index, px, py, bSizeX, bSizeY)
								
								nodeEffects[index] = effect
								changedList[index] = true
							end

							effectDatas[eindex] = color
							changedColorList[index] = true
						end
					end
				end
			elseif color ~= oldBackplateColor then
				_changes[index] = true
				local px = math_floor(index / sizeY)
				local py = index % sizeY
				if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
					local effect = createEffectUnhide(hideList)

					nodeEffects[index] = effect

					local eindex = getEIndex(index)
					local bSizeX, bSizeY = getBlockSize(index, px, py)
					effectDatas[eindex] = color
					effectDatas[eindex+1] = px
					effectDatas[eindex+2] = py
					effectDatas[eindex+3] = bSizeX
					effectDatas[eindex+4] = bSizeY
					fillEffectsLinks(index, px, py, bSizeX, bSizeY)
					
					changedList[index] = true
					changedColorList[index] = true
				end
			end
		end
		profiller("change-loop", startTime)
		]]

		--local localEffectsBlacklist = {}

		local startTime = os_clock()
		for i2 = 1, changesCount do
			local index = changesIndex[i2]
			local color = newBuffer[index] or base
			local rindex = effects[index]
			if rindex --[[and not localEffectsBlacklist[rindex] ]] then
				local eindex = getEIndex(rindex)
				--local isBackgroundColor = color == oldBackplateColor
				--if color == oldBackplateColor or not colorEquals(effectDatas[eindex], color) then
				if effectDatas[eindex] ~= color then
					--local px = math_floor(index / sizeY)
					--local py = index % sizeY
					--local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
					--[[if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, backplateColor) then
						if backplateColor then
							changedList[rindex] = nil
							changedColorList[rindex] = nil
							hideEffectDataLater(rindex, hideList)
						else
							effectDatas[eindex] = color
							changedColorList[rindex] = true
						end
					else]]
					
					--local aSizeX, aSizeY = effectDatas[eindex+3], effectDatas[eindex+4]
					if effectDatas[eindex+3] > 1 or effectDatas[eindex+4] > 1 then
						local px = math_floor(index / sizeY)
						local py = index % sizeY
						--local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
						--extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)
						extractPixel(changedList, changedColorList, hideList, index, px, py, getChangesBlockSize(rindex, index, changes, px, py, color))

						--[[
						local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
						if aSizeX == bSizeX and aSizeY == bSizeY then
							effectDatas[eindex] = color
							changedColorList[rindex] = true
						else
							extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)
						end
						]]

						--[[
						if not isBackgroundColor then
							if not tryAttach(changedList, changedColorList, hideList, index, px, py, color, bSizeX, bSizeY) then
								local effect = createEffectUnhide(hideList)

								nodeEffects[index] = effect

								local eindex = getEIndex(index)
								effectDatas[eindex] = color
								effectDatas[eindex+1] = px
								effectDatas[eindex+2] = py
								effectDatas[eindex+3] = bSizeX
								effectDatas[eindex+4] = bSizeY
								fillEffectsLinks(index, px, py, bSizeX, bSizeY)
								
								changedList[index] = true
								changedColorList[index] = true
								localEffectsBlacklist[index] = true
							end
						end
						]]
					else
						changedList[rindex] = nil
						changedColorList[rindex] = nil
						hideEffectDataLater(rindex, hideList)
					end
				end
			end
		end
		profiller("extract-loop", startTime)

		local blockSizeCache = {}
		local startTime = os_clock()
		for i2 = 1, changesCount do
			local index = changesIndex[i2]
			local color = newBuffer[index] or base
			if color ~= oldBackplateColor then
				_changes[index] = true

				if not effects[index] then
					local px = math_floor(index / sizeY)
					local py = index % sizeY

					if not tryLongAttach(changedList, changedColorList, hideList, index, px, py, color, 1, 1) then
						local blockSize
						if blockSizeCache[index] then
							blockSize = blockSizeCache[index]
						else
							blockSize = {getBlockSize(index, px, py, color)}
							blockSizeCache[index] = blockSize
						end

						if not tryLongAttach(changedList, changedColorList, hideList, index, px, py, color, blockSize[1], blockSize[2]) then
							local effect = createEffectUnhide(hideList)

							nodeEffects[index] = effect

							local eindex = getEIndex(index)
							effectDatas[eindex] = color
							effectDatas[eindex+1] = px
							effectDatas[eindex+2] = py
							effectDatas[eindex+3] = blockSize[1]
							effectDatas[eindex+4] = blockSize[2]
							fillEffectsLinks(index, px, py, blockSize[1], blockSize[2])
							
							changedList[index] = true
							changedColorList[index] = true
						end
					end
				end
			end
		end
		profiller("add-loop", startTime)

		--[[
		local localEffectsBlacklist = {}
		local startTime = os_clock()
		for i2 = 1, changesCount do
			local index = changesIndex[i2]
			local color = newBuffer[index] or base
			local rindex = effects[index]
			if rindex then
				if not localEffectsBlacklist[rindex] then
					local eindex = getEIndex(rindex)
					local isBackgroundColor = color == oldBackplateColor
					if isBackgroundColor or not colorEquals(effectDatas[eindex], color) then
						if effectDatas[eindex+3] > 1 or effectDatas[eindex+4] > 1 then
							local px = math_floor(index / sizeY)
							local py = index % sizeY
							local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
							extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)

							if not isBackgroundColor then
								_changes[index] = true

								if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
									local effect = createEffectUnhide(hideList)

									nodeEffects[index] = effect

									local eindex = getEIndex(index)
									effectDatas[eindex] = color
									effectDatas[eindex+1] = px
									effectDatas[eindex+2] = py
									effectDatas[eindex+3] = bSizeX
									effectDatas[eindex+4] = bSizeY
									fillEffectsLinks(index, px, py, bSizeX, bSizeY)
									
									changedList[index] = true
									changedColorList[index] = true
									localEffectsBlacklist[index] = true
								end
							end
						elseif not isBackgroundColor then
							_changes[index] = true

							local px = math_floor(index / sizeY)
							local py = index % sizeY
							if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
								effectDatas[eindex] = color
								changedColorList[rindex] = true
							end
						else
							changedList[rindex] = nil
							changedColorList[rindex] = nil
							hideEffectDataLater(rindex, hideList)
						end
					end
				end
			elseif color ~= oldBackplateColor then
				_changes[index] = true

				local px = math_floor(index / sizeY)
				local py = index % sizeY
				if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
					local effect = createEffectUnhide(hideList)

					nodeEffects[index] = effect

					local eindex = getEIndex(index)
					local bSizeX, bSizeY = getBlockSize(nil, index, px, py, color)
					effectDatas[eindex] = color
					effectDatas[eindex+1] = px
					effectDatas[eindex+2] = py
					effectDatas[eindex+3] = bSizeX
					effectDatas[eindex+4] = bSizeY
					fillEffectsLinks(index, px, py, bSizeX, bSizeY)
					
					changedList[index] = true
					changedColorList[index] = true
					localEffectsBlacklist[index] = true
				end
			end
		end
		profiller("change-loop", startTime)
		]]

		startTime = os_clock()
		for index in pairs(changedList) do
			setEffectDataParams(index)
		end
		profiller("apply-params", startTime)

		--[[
		startTime = os_clock()
		for index in pairs(changedColorList) do
			local color = effectDatas[getEIndex(index)]
			if not colorCache[color] then
				colorCache[color] = color_new_fromSmallNumber(color, alpha)
			end
			effect_setParameter(nodeEffects[index], "color", colorCache[color])
		end
		profiller("apply-colors", startTime)
		]]
		startTime = os_clock()
		local colorobj = color_new(0)
		for index in pairs(changedColorList) do
			local color = effectDatas[getEIndex(index)]
			colorobj.r, colorobj.g, colorobj.b = hexToRGB(color)
			colorobj.a = alpha / 255
			effect_setParameter(nodeEffects[index], "color", colorobj)
		end
		profiller("apply-colors", startTime)

		startTime = os_clock()
		for effect in pairs(hideList) do
			_setPosition(effect, hiddenOffset)
		end
		profiller("later-hide", startTime)

		profillerPrint("fill-sum", sumFillTime)
		profillerPrint("extract-sum", sumExtractTime)
		profillerPrint("attach-sum", sumAttachTime)
		profillerPrint("attach-fill-sum", sumAttachFillTime)
		--profillerPrint("isFullChange-sum", sumIsFullChangeTime)
		--sumIsFullChangeTime = 0
		sumFillTime = 0
		sumExtractTime = 0
		sumAttachTime = 0
		sumAttachFillTime = 0
		
		if clearBackplate then
			drawer.setOldChanges(oldChanges)
			--clearBackplate = false
		end

		if clearOnly then
			clearBufferedEffects()
			return
		end

		needOptimize = true
	end, nil, function (_, color, changes)
		if backplate then
			oldBackplateColor = color
			effect_setParameter(backplate, "color", color_new_fromSmallNumber(color, alpha))
		elseif color ~= _oldVirtualBackplateColor then
			drawer.fullRefresh()
			_oldVirtualBackplateColor = color
		end
	end, nil, nil, true)

	if not backplate then
		drawer.fullRefresh()
	end

	local canvasWait
	local wait_dataTunnel
	local function _setWait(wait)
		canvasWait = wait
		drawer.setWait(wait)
		if not wait and wait_dataTunnel then
			obj.realPushDataTunnelParams(wait_dataTunnel)
			wait_dataTunnel = nil
		end
	end

	_setWait(true)

	local function recreateCanvas()
		if not lastNewBuffer then
			return
		end

		if backplate and false then --WHAT?
			mathPopularColor()
			if lastPopularColor ~= oldBackplateColor then
				effect_setParameter(backplate, "color", color_new_fromSmallNumber(lastPopularColor, alpha))
				oldBackplateColor = lastPopularColor
			end
		end
		
		local hideList = {}
		for i, effect in pairs(nodeEffects) do
			hideEffectLater(effect, hideList)
		end
		effects = {}
		nodeEffects = {}
		effectDatas = {}

		local changedList = {}
		local changedColorList = {}

		local index = 0
		while index <= maxEffectArrayBuffer do
			local px = math_floor(index / sizeY)
			local py = index % sizeY
			local color = lastNewBuffer[index] or lastBase
			if effects[index] then
				index = index + effectDatas[getEIndex(effects[index])+4]
			elseif color ~= oldBackplateColor then
				local eindex = getEIndex(index)

				local newRootIndex = tryAttach(changedList, changedColorList, hideList, index, px, py, color, 1, 1)
				if newRootIndex then
					local newRootEIndex = getEIndex(newRootIndex)
					index = effectIndexAtPos(px, effectDatas[newRootEIndex+2] + effectDatas[newRootEIndex+4])
				else
					local effect = createEffectUnhide(hideList)

					nodeEffects[index] = effect
					effects[index] = index

					effectDatas[eindex] = color
					effectDatas[eindex+1] = px
					effectDatas[eindex+2] = py
					effectDatas[eindex+3] = 1
					effectDatas[eindex+4] = 1
					
					changedList[index] = true
					changedColorList[index] = true
					index = index + 1
				end

				--[[
				local bSizeX, bSizeY = getBlockSizeOptimization(index, px, py, color)
				local effect = createEffectUnhide(hideList)

				nodeEffects[index] = effect
				effectDatas[eindex] = color
				effectDatas[eindex+1] = px
				effectDatas[eindex+2] = py
				effectDatas[eindex+3] = bSizeX
				effectDatas[eindex+4] = bSizeY
				fillEffectsLinks(index, px, py, bSizeX, bSizeY)
				
				changedList[index] = true
				changedColorList[index] = true
				index = index + bSizeY
				]]
			else
				index = index + 1
			end
		end

		for index in pairs(changedList) do
			setEffectDataParams(index)
		end

		local colorobj = color_new(0)
		for index in pairs(changedColorList) do
			local color = effectDatas[getEIndex(index)]
			colorobj.r, colorobj.g, colorobj.b = hexToRGB(color)
			colorobj.a = alpha / 255
			effect_setParameter(nodeEffects[index], "color", colorobj)
		end

		for effect in pairs(hideList) do
			_setPosition(effect, hiddenOffset)
		end
	end

	local _s_pixelSize, _s_offset, _s_rotation
	local function switchMaterial(_material)
		material = _material
		local newBackplateExists = not not canvasAPI.multi_layer[tostring(material)]
		local oldBackplateExists = not not backplate

		if newBackplateExists ~= oldBackplateExists then
			_oldVirtualBackplateColor = nil
		end

		local updateParameters = false
		if newBackplateExists then
			if not oldBackplateExists then
				updateParameters = true
				oldBackplateColor = 0
				backplate = sm_effect_createEffect(getEffectName(), parent)
				effect_setParameter(backplate, "color", black)
				effect_setParameter(backplate, "uuid", material)
				if showState then
					effect_start(backplate)
				end
			else
				effect_stop(backplate)
				effect_setParameter(backplate, "uuid", material)
				effect_start(backplate)
			end
		elseif oldBackplateExists then
			effect_destroy(backplate)
			oldBackplateColor = nil
			backplate = nil
			recreateCanvas()
		end

		for _, effect in pairs(nodeEffects) do
			effect_stop(effect)
			effect_setParameter(effect, "uuid", material)
			effect_start(effect)
		end

		for i = 1, bufferedEffectsIndex do
			local effect = bufferedEffects[i]
			effect_stop(effect)
			effect_setParameter(effect, "uuid", material)
			effect_start(effect)
		end

		local layerCreated = updateAdditionalLayer()

		if updateParameters or layerCreated then
			obj.setPixelSize(_s_pixelSize)
			obj.setOffset(_s_offset, true)
			obj.setCanvasRotation(_s_rotation)
		end
	end

	local function switchHardware()
		obj.setPixelSize(_s_pixelSize)
		obj.setOffset(_s_offset, true)
		obj.setCanvasRotation(_s_rotation)
	end

	local defaultPosition = vec3_new(0, 0, 0)
	local function getSelfPos()
		local pt = type(parent)
		if pt == "Interactable" then
			return parent.shape.worldPosition
		elseif pt == "Character" then
			return parent.worldPosition
		end
		return defaultPosition
	end

	local function updateLayersPos()
		if backplate then
			_setPosition(backplate, rotation * offset)
		end
		if additionalLayer then
			_setPosition(additionalLayer, rotation * (offset + vec3_new(0, 0, 0.0015)))
		end
	end

	local longOptimizeCounter = 0
	local function optimize()
		if longOptimizeCounter >= 3 then
			if debugMode then
				print("skip optimize")
			end
			return
		end

		local startTime = os_clock()

		recreateCanvas()

		if bufferedEffectsIndex > 4096 then
			if debugMode then
				print("stoping buffered effects", bufferedEffectsIndex - 4096)
			end

			for i = 1, bufferedEffectsIndex - 4096 do
				effect_stop(bufferedEffects[i])
			end

			--[[
			if bufferedEffectsIndex > 3000 then
				if debugMode then
					print("destroy buffered effects")
				end

				for i = 3001, bufferedEffectsIndex do
					effect_destroy(bufferedEffects[i])
					bufferedEffects[i] = nil
				end
				bufferedEffectsIndex = 3000
			end
			]]
		end

		local optimizeTime = os_clock() - startTime
		if optimizeTime > ((1 / 1000) * 50) then
			if debugMode then
				print("long optimize time", optimizeTime)
			end
			longOptimizeCounter = longOptimizeCounter + 1
		end

		updateLayersPos()
	end

	function obj.setAlpha(_alpha)
		alpha = _alpha
		for rindex, effect in pairs(nodeEffects) do
			effect_setParameter(effect, "color", color_new_fromSmallNumber(effectDatas[getEIndex(rindex)], alpha))
		end
	end

	function obj.setCanvasOptimizationLevel(value)
		optimizationLevel = value
		if value == 0 then
			colorEquals = colorEquals_raw
		else
			colorEquals = colorEquals_smart
		end
		optimizationValue = optimizationLevelToValue(optimizationLevel)
	end

	function obj.isRendering()
		return showState
	end

	function obj.disable(state)
		disable = state
	end

	function obj.setRenderDistance(_dist)
		dist = _dist
	end

	local reoptimizeTime = 20
	local reoptimizeDynamicTime = 40
	local canvasSize = sizeX * sizeY
	if canvasSize >= (512 * 512) then
		reoptimizeTime = 40
		reoptimizeDynamicTime = 80
	elseif canvasSize >= (256 * 256) then
		reoptimizeTime = 40
		reoptimizeDynamicTime = 60
	end

	local oldOptimizeTime
	function obj.update()
		local newShowState = true
		if disable then
			newShowState = false
		elseif dist then
			if not pcall(function()
				newShowState = mathDist(getSelfPos(), sm_localPlayer_getPlayer().character.worldPosition) <= dist
			end) then
				newShowState = false
			end
		end

		--recreateCanvas()

		if newShowState ~= showState then
			showState = newShowState
			if newShowState then
				obj.setWait(false)
				if not backplate and not flushedDefault then
					drawer.flush(true)
					flushedDefault = true
				end
				for _, effect in pairs(nodeEffects) do
					if not effect_isPlaying(effect) then
						effect_start(effect)
					end
				end
				if backplate then
					effect_start(backplate)
				end
				if additionalLayer then
					effect_start(additionalLayer)
				end
			else
				for _, effect in pairs(nodeEffects) do
					effect_stop(effect)
				end
				for i = 1, bufferedEffectsIndex do
					effect_stop(bufferedEffects[i])
				end
				if backplate then
					effect_stop(backplate)
				end
				if additionalLayer then
					effect_stop(additionalLayer)
				end
				obj.setWait(true)
			end
		end

		local ctick = sm.game.getCurrentTick()
		local optimizePeer = reoptimizeTime
		if lastDrawTickTime then
			if ctick - lastDrawTickTime < 20 then
				optimizePeer = reoptimizeDynamicTime
			end

			if longOptimizeCounter > 0 and ctick - lastDrawTickTime > (40 * 5) then
				if debugMode then
					print("reset longOptimizeCounter")
				end
				longOptimizeCounter = 0
			end
		end

		if newShowState and needOptimize and optimizePeer and (not oldOptimizeTime or ctick - oldOptimizeTime >= optimizePeer) then
			needOptimize = false
			oldOptimizeTime = ctick
			optimize()
		end
	end

	function obj.setPixelSize(_pixelSize)
		pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
		if type(pixelSize) == "Vec3" then
			_s_pixelSize = vec3_new(pixelSize.x, pixelSize.y, pixelSize.z)
		else
			_s_pixelSize = pixelSize
		end
		if type(pixelSize) == "number" then
			if pixelSize < 0 then
				pixelSize = math_abs(pixelSize)
				local vec = vec3_new(pixelSize, pixelSize, 0)
				vec.z = 0.00025
				obj.setPixelSize(vec)
				return
			else
				local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
				vec.z = 0.00025
				obj.setPixelSize(vec)
				return
			end
		end
		pixelSize.x = pixelSize.x + (0.0025 / sizeX)
		pixelSize.y = pixelSize.y + (0.0025 / sizeY)
		pixelSize.x = pixelSize.x * oldHardwareParams.scale_x * pixelScaleX
		pixelSize.y = pixelSize.y * oldHardwareParams.scale_y * pixelScaleY
		if backplate then
			effect_setScale(backplate, vec3_new(pixelSize.x * sizeX, pixelSize.y * sizeY, pixelSize.z))
		end
		updateLayerDistance(math.max(pixelSize.x * sizeX, pixelSize.y * sizeY) / 1000)
		if additionalLayer then
			effect_setScale(additionalLayer, vec3_new(pixelSize.x * sizeX * 1.005, pixelSize.y * sizeY * 1.005, math.min(2, layerDistance + ((pixelSize.x * sizeX) / 3 / 128))))
		end
		if autoScaleAddValue then
			scaleAddValue = math_min((pixelSize.x + pixelSize.y + pixelSize.z) / 50, 0.0001)
		end
	end

	function obj.setOffset(_offset, noUpdateParameters)
		offset = vec3_new(_offset.x, _offset.y, _offset.z)
		_s_offset = vec3_new(_offset.x, _offset.y, _offset.z)
		offset.x = offset.x + oldHardwareParams.offset_x
		offset.y = offset.y + oldHardwareParams.offset_y
		offset.z = offset.z + oldHardwareParams.offset_z
		updateLayersPos()
		if not noUpdateParameters then
			for index in pairs(nodeEffects) do
				setEffectDataParams(index)
			end
		end
	end

	function obj.setCanvasRotation(_rotation)
		_s_rotation = _rotation
		if type(_rotation) == "Quat" then
		elseif altFromEuler then
			_rotation = custom_fromEulerYEnd(math.rad(_rotation.x) + oldHardwareParams.rotation_x, math.rad(_rotation.y) + oldHardwareParams.rotation_y, math.rad(_rotation.z) + oldHardwareParams.rotation_z)
		else
			_rotation = quat_fromEuler(vec3_new(_rotation.x + math.deg(oldHardwareParams.rotation_x), _rotation.y + math.deg(oldHardwareParams.rotation_y), _rotation.z + math.deg(oldHardwareParams.rotation_z)))
		end
		rotation = _rotation
		if backplate then
			_setRotation(backplate, rotation)
		end
		if additionalLayer then
			_setRotation(additionalLayer, rotation)
		end
		for index, effect in pairs(nodeEffects) do
			_setRotation(effect, rotation)
			setEffectDataParams(index)
		end
		for _, effect in pairs(bufferedEffects) do
			_setRotation(effect, rotation)
		end
	end

	function obj.destroy()
		for _, effect in pairs(nodeEffects) do
			effect_destroy(effect)
		end
		if backplate then
			effect_destroy(backplate)
		end
		if additionalLayer then
			effect_destroy(additionalLayer)
		end
	end

	---------------------------------------

	obj.setPixelSize(pixelSize)
	obj.setCanvasRotation(rotation or vec3_new(0, 0, 0))
	obj.setOffset(offset or vec3_new(0, 0, 0))

	---------------------------------------

	obj.drawer = drawer
	for k, v in pairs(drawer) do
		obj[k] = v
	end
	obj.setWait = _setWait

	function obj.pushDataTunnelParams(dataTunnel)
		if canvasWait then
			wait_dataTunnel = dataTunnel
		else
			wait_dataTunnel = nil
			obj.realPushDataTunnelParams(dataTunnel)
		end
	end

	function obj.realPushDataTunnelParams(dataTunnel)
		obj.setCanvasOptimizationLevel(dataTunnel.optimizationLevel)
		drawer.pushDataTunnelParams(dataTunnel)

		local hardwareParamsChanged = false
		if dataTunnel.res_x ~= sizeX or dataTunnel.res_y ~= sizeY then
			for _, effect in pairs(nodeEffects) do
				hideEffect(effect)
			end
			effects = {}
			nodeEffects = {}
			effectDatas = {}
			
			sizeX = dataTunnel.res_x
			sizeY = dataTunnel.res_y
			obj.sizeX = sizeX
			obj.sizeY = sizeY
			maxX, maxY = sizeX - 1, sizeY - 1
			maxEffectArrayBuffer = maxX + (maxY * sizeX)
			pixelScaleX, pixelScaleY = defaultSizeX / sizeX, defaultSizeY / sizeY

			hardwareParamsChanged = true
		end

		obj.setAlpha(dataTunnel.light)
		if dataTunnel.material and dataTunnel.material ~= material then
			switchMaterial(dataTunnel.material)
		end
		for key, value in pairs(oldHardwareParams) do
			if dataTunnel[key] ~= value then
				hardwareParamsChanged = true
				oldHardwareParams[key] = dataTunnel[key]
			end
		end
		if hardwareParamsChanged then
			switchHardware()
		end
	end

	return obj
end

--simulates the API of display from SComputers on the client side of your parts
--this is the easiest way to implement the display in your mod
function canvasAPI.createClientScriptableCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
	local dataTunnel = {}
	local canvas = canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
	local api = canvasAPI.createScriptableApi(sizeX, sizeY, dataTunnel, nil, canvas.drawer, canvasAPI.materialList, 1, {
		maxOffset = math.huge,
		maxScale = math.huge
	}, {
		maxPixels = math.huge
	})
	api.registerClick = canvasAPI.addTouch(api, dataTunnel)
	api.dataTunnel = dataTunnel
	api.canvas = canvas

	local renderDistance = 15

	for k, v in pairs(canvas) do
		if k ~= "flush" then
			api[k] = v
		end
	end

	function api.getAudience()
		return canvas.isRendering() and 1 or 0
	end

	function api.update()
		canvas.disable(not api.isAllow())
		if dataTunnel.renderAtDistance then
			canvas.setRenderDistance()
		else
			canvas.setRenderDistance(renderDistance)
		end
		canvas.pushDataTunnelParams(dataTunnel)
		canvas.update()
		dataTunnel.scriptableApi_update()

		if dataTunnel.display_reset then
			canvas.drawerReset()
			dataTunnel.display_reset = nil
		end

		if dataTunnel.display_flush then
			if needPushStack(canvas, dataTunnel) then
				canvas.pushStack(dataTunnel.display_stack)
				canvas.flush()
			end
			
			dataTunnel.display_flush()
			dataTunnel.display_stack = nil
			dataTunnel.display_flush = nil
			dataTunnel.display_forceFlush = nil
		end
	end

	function api.setRenderDistance(dist)
		renderDistance = dist
	end

	return api
end

local customFontIndexesCache = {}
local checkedFonts = {}

--implement the SComputers API, does not implement data transfer
function canvasAPI.createScriptableApi(width, height, dataTunnel, flushCallback, drawer, materialList, defaultMaterial, allowHoloAPI, allowSetResolution)
	local defaultResolutionX, defaultResolutionY = width, height
	
	dataTunnel = dataTunnel or {}
	dataTunnel.rotation = 0
	dataTunnel.brightness = 1
	dataTunnel.light = DEFAULT_ALPHA_VALUE
	dataTunnel.skipAtNotSight = false
	dataTunnel.utf8support = false
	dataTunnel.renderAtDistance = false
	dataTunnel.display_forceFlush = true
	dataTunnel.dataUpdated = true
	dataTunnel.optimizationLevel = 16

	local stack = {}
	local stackIndex = 1
	local pixelsCache = {} --optimizations for cameras
	local pixelsCacheExists = false
	local oldStackSum, oldDataSum, oldStack, oldStackIndex
	local forceFlag = false

	local function clearStackForce()
		stack = {}
		stackIndex = 1
	end

	local function clearStack()
		if dataTunnel.display_stack == stack then
			clearStackForce()
		end
	end

	local function setForceFrame()
		if pixelsCacheExists then
			pixelsCache = {}
			pixelsCacheExists = false
		end
		forceFlag = true
		dataTunnel.display_forceFlush = true
	end

	local oldPlayersCount = #sm.player.getAllPlayers()
	function dataTunnel.scriptableApi_update()
		local playersCount = #sm.player.getAllPlayers()
		--local force = sm.game.getCurrentTick() % 80 == 0
		local force = false
		if oldPlayersCount ~= playersCount or force then
			--dataTunnel.display_forceForceFlush = force
			setForceFrame()
			oldPlayersCount = playersCount
		end
	end

	local rwidth, rheight = width, height
	local rmwidth, rmheight = width - 1, height - 1
	local utf8support = false
	local monoFont = true
	local newDataFlag = false
	local spacing = 1
	local fontIndex = 0
	local lastPixelX, lastPixelY, lastPixelColor, lastAction
	local currentSettedFont

	local viewport_x, viewport_y, viewport_sx, viewport_sy

	local dFontX, dFontY = defaultFont.width, defaultFont.height
	local drFontX, drFontY = defaultFont.width, defaultFont.height
	local fontX, fontY
	local mFontX, mFontY
	local xFontX, xFontY
	local sFontX, sFontY
	local rFontX, rFontY
	local fontScaleX, fontScaleY = 1, 1
	local function updateFontSize()
		fontX, fontY = math_ceil(dFontX * fontScaleX), math_ceil(dFontY * fontScaleY)
		rFontX, rFontY = math_ceil(drFontX * fontScaleX), math_ceil(drFontY * fontScaleY)
		mFontX, mFontY = fontX - 1, fontY - 1
		xFontX, xFontY = fontX + 1, fontY + 1
		sFontX, sFontY = fontX + spacing, fontY + 1
	end
	updateFontSize()

	---------------- color equals check
	local optimizationValue = optimizationLevelToValue(16)

	--local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
	local function colorEquals_smart(color1, color2)
		if color1 == color2 then return true end
		local rVal, gVal, bVal = hexToRGB256(color1)
		local rVal2, gVal2, bVal2 = hexToRGB256(color2)
		--return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
		return ((math_abs(rVal - rVal2) + math_abs(gVal - gVal2) + math_abs(bVal - bVal2)) / 1024) <= optimizationValue
	end

	local colorEquals = colorEquals_smart

	local function colorEquals_raw(color1, color2)
		return color1 == color2
	end

	----------------

	local api
	local api_flush
	api = {
		--[[
		getBuffer = function (x, y)
			if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
			return drawer.getNewBuffer(x + (y * rwidth))
		end,
		getCurrent = function (x, y)
			if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
			return drawer.getRealBuffer(x + (y * rwidth))
		end,
		]]
		get = function (x, y)
			if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
			return drawer.getNewBuffer(x + (y * rwidth))
		end,

		-- not implemented (implement it yourself if necessary)
		isAllow = function()
			return true
		end,
		getAudience = function()
			return 1
		end,

		setOptimizationLevel = function(value)
			checkArg(1, value, "number")
			value = round(value)
			if value < 0 then value = 0 end
			if value > 255 then value = 255 end
			if dataTunnel.optimizationLevel ~= value then
				optimizationValue = optimizationLevelToValue(value)
				if value == 0 then
					colorEquals = colorEquals_raw
				else
					colorEquals = colorEquals_smart
				end

				dataTunnel.optimizationLevel = value
				dataTunnel.dataUpdated = true
			end
		end,
		getOptimizationLevel = function()
			return dataTunnel.optimizationLevel
		end,


		-- stubs (outdated methods)
		optimize = function() end,
		setFrameCheck = function () end,
		getFrameCheck = function () return false end,
		setSkipAtLags = function() end,
		getSkipAtLags = function() return false end,


		-- main
		setFontScale = function(scaleX, scaleY)
			checkArg(1, scaleX, "number")
			checkArg(2, scaleY, "number")
			if scaleX < 0 then scaleX = 0 end
			if scaleY < 0 then scaleY = 0 end
			fontScaleX, fontScaleY = scaleX, scaleY
			updateFontSize()
		end,
		getFontScale = function()
			return fontScaleX, fontScaleY
		end,
		setTextSpacing = function(_spacing)
			if _spacing < 0 then _spacing = 0 end
			spacing = _spacing
			updateFontSize()
		end,
		setFontSize = function(_width, _height)
			api.setFontScale(_width / dFontX, _height / dFontY)
		end,
		getTextSpacing = function()
			return spacing
		end,
		calcTextBox = function(text) --it will return two numbers, this will be the size of the box that your text will occupy with this font and this scale
			local px, py
			local len, sep
			if utf8support then
				len, sep = utf8_len, utf8_sub
			else
				len, sep = string_len, string_byte
			end

			local textLen = len(text)
			if textLen == 0 then
				return 0, 0
			end

			local totalSize = 0
			if monoFont then
				totalSize = textLen * (fontX + spacing)
			else
				local localFontWidth = dFontX
				local localFont = dataTunnel.customFont or font.optimized
				if fontIndex > 0 and fontsOptimized[fontIndex] then
					localFont = fontsOptimized[fontIndex]
					localFontWidth = localFont.width
				end

				local char, chrdata
				for i = 1, textLen do
					char = sep(text, i, i)
					if char ~= " " and char ~= spaceCharCode then
						chrdata = localFont[char] or localFont.error or defaultError
						totalSize = totalSize + (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
					else
						totalSize = totalSize + (localFont.spaceSize or localFontWidth) + spacing
					end
					canvasAPI.yield()
				end
			end

			return totalSize - spacing, fontY
		end,
		calcCharsSize = function(text) --calculates the length of each character in a string, taking into account its spacing from the next character, and returns a table with these values
			local px, py
			local len, sep
			if utf8support then
				len, sep = utf8_len, utf8_sub
			else
				len, sep = string_len, string_byte
			end

			local textLen = len(text)
			if textLen == 0 then
				return 0, 0
			end

			local lens = {}

			local localFontWidth = dFontX
			local localFont = dataTunnel.customFont or font.optimized
			if fontIndex > 0 and fontsOptimized[fontIndex] then
				localFont = fontsOptimized[fontIndex]
				localFontWidth = localFont.width
			end

			local char, chrdata
			for i = 1, textLen do
				char = sep(text, i, i)
				if char ~= " " and char ~= spaceCharCode then
					chrdata = localFont[char] or localFont.error or defaultError
					table_insert(lens, (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing)
				else
					table_insert(lens, (localFont.spaceSize or localFontWidth) + spacing)
				end
				canvasAPI.yield()
			end

			lens[#lens] = lens[#lens] - spacing
			return lens
		end,
		calcDecreasingTextSizes = function(text) --it works almost like calcCharsSize. however, each value contains all the previous ones. this is used in the graphic.textBox function, but probably not applicable to any other
			local px, py
			local len, sep
			if utf8support then
				len, sep = utf8_len, utf8_sub
			else
				len, sep = string_len, string_byte
			end

			local textLen = len(text)
			if textLen == 0 then
				return 0, 0
			end

			local lens = {}
			local otherVals = 0

			local localFontWidth = dFontX
			local localFont = dataTunnel.customFont or font.optimized
			if fontIndex > 0 and fontsOptimized[fontIndex] then
				localFont = fontsOptimized[fontIndex]
				localFontWidth = localFont.width
			end

			local char, chrdata
			for i = 1, textLen do
				char = sep(text, i, i)
				local val
				if char ~= " " and char ~= spaceCharCode then
					chrdata = localFont[char] or localFont.error or defaultError
					val = (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
				else
					val = (localFont.spaceSize or localFontWidth) + spacing
				end
				otherVals = otherVals + val
				table_insert(lens, otherVals)
				canvasAPI.yield()
			end

			lens[#lens] = lens[#lens] - spacing
			return lens
		end,
		isMonospacedFont = function()
			return not not monoFont
		end,

		getWidth = function()
			return rwidth
		end,
		getHeight = function()
			return rheight
		end,
		getSize = function()
			return rwidth, rheight
		end,

		clear = function(color)
			if pixelsCacheExists then
				pixelsCache = {}
				pixelsCacheExists = false
			end

			lastAction = nil

			clearStackForce()
			stackIndex = 4
			stack[1] = resetViewportCodeID
			stack[2] = 0
			stack[3] = formatColorToSmallNumber(color, blackSmallNumber)
			
			--[[
			for i = 3, stackIndex - 1 do
				stack[i] = nil
			end
			stackIndex = 3
			]]
		end,
		drawPixel = function(x, y, color)
			x, y = round(x), round(y)
			if x < 0 or x >= width or y < 0 or y >= height then return end
			local index = x + (y * rwidth)
			color = formatColorToSmallNumber(color, whiteSmallNumber)
			if pixelsCache[index] ~= color then
				lastPixelX, lastPixelY = x, y

				if lastAction and x == lastPixelX + 1 and y == lastPixelY and colorEquals(lastPixelColor, color) then
					if lastAction == 1 then
						local i = stackIndex - 1
						stack[i] = stack[i] + 1
					else
						stack[stackIndex] = 12
						stackIndex = stackIndex + 1
						stack[stackIndex] = 1
						stackIndex = stackIndex + 1
					end

					lastAction = 1
				elseif lastAction and x == lastPixelX - 1 and y == lastPixelY and colorEquals(lastPixelColor, color) then
					if lastAction == 2 then
						local i = stackIndex - 1
						stack[i] = stack[i] + 1
					else
						stack[stackIndex] = 13
						stackIndex = stackIndex + 1
						stack[stackIndex] = 1
						stackIndex = stackIndex + 1
					end

					lastAction = 2
				elseif lastAction and x == lastPixelX and y == lastPixelY + 1 and colorEquals(lastPixelColor, color) then
					if lastAction == 3 then
						local i = stackIndex - 1
						stack[i] = stack[i] + 1
					else
						stack[stackIndex] = 14
						stackIndex = stackIndex + 1
						stack[stackIndex] = 1
						stackIndex = stackIndex + 1
					end

					lastAction = 3
				elseif lastAction and x == lastPixelX and y == lastPixelY - 1 and colorEquals(lastPixelColor, color) then
					if lastAction == 4 then
						local i = stackIndex - 1
						stack[i] = stack[i] + 1
					else
						stack[stackIndex] = 15
						stackIndex = stackIndex + 1
						stack[stackIndex] = 1
						stackIndex = stackIndex + 1
					end

					lastAction = 4
				else
					lastPixelColor = color

					stack[stackIndex] = 16
					stackIndex = stackIndex + 1
					stack[stackIndex] = index
					stackIndex = stackIndex + 1
					stack[stackIndex] = color
					stackIndex = stackIndex + 1

					lastAction = 0
				end

				pixelsCache[index] = color
				pixelsCacheExists = true
			end
		end,
		fillRect = function(x, y, sizeX, sizeY, color)
			if x <= 0 and y <= 0 and x + sizeX >= width and y + sizeY >= height then
				return api.clear(color or 0xffffff)
			end

			stack[stackIndex] = 2
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(x)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(y)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(sizeX)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(sizeY)
			stackIndex = stackIndex + 1
			stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
			stackIndex = stackIndex + 1
			
			if pixelsCacheExists then
				pixelsCache = {}
				pixelsCacheExists = false
			end
		end,
		drawRect = function(x, y, sizeX, sizeY, color, lineWidth)
			lineWidth = round(lineWidth or 1)
			if lineWidth < 1 then
				lineWidth = 1
			end

			stack[stackIndex] = 3
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(x)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(y)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(sizeX)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(sizeY)
			stackIndex = stackIndex + 1
			stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
			stackIndex = stackIndex + 1
			stack[stackIndex] = lineWidth
			stackIndex = stackIndex + 1
			
			if pixelsCacheExists then
				pixelsCache = {}
				pixelsCacheExists = false
			end
		end,
		drawText = function(x, y, text, color)
			if y > rmheight or y + mFontY < 0 or fontScaleX <= 0 or fontScaleY <= 0 then return end
			text = tostring(text)

			if monoFont then
				local maxTextLen = math_ceil((width - x) / sFontX)
				if maxTextLen <= 0 then return end
				local startTextFrom = math_max(1, math_floor(-x / sFontX) + 1)

				if utf8support then
					if utf8.len(text) > maxTextLen or startTextFrom > 1 then
						text = utf8.sub(text, startTextFrom, maxTextLen)
					end
				else
					if #text > maxTextLen or startTextFrom > 1 then
						text = text:sub(startTextFrom, maxTextLen)
					end
				end

				if #text == 0 then return end
				stack[stackIndex] = 4
				stackIndex = stackIndex + 1
				stack[stackIndex] = round(x) + ((startTextFrom - 1) * sFontX)
				stackIndex = stackIndex + 1
				stack[stackIndex] = round(y)
				stackIndex = stackIndex + 1
				stack[stackIndex] = text
				stackIndex = stackIndex + 1
				stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
				stackIndex = stackIndex + 1
				stack[stackIndex] = fontScaleX
				stackIndex = stackIndex + 1
				stack[stackIndex] = fontScaleY
				stackIndex = stackIndex + 1
				stack[stackIndex] = spacing
				stackIndex = stackIndex + 1
				stack[stackIndex] = fontIndex
				stackIndex = stackIndex + 1
			else
				if #text == 0 then return end
				stack[stackIndex] = 4
				stackIndex = stackIndex + 1
				stack[stackIndex] = round(x)
				stackIndex = stackIndex + 1
				stack[stackIndex] = round(y)
				stackIndex = stackIndex + 1
				stack[stackIndex] = text
				stackIndex = stackIndex + 1
				stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
				stackIndex = stackIndex + 1
				stack[stackIndex] = fontScaleX
				stackIndex = stackIndex + 1
				stack[stackIndex] = fontScaleY
				stackIndex = stackIndex + 1
				stack[stackIndex] = spacing
				stackIndex = stackIndex + 1
				stack[stackIndex] = fontIndex
				stackIndex = stackIndex + 1
			end
			
			if pixelsCacheExists then
				pixelsCache = {}
				pixelsCacheExists = false
			end
		end,
		drawCenteredText = function(x, y, text, color, centerX, centerY)
			if centerX == nil then centerX = true end
			if centerY == nil then centerY = true end
			
			local sizeX, sizeY
			if centerX or centerY then
				sizeX, sizeY = api.calcTextBox(text)
			end

			if centerX then
				x = x - (sizeX / 2)
			end

			if centerY then
				y = y - (sizeY / 2)
			end

			api.drawText(x, y, text, color)
		end,
		drawLine = function(x, y, x2, y2, color, width, roundFlag)
			width = round(width or 1)
			if width < 1 then
				width = 1
			end
			if roundFlag then
				width = -width
			end

			stack[stackIndex] = 5
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(x)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(y)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(x2)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(y2)
			stackIndex = stackIndex + 1
			stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
			stackIndex = stackIndex + 1
			stack[stackIndex] = width
			stackIndex = stackIndex + 1
			
			if pixelsCacheExists then
				pixelsCache = {}
				pixelsCacheExists = false
			end
		end,
		drawCircle = function (x, y, r, color)
			if r > 1024 then r = 1024 end

			stack[stackIndex] = 6
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(x)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(y)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(r)
			stackIndex = stackIndex + 1
			stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
			stackIndex = stackIndex + 1
			
			if pixelsCacheExists then
				pixelsCache = {}
				pixelsCacheExists = false
			end
		end,
		fillCircle = function (x, y, r, color)
			if r > 1024 then r = 1024 end
			
			stack[stackIndex] = 7
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(x)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(y)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(r)
			stackIndex = stackIndex + 1
			stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
			stackIndex = stackIndex + 1
			
			if pixelsCacheExists then
				pixelsCache = {}
				pixelsCacheExists = false
			end
		end,
		drawCircleEvenly = function (x, y, r, color)
			if r > 1024 then r = 1024 end

			stack[stackIndex] = 8
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(x)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(y)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(r)
			stackIndex = stackIndex + 1
			stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
			stackIndex = stackIndex + 1
			
			if pixelsCacheExists then
				pixelsCache = {}
				pixelsCacheExists = false
			end
		end,
		drawCircleVeryEvenly = function (x, y, r, color, stroke)
			if r > 1024 then r = 1024 end
			if not stroke or stroke < 1 then stroke = 1 end

			stack[stackIndex] = 9
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(x)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(y)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(r)
			stackIndex = stackIndex + 1
			stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
			stackIndex = stackIndex + 1
			stack[stackIndex] = round(stroke)
			stackIndex = stackIndex + 1
			
			if pixelsCacheExists then
				pixelsCache = {}
				pixelsCacheExists = false
			end
		end,
		drawPoly = function(color, ...)
			api.drawWidePoly(color, 1, false, ...)
		end,
		drawWidePoly = function(color, width, roundFlag, ...)
			stack[stackIndex] = 10
			stackIndex = stackIndex + 1
			stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
			stackIndex = stackIndex + 1

			width = round(width or 1)
			if width < 1 then
				width = 1
			end
			if roundFlag then
				width = -width
			end

			local points = {...}
			if #points == 0 or #points % 2 ~= 0 then
				error("an odd number of points are specified", 2)
			end
			stack[stackIndex] = #points
			stackIndex = stackIndex + 1

			stack[stackIndex] = width
			stackIndex = stackIndex + 1

			for _, v in ipairs(points) do
				stack[stackIndex] = round(v)
				stackIndex = stackIndex + 1
			end
			
			if pixelsCacheExists then
				pixelsCache = {}
				pixelsCacheExists = false
			end
		end,
		fillPoly = function(color, ...)
			api.fillWidePoly(color, 1, false, ...)
		end,
		fillWidePoly = function(color, width, roundFlag, ...)
			stack[stackIndex] = 11
			stackIndex = stackIndex + 1
			stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
			stackIndex = stackIndex + 1

			width = round(width or 1)
			if width < 1 then
				width = 1
			end
			if roundFlag then
				width = -width
			end

			local points = {...}
			if #points == 0 or #points % 2 ~= 0 then
				error("an odd number of points are specified", 2)
			end
			stack[stackIndex] = #points
			stackIndex = stackIndex + 1

			stack[stackIndex] = width
			stackIndex = stackIndex + 1

			for _, v in ipairs(points) do
				stack[stackIndex] = round(v)
				stackIndex = stackIndex + 1
			end
			
			if pixelsCacheExists then
				pixelsCache = {}
				pixelsCacheExists = false
			end
		end,
		drawTriangle = function(x1, y1, x2, y2, x3, y3, color)
			api.drawPoly(color, x1, y1, x2, y2, x3, y3)
		end,
		fillTriangle = function(x1, y1, x2, y2, x3, y3, color)
			api.fillPoly(color, x1, y1, x2, y2, x3, y3)
		end,
		flush = function()
			lastAction = nil
			api.setViewport()

			if dataTunnel.display_flush and dataTunnel.display_stack == stack then
				return
			end

			local needFlush = forceFlag
			--print("--------------------------- FLUSH 1", needFlush, stack, stackChecksum(stack), stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel)))

			if not needFlush and stackIndex ~= oldStackIndex then
				--print("FLUSH 2", stackIndex, oldStackIndex)
				needFlush = true
			end

			if not needFlush and newDataFlag then
				local dataSum = stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel))
				if dataSum ~= oldDataSum then
					--print("FLUSH 3")
					needFlush = true
					oldDataSum = dataSum
				end
			end

			if not needFlush and stack ~= oldStack then
				for i = 1, stackIndex - 1 do
					if stack[i] ~= oldStack[i] then
						needFlush = true
						--print("FLUSH 4", oldStack)
						break
					end
				end
			end

			--[[
			if needFlush then
				oldStackSum = nil
			else
				local stachSum = stackChecksum(stack)
				if stachSum ~= oldStackSum then
					--print("FLUSH 5")
					needFlush = true
					oldStackSum = stachSum
				end
			end
			]]
			
			if needFlush then
				--print("FLUSH ACTION")
				oldStack = stack
				oldStackIndex = stackIndex

				dataTunnel.display_stack = stack
				dataTunnel.display_flush = clearStack
				
				if flushCallback then
					flushCallback()
				end
			else
				clearStackForce()
			end

			forceFlag = false
			newDataFlag = false
		end,
		forceFlush = function()
			api_flush()
			dataTunnel.display_forceFlush = true
		end,

		-- settings
		setUtf8Support = function (state)
			if type(state) == "boolean" then
				if dataTunnel.utf8support ~= state then
					dataTunnel.utf8support = state
					dataTunnel.dataUpdated = true
					newDataFlag = true
					utf8support = state
				end
			else
				error("Type must be boolean", 2)
			end
		end,
		getUtf8Support = function () return dataTunnel.utf8support end,

		setRenderAtDistance = function (c)
			if type(c) == "boolean" then
				if dataTunnel.renderAtDistance ~= c then
					dataTunnel.renderAtDistance = c
					dataTunnel.dataUpdated = true
				end
			else
				error("Type must be boolean", 2)
			end
		end,
		getRenderAtDistance = function () return dataTunnel.renderAtDistance end,

		setRotation = function (rotation)
			if type(rotation) == "number" and rotation % 1 == 0 and rotation >= 0 and rotation <= 3 then
				if rotation ~= dataTunnel.rotation then
					dataTunnel.rotation = rotation
					dataTunnel.dataUpdated = true
					newDataFlag = true

					if pixelsCacheExists then
						pixelsCache = {}
						pixelsCacheExists = false
					end

					if rotation == 1 or rotation == 3 then
						rwidth = height
						rheight = width
					else
						rwidth = width
						rheight = height
					end
					rmheight = rheight - 1
					rmwidth = rwidth - 1
				end
			else
				error("integer must be in [0; 3]", 2)
			end
		end,
		getRotation = function () return dataTunnel.rotation end,

		setFont = function (customFont)
			checkArg(1, customFont, "table", "nil")
			currentSettedFont = customFont
			fontIndex = 0
			if dataTunnel.customFont then
				dataTunnel.dataUpdated = true
				dataTunnel.customFont = nil
			end
			if customFont then
				if not checkedFonts[customFont] then
					checkFont(customFont)
					checkedFonts[customFont] = true
				end
				dFontX, dFontY = customFont.width, customFont.height
				drFontX, drFontY = customFont.returnWidth or customFont.width, customFont.returnHeight or customFont.height
				fontIndex = customFontIndexesCache[customFont]
				if not fontIndex then
					fontIndex = 0
					for _, v in pairs(fonts) do
						if v == customFont then
							fontIndex = v.index
						end
					end
					customFontIndexesCache[customFont] = fontIndex
				end
				if fontIndex == 0 then
					dataTunnel.customFont = font.optimizeFont(customFont)
					dataTunnel.dataUpdated = true
				end
				monoFont = customFont.mono or customFont.mono == nil
			else
				dFontX, dFontY = defaultFont.width, defaultFont.height
				drFontX, drFontY = defaultFont.width, defaultFont.height
				monoFont = true
			end
			updateFontSize()
			newDataFlag = true
		end,
		getFont = function()
			return currentSettedFont
		end,

		getFontWidth = function ()
			return rFontX
		end,
		getFontHeight = function ()
			return rFontY
		end,
		getFontSize = function()
			return rFontX, rFontY
		end,

		getRealFontWidth = function ()
			return drFontX
		end,
		getRealFontHeight = function ()
			return drFontY
		end,
		getRealFontSize = function()
			return drFontX, drFontY
		end,

		setSkipAtNotSight = function (state)
			checkArg(1, state, "boolean")
			if dataTunnel.skipAtNotSight ~= state then
				dataTunnel.skipAtNotSight = state
				dataTunnel.dataUpdated = true
			end
		end,
		getSkipAtNotSight = function () return dataTunnel.skipAtNotSight end,

		getViewport = function()
			return viewport_x, viewport_y, viewport_sx, viewport_sy
		end,
		setViewport = function(x, y, sizeX, sizeY)
			if x or y or sizeX or sizeY then
				viewport_x, viewport_y, viewport_sx, viewport_sy = x or 0, y or 0, sizeX or api.getWidth(), sizeY or api.getHeight()
				stack[stackIndex] = -1
				stackIndex = stackIndex + 1
				stack[stackIndex] = round(viewport_x)
				stackIndex = stackIndex + 1
				stack[stackIndex] = round(viewport_y)
				stackIndex = stackIndex + 1
				stack[stackIndex] = round(viewport_sx)
				stackIndex = stackIndex + 1
				stack[stackIndex] = round(viewport_sy)
				stackIndex = stackIndex + 1
			else
				viewport_x, viewport_y, viewport_sx, viewport_sy = nil, nil, nil, nil
				stack[stackIndex] = resetViewportCodeID
				stackIndex = stackIndex + 1
			end
		end,
		setInlineViewport = function(x, y, sizeX, sizeY)
			if viewport_x then
				local x2 = x + (sizeX - 1)
				local y2 = y + (sizeY - 1)
				local px2 = viewport_x + (viewport_sx - 1)
				local py2 = viewport_y + (viewport_sy - 1)
				if x < viewport_x then x = viewport_x elseif x > px2 then x = px2 end
				if y < viewport_y then y = viewport_y elseif y > py2 then y = py2 end
				if x2 < viewport_x then x2 = viewport_x elseif x2 > px2 then x2 = px2 end
				if y2 < viewport_y then y2 = viewport_y elseif y2 > py2 then y2 = py2 end
				api.setViewport(x, y, (x2 - x) + 1, (y2 - y) + 1)
			else
				api.setViewport(x, y, sizeX, sizeY)
			end
		end,

		setBrightness = function(value) --float from 0
			checkArg(1, value, "number")
			if value < 0 then value = 0 end
			if value > 255 then value = 255 end
			if dataTunnel.brightness ~= value then
				dataTunnel.brightness = value
				dataTunnel.dataUpdated = true
			end
		end,
		getBrightness = function(value)
			return dataTunnel.brightness
		end,

		setLight = function(value)
			checkArg(1, value, "number")
			value = math_floor(value + 0.5)
			if value < 0 then value = 0 end
			if value > 255 then value = 255 end
			if dataTunnel.light ~= value then
				dataTunnel.light = value
				dataTunnel.dataUpdated = true
			end
		end,
		getLight = function(value)
			return dataTunnel.light
		end,

		getDefaultResolution = function()
			return defaultResolutionX, defaultResolutionY
		end,

		reset = function()
			if api.setMaterial then api.setMaterial(api.getDefaultMaterial()) end
			if api.setFontScale then api.setFontScale(1, 1) end
			if api.setTextSpacing then api.setTextSpacing(1) end
			if api.setFont then api.setFont() end
			if api.setRotation then api.setRotation(0) end
			if api.setUtf8Support then api.setUtf8Support(false) end
			if api.setClicksAllowed then api.setClicksAllowed(false) end
			if api.setMaxClicks then api.setMaxClicks(16) end
			if api.clearClicks then api.clearClicks() end
			if api.setSkipAtNotSight then api.setSkipAtNotSight(false) end
			if api.setRenderAtDistance then api.setRenderAtDistance(false) end
			if api.setViewport then api.setViewport() end
			if api.setBrightness then api.setBrightness(1) end
			if api.setLight then api.setLight(DEFAULT_ALPHA_VALUE) end
			if api.setOptimizationLevel then api.setOptimizationLevel(16) end
			if api.setHoloOffset then api.setHoloOffset(0, 0, 0) end
			if api.setHoloRotation then api.setHoloRotation(0, 0, 0) end
			if api.setHoloScale then api.setHoloScale(1, 1) end
			if api.setResolution then api.setResolution(defaultResolutionX, defaultResolutionY) end
			dataTunnel.display_reset = true
		end
	}

	if materialList then
		defaultMaterial = defaultMaterial or (materialList[0] and 0 or 1)
		local currentMaterialID

		function api.setMaterial(materialId)
			checkArg(1, materialId, "number")
			currentMaterialID = materialId
			if not materialList[currentMaterialID] then
				currentMaterialID = defaultMaterial
			end
			local material = materialList[currentMaterialID]
			if material == true then
				error("this material is not supported on this display", 2)
			end
			if dataTunnel.material ~= material then
				dataTunnel.material = material
				dataTunnel.dataUpdated = true
			end
		end

		function api.getMaterial()
			return currentMaterialID
		end

		function api.getDefaultMaterial()
			return defaultMaterial
		end

		api.setMaterial(api.getDefaultMaterial())
	end

	dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z = 0, 0, 0
	dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z = 0, 0, 0
	dataTunnel.scale_x, dataTunnel.scale_y = 1, 1
	if allowHoloAPI then
		local maxOffset = 5
		local maxScale = 5
		if type(allowHoloAPI) == "table" then
			maxOffset = allowHoloAPI.maxOffset or maxOffset
			maxScale = allowHoloAPI.maxScale or maxScale
		end

		function api.setHoloOffset(x, y, z)
			checkArg(1, x, "number")
			checkArg(2, y, "number")
			checkArg(3, z, "number")
			
			if x < -maxOffset then x = -maxOffset end
			if y < -maxOffset then y = -maxOffset end
			if z < -maxOffset then z = -maxOffset end
			if x > maxOffset then x = maxOffset end
			if y > maxOffset then y = maxOffset end
			if z > maxOffset then z = maxOffset end

			if x ~= dataTunnel.offset_x or y ~= dataTunnel.offset_y or z ~= dataTunnel.offset_z then
				dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z = x, y, z
				dataTunnel.dataUpdated = true
			end
		end

		function api.getHoloOffset()
			return dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z
		end

		function api.setHoloRotation(x, y, z)
			checkArg(1, x, "number")
			checkArg(2, y, "number")
			checkArg(3, z, "number")
			if x ~= dataTunnel.rotation_x or y ~= dataTunnel.rotation_y or z ~= dataTunnel.rotation_z then
				dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z = x, y, z
				dataTunnel.dataUpdated = true
			end
		end

		function api.getHoloRotation()
			return dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z
		end

		function api.setHoloScale(x, y)
			checkArg(1, x, "number")
			checkArg(2, y, "number")

			if x < 0 then x = 0 end
			if y < 0 then y = 0 end
			if x > maxScale then x = maxScale end
			if y > maxScale then y = maxScale end

			if x ~= dataTunnel.scale_x or y ~= dataTunnel.scale_y then
				dataTunnel.scale_x, dataTunnel.scale_y = x, y
				dataTunnel.dataUpdated = true
			end
		end

		function api.getHoloScale()
			return dataTunnel.scale_x, dataTunnel.scale_y
		end
	end

	dataTunnel.res_x, dataTunnel.res_y = defaultResolutionX, defaultResolutionY
	if allowSetResolution then
		if type(allowSetResolution) ~= "table" then
			allowSetResolution = {
				maxPixels = 4096 * 4096,
				maxWidth = 4096,
				maxHeight = 4096
			}
		end

		function api.setResolution(resX, resY)
			checkArg(1, resX, "number")
			checkArg(2, resY, "number")

			resX = math.floor(resX)
			resY = math.floor(resY)
			if resX < 1 then resX = 1 end
			if resY < 1 then resY = 1 end

			if allowSetResolution.maxWidth and resX > allowSetResolution.maxWidth then
				error("the width resolution has been exceeded. maximum: " .. allowSetResolution.maxWidth, 2)
			end

			if allowSetResolution.maxHeight and resX > allowSetResolution.maxHeight then
				error("the height resolution has been exceeded. maximum: " .. allowSetResolution.maxHeight, 2)
			end

			if allowSetResolution.maxPixels and (resX * resY) > allowSetResolution.maxPixels then
				error("the total maximum number of pixels has been exceeded. maximum: " .. allowSetResolution.maxPixels, 2)
			end
			
			if resX ~= dataTunnel.res_x or resY ~= dataTunnel.res_y then
				dataTunnel.res_x, dataTunnel.res_y = resX, resY
				dataTunnel.dataUpdated = true
				dataTunnel.resolutionChanged = true

				if pixelsCacheExists then
					pixelsCache = {}
					pixelsCacheExists = false
				end

				width, height = resX, resY
				if dataTunnel.rotation == 1 or dataTunnel.rotation == 3 then
					rwidth = height
					rheight = width
				else
					rwidth = width
					rheight = height
				end
				rmheight = rheight - 1
				rmwidth = rwidth - 1
			end
		end
	end

	api.update = api.flush
	api.getBuffer = api.get
	api.getCurrent = api.get
	api_flush = api.flush

	local internal = {
		rawPush = function(tbl)
			for i = 1, #tbl do
				stack[stackIndex] = tbl[i]
				stackIndex = stackIndex + 1
			end
		end,
		setForceFrame = setForceFrame
	}

	return api, internal
end

--adds a touch screen API (does not implement click processing)
function canvasAPI.addTouch(api, dataTunnel)
	dataTunnel = dataTunnel or {}
	dataTunnel.clicksAllowed = false
	dataTunnel.maxClicks = 16
	dataTunnel.clickData = {}

	api.getClick = function ()
		return (table_remove(dataTunnel.clickData, 1))
	end

	api.setMaxClicks = function (c)
		if type(c) == "number" and c % 1 == 0 and c > 0 and c <= 16 then
			dataTunnel.maxClicks = c
		else
			error("integer must be in [1; 16]", 2)
		end
	end

	api.getMaxClicks = function ()
		return dataTunnel.maxClicks
	end

	api.clearClicks = function ()
		dataTunnel.clickData = {}
	end

	api.setClicksAllowed = function (c)
		if type(c) == "boolean" then
			if dataTunnel.clicksAllowed ~= c then
				dataTunnel.clicksAllowed = c
				dataTunnel.dataUpdated = true
			end
		else
			error("Type must be boolean", 2)
		end
	end

	api.getClicksAllowed = function ()
		return dataTunnel.clicksAllowed
	end

	return function (tbl)
		tbl.x = tbl[1] or tbl.x
		tbl.y = tbl[2] or tbl.y
		tbl.state = tbl[3] or tbl.state
		tbl.button = tbl[4] or tbl.button
		tbl.nickname = tbl[5] or tbl.nickname
		tbl[1] = tbl.x or tbl[1]
		tbl[2] = tbl.y or tbl[2]
		tbl[3] = tbl.state or tbl[3]
		tbl[4] = tbl.button or tbl[4]
		tbl[5] = tbl.nickname or tbl[5]
		if #dataTunnel.clickData < dataTunnel.maxClicks then
			table_insert(dataTunnel.clickData, tbl)
		end
	end
end

--leaves only those tunnel fields that are needed for transmission over the network
function canvasAPI.minimizeDataTunnel(dataTunnel)
	return {
		clicksAllowed = dataTunnel.clicksAllowed,
		rotation = dataTunnel.rotation,
		renderAtDistance = dataTunnel.renderAtDistance,
		skipAtNotSight = dataTunnel.skipAtNotSight,
		utf8support = dataTunnel.utf8support,
		customFont = dataTunnel.customFont,
		display_reset = dataTunnel.display_reset,
		brightness = dataTunnel.brightness,
		optimizationLevel = dataTunnel.optimizationLevel,
		light = dataTunnel.light,
		material = dataTunnel.material,

		offset_x = dataTunnel.offset_x,
		offset_y = dataTunnel.offset_y,
		offset_z = dataTunnel.offset_z,

		rotation_x = dataTunnel.rotation_x,
		rotation_y = dataTunnel.rotation_y,
		rotation_z = dataTunnel.rotation_z,

		scale_x = dataTunnel.scale_x,
		scale_y = dataTunnel.scale_y,

		res_x = dataTunnel.res_x,
		res_y = dataTunnel.res_y
	}
end

-------- additional
canvasAPI.stackChecksum = stackChecksum
canvasAPI.formatColor = formatColor
canvasAPI.formatColorToNumber = formatColorToNumber
canvasAPI.formatColorToSmallNumber = formatColorToSmallNumber
canvasAPI.checkFont = checkFont
canvasAPI.simpleRemathRect = simpleRemathRect
canvasAPI.remathRect = remathRect
canvasAPI.hexToRGB = hexToRGB
canvasAPI.hexToRGB256 = hexToRGB256
canvasAPI.posCheck = posCheck
canvasAPI.mathDist = mathDist
canvasAPI.needPushStack = needPushStack
canvasAPI.font = font
canvasAPI.tableClone = tableClone
canvasAPI.canvasService = canvasService
canvasAPI.userCalls = userCalls
canvasAPI.dataSizes = dataSizes
canvasAPI.color_new_fromSmallNumber = color_new_fromSmallNumber
canvasAPI.getEffectName = getEffectName
canvasAPI.fonts = fonts
canvasAPI.utf8 = utf8

function canvasAPI.pushData(stack, ...)
	for i, v in ipairs({...}) do
		table.insert(stack, v)
	end
end

_G.canvasAPI = canvasAPI
end
function scmframework_72f24a17458cf6b8fcf97fc9ffba52ef() --$CONTENT_DATA/Scripts/canvasAPI/backup/canvas_best2.lua
print("> canvas.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/luajit.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/load.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/utf8.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/canvasService.lua")

local debugMode = false
local profileMode = false

local canvasAPI = {
    draw = {
        clear = 0,
        set   = 1,
        fill  = 2,
        rect  = 3,
        text  = 4,
        line  = 5,
        circle  = 6,
        circleF = 7,
        circleE = 8,
        circleVE = 9,
        poly = 10,
        polyF = 11,

        copyNX = 12,
        copyPX = 13,
        copyNY = 14,
        copyPY = 15,
        setI = 16
    },
    material = {
        glass = sm.uuid.new("a683f897-5b8a-4c96-9c46-7b9fbc76d186"),
        classic = sm.uuid.new("8328a29d-35e0-471b-8bfe-06952e9d916d"),
        plastic = sm.uuid.new("82d2da58-6597-4ffa-9b53-1af3b707fa7a"),
        smoothed = sm.uuid.new("a23a4ea2-96da-4bb2-a723-af8c27de2511"),
        glowing = sm.uuid.new("b46ae32a-9037-4360-9f98-3bef1cd4f366")
    },
    multi_layer = {}
}

canvasAPI.multi_layer[tostring(canvasAPI.material.classic)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.plastic)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.smoothed)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.glowing)] = true
canvasAPI.version = 55

canvasAPI.materialList = {
    [0] = canvasAPI.material.glass,
    canvasAPI.material.classic,
    canvasAPI.material.plastic,
    canvasAPI.material.smoothed,
    canvasAPI.material.glowing
}

canvasAPI.materialListWithoutGlass = {
    [0] = true,
    canvasAPI.material.classic,
    canvasAPI.material.plastic,
    canvasAPI.material.smoothed,
    canvasAPI.material.glowing
}

local MAX_DRAW_TIME = 2 --protecting the world from crashing using the display
local FONT_SIZE_LIMIT = 256
local DEFAULT_ALPHA_VALUE = 255
local MAX_CLICKS = 16
canvasAPI.DEFAULT_ALPHA_VALUE = DEFAULT_ALPHA_VALUE

local font = font
local defaultFont = font.default
local fonts = font.fonts
local fontsOptimized = font.fontsOptimized
local spaceCharCode = string.byte(" ")

local huge = math.huge
local string_len = string.len
local bit = bit or bit32
local bit_rshift = bit.rshift
local bit_lshift = bit.lshift
local utf8 = utf8
local string = string
local table_sort = table.sort
local type = type
local math_ceil = math.ceil
local math_max = math.max
local string_format = string.format
local table_insert = table.insert
local table_remove = table.remove
local math_floor = math.floor
local vec3_new = sm.vec3.new
local color_new = sm.color.new
local quat_fromEuler = sm.quat.fromEuler
local ipairs = ipairs
local pairs = pairs
local string_byte = string.byte
local defaultError = font.optimized.error
local tostring = tostring
local math_abs = math.abs
local math_min = math.min
local string_sub = string.sub
local table_concat = table.concat
local tonumber = tonumber
local utf8_len = utf8.len
local utf8_sub = utf8.sub
local sm_localPlayer_getPlayer = sm.localPlayer.getPlayer
local os_clock = os.clock
local math_sqrt = math.sqrt
local quat_new = sm.quat.new
local game_getCurrentTick = sm.game.getCurrentTick

local black = color_new(0, 0, 0)
local white = color_new(1, 1, 1)
local blackNumber = 0x000000ff
local whiteNumber = 0xffffffff
local blackSmallNumber = 0x000000
local whiteSmallNumber = 0xffffff

local getEffectName
do
    local currentEffect = 1
    local effectsNames = {}

    for i = 0, 255 do
        table_insert(effectsNames, "ShapeRenderable" .. tostring(i))
    end

    function getEffectName()
        local name = effectsNames[currentEffect]
        currentEffect = currentEffect + 1
        if currentEffect > #effectsNames then
            currentEffect = 1
        end
        return name
    end
end

local function profillerPrint(name, execTime)
    local t = execTime * 1000
    if profileMode and t > 0 then
        print("profiller", name, t)
    end
end

local function profiller(name, startTime)
    profillerPrint(name, os_clock() - startTime)
end

--[[
local sm_effect_createEffect = sm.effect.withoutHook_createEffect or sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local withoutHookEmptyEffect = emptyEffect
local whook = "withoutHook_"
if better and better.version >= 45 and better.isAvailable() then
    local mt = getmetatable(emptyEffect)
    local newMt = {}
    for k, v in pairs(mt) do
        newMt[k] = v
    end
    for k, v in pairs(mt) do
        if k:sub(1, #whook) == whook then
            newMt[k:sub(#whook + 1, #k)] = v
        end
    end
    withoutHookEmptyEffect = setmetatable({}, newMt)
end
local effect_setParameter = withoutHookEmptyEffect.setParameter
local effect_stop = withoutHookEmptyEffect.stop
local effect_destroy = withoutHookEmptyEffect.destroy
local effect_start = withoutHookEmptyEffect.start
local effect_isDone = withoutHookEmptyEffect.isDone
local effect_isPlaying = withoutHookEmptyEffect.isPlaying
local effect_setScale = withoutHookEmptyEffect.setScale
local effect_setOffsetPosition = withoutHookEmptyEffect.setOffsetPosition
local effect_setOffsetRotation = withoutHookEmptyEffect.setOffsetRotation
effect_destroy(emptyEffect)
]]

local sm_effect_createEffect = sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local effect_setParameter = emptyEffect.setParameter
local effect_stop = emptyEffect.stop
local effect_destroy = emptyEffect.destroy
local effect_start = emptyEffect.start
local effect_isDone = emptyEffect.isDone
local effect_isPlaying = emptyEffect.isPlaying
local effect_setScale = emptyEffect.setScale
local effect_setOffsetPosition = emptyEffect.setOffsetPosition
local effect_setOffsetRotation = emptyEffect.setOffsetRotation
local effect_setPosition = emptyEffect.setPosition
local effect_setRotation = emptyEffect.setRotation
effect_destroy(emptyEffect)

local function reverse_ipairs(t)
    local i = #t + 1
    return function()
        i = i - 1
        if i > 0 then
            return i, t[i]
        end
    end
end

local function round(number)
    return math_floor(number + 0.5)
end

local function checkFont(lfont)
    if type(lfont) ~= "table" then
        error("the font should be a table", 3)
    end

    if lfont.mono or lfont.mono == nil then
        if type(lfont.chars) ~= "table" or (type(lfont.width) ~= "number") or (type(lfont.height) ~= "number") then
            error("invalid basic char data", 3)
        end
        
        if lfont.width > FONT_SIZE_LIMIT then
            error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
        elseif lfont.height > FONT_SIZE_LIMIT then
            error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
        end

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data ~= lfont.height then
                error("font failed integrity check", 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" then
                    error("the char string has the wrong type", 3)
                elseif #line ~= lfont.width then
                    print(char, #line, data)
                    error("the char string has the wrong lenght", 3)
                end
            end
        end
    else
        if type(lfont.chars) ~= "table" then
            error("font failed integrity check", 3)
        end

        local oFont = font.optimizeFont(lfont)
        lfont.spaceSize = oFont.spaceSize
        lfont.width = oFont.width
        lfont.height = oFont.height

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data > FONT_SIZE_LIMIT then
                error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" or #line > FONT_SIZE_LIMIT then
                    error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
                end
            end
        end
    end
end

local function doQuat(x, y, z, w)
    local sin = math.sin(w / 2)
    return quat_new(sin * x, sin * y, sin * z, math.cos(w / 2))
end

local function custom_fromEulerYEnd(x, y, z) --custom implementation
    return doQuat(1, 0, 0, x) * doQuat(0, 0, 1, z) * doQuat(0, 1, 0, y)
end

local function tableClone(tbl)
    local newtbl = {}
    for k, v in pairs(tbl) do
        newtbl[k] = v
    end
    return newtbl
end

local function stackChecksum(stack)
    local num = -#stack
    local t, v
    for i = 1, #stack do
        v = stack[i]
        t = type(v)
        num = num - i
        if t == "number" then
            num = num + ((v * i) + v + i + (v / i))
        elseif t == "Color" then
            num = num + ((i * (v.r / i) * -4) + v.g)
            num = num - ((i * (v.g + i) * 5) + v.b)
            num = num + ((i * (v.b - i) * 8) + v.r)
        elseif t == "string" then
            for i3 = 1, #v do
                num = num + (i * (-i3 - (string_byte(v, i3) * i3)))
            end
        end
    end
    return num
end

local function checkArg(n, have, ...)
    have = type(have)
    local tbl = {...}
    for _, t in ipairs(tbl) do
        if have == t then
            return
        end
    end
    error(string_format("bad argument #%d (%s expected, got %s)", n, table_concat(tbl, " or "), have), 3)
end

local function simpleRemathRect(x, y, w, h, maxX, maxY)
    local x2, y2 = x + (w - 1), y + (h - 1)
    if x < 0 then
        x = 0
    elseif x > maxX then
        --x = maxX
        return
    end
    if y < 0 then
        y = 0
    elseif y > maxY then
        --y = maxY
        return
    end
    if x2 < 0 then
        --x2 = 0
        return
    elseif x2 > maxX then
        x2 = maxX
    end
    if y2 < 0 then
        --y2 = 0
        return
    elseif y2 > maxY then
        y2 = maxY
    end
    return x, y, x2, y2, w, h
end

local function remathRect(offset, stack, maxX, maxY)
    return simpleRemathRect(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], maxX, maxY)
end

local function posCheck(width, height, x, y)
    return x >= 0 and y >= 0 and x < width and y < height
end

local hashChar = string.byte("#")
local bit = bit or bit32
local band = bit.band
local rshift = bit.rshift
local function hexToRGB(color)
    return math_floor(color / 256 / 256) / 255, (math_floor(color / 256) % 256) / 255, (color % 256) / 255
end

local function hexToRGB256(color)
    return math_floor(color / 256 / 256), math_floor(color / 256) % 256, color % 256
end

local function optimizationLevelToValue(level)
    return (level / 255) * 0.25
end

local function formatColor(color, default)
    local t = type(color)
    if t == "Color" then
        return color
    elseif t == "string" then
        return color_new(color)
    elseif t == "number" then
        return color_new(hexToRGB(color))
    end

    return default
end

local redMul = 256 * 256 * 256
local greenMul = 256 * 256
local blueMul = 256
local function formatColorToNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * redMul) + (math_floor(color.g * 255) * greenMul) + (math_floor(color.b * 255) * blueMul) + math_floor(color.a * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return val
        end
        return (val * 256) + 255
    elseif t == "number" then
        return (color * 256) + 255
    end

    return default or 0
end

local function formatColorToSmallNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * greenMul) + (math_floor(color.g * 255) * blueMul) + math_floor(color.b * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return math_floor(val / 256)
        end
        return val
    elseif t == "number" then
        return color
    end

    return default or 0
end

local function color_new_fromSmallNumber(number, alpha)
    return color_new((number * 256) + (alpha or 255))
end

local function mathDist(pos1, pos2)
    return math.sqrt(((pos1.x - pos2.x) ^ 2) + ((pos1.y - pos2.y) ^ 2) + ((pos1.z - pos2.z) ^ 2))
end

local function needPushStack(canvas, dataTunnel) --returns true if the rendering stack should be applied
    return dataTunnel.display_forceFlush or not ((dataTunnel.skipAtNotSight and not canvas.isRendering()))
end

local resetViewportCodeID = -23124
local dataSizes = {
    [resetViewportCodeID] = 1,
    [-1] = 5,
    [0] = 2,
    4,
    6,
    7,
    9, --text
    7, --line
    5,
    5,
    5,
    6,

    4, --drawPoly
    4, --fillPoly

    2,
    2,
    2,
    2,
    3
}

local userCalls = {}

canvasAPI.yield = function() end

function canvasAPI.createDrawer(sizeX, sizeY, callback, callbackBefore, directArg, direct_clear, direct_fill, direct_set, updatedList)
    local obj = {}
    local oldStackSum
    local rSizeX, rSizeY = sizeX, sizeY
    local maxX, maxY = sizeX - 1, sizeY - 1
    local newBuffer, newBufferBase = {}, 0
    local realBuffer = {}
    local maxBuffer = maxX + (maxY * sizeX)
    local currentFont = font.optimized
    local fontWidth, fontHeight = defaultFont.width, defaultFont.height
    local rotation = 0
    local utf8Support = false
    local updated = false
    local clearOnly = false
    local clearBackplate = false
    local maxLineSize = sizeX + sizeY
    local bigSide = math_max(sizeX, sizeY)
    local drawerData = {}
    local _oldBufferBase
    local changes = {}
    local _changes = {}
    local changesIndex, changesCount = {}, 0

    local viewportEnable = false
    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local function bufferRangeUpdate() end

    local function setDot(px, py, col)
        if viewportEnable and (px < viewport_x or py < viewport_y or px >= (viewport_x + viewport_sx) or py >= (viewport_y + viewport_sy)) then
            return
        end

        --[[
        if rotation == 0 then
            index = px + (py * rSizeX)
        elseif rotation == 1 then
            index = (rSizeX - py - 1) + (px * rSizeX)
        elseif rotation == 2 then
            index = (rSizeX - px - 1) + ((rSizeY - py - 1) * rSizeX)
        else
            index = py + ((rSizeY - px - 1) * rSizeX)
        end
        ]]

        local index
        if rotation == 0 then
            index = py + (px * rSizeY)
        elseif rotation == 1 then
            index = px + ((rSizeX - py - 1) * rSizeY)
        elseif rotation == 2 then
            index = (rSizeY - py - 1) + ((rSizeX - px - 1) * rSizeY)
        else
            index = (rSizeY - px - 1) + (py * rSizeY)
        end

        if direct_set then
            newBuffer[index] = col
            direct_set(directArg, math_floor(index / rSizeY), index % rSizeY, col)
            return true
        elseif newBuffer[index] ~= col then
            if updatedList and not changes[index] then
                changes[index] = true
                changesCount = changesCount + 1
                changesIndex[changesCount] = index
            end

            newBuffer[index] = col
            return true
        end
    end

    local function check(px, py)
        return px >= 0 and py >= 0 and px < sizeX and py < sizeY
    end

    local function checkSetDot(px, py, col)
        if check(px, py) then
            setDot(px, py, col)
            return true
        end
        return false
    end

    function obj.drawerReset()
    end

    function obj.drawer_setRotation(_rotation)
        rotation = _rotation
        if rotation == 1 or rotation == 3 then
            sizeX = rSizeY
            sizeY = rSizeX
        else
            sizeX = rSizeX
            sizeY = rSizeY
        end
        maxX, maxY = sizeX - 1, sizeY - 1
    end

    function obj.drawer_setUtf8Support(state)
        utf8Support = not not state
    end

    function obj.drawer_setFont(customFont)
        if customFont then
            currentFont = customFont
            fontWidth, fontHeight = customFont.width, customFont.height
        else
            currentFont = font.optimized
            fontWidth, fontHeight = defaultFont.width, defaultFont.height
        end
    end

    local old_rotation
    local old_utf8support
    local old_customFont
    function obj.pushDataTunnelParams(params)
        if params.res_x ~= rSizeX or params.res_y ~= rSizeY then
            rSizeX, rSizeY = params.res_x, params.res_y
            obj.drawer_setRotation(rotation)
            newBuffer, newBufferBase = {}, 0
            realBuffer = {}
            maxBuffer = maxX + (maxY * sizeX)
            maxLineSize = sizeX + sizeY
            bigSide = math_max(sizeX, sizeY)
            changes = {}
            _changes = {}
            changesIndex, changesCount = {}, 0
            oldStackSum = nil
        end

        if params.rotation ~= old_rotation then
            obj.drawer_setRotation(params.rotation)
            old_rotation = params.rotation
        end
        if params.utf8support ~= old_utf8support then
            obj.drawer_setUtf8Support(params.utf8support)
            old_utf8support = params.utf8support
        end
        if params.customFont ~= old_customFont then
            obj.drawer_setFont(params.customFont)
            old_customFont = params.customFont
        end
    end

    ------------------------------------------
    
    local function rasterize_fill(x, y, sx, sy, col)
        local x, y, x2, y2 = simpleRemathRect(x, y, sx, sy, maxX, maxY)
        if not x then return end

        local ix, iy = x, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy + 1
            if iy > y2 then
                iy = y
                ix = ix + 1
            end
        end

        --[[
        local ix, iy = x, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            ix = ix + 1
            if ix > x2 then
                ix = x
                iy = iy + 1
            end
        end
        ]]

        --[[
        local ix, iy = x2, y2
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy - 1
            if iy < y then
                iy = y2
                ix = ix - 1
            end
        end
        ]]

        --[[
        local ix, iy = x2, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy + 1
            if iy > y2 then
                iy = y
                ix = ix - 1
            end
        end
        ]]
    end

    local function rasterize_circleF(px, py, r, col)
        local chr = r*r
        local sx, sy, tempInt, tempBool

        if r < bigSide and px >= 0 and py >= 0 and px < sizeX and py < sizeY then --now only a quarter of the circle is rendered
            for iy = 0, r do
                sy = iy + 0.5
                tempBool = false
                for ix = r, 0, -1 do
                    sx = ix + 0.5
                    if tempBool or (sx * sx) + (sy * sy) <= chr then
                        tempBool = true
                        checkSetDot(px + ix, py + iy, col)
                        checkSetDot(px - ix - 1, py + iy, col)
                        checkSetDot(px + ix, py - iy - 1, col)
                        checkSetDot(px - ix - 1, py - iy - 1, col)
                    end
                end
            end
        else
            for ix = math_max(-r, -px), math_min(r, (sizeX - px) - 1) do --if the starting point is not within the screen or the circle is too large, then will have to check every pixel
                sx = ix + 0.5
                for iy = math_max(-r, -py), math_min(r, (sizeY - py) - 1) do
                    sy = iy + 0.5
                    if (sx * sx) + (sy * sy) <= chr then
                        setDot(px + ix, py + iy, col)
                    end
                end
            end
        end
    end

    local function rasterize_line(px, py, px2, py2, col, width, linesInfo)
        if px2 < px or py2 < py then
            local _px, _py = px, py
            px, py = px2, py2
            px2, py2 = _px, _py
        end
        local dx = math_abs(px2 - px)
        local dy = math_abs(py2 - py)
        local sx = (px < px2) and 1 or -1
        local sy = (py < py2) and 1 or -1
        local err = dx - dy
        if width == -1 or width == 0 or width == 1 then
            local drawAllowed = false
            for _ = 1, maxLineSize do
                if check(px, py) then
                    setDot(px, py, col)
                    drawAllowed = true
                elseif drawAllowed then
                    break
                end
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        elseif width < 0 then
            width = math_ceil((-width) / 2)
            if width < 1 then
                width = 1
            end
            for _ = 1, maxLineSize do
                rasterize_circleF(px, py, width, col)
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        else
            local offsetFill = math_floor(width / 2)
            for _ = 1, maxLineSize do
                rasterize_fill(px - offsetFill, py - offsetFill, width, width, col)
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        end
    end

    ------------------------------------------

    local function render_fill(stack, offset)
        local col = stack[offset+4]
        if direct_fill then
            direct_fill(directArg, stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
        else
            rasterize_fill(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
        end
    end

    local function render_rect(stack, offset)
        local x, y, x2, y2, w, h = remathRect(offset, stack, maxX, maxY)
        if not x then return end
        local col = stack[offset+4]
        local lineWidth = stack[offset+5]
        if lineWidth == 1 then
            for ix = x, x2 do
                setDot(ix, y, col)
                setDot(ix, y2, col)
            end

            for iy = y + 1, y2 - 1 do
                setDot(x, iy, col)
                setDot(x2, iy, col)
            end
        else
            local _y, _y2, _x, _x2
            for ioff = 0, math_min(lineWidth, math_max(w, h) / 2) - 1 do
                _y = y + ioff
                _y2 = y2 - ioff
                for ix = x + ioff, x2 - ioff do
                    setDot(ix, _y, col)
                    setDot(ix, _y2, col)
                end

                _x = x + ioff
                _x2 = x2 - ioff
                for iy = y + 1 + ioff, y2 - (1 + ioff) do
                    setDot(_x, iy, col)
                    setDot(_x2, iy, col)
                end
            end
        end
    end

    local function render_text(stack, offset)
        local tx, ty = stack[offset], stack[offset+1]
        local text = stack[offset+2]
        local col = stack[offset+3]
        local scaleX = stack[offset+4]
        local scaleY = stack[offset+5]
        local spacing = stack[offset+6]
        local fontIndex = stack[offset+7]

        local localFont = currentFont
        local localFontWidth = fontWidth
        if fontIndex > 0 and fontsOptimized[fontIndex] then
            localFont = fontsOptimized[fontIndex]
            localFontWidth = localFont.width
        end

        local len, sep
        if utf8Support then
            len, sep = utf8_len, utf8_sub
        else
            len, sep = string_len, string_byte
        end
        local scaledFontWidth = math_ceil(localFontWidth * scaleX)
        if localFont.mono then
            for i = len(text), 1, -1 do
                local char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    local chrdata = localFont[char] or localFont.error or defaultError
                    local charOffset = (i - 1) * (scaledFontWidth + spacing)
                    for i2 = 1, #chrdata, 2 do
                        local px, py = chrdata[i2], chrdata[i2 + 1]
                        local lposX, lposY = round(px * scaleX), round(py * scaleY)
                        for ix = math_min(sizeX, round((px + 1) * scaleX) - lposX - 1), 0, -1 do
                            local setPosX = tx + ix + lposX + charOffset
                            for iy = math_min(sizeY, round((py + 1) * scaleY) - lposY - 1), 0, -1 do
                                checkSetDot(setPosX, ty + iy + lposY, col)
                            end
                        end
                    end
                end
            end
        else
            local charOffset = 0
            local startDrawTime = os_clock()
            for i = 1, len(text) do
                local char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    local chrdata = localFont[char] or localFont.error or defaultError
                    local charPos = tx + charOffset
                    if not chrdata[0] or charPos + round(chrdata[0] * scaleX) > 0 then
                        if charPos > maxX then
                            goto endDraw
                        end
                        for i2 = 1, #chrdata, 2 do
                            local px, py = chrdata[i2], chrdata[i2 + 1]
                            local lposX, lposY = round(px * scaleX), round(py * scaleY)
                            for ix = 0, math_min(sizeX, round((px + 1) * scaleX) - lposX - 1) do
                                local setPosX = tx + ix + lposX + charOffset
                                for iy = 0, math_min(sizeY, round((py + 1) * scaleY) - lposY - 1) do
                                    checkSetDot(setPosX, ty + iy + lposY, col)
                                end
                            end
                        end
                    end
                    charOffset = charOffset + (chrdata[0] and math_ceil(chrdata[0] * scaleX) or 0) + spacing
                else
                    charOffset = charOffset + (math_ceil(localFont.spaceSize * scaleX) or localFontWidth) + spacing
                end
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
        end
        ::endDraw::
    end

    local function render_line(stack, offset)
        rasterize_line(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4], stack[offset+5])
    end

    local function render_circle(stack, offset) --Michener’s Algorithm
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx, py + dy, col)
            checkSetDot(px + dy, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy, col)
            checkSetDot(px + dy, py - dx, col)
            checkSetDot(px + dx, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleE(stack, offset)
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx - 1, py + dy - 1, col)
            checkSetDot(px + dy - 1, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy - 1, col)
            checkSetDot(px + dy - 1, py - dx, col)
            checkSetDot(px + dx - 1, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleF(stack, offset)
        rasterize_circleF(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3])
    end

    local function render_circleVE(stack, offset) --drawCircleVeryEvenly
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local chr = e2*e2
        local col = stack[offset+3]
        local sx, sy, tempInt, tempBool

        e2 = math_min(e2, bigSide)
        for iy = 0, e2 do
            sy = iy + 0.5
            tempInt = stack[offset+4]
            for ix = e2, 0, -1 do
                sx = ix + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
        for ix = 0, e2 do
            sx = ix + 0.5
            tempInt = stack[offset+4]
            for iy = e2, 0, -1 do
                sy = iy + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
    end

    local function render_drawPoly(stack, offset, getFillInfo)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local startDrawTime = os_clock()
        local _px = stack[offset+3]
        local _py = stack[offset+4]
        local px, py
        local pointsPos
        if getFillInfo then
            pointsPos = {}

            local _setDot = setDot
            setDot = function(px, py, col)
                if not pointsPos[py] then
                    pointsPos[py] = {px, px}
                else
                    local data = pointsPos[py]
                    if px < data[1] then data[1] = px end
                    if px > data[2] then data[2] = px end
                end
            end
            
            for i = 3, points, 2 do
                px = stack[offset+2+i]
                py = stack[offset+3+i]
                rasterize_line(_px, _py, px, py, col, width)
                _px = px
                _py = py
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width)

            setDot = _setDot
        else
            for i = 3, points, 2 do
                px = stack[offset+2+i]
                py = stack[offset+3+i]
                rasterize_line(_px, _py, px, py, col, width)
                _px = px
                _py = py
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width)
        end
        
        ::endDraw::
        return points, pointsPos
    end

    local function render_fillPoly(stack, offset)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local gpoints = points
        for ii = 0, points / 2, 2 do
            local i = ii * 2
            local _, pointsPos = render_drawPoly({col, math_min(6, gpoints), width, stack[offset+3+i], stack[offset+4+i], stack[offset+5+i], stack[offset+6+i], stack[offset+7+i], stack[offset+8+i]}, 1, true)
            local startDrawTime = os_clock()
            for posY, v in pairs(pointsPos) do
                for i = v[1], v[2] do
                    setDot(i, posY, col)
                end

                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            gpoints = gpoints - 4
            if gpoints <= 0 then
                break
            end
        end

        ::endDraw::
        return points
    end

    local lastPixelX, lastPixelY, lastPixelColor
    function obj.pushStack(stack)
        local offset = 2
        local actionNum
        local addValue = 0
        local startDrawTime = os_clock()
        local idx
        while stack[offset] do
            actionNum = stack[offset-1]
            clearOnly = actionNum == 0
            addValue = 0

            if actionNum == 0 then
                newBufferBase = stack[offset]
                newBuffer = {}
                if direct_clear then
                    direct_clear(directArg, newBufferBase, changes)
                end
                updated = true
                clearBackplate = true
                if callback and newBufferBase ~= _oldBufferBase then
                    obj.fullRefresh()
                    _oldBufferBase = newBufferBase
                end
            elseif actionNum == resetViewportCodeID then
                viewportEnable = false
            elseif actionNum == -1 then
                viewportEnable = true
                viewport_x = stack[offset]
                viewport_y = stack[offset+1]
                viewport_sx = stack[offset+2]
                viewport_sy = stack[offset+3]
            elseif actionNum == 1 then
                setDot(stack[offset], stack[offset+1], stack[offset+2])
                updated = true
            elseif actionNum == 2 then
                render_fill(stack, offset)
                updated = true
            elseif actionNum == 3 then
                render_rect(stack, offset)
                updated = true
            elseif actionNum == 4 then
                render_text(stack, offset)
                updated = true
            elseif actionNum == 5 then
                render_line(stack, offset)
                updated = true
            elseif actionNum == 6 then
                render_circle(stack, offset)
                updated = true
            elseif actionNum == 8 then
                render_circleE(stack, offset)
                updated = true
            elseif actionNum == 7 then
                render_circleF(stack, offset)
                updated = true
            elseif actionNum == 9 then
                render_circleVE(stack, offset)
                updated = true
            elseif actionNum == 10 then
                addValue = render_drawPoly(stack, offset)
                updated = true
            elseif actionNum == 11 then
                addValue = render_fillPoly(stack, offset)
                updated = true
            elseif actionNum == 12 then
                for _ = 1, stack[offset] do
                    lastPixelX = lastPixelX + 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 13 then
                for _ = 1, stack[offset] do
                    lastPixelX = lastPixelX - 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 14 then
                for _ = 1, stack[offset] do
                    lastPixelY = lastPixelY + 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 15 then
                for _ = 1, stack[offset] do
                    lastPixelY = lastPixelY - 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 16 then
                idx = stack[offset]
                lastPixelX, lastPixelY, lastPixelColor = idx % rSizeX, math_floor(idx / rSizeX), stack[offset+1]
                setDot(lastPixelX, lastPixelY, lastPixelColor)
                updated = true
            elseif userCalls[actionNum] then
                if userCalls[actionNum](newBuffer, rotation, rSizeX, rSizeY, sizeX, sizeY, stack, offset, drawerData, bufferRangeUpdate, setDot, checkSetDot, rasterize_fill) then
                    updated = true
                end
            end

            if os_clock() - startDrawTime > MAX_DRAW_TIME then
                goto endDraw
            end

            offset = offset + dataSizes[actionNum] + addValue
        end

        ::endDraw::
    end

    function obj.flush(force)
        if not obj.wait and (updated or force) then
            if callbackBefore and callbackBefore(newBufferBase, clearOnly, maxBuffer, force, newBuffer, realBuffer, nil, nil, changes, changesIndex, changesCount, _changes, clearBackplate) then
                realBuffer = {}
            end

            if callback then
                --[[
                local color, px, py
                for i = bufferChangedFrom, bufferChangedTo do
                    color = newBuffer[i] or newBufferBase
                    if color ~= realBuffer[i] or force then
                        px = math_floor(i / rSizeY)
                        py = i % rSizeY
                        callback(px, py, color, newBufferBase)
                        realBuffer[i] = color
                    end
                end
                ]]

                local oldChanges
                if clearBackplate then
                    oldChanges = {}
                    for index in pairs(changes) do
                        oldChanges[index] = true
                    end

                    for index in pairs(_changes) do
                        if not changes[index] then
                            changesCount = changesCount + 1
                            changesIndex[changesCount] = index
                            changes[index] = true
                        end
                    end
                end
        
                for i2 = 1, changesCount do
                    local index = changesIndex[i2]
                    --if changes[index] then
                        callback(math_floor(index / sizeY), index % sizeY, newBuffer[index] or newBufferBase, newBufferBase)
                        _changes[index] = true
                    --end
                end

                if clearBackplate then
                    obj.setOldChanges(oldChanges)
                end
            end

            updated = false
            clearBackplate = false
            if updatedList then
                changes = {}
                changesIndex = {}
                changesCount = 0
            end
        end
    end

    function obj.setWait(state)
        obj.wait = state
        if not state then
            obj.flush()
        end
    end

    function obj.getNewBuffer(i)
        return newBuffer[i] or newBufferBase
    end

    function obj.getRealBuffer(i)
        return realBuffer[i]
    end

    function obj.getChanges()
        return changes
    end

    function obj.fullRefresh()
        changesCount = 0
        changesIndex = {}
        for i = 0, (sizeX * sizeY) - 1 do
            changes[i] = true
            changesCount = changesCount + 1
            changesIndex[changesCount] = i
        end
    end

    --[[
    function obj.flushOldChanges()
        _changes = changes
    end
    ]]

    function obj.setOldChanges(oldChanges)
        _changes = oldChanges
    end

    function obj.clearChangesBuffer()
        _changes = {}
        changes = {}
    end

    return obj
end

if better and better.isAvailable() and better.canvas and better.version >= 40 then
    local better_canvas_clear = better.canvas.clear
    local better_canvas_fill = better.canvas.fill
    local better_canvas_set = better.canvas.set

    function canvasAPI.createBetterCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation)
        local obj = {sizeX = sizeX, sizeY = sizeY}
        local maxX, maxY = sizeX - 1, sizeY - 1
        local maxEffectArrayBuffer = maxX + (maxY * sizeX)
        local dist
        local needOptimize = false
        local showState = false
        local disable = false
        local flushedDefault = false

        local betterCanvas = better.canvas.create(sizeX, sizeY)

        local drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, nil, betterCanvas, better_canvas_clear, better_canvas_fill, better_canvas_set)
        drawer.setWait(true)

        local defaultPosition = vec3_new(0, 0, 0)
        local function getSelfPos()
            local pt = type(parent)
            if pt == "Interactable" then
                return parent.shape.worldPosition
            elseif pt == "Character" then
                return parent.worldPosition
            end
            return defaultPosition
        end

        function obj.isRendering()
            return showState
        end

        function obj.disable(state)
            disable = state
        end

        function obj.setRenderDistance(_dist)
            dist = _dist
        end

        function obj.update()
            local newShowState = true
            local selfPosition
            if disable then
                newShowState = false
            elseif dist then
                if not pcall(function()
                    selfPosition = getSelfPos()
                    newShowState = mathDist(selfPosition, sm_localPlayer_getPlayer().character.worldPosition) <= dist
                end) then
                    selfPosition = selfPosition or vec3_new(0, 0, 0)
                    newShowState = false
                end
            end

            if newShowState ~= showState then
                showState = newShowState
                if newShowState then
                    drawer.setWait(false)
                    if not flushedDefault then
                        drawer.flush(true)
                        flushedDefault = true
                    end
                else
                    drawer.setWait(true)
                    better.canvas.stopUpdate(betterCanvas)
                end
            end

            if newShowState then
                better.canvas.update_3d(betterCanvas, selfPosition + (rotation * offset), -sm.quat.getRight(rotation), -sm.quat.getUp(rotation), (pixelSize.x * sizeX) / 2, (pixelSize.y * sizeY) / 2)
            end
        end

        function obj.setPixelSize(_pixelSize)
            pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
            if type(pixelSize) == "number" then
                if pixelSize < 0 then
                    pixelSize = math_abs(pixelSize)
                    local vec = vec3_new(pixelSize, pixelSize, 0)
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                else
                    local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                end
            end
        end

        function obj.setOffset(_offset)
            offset = _offset
        end

        function obj.setCanvasRotation(_rotation)
            rotation = _rotation
        end

        function obj.destroy()
            better.canvas.destroy(betterCanvas)
        end

        ---------------------------------------

        obj.setPixelSize(pixelSize)
        obj.setCanvasRotation(rotation or quat_fromEuler(vec3_new(0, 0, 0)))
        obj.setOffset(offset or vec3_new(0, 0, 0))

        --[[
        local c = 0xff0000
        local seffect = createEffect(5, 5, 16, 16, c)
        local idx = 5 + (5 * sizeX)
        for i = 0, 16 - 1 do
            effects[idx + i] = {
                seffect,
                c,
                i,
                16,
                idx,
                5,
                5,
                1, --8. sizeY
                0 --9. indexY
            }
        end
        ]]

        ---------------------------------------

        obj.drawer = drawer
        for k, v in pairs(drawer) do
            obj[k] = v
        end

        return obj
    end
end

--low level display api
function canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material, scaleAddValue, altFromEuler, autoLayerDistance)
    local hiddenOffset = vec3_new(1000000, 1000000, 1000000)
    local defaultSizeX, defaultSizeY = sizeX, sizeY
    local pixelScaleX, pixelScaleY = 1, 1
    local obj = {sizeX = sizeX, sizeY = sizeY}
    local maxX, maxY = sizeX - 1, sizeY - 1
    local maxEffectArrayBuffer = maxX + (maxY * sizeX)
    local dist
    local needOptimize = false
    local skipOptimize = false
    local showState = false
    local disable = false

    local _setPosition, _setRotation
    if parent then
        _setPosition, _setRotation = effect_setOffsetPosition, effect_setOffsetRotation
    else
        _setPosition, _setRotation = effect_setPosition, effect_setRotation
    end

    material = material or canvasAPI.material.classic
    local autoScaleAddValue = false
    if not scaleAddValue then
        autoScaleAddValue = true
    end

    local flushedDefault = false
    local oldBackplateColor
    local backplate
    if canvasAPI.multi_layer[tostring(material)] then
        oldBackplateColor = 0
        backplate = sm_effect_createEffect(getEffectName(), parent)
        effect_setParameter(backplate, "uuid", material)
        effect_setParameter(backplate, "color", black)
    end

    local additionalLayer
    local function updateAdditionalLayer()
        if material == canvasAPI.material.smoothed then
            if not additionalLayer then
                additionalLayer = sm_effect_createEffect(getEffectName(), parent)
                effect_setParameter(additionalLayer, "uuid", canvasAPI.material.glass)
                effect_setParameter(additionalLayer, "color", black)
                effect_start(additionalLayer)
                return true
            end
        elseif additionalLayer then
            effect_destroy(additionalLayer)
            additionalLayer = nil
        end
    end
    updateAdditionalLayer()

    local layerDistance
    local function updateLayerDistance(distance)
        layerDistance = math.max(0.001, autoLayerDistance and distance or 0)
    end
    updateLayerDistance()

    local effects = {}
    local nodeEffects = {}
    local effectDatas = {}
    local effectDataLen = 5

    local bufferedEffectsUpdateTime = {}
    local bufferedEffects = {}
    local bufferedEffectsIndex = 0
    local lastDrawTickTime
    local optimizationLevel = 16
    local optimizationValue = optimizationLevelToValue(optimizationLevel)
    local alpha = DEFAULT_ALPHA_VALUE

    local oldHardwareParams = {
        offset_x = 0,
        offset_y = 0,
        offset_z = 0,
        
        rotation_x = 0,
        rotation_y = 0,
        rotation_z = 0,

        scale_x = 1,
        scale_y = 1
    }

    local function getEIndex(index)
        return index * effectDataLen
    end

    local function fromEIndex(index)
        return index / effectDataLen
    end

    local function setEffectDataParams(index)
        local effect = nodeEffects[index]
        local eindex = getEIndex(index)
        local posX, posY, lSizeX, lSizeY = effectDatas[eindex+1], effectDatas[eindex+2], effectDatas[eindex+3], effectDatas[eindex+4]

        posX = posX + ((lSizeX - 1) * 0.5)
        posY = posY + ((lSizeY - 1) * 0.5)
        _setPosition(effect, rotation * (offset + vec3_new(((posX + 0.5) - (sizeX / 2)) * pixelSize.x, ((posY + 0.5) - (sizeY / 2)) * -pixelSize.y, backplate and (debugMode and 0.05 or layerDistance) or 0)))

        local localScaleAddValue = debugMode and -(pixelSize.x / 2) or scaleAddValue
        local vec = pixelSize * 1
        vec.x = (pixelSize.x * lSizeX) + localScaleAddValue
        vec.y = (pixelSize.y * lSizeY) + localScaleAddValue
        effect_setScale(effect, vec)

        effect_setParameter(effect, "color", color_new_fromSmallNumber(effectDatas[eindex], alpha))
    end

    local function createEffect()
        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            _setRotation(effect, rotation)
        end
        return effect
    end

    local function createEffectUnhide(hideList)
        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            hideList[effect] = nil
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            _setRotation(effect, rotation)
        end
        return effect
    end

    local function clearBufferedEffects()
        for i = 1, bufferedEffectsIndex do
            effect_destroy(bufferedEffects[i])
        end
        bufferedEffectsUpdateTime = {}
        bufferedEffects = {}
        bufferedEffectsIndex = 0
    end

    local lastNewBuffer, lastBase

    local lastPopularColor
    local function mathPopularColor()
        local colorUsesTable = {}
        local colorUses = 0
        local oldColorUses = 0
        local colorSum = 0
        for index in pairs(nodeEffects) do
            local eindex = getEIndex(index)
            local color = effectDatas[eindex]
            local colorSize = effectDatas[eindex+3] * effectDatas[eindex+4]
            colorUsesTable[color] = (colorUsesTable[color] or 0) + colorSize
            colorSum = colorSum + colorSize
            colorUses = colorUsesTable[color]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = color
            end
        end

        if oldBackplateColor then
            local colorSize = (sizeX * sizeY) - colorSum
            colorUsesTable[oldBackplateColor] = (colorUsesTable[oldBackplateColor] or 0) + colorSize
            colorUses = colorUsesTable[oldBackplateColor]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = oldBackplateColor
            end
        end
    end

    local function effectIndexAtPos(px, py)
        return py + (px * sizeY)
    end

    local function getRootEIndexAtPos(px, py)
        if py < 0 or py >= sizeY then return end
        local index = effects[effectIndexAtPos(px, py)]
        return index and getEIndex(index), index
    end

    local function clearEffectFromBuffer(index)
        local eindex = getEIndex(index)
        local six, ix, iy = effectDatas[eindex+1], effectDatas[eindex+1], effectDatas[eindex+2]
        local sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        nodeEffects[index] = nil
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix >= six + sizeX then
                ix = six
                iy = iy + 1
            end
        end
    end

    local function hideEffect(effect)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        bufferedEffectsUpdateTime[bufferedEffectsIndex] = game_getCurrentTick()
        _setPosition(effect, hiddenOffset)
    end

    local function hideEffectData(index)
        hideEffect(nodeEffects[index])
        clearEffectFromBuffer(index)
    end

    local function hideEffectLater(effect, hideList)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        bufferedEffectsUpdateTime[bufferedEffectsIndex] = game_getCurrentTick()
        hideList[effect] = true
        --_setPosition(effect, hiddenOffset)
    end

    local function hideEffectDataLater(index, hideList)
        hideEffectLater(nodeEffects[index], hideList)
        clearEffectFromBuffer(index)
    end    
    
    local function hideEffectsWithColor(color)
        for index in pairs(nodeEffects) do
            if effectDatas[getEIndex(index)] == color then
                hideEffectData(index)
            end
        end
    end

    local function delAllEffects()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        effects = {}
        nodeEffects = {}
    end

    --[[
    local function forceRecreateNodeEffects()
        nodeEffects = {}
        for i, effectData in pairs(effects) do
            if effectData[7] == i then
                nodeEffects[i] = effectData
            end
        end
    end
    ]]

    --local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
    local function colorEquals_smart(color1, color2)
        if color1 == color2 then return true end
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        --return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
        return ((math_abs(rVal - rVal2) + math_abs(gVal - gVal2) + math_abs(bVal - bVal2)) / 1024) <= optimizationValue
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    local function getFillZone(eindex)
        local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
        return fillX1, fillY1, fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
    end

    local sumAttachTime = 0
    local sumAttachFillTime = 0
    local function tryLongAttach(changedList, hideList, index, px, py, color, sizeX, sizeY)
        local startTime = os_clock()

        --[[
        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        local origEffect
        if origIndex then
            origEffect = nodeEffects[origIndex]
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end
        ]]

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local downParentE, downParent = getRootEIndexAtPos(px, py + sizeY)
        local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)
        local downAvailable = downParentE and nodeEffects[downParent] and effectDatas[downParentE+1] == px and effectDatas[downParentE+3] == sizeX and colorEquals(effectDatas[downParentE], color)

        local fillOptional = false
        local fillX1, fillY1, fillX2, fillY2
        local fill2X1, fill2Y1, fill2X2, fill2Y2

        --[[
        if origEffect and (upAvailable or downAvailable) then
            hideEffectLater(origEffect, hideList)
            changedList[origIndex] = nil
            changedColorList[origIndex] = nil
            nodeEffects[origIndex] = nil
        end
        ]]

        local newIndex, newEIndex
        local fillVal
        if upAvailable and downAvailable then
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

            local addSizeY = sizeY + effectDatas[downParentE+4]

            hideEffectLater(nodeEffects[downParent], hideList)
            changedList[downParent] = nil
            --changedColorList[downParent] = nil
            nodeEffects[downParent] = nil

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + addSizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
        elseif upAvailable then
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
        elseif downAvailable then
            fillOptional = true
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

            changedList[downParent] = nil
           --changedColorList[downParent] = nil

            nodeEffects[index] = nodeEffects[downParent]
            nodeEffects[downParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[downParentE]
            effectDatas[eindex+1] = effectDatas[downParentE+1]
            effectDatas[eindex+2] = py
            effectDatas[eindex+3] = effectDatas[downParentE+3]
            effectDatas[eindex+4] = effectDatas[downParentE+4] + sizeY
            
            newIndex, newEIndex = index, eindex
            fillVal = index
        end

        if fillVal then
            index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
            sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
        end

        local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
        local rightParentE, rightParent = getRootEIndexAtPos(px + sizeX, py)
        local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
        local rightAvailable = rightParentE and nodeEffects[rightParent] and effectDatas[rightParentE+2] == py and effectDatas[rightParentE+4] == sizeY and colorEquals(effectDatas[rightParentE], color)

        if nodeEffects[index] and (leftAvailable or rightAvailable) then
            hideEffectLater(nodeEffects[index], hideList)
            changedList[index] = nil
            --changedColorList[index] = nil
            nodeEffects[index] = nil
        end

        if leftAvailable and rightAvailable then
            fillOptional = false
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

            local addSizeX = sizeX + effectDatas[rightParentE+3]

            hideEffectLater(nodeEffects[rightParent], hideList)
            changedList[rightParent] = nil
            --changedColorList[rightParent] = nil
            nodeEffects[rightParent] = nil

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + addSizeX
            fillVal = leftParent
        elseif leftAvailable then
            fillOptional = false
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = nil, nil, nil, nil

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
            fillVal = leftParent
        elseif rightAvailable then
            fillOptional = not upAvailable and not downAvailable
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

            changedList[rightParent] = nil
            --changedColorList[rightParent] = nil

            nodeEffects[index] = nodeEffects[rightParent]
            nodeEffects[rightParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[rightParentE]
            effectDatas[eindex+1] = px
            effectDatas[eindex+2] = effectDatas[rightParentE+2]
            effectDatas[eindex+3] = sizeX + effectDatas[rightParentE+3]
            effectDatas[eindex+4] = effectDatas[rightParentE+4]
            
            fillVal = index
        end

        sumAttachTime = sumAttachTime + (os_clock() - startTime)

        if fillVal then
            changedList[fillVal] = true
            --changedColorList[fillVal] = true

            --[[
            local eindex = getEIndex(fillVal)
            local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
            local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = fillVal
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            ]]

            startTime = os_clock()

            --fillOptional = false
            --if not fillOptional or not origEffect then
                local ix, iy = fillX1, fillY1
                for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = fillVal
                    ix = ix + 1
                    if ix > fillX2 then
                        ix = fillX1
                        iy = iy + 1
                    end
                end
            --[[else
                local ix, iy = fillX1, fillY1
                for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                    if fillVal ~= effects[effectIndexAtPos(ix, iy)] then
                        print("WTTT", fillVal, effects[effectIndexAtPos(ix, iy)])
                    end
                    ix = ix + 1
                    if ix > fillX2 then
                        ix = fillX1
                        iy = iy + 1
                    end
                end
                ]]
            --end

            if fill2X1 then
                local ix, iy = fill2X1, fill2Y1
                for _ = 1, ((fill2X2 - fill2X1) + 1) * ((fill2Y2 - fill2Y1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = fillVal
                    ix = ix + 1
                    if ix > fill2X2 then
                        ix = fill2X1
                        iy = iy + 1
                    end
                end
            end

            sumAttachFillTime = sumAttachFillTime + (os_clock() - startTime)

            --fillVal = tryAttach(changedList, changedColorList, index, px, py, color) or fillVal
        end

        return fillVal
    end

    local function tryAttach(changedList, hideList, index, px, py, color, sizeX, sizeY)
        local startTime = os_clock()

        --[[
        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        local origEffect
        if origIndex then
            origEffect = nodeEffects[origIndex]
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end
        ]]

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)

        local fillX1, fillY1, fillX2, fillY2
        local newIndex, newEIndex, fillVal
        if upAvailable then
            --[[
            if origEffect then
                hideEffectLater(origEffect, hideList)
                changedList[origIndex] = nil
                changedColorList[origIndex] = nil
                nodeEffects[origIndex] = nil
            end
            ]]

            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent

            index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
            sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
        end

        local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
        local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
        if leftAvailable then
            if nodeEffects[index] then
                hideEffectLater(nodeEffects[index], hideList)
                changedList[index] = nil
                --changedColorList[index] = nil
                nodeEffects[index] = nil
            end

            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
            fillVal = leftParent
        end

        sumAttachTime = sumAttachTime + (os_clock() - startTime)

        if fillVal then
            changedList[fillVal] = true
            --changedColorList[fillVal] = true

            startTime = os_clock()
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = fillVal
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            sumAttachFillTime = sumAttachFillTime + (os_clock() - startTime)
        end

        return fillVal
    end

    local sumFillTime = 0
    local function fillBlock(x, y, sx, sy, changedList, hideList, color, iterate, effect)
        if sx <= 0 or sy <= 0 then
            return
        end

        local newRIndex = effectIndexAtPos(x, y)
        nodeEffects[newRIndex] = effect or createEffectUnhide(hideList)
        changedList[newRIndex] = true
        --changedColorList[newRIndex] = true

        local newEIndex = getEIndex(newRIndex)
        effectDatas[newEIndex] = color
        effectDatas[newEIndex+1] = x
        effectDatas[newEIndex+2] = y
        effectDatas[newEIndex+3] = sx
        effectDatas[newEIndex+4] = sy

        if not iterate then
            return true
        end
        
        local startTime = os_clock()
        local ix, iy = x, y
        local six = ix
        local mix = six + sx
        for _ = 1, sx * sy do
            effects[effectIndexAtPos(ix, iy)] = newRIndex
            ix = ix + 1
            if ix >= mix then
                ix = six
                iy = iy + 1
            end
        end
        sumFillTime = sumFillTime + (os_clock() - startTime)

        return true
    end

    local sumExtractTime = 0
    local function extractPixel(changedList, hideList, index, px, py, sizeX, sizeY)
        local startTime = os_clock()

        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local lx = px - rpx
        local ly = py - rpy

        local effect = nodeEffects[rindex]
        changedList[rindex] = nil
        --changedColorList[rindex] = nil
        nodeEffects[rindex] = nil

        local color = effectDatas[eindex]
        --local block1, block2, block3, block4 = false, false, false, false
        if fillBlock(rpx, rpy, lx, rsy, changedList, hideList, color, false, effect) then --[[block1 = true]] effect = nil end
        if fillBlock(rpx + lx + sizeX, rpy, rsx - lx - sizeX, rsy, changedList, hideList, color, true, effect) then --[[block2 = true]] effect = nil end
        if fillBlock(rpx + lx, rpy, sizeX, ly, changedList, hideList, color, true, effect) then --[[block3 = true]] effect = nil end
        if fillBlock(rpx + lx, rpy + ly + sizeY, sizeX, rsy - ly - sizeY, changedList, hideList, color, true, effect) then --[[block4 = true]] effect = nil end

        local ix, iy, endX = px, py, px + (sizeX - 1)
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix > endX then
                ix = px
                iy = iy + 1
            end
        end

        if effect then
            hideEffectLater(effect, hideList)
        end

        sumExtractTime = sumExtractTime + (os_clock() - startTime)

        --if block1 then tryAttach(changedList, changedColorList, effectIndexAtPos(rpx, rpy), rpx, rpy, color) end
        --if block2 then tryAttach(changedList, changedColorList, effectIndexAtPos(block2X, rpy), block2X, rpy, color) end
        --if block3 then tryAttach(changedList, changedColorList, effectIndexAtPos(block3X, rpy), block3X, rpy, color) end
        --if block4 then tryAttach(changedList, changedColorList, effectIndexAtPos(block4X, block4Y), block4X, block4Y, color) end
    end

    --[[
    local function extractXLine(changedList, changedColorList, hideList, index, px, py)
        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local ly = py - rpy

        local effect = nodeEffects[rindex]
        changedList[rindex] = nil
        changedColorList[rindex] = nil
        nodeEffects[rindex] = nil
        effects[index] = nil

        local color = effectDatas[eindex]
        if fillBlock(rpx, rpy, rsx, ly, changedList, changedColorList, hideList, color, false, effect) then effect = nil end
        if fillBlock(rpx, rpy + ly + 1, rsx, rsy - ly - 1, changedList, changedColorList, hideList, color, true, effect) then effect = nil end

        if effect then
            hideEffectLater(effect, hideList)
        end
    end
    ]]

    local function fillEffectsLinks(index, px, py, sizeX, sizeY)
        local ix, iy, endX = px, py, px + (sizeX - 1)
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = index
            ix = ix + 1
            if ix > endX then
                ix = px
                iy = iy + 1
            end
        end
    end

    --[[
    local sumIsFullChangeTime = 0
    local function isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, forDestroy)
        local effectID = nodeEffects[rindex].id
        if fullChecked[effectID] then
            return false
        end
        fullChecked[effectID] = true


        local startTime = os_clock()

        local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
        local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
        local baseColor = lastNewBuffer[effectIndexAtPos(fillX1, fillY1)] or lastBase

        local ix, iy = fillX1 + 1, fillY1
        if ix > fillX2 then
            ix = fillX1
            iy = iy + 1
        end
        for _ = 2, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
            local color = lastNewBuffer[effectIndexAtPos(ix, iy)] or lastBase
            if color ~= baseColor then
                sumIsFullChangeTime = sumIsFullChangeTime + (os_clock() - startTime)
                return false
            end
            ix = ix + 1
            if ix > fillX2 then
                ix = fillX1
                iy = iy + 1
            end
        end

        ix, iy = fillX1, fillY1
        if not forDestroy then
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                local index = effectIndexAtPos(ix, iy)
                _changes[index] = true
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
        end

        sumIsFullChangeTime = sumIsFullChangeTime + (os_clock() - startTime)
        return true
    end
    ]]

    --[[
    local function getBlockSize(rindex, index, px, py, color)
        local sizeX = 1
        --local sizeY = 1
        --[[
        for i = 1, maxY - py do
            if rindex ~= effects[index+i] or (lastNewBuffer[index+i] or lastBase) ~= color then
                break
            end
            sizeY = sizeY + 1
        end
        ] ]
        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
                --sizeY = sizeY + 1
            end
        end

        --[[
        for iy = 1, maxY - py do
            local multibrake = false
            for ix = 0, sizeX - 1 do
                local lindex = effectIndexAtPos(px+ix, py+iy)
                if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                    multibrake = true
                    break
                end
            end
            if multibrake then
                break
            end
            sizeY = sizeY + 1
        end
        ] ]

        return sizeX, iy
    end
    ]]

    local function getBlockSize(index, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local function getBlockSizeOptimization(index, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if effects[lindex] or not lastNewBuffer[lindex] or not colorEquals(lastNewBuffer[lindex], color) then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if effects[lindex] or not lastNewBuffer[lindex] or not colorEquals(lastNewBuffer[lindex], color) then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local function getChangesBlockSize(rindex, index, changes, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if rindex ~= effects[lindex] or not changes[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if rindex ~= effects[lindex] or not changes[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local _oldVirtualBackplateColor
    local drawer
    local lastDrawWithClear = true
    drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, function (base, clearOnly, maxBuffer, force, newBuffer, realBuffer, _, _, changes, changesIndex, changesCount, _changes, clearBackplate)
        lastNewBuffer, lastBase = newBuffer, base
        lastDrawWithClear = clearBackplate

        if clearOnly and backplate then
            clearBufferedEffects()
            drawer.clearChangesBuffer()
            delAllEffects()
            return
        end

        local changedList = {}
        --local changedColorList = {}
        local hideList = {}
        --local fullChecked = {}

        --print("changesCount 1", changesCount)

        local oldChanges
        if clearBackplate then
            local startTime = os_clock()

            oldChanges = {}
            for index in pairs(changes) do
                oldChanges[index] = true
            end

            for index in pairs(_changes) do
                if not changes[index] then
                    changesCount = changesCount + 1
                    changesIndex[changesCount] = index
                    changes[index] = true
                end
            end

            profiller("clear-loop", startTime)
        end

        --[[
        local _changesSize = 0
        for k, v in pairs(_changes) do
            _changesSize = _changesSize + 1
        end
        print(tostring(_changes), _changesSize)
        ]]

        --print("changesCount 2", changesCount)

        --[[
        local startTime = os_clock()
        table_sort(changesIndex, function (a, b)
            return a < b
        end)
        profiller("stack-sort", startTime)
        ]]

        --[[
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex then
                local eindex = getEIndex(rindex)
                if not colorEquals(effectDatas[eindex], color) then
                    local px = math_floor(index / sizeY)
                    local py = index % sizeY
                    local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
                    local backplateColor = color == oldBackplateColor
                    if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, backplateColor) then
                        if backplateColor then
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        elseif not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        end
                    elseif backplateColor then
                        if aSizeX or aSizeY then
                            extractPixel(changedList, changedColorList, hideList, index, px, py)
                        else
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        end
                    else
                        _changes[index] = true

                        if aSizeX or aSizeY then
                            extractPixel(changedList, changedColorList, hideList, index, px, py)
                        end

                        if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                            local eindex = getEIndex(index)

                            if not nodeEffects[index] then
                                local effect = createEffectUnhide(hideList)

                                local bSizeX, bSizeY = 1, 1
                                effectDatas[eindex+1] = px
                                effectDatas[eindex+2] = py
                                effectDatas[eindex+3] = bSizeX
                                effectDatas[eindex+4] = bSizeY
                                fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                
                                nodeEffects[index] = effect
                                changedList[index] = true
                            end

                            effectDatas[eindex] = color
                            changedColorList[index] = true
                        end
                    end
                end
            elseif color ~= oldBackplateColor then
                _changes[index] = true
                local px = math_floor(index / sizeY)
                local py = index % sizeY
                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect

                    local eindex = getEIndex(index)
                    local bSizeX, bSizeY = getBlockSize(index, px, py)
                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = bSizeX
                    effectDatas[eindex+4] = bSizeY
                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                    
                    changedList[index] = true
                    changedColorList[index] = true
                end
            end
        end
        profiller("change-loop", startTime)
        ]]

        --local localEffectsBlacklist = {}

        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex --[[and not localEffectsBlacklist[rindex] ]] then
                local eindex = getEIndex(rindex)
                --local isBackgroundColor = color == oldBackplateColor
                --if color == oldBackplateColor or not colorEquals(effectDatas[eindex], color) then
                if effectDatas[eindex] ~= color then
                    --local px = math_floor(index / sizeY)
                    --local py = index % sizeY
                    --local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
                    --[[if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, backplateColor) then
                        if backplateColor then
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        else
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        end
                    else]]
                    
                    --local aSizeX, aSizeY = effectDatas[eindex+3], effectDatas[eindex+4]
                    if effectDatas[eindex+3] > 1 or effectDatas[eindex+4] > 1 then
                        local px = math_floor(index / sizeY)
                        local py = index % sizeY
                        --local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                        --extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)
                        extractPixel(changedList, hideList, index, px, py, getChangesBlockSize(rindex, index, changes, px, py, color))

                        --[[
                        local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                        if aSizeX == bSizeX and aSizeY == bSizeY then
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        else
                            extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)
                        end
                        ]]

                        --[[
                        if not isBackgroundColor then
                            if not tryAttach(changedList, changedColorList, hideList, index, px, py, color, bSizeX, bSizeY) then
                                local effect = createEffectUnhide(hideList)

                                nodeEffects[index] = effect

                                local eindex = getEIndex(index)
                                effectDatas[eindex] = color
                                effectDatas[eindex+1] = px
                                effectDatas[eindex+2] = py
                                effectDatas[eindex+3] = bSizeX
                                effectDatas[eindex+4] = bSizeY
                                fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                
                                changedList[index] = true
                                changedColorList[index] = true
                                localEffectsBlacklist[index] = true
                            end
                        end
                        ]]
                    else
                        changedList[rindex] = nil
                        --changedColorList[rindex] = nil
                        hideEffectDataLater(rindex, hideList)
                    end
                end
            end
        end
        profiller("extract-loop", startTime)

        --local blockSizeCache = {}
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            if color ~= oldBackplateColor then
                _changes[index] = true

                if not effects[index] then
                    local px = math_floor(index / sizeY)
                    local py = index % sizeY

                    if not tryLongAttach(changedList, hideList, index, px, py, color, 1, 1) then
                        --[[
                        local blockSize
                        if blockSizeCache[index] then
                            blockSize = blockSizeCache[index]
                            print("LOAD", index, blockSize)
                        else
                            blockSize = {getBlockSize(index, px, py, color)}
                            blockSizeCache[index] = blockSize
                        end
                        ]]

                        local bSizeX, bSizeY = getBlockSize(index, px, py, color)
                        if not tryLongAttach(changedList, hideList, index, px, py, color, bSizeX, bSizeY) then
                            local effect = createEffectUnhide(hideList)

                            nodeEffects[index] = effect

                            local eindex = getEIndex(index)
                            effectDatas[eindex] = color
                            effectDatas[eindex+1] = px
                            effectDatas[eindex+2] = py
                            effectDatas[eindex+3] = bSizeX
                            effectDatas[eindex+4] = bSizeY
                            fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                            
                            changedList[index] = true
                            --changedColorList[index] = true
                        end

                        --[[
                        local effect = createEffectUnhide(hideList)

                        nodeEffects[index] = effect
                        effects[index] = index

                        local eindex = getEIndex(index)
                        effectDatas[eindex] = color
                        effectDatas[eindex+1] = px
                        effectDatas[eindex+2] = py
                        effectDatas[eindex+3] = 1
                        effectDatas[eindex+4] = 1
                        
                        changedList[index] = true
                        ]]
                    end
                end
            end
        end
        profiller("add-loop", startTime)

        --[[
        local localEffectsBlacklist = {}
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex then
                if not localEffectsBlacklist[rindex] then
                    local eindex = getEIndex(rindex)
                    local isBackgroundColor = color == oldBackplateColor
                    if isBackgroundColor or not colorEquals(effectDatas[eindex], color) then
                        if effectDatas[eindex+3] > 1 or effectDatas[eindex+4] > 1 then
                            local px = math_floor(index / sizeY)
                            local py = index % sizeY
                            local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                            extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)

                            if not isBackgroundColor then
                                _changes[index] = true

                                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                                    local effect = createEffectUnhide(hideList)

                                    nodeEffects[index] = effect

                                    local eindex = getEIndex(index)
                                    effectDatas[eindex] = color
                                    effectDatas[eindex+1] = px
                                    effectDatas[eindex+2] = py
                                    effectDatas[eindex+3] = bSizeX
                                    effectDatas[eindex+4] = bSizeY
                                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                    
                                    changedList[index] = true
                                    changedColorList[index] = true
                                    localEffectsBlacklist[index] = true
                                end
                            end
                        elseif not isBackgroundColor then
                            _changes[index] = true

                            local px = math_floor(index / sizeY)
                            local py = index % sizeY
                            if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                                effectDatas[eindex] = color
                                changedColorList[rindex] = true
                            end
                        else
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        end
                    end
                end
            elseif color ~= oldBackplateColor then
                _changes[index] = true

                local px = math_floor(index / sizeY)
                local py = index % sizeY
                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect

                    local eindex = getEIndex(index)
                    local bSizeX, bSizeY = getBlockSize(nil, index, px, py, color)
                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = bSizeX
                    effectDatas[eindex+4] = bSizeY
                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                    
                    changedList[index] = true
                    changedColorList[index] = true
                    localEffectsBlacklist[index] = true
                end
            end
        end
        profiller("change-loop", startTime)
        ]]

        local contentUpdated = false

        startTime = os_clock()
        for index in pairs(changedList) do
            setEffectDataParams(index)
            contentUpdated = true
        end
        profiller("apply-params", startTime)

        --[[
        startTime = os_clock()
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            if not colorCache[color] then
                colorCache[color] = color_new_fromSmallNumber(color, alpha)
            end
            effect_setParameter(nodeEffects[index], "color", colorCache[color])
        end
        profiller("apply-colors", startTime)
        ]]
        --[[
        startTime = os_clock()
        local colorobj = color_new(0)
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            colorobj.r, colorobj.g, colorobj.b = hexToRGB(color)
            colorobj.a = alpha / 255
            effect_setParameter(nodeEffects[index], "color", colorobj)
            contentUpdated = true
        end
        profiller("apply-colors", startTime)
        ]]

        startTime = os_clock()
        for effect in pairs(hideList) do
            _setPosition(effect, hiddenOffset)
        end
        profiller("later-hide", startTime)

        profillerPrint("fill-sum", sumFillTime)
        profillerPrint("extract-sum", sumExtractTime)
        profillerPrint("attach-sum", sumAttachTime)
        profillerPrint("attach-fill-sum", sumAttachFillTime)
        --profillerPrint("isFullChange-sum", sumIsFullChangeTime)
        --sumIsFullChangeTime = 0
        sumFillTime = 0
        sumExtractTime = 0
        sumAttachTime = 0
        sumAttachFillTime = 0
        
        if clearBackplate then
            drawer.setOldChanges(oldChanges)
            --clearBackplate = false
        end

        if clearOnly then
            clearBufferedEffects()
            return
        end

        if contentUpdated then
            lastDrawTickTime = game_getCurrentTick()
            needOptimize = true
        end
    end, nil, function (_, color, changes)
        if backplate then
            oldBackplateColor = color
            effect_setParameter(backplate, "color", color_new_fromSmallNumber(color, alpha))
        elseif color ~= _oldVirtualBackplateColor then
            drawer.fullRefresh()
            _oldVirtualBackplateColor = color
        end
    end, nil, nil, true)

    if not backplate then
        drawer.fullRefresh()
    end

    local canvasWait
    local wait_dataTunnel
    local function _setWait(wait)
        canvasWait = wait
        drawer.setWait(wait)
        if not wait and wait_dataTunnel then
            obj.realPushDataTunnelParams(wait_dataTunnel)
            wait_dataTunnel = nil
        end
    end

    _setWait(true)

    local function recreateCanvas()
        if not lastNewBuffer then
            return
        end

        if backplate and not lastDrawWithClear then --WHAT? (fixed)
            mathPopularColor()
            if lastPopularColor ~= oldBackplateColor then
                effect_setParameter(backplate, "color", color_new_fromSmallNumber(lastPopularColor, alpha))
                oldBackplateColor = lastPopularColor
                drawer.fullRefresh()
            end
        end
        
        local hideList = {}
        for i, effect in pairs(nodeEffects) do
            hideEffectLater(effect, hideList)
        end
        effects = {}
        nodeEffects = {}
        effectDatas = {}

        local changedList = {}
        --local changedColorList = {}

        --local startTime = os.clock()
        local index = 0
        while index <= maxEffectArrayBuffer do
            local px = math_floor(index / sizeY)
            local py = index % sizeY
            local color = lastNewBuffer[index] or lastBase
            if effects[index] then
                index = index + effectDatas[getEIndex(effects[index])+4]
            elseif color ~= oldBackplateColor then
                local eindex = getEIndex(index)

                --[[
                local newRootIndex = tryAttach(changedList, hideList, index, px, py, color, 1, 1)
                if newRootIndex then
                    local newRootEIndex = getEIndex(newRootIndex)
                    index = effectIndexAtPos(px, effectDatas[newRootEIndex+2] + effectDatas[newRootEIndex+4])
                else
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect
                    effects[index] = index

                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = 1
                    effectDatas[eindex+4] = 1
                    
                    changedList[index] = true
                    --changedColorList[index] = true
                    index = index + 1
                end
                ]]

                local bSizeX, bSizeY = getBlockSizeOptimization(index, px, py, color)
                local effect = createEffectUnhide(hideList)

                nodeEffects[index] = effect
                effectDatas[eindex] = color
                effectDatas[eindex+1] = px
                effectDatas[eindex+2] = py
                effectDatas[eindex+3] = bSizeX
                effectDatas[eindex+4] = bSizeY
                fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                
                changedList[index] = true
                index = index + bSizeY
            else
                index = index + 1
            end
        end
        --print("recreate-loop time:", os.clock() - startTime)

        for index in pairs(changedList) do
            setEffectDataParams(index)
        end

        --[[
        local colorobj = color_new(0)
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            colorobj.r, colorobj.g, colorobj.b = hexToRGB(color)
            colorobj.a = alpha / 255
            effect_setParameter(nodeEffects[index], "color", colorobj)
        end
        ]]

        for effect in pairs(hideList) do
            _setPosition(effect, hiddenOffset)
        end
    end

    local _s_pixelSize, _s_offset, _s_rotation
    function obj.setCanvasMaterial(_material)
        material = _material
        local newBackplateExists = not not canvasAPI.multi_layer[tostring(material)]
        local oldBackplateExists = not not backplate

        if newBackplateExists ~= oldBackplateExists then
            _oldVirtualBackplateColor = nil
        end

        local updateParameters = false
        if newBackplateExists then
            if not oldBackplateExists then
                updateParameters = true
                oldBackplateColor = 0
                backplate = sm_effect_createEffect(getEffectName(), parent)
                effect_setParameter(backplate, "color", black)
                effect_setParameter(backplate, "uuid", material)
                if showState then
                    effect_start(backplate)
                end
            else
                effect_stop(backplate)
                effect_setParameter(backplate, "uuid", material)
                effect_start(backplate)
            end
        elseif oldBackplateExists then
            effect_destroy(backplate)
            oldBackplateColor = nil
            backplate = nil
            recreateCanvas()
        end

        for _, effect in pairs(nodeEffects) do
            effect_stop(effect)
            effect_setParameter(effect, "uuid", material)
            effect_start(effect)
        end

        for i = 1, bufferedEffectsIndex do
            local effect = bufferedEffects[i]
            effect_stop(effect)
            effect_setParameter(effect, "uuid", material)
            effect_start(effect)
        end

        local layerCreated = updateAdditionalLayer()

        if updateParameters or layerCreated then
            obj.setPixelSize(_s_pixelSize)
            obj.setOffset(_s_offset, true)
            obj.setCanvasRotation(_s_rotation)
        end
    end

    local function switchHardware()
        obj.setPixelSize(_s_pixelSize)
        obj.setOffset(_s_offset, true)
        obj.setCanvasRotation(_s_rotation)
    end

    local defaultPosition = vec3_new(0, 0, 0)
    local function getSelfPos()
        local pt = type(parent)
        if pt == "Interactable" then
            return parent.shape.worldPosition
        elseif pt == "Character" then
            return parent.worldPosition
        end
        return defaultPosition
    end

    local function updateLayersPos()
        if backplate then
            _setPosition(backplate, rotation * offset)
        end
        if additionalLayer then
            _setPosition(additionalLayer, rotation * (offset + vec3_new(0, 0, 0.0015)))
        end
    end

    local longOptimizeCounter = 0
    local lastOptimizeTime = game_getCurrentTick()
    local function optimize()
        --[[
        if bufferedEffectsIndex > 4096 then
            for i = 1, bufferedEffectsIndex - 4096 do
                effect_stop(bufferedEffects[i])
                stoppedCount = stoppedCount + 1
            end

            --[[
            if bufferedEffectsIndex > 3000 then
                if debugMode then
                    print("destroy buffered effects")
                end

                for i = 3001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                end
                bufferedEffectsIndex = 3000
            end
            ] ]
        end
        ]]

        if longOptimizeCounter >= 3 then
            skipOptimize = true
            if debugMode then
                print("skip optimize")
            end
            return
        end

        local startTime = os_clock()
        recreateCanvas()

        local optimizeTime = os_clock() - startTime
        if optimizeTime > ((1 / 1000) * 50) then
            if debugMode then
                print("long optimize time", optimizeTime)
            end
            longOptimizeCounter = longOptimizeCounter + 1
        end

        lastOptimizeTime = game_getCurrentTick()
    end

    function obj.setAlpha(_alpha)
        alpha = _alpha
        for rindex, effect in pairs(nodeEffects) do
            effect_setParameter(effect, "color", color_new_fromSmallNumber(effectDatas[getEIndex(rindex)], alpha))
        end
    end

    function obj.setCanvasOptimizationLevel(value)
        optimizationLevel = value
        if value == 0 then
            colorEquals = colorEquals_raw
        else
            colorEquals = colorEquals_smart
        end
        optimizationValue = optimizationLevelToValue(optimizationLevel)
    end

    function obj.isRendering()
        return showState
    end

    function obj.disable(state)
        disable = state
    end

    function obj.setRenderDistance(_dist)
        dist = _dist
    end

    local reoptimizeTime = 20
    local reoptimizeDynamicTime = 40
    local canvasSize = sizeX * sizeY
    if canvasSize >= (512 * 512) then
        reoptimizeTime = 40
        reoptimizeDynamicTime = 80
    elseif canvasSize >= (256 * 256) then
        reoptimizeTime = 40
        reoptimizeDynamicTime = 60
    end

    local oldOptimizeTime
    local newShowState = true
    function obj.update()
        if disable then
            newShowState = false
        elseif dist then
            if not pcall(function()
                local currentDist = mathDist(getSelfPos(), sm_localPlayer_getPlayer().character.worldPosition)
                if currentDist <= dist then
                    newShowState = true
                elseif currentDist >= dist + 2 then
                    newShowState = false
                end
            end) then
                newShowState = false
            end
        end

        --recreateCanvas()

        if newShowState ~= showState then
            showState = newShowState
            if newShowState then
                obj.setWait(false)
                if not backplate and not flushedDefault then
                    drawer.flush(true)
                    flushedDefault = true
                end
                for _, effect in pairs(nodeEffects) do
                    if not effect_isPlaying(effect) then
                        effect_start(effect)
                    end
                end
                if backplate then
                    effect_start(backplate)
                end
                if additionalLayer then
                    effect_start(additionalLayer)
                end
            else
                for _, effect in pairs(nodeEffects) do
                    effect_stop(effect)
                end
                for i = 1, bufferedEffectsIndex do
                    effect_stop(bufferedEffects[i])
                end
                if backplate then
                    effect_stop(backplate)
                end
                if additionalLayer then
                    effect_stop(additionalLayer)
                end
                obj.setWait(true)
            end
        end

        local ctick = game_getCurrentTick()
        local optimizePeer = reoptimizeTime
        if lastDrawTickTime then
            if ctick - lastDrawTickTime < 20 then
                optimizePeer = reoptimizeDynamicTime
            end

            if longOptimizeCounter > 0 and (ctick - lastDrawTickTime > 40 * 5 or ctick - lastOptimizeTime > 40 * 10) then
                if debugMode then
                    print("reset longOptimizeCounter", longOptimizeCounter)
                end
                longOptimizeCounter = 0
                if skipOptimize then
                    optimize()
                    longOptimizeCounter = 0
                    skipOptimize = false
                end
            end
        end

        if ctick % 20 == 0 then
            local stoppedCount = 0
            local destroyedCount = 0

            if bufferedEffectsIndex > 6000 then
                for i = 6001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                    destroyedCount = destroyedCount + 1
                end
                bufferedEffectsIndex = 6000
            end

            for i = 1, bufferedEffectsIndex - 1024 do
                local otick = bufferedEffectsUpdateTime[i]
                if otick ~= true and ctick - otick > 160 then
                    bufferedEffectsUpdateTime[i] = true
                    effect_stop(bufferedEffects[i])
                    stoppedCount = stoppedCount + 1
                end
            end

            if debugMode then
                if destroyedCount > 0 then
                    print("destroying buffered effects", destroyedCount)
                end
                print("stoping buffered effects", stoppedCount .. " / " .. bufferedEffectsIndex)
            end
        end

        if newShowState and needOptimize and optimizePeer and (not oldOptimizeTime or ctick - oldOptimizeTime >= optimizePeer) then
            needOptimize = false
            oldOptimizeTime = ctick
            optimize()
        end

        updateLayersPos()
    end

    function obj.setPixelSize(_pixelSize)
        pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
        if type(pixelSize) == "Vec3" then
            _s_pixelSize = vec3_new(pixelSize.x, pixelSize.y, pixelSize.z)
        else
            _s_pixelSize = pixelSize
        end
        if type(pixelSize) == "number" then
            if pixelSize < 0 then
                pixelSize = math_abs(pixelSize)
                local vec = vec3_new(pixelSize, pixelSize, 0)
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            else
                local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            end
        end
        pixelSize.x = pixelSize.x * oldHardwareParams.scale_x * pixelScaleX
        pixelSize.y = pixelSize.y * oldHardwareParams.scale_y * pixelScaleY
        pixelSize.x = pixelSize.x + (0.0025 / sizeX)
        pixelSize.y = pixelSize.y + (0.0025 / sizeY)
        if backplate then
            effect_setScale(backplate, vec3_new(pixelSize.x * sizeX, pixelSize.y * sizeY, pixelSize.z))
        end
        updateLayerDistance(math.max(pixelSize.x * sizeX, pixelSize.y * sizeY) / 1000)
        if additionalLayer then
            effect_setScale(additionalLayer, vec3_new(pixelSize.x * sizeX * 1.005, pixelSize.y * sizeY * 1.005, math.min(2, layerDistance + ((pixelSize.x * sizeX) / 3 / 128))))
        end
        if autoScaleAddValue then
            scaleAddValue = math_min((pixelSize.x + pixelSize.y + pixelSize.z) / 50, 0.0001)
        end
    end

    function obj.setOffset(_offset, noUpdateParameters)
        offset = vec3_new(_offset.x, _offset.y, _offset.z)
        _s_offset = vec3_new(_offset.x, _offset.y, _offset.z)
        offset.x = offset.x + oldHardwareParams.offset_x
        offset.y = offset.y + oldHardwareParams.offset_y
        offset.z = offset.z + oldHardwareParams.offset_z
        updateLayersPos()
        if not noUpdateParameters then
            for index in pairs(nodeEffects) do
                setEffectDataParams(index)
            end
        end
    end

    function obj.setCanvasRotation(_rotation)
        _s_rotation = _rotation
        if type(_rotation) == "Quat" then
        elseif altFromEuler then
            _rotation = custom_fromEulerYEnd(math.rad(_rotation.x) + oldHardwareParams.rotation_x, math.rad(_rotation.y) + oldHardwareParams.rotation_y, math.rad(_rotation.z) + oldHardwareParams.rotation_z)
        else
            _rotation = quat_fromEuler(vec3_new(_rotation.x + math.deg(oldHardwareParams.rotation_x), _rotation.y + math.deg(oldHardwareParams.rotation_y), _rotation.z + math.deg(oldHardwareParams.rotation_z)))
        end
        rotation = _rotation
        if backplate then
            _setRotation(backplate, rotation)
        end
        if additionalLayer then
            _setRotation(additionalLayer, rotation)
        end
        for index, effect in pairs(nodeEffects) do
            _setRotation(effect, rotation)
            setEffectDataParams(index)
        end
        for _, effect in pairs(bufferedEffects) do
            _setRotation(effect, rotation)
        end
    end

    function obj.destroy()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        if backplate then
            effect_destroy(backplate)
        end
        if additionalLayer then
            effect_destroy(additionalLayer)
        end
    end

    local function raw_setResolution(_sizeX, _sizeY)
        for _, effect in pairs(nodeEffects) do
            hideEffect(effect)
        end
        effects = {}
        nodeEffects = {}
        effectDatas = {}
        
        sizeX = _sizeX
        sizeY = _sizeY
        obj.sizeX = sizeX
        obj.sizeY = sizeY
        maxX, maxY = sizeX - 1, sizeY - 1
        maxEffectArrayBuffer = maxX + (maxY * sizeX)
        pixelScaleX, pixelScaleY = defaultSizeX / sizeX, defaultSizeY / sizeY
    end

    function obj.setCanvasResolution(sizeX, sizeY)
        raw_setResolution(sizeX, sizeY)
        switchHardware()
    end

    ---------------------------------------

    obj.setPixelSize(pixelSize)
    obj.setCanvasRotation(rotation or vec3_new(0, 0, 0))
    obj.setOffset(offset or vec3_new(0, 0, 0))

    ---------------------------------------

    obj.drawer = drawer
    for k, v in pairs(drawer) do
        obj[k] = v
    end
    obj.setWait = _setWait

    function obj.pushDataTunnelParams(dataTunnel)
        if canvasWait then
            wait_dataTunnel = dataTunnel
        else
            wait_dataTunnel = nil
            obj.realPushDataTunnelParams(dataTunnel)
        end
    end

    function obj.realPushDataTunnelParams(dataTunnel)
        obj.setCanvasOptimizationLevel(dataTunnel.optimizationLevel)
        drawer.pushDataTunnelParams(dataTunnel)

        local hardwareParamsChanged = false
        if dataTunnel.res_x ~= sizeX or dataTunnel.res_y ~= sizeY then
            raw_setResolution(dataTunnel.res_x, dataTunnel.res_y)

            hardwareParamsChanged = true
        end

        obj.setAlpha(dataTunnel.light)
        if dataTunnel.material and dataTunnel.material ~= material then
            obj.setCanvasMaterial(dataTunnel.material)
        end
        for key, value in pairs(oldHardwareParams) do
            if dataTunnel[key] ~= value then
                hardwareParamsChanged = true
                oldHardwareParams[key] = dataTunnel[key]
            end
        end
        if hardwareParamsChanged then
            switchHardware()
        end
    end

    return obj
end

--simulates the API of display from SComputers on the client side of your parts
--this is the easiest way to implement the display in your mod
function canvasAPI.createClientScriptableCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local dataTunnel = {}
    local canvas = canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local api = canvasAPI.createScriptableApi(sizeX, sizeY, dataTunnel, nil, canvas.drawer, canvasAPI.materialList, 1, {
        maxOffset = math.huge,
        maxScale = math.huge
    }, {
        maxPixels = math.huge
    })
    api.registerClick = canvasAPI.addTouch(api, dataTunnel)
    api.dataTunnel = dataTunnel
    api.canvas = canvas

    local renderDistance = 15

    for k, v in pairs(canvas) do
        if k ~= "flush" then
            api[k] = v
        end
    end

    function api.getAudience()
        return canvas.isRendering() and 1 or 0
    end

    function api.update()
        canvas.disable(not api.isAllow())
        if dataTunnel.renderAtDistance then
            canvas.setRenderDistance()
        else
            canvas.setRenderDistance(renderDistance)
        end
        canvas.pushDataTunnelParams(dataTunnel)
        canvas.update()
        dataTunnel.scriptableApi_update()

        if dataTunnel.display_reset then
            canvas.drawerReset()
            dataTunnel.display_reset = nil
        end

        if dataTunnel.display_flush then
            if needPushStack(canvas, dataTunnel) then
                canvas.pushStack(dataTunnel.display_stack)
                canvas.flush()
            end
            
            dataTunnel.display_flush()
            dataTunnel.display_stack = nil
            dataTunnel.display_flush = nil
            dataTunnel.display_forceFlush = nil
        end
    end

    function api.setRenderDistance(dist)
        renderDistance = dist
    end

    return api
end

local customFontIndexesCache = {}
local checkedFonts = {}

--implement the SComputers API, does not implement data transfer
function canvasAPI.createScriptableApi(width, height, dataTunnel, flushCallback, drawer, materialList, defaultMaterial, allowHoloAPI, allowSetResolution)
    local defaultResolutionX, defaultResolutionY = width, height
    
    dataTunnel = dataTunnel or {}
    dataTunnel.rotation = 0
    dataTunnel.light = DEFAULT_ALPHA_VALUE
    dataTunnel.skipAtNotSight = false
    dataTunnel.utf8support = false
    dataTunnel.renderAtDistance = false
    dataTunnel.display_forceFlush = true
    dataTunnel.dataUpdated = true
    dataTunnel.optimizationLevel = 16

    local stack = {}
    local stackIndex = 1
    local pixelsCache = {} --optimizations for cameras
    local pixelsCacheExists = false
    local oldStackSum, oldDataSum, oldStack, oldStackIndex
    local forceFlag = false

    local function clearStackForce()
        stack = {}
        stackIndex = 1
    end

    local function clearStack()
        if dataTunnel.display_stack == stack then
            clearStackForce()
        end
    end

    local function setForceFrame()
        if pixelsCacheExists then
            pixelsCache = {}
            pixelsCacheExists = false
        end
        forceFlag = true
        dataTunnel.display_forceFlush = true
    end

    local oldPlayersCount = #sm.player.getAllPlayers()
    function dataTunnel.scriptableApi_update()
        local playersCount = #sm.player.getAllPlayers()
        --local force = sm.game.getCurrentTick() % 80 == 0
        local force = false
        if oldPlayersCount ~= playersCount or force then
            --dataTunnel.display_forceForceFlush = force
            setForceFrame()
            oldPlayersCount = playersCount
        end
    end

    local rwidth, rheight = width, height
    local rmwidth, rmheight = width - 1, height - 1
    local utf8support = false
    local monoFont = true
    local newDataFlag = false
    local spacing = 1
    local fontIndex = 0
    local lastPixelX, lastPixelY, lastPixelColor, lastAction
    local currentSettedFont
    local currentTouchs = {}

    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local dFontX, dFontY = defaultFont.width, defaultFont.height
    local drFontX, drFontY = defaultFont.width, defaultFont.height
    local fontX, fontY
    local mFontX, mFontY
    local xFontX, xFontY
    local sFontX, sFontY
    local rFontX, rFontY
    local fontScaleX, fontScaleY = 1, 1
    local function updateFontSize()
        fontX, fontY = math_ceil(dFontX * fontScaleX), math_ceil(dFontY * fontScaleY)
        rFontX, rFontY = math_ceil(drFontX * fontScaleX), math_ceil(drFontY * fontScaleY)
        mFontX, mFontY = fontX - 1, fontY - 1
        xFontX, xFontY = fontX + 1, fontY + 1
        sFontX, sFontY = fontX + spacing, fontY + 1
    end
    updateFontSize()

    ---------------- color equals check
    local optimizationValue = optimizationLevelToValue(16)

    --local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
    local function colorEquals_smart(color1, color2)
        if color1 == color2 then return true end
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        --return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
        return ((math_abs(rVal - rVal2) + math_abs(gVal - gVal2) + math_abs(bVal - bVal2)) / 1024) <= optimizationValue
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    ----------------

    local api
    local api_flush
    api = {
        --[[
        getBuffer = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,
        getCurrent = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getRealBuffer(x + (y * rwidth))
        end,
        ]]
        get = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,

        -- not implemented (implement it yourself if necessary)
        isAllow = function()
            return true
        end,
        getAudience = function()
            return 1
        end,

        setOptimizationLevel = function(value)
            checkArg(1, value, "number")
            value = round(value)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.optimizationLevel ~= value then
                optimizationValue = optimizationLevelToValue(value)
                if value == 0 then
                    colorEquals = colorEquals_raw
                else
                    colorEquals = colorEquals_smart
                end

                dataTunnel.optimizationLevel = value
                dataTunnel.dataUpdated = true
            end
        end,
        getOptimizationLevel = function()
            return dataTunnel.optimizationLevel
        end,


        -- stubs (outdated methods)
        optimize = function() end,
        setFrameCheck = function () end,
        getFrameCheck = function () return false end,
        setSkipAtLags = function() end,
        getSkipAtLags = function() return false end,


        -- main
        setFontScale = function(scaleX, scaleY)
            checkArg(1, scaleX, "number")
            checkArg(2, scaleY, "number")
            if scaleX < 0 then scaleX = 0 end
            if scaleY < 0 then scaleY = 0 end
            fontScaleX, fontScaleY = scaleX, scaleY
            updateFontSize()
        end,
        getFontScale = function()
            return fontScaleX, fontScaleY
        end,
        setTextSpacing = function(_spacing)
            if _spacing < 0 then _spacing = 0 end
            spacing = _spacing
            updateFontSize()
        end,
        setFontSize = function(_width, _height)
            api.setFontScale(_width / dFontX, _height / dFontY)
        end,
        getTextSpacing = function()
            return spacing
        end,
        calcTextBox = function(text) --it will return two numbers, this will be the size of the box that your text will occupy with this font and this scale
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local totalSize = 0
            if monoFont then
                totalSize = textLen * (fontX + spacing)
            else
                local localFontWidth = dFontX
                local localFont = dataTunnel.customFont or font.optimized
                if fontIndex > 0 and fontsOptimized[fontIndex] then
                    localFont = fontsOptimized[fontIndex]
                    localFontWidth = localFont.width
                end

                local char, chrdata
                for i = 1, textLen do
                    char = sep(text, i, i)
                    if char ~= " " and char ~= spaceCharCode then
                        chrdata = localFont[char] or localFont.error or defaultError
                        totalSize = totalSize + (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                    else
                        totalSize = totalSize + (localFont.spaceSize or localFontWidth) + spacing
                    end
                    canvasAPI.yield()
                end
            end

            return totalSize - spacing, fontY
        end,
        calcCharsSize = function(text) --calculates the length of each character in a string, taking into account its spacing from the next character, and returns a table with these values
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    table_insert(lens, (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing)
                else
                    table_insert(lens, (localFont.spaceSize or localFontWidth) + spacing)
                end
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        calcDecreasingTextSizes = function(text) --it works almost like calcCharsSize. however, each value contains all the previous ones. this is used in the graphic.textBox function, but probably not applicable to any other
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}
            local otherVals = 0

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                local val
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    val = (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                else
                    val = (localFont.spaceSize or localFontWidth) + spacing
                end
                otherVals = otherVals + val
                table_insert(lens, otherVals)
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        isMonospacedFont = function()
            return not not monoFont
        end,

        getWidth = function()
            return rwidth
        end,
        getHeight = function()
            return rheight
        end,
        getSize = function()
            return rwidth, rheight
        end,
        getResolution = function()
            return rwidth, rheight
        end,

        clear = function(color)
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end

            lastAction = nil

            clearStackForce()
            stackIndex = 4
            stack[1] = resetViewportCodeID
            stack[2] = 0
            stack[3] = formatColorToSmallNumber(color, blackSmallNumber)
            
            --[[
            for i = 3, stackIndex - 1 do
                stack[i] = nil
            end
            stackIndex = 3
            ]]
        end,
        drawPixel = function(x, y, color)
            x, y = round(x), round(y)
            if x < 0 or x >= width or y < 0 or y >= height then return end
            local index = x + (y * rwidth)
            color = formatColorToSmallNumber(color, whiteSmallNumber)
            if pixelsCache[index] ~= color then
                if lastAction and x == lastPixelX + 1 and y == lastPixelY and colorEquals(lastPixelColor, color) then
                    if lastAction == 1 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 12
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 1
                elseif lastAction and x == lastPixelX - 1 and y == lastPixelY and colorEquals(lastPixelColor, color) then
                    if lastAction == 2 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 13
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 2
                elseif lastAction and x == lastPixelX and y == lastPixelY + 1 and colorEquals(lastPixelColor, color) then
                    if lastAction == 3 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 14
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 3
                elseif lastAction and x == lastPixelX and y == lastPixelY - 1 and colorEquals(lastPixelColor, color) then
                    if lastAction == 4 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 15
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 4
                else
                    lastPixelColor = color

                    stack[stackIndex] = 16
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = index
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = color
                    stackIndex = stackIndex + 1

                    lastAction = 0
                end

                lastPixelX, lastPixelY = x, y
                pixelsCache[index] = color
                pixelsCacheExists = true
            end
        end,
        fillRect = function(x, y, sizeX, sizeY, color)
            if x <= 0 and y <= 0 and x + sizeX >= width and y + sizeY >= height then
                return api.clear(color or 0xffffff)
            end

            stack[stackIndex] = 2
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawRect = function(x, y, sizeX, sizeY, color, lineWidth)
            lineWidth = round(lineWidth or 1)
            if lineWidth < 1 then
                lineWidth = 1
            end

            stack[stackIndex] = 3
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = lineWidth
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawText = function(x, y, text, color)
            if y > rmheight or y + mFontY < 0 or fontScaleX <= 0 or fontScaleY <= 0 then return end
            text = tostring(text)

            if monoFont then
                local maxTextLen = math_ceil((width - x) / sFontX)
                if maxTextLen <= 0 then return end
                local startTextFrom = math_max(1, math_floor(-x / sFontX) + 1)

                if utf8support then
                    if utf8.len(text) > maxTextLen or startTextFrom > 1 then
                        text = utf8.sub(text, startTextFrom, maxTextLen)
                    end
                else
                    if #text > maxTextLen or startTextFrom > 1 then
                        text = text:sub(startTextFrom, maxTextLen)
                    end
                end

                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x) + ((startTextFrom - 1) * sFontX)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            else
                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCenteredText = function(x, y, text, color, centerX, centerY)
            if centerX == nil then centerX = true end
            if centerY == nil then centerY = true end
            
            local sizeX, sizeY
            if centerX or centerY then
                sizeX, sizeY = api.calcTextBox(text)
            end

            if centerX then
                x = x - (sizeX / 2)
            end

            if centerY then
                y = y - (sizeY / 2)
            end

            api.drawText(x, y, text, color)
        end,
        drawLine = function(x, y, x2, y2, color, width, roundFlag)
            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            stack[stackIndex] = 5
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = width
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 6
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end
            
            stack[stackIndex] = 7
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleEvenly = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 8
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleVeryEvenly = function (x, y, r, color, stroke)
            if r > 1024 then r = 1024 end
            if not stroke or stroke < 1 then stroke = 1 end

            stack[stackIndex] = 9
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(stroke)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawPoly = function(color, ...)
            api.drawWidePoly(color, 1, false, ...)
        end,
        drawWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 10
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillPoly = function(color, ...)
            api.fillWidePoly(color, 1, false, ...)
        end,
        fillWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 11
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawTriangle = function(x1, y1, x2, y2, x3, y3, color)
            api.drawPoly(color, x1, y1, x2, y2, x3, y3)
        end,
        fillTriangle = function(x1, y1, x2, y2, x3, y3, color)
            api.fillPoly(color, x1, y1, x2, y2, x3, y3)
        end,
        flush = function()
            lastAction = nil
            api.setViewport()

            if dataTunnel.display_flush and dataTunnel.display_stack == stack then
                return
            end

            local needFlush = forceFlag
            --print("--------------------------- FLUSH 1", needFlush, stack, stackChecksum(stack), stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel)))

            if not needFlush and stackIndex ~= oldStackIndex then
                --print("FLUSH 2", stackIndex, oldStackIndex)
                needFlush = true
            end

            if not needFlush and newDataFlag then
                local dataSum = stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel))
                if dataSum ~= oldDataSum then
                    --print("FLUSH 3")
                    needFlush = true
                    oldDataSum = dataSum
                end
            end

            if not needFlush and stack ~= oldStack then
                for i = 1, stackIndex - 1 do
                    if stack[i] ~= oldStack[i] then
                        needFlush = true
                        --print("FLUSH 4", oldStack)
                        break
                    end
                end
            end

            --[[
            if needFlush then
                oldStackSum = nil
            else
                local stachSum = stackChecksum(stack)
                if stachSum ~= oldStackSum then
                    --print("FLUSH 5")
                    needFlush = true
                    oldStackSum = stachSum
                end
            end
            ]]
            
            if needFlush then
                --print("FLUSH ACTION")
                oldStack = stack
                oldStackIndex = stackIndex

                dataTunnel.display_stack = stack
                dataTunnel.display_flush = clearStack
                
                if flushCallback then
                    flushCallback()
                end
            else
                clearStackForce()
            end

            forceFlag = false
            newDataFlag = false
        end,
        forceFlush = function()
            api_flush()
            dataTunnel.display_forceFlush = true
        end,

        -- settings
        setUtf8Support = function (state)
            if type(state) == "boolean" then
                if dataTunnel.utf8support ~= state then
                    dataTunnel.utf8support = state
                    dataTunnel.dataUpdated = true
                    newDataFlag = true
                    utf8support = state
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getUtf8Support = function () return dataTunnel.utf8support end,

        setRenderAtDistance = function (c)
            if type(c) == "boolean" then
                if dataTunnel.renderAtDistance ~= c then
                    dataTunnel.renderAtDistance = c
                    dataTunnel.dataUpdated = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getRenderAtDistance = function () return dataTunnel.renderAtDistance end,

        setRotation = function (rotation)
            if type(rotation) == "number" and rotation % 1 == 0 and rotation >= 0 and rotation <= 3 then
                if rotation ~= dataTunnel.rotation then
                    dataTunnel.rotation = rotation
                    dataTunnel.dataUpdated = true
                    newDataFlag = true

                    if pixelsCacheExists then
                        pixelsCache = {}
                        pixelsCacheExists = false
                    end

                    if rotation == 1 or rotation == 3 then
                        rwidth = height
                        rheight = width
                    else
                        rwidth = width
                        rheight = height
                    end
                    rmheight = rheight - 1
                    rmwidth = rwidth - 1
                end
            else
                error("integer must be in [0; 3]", 2)
            end
        end,
        getRotation = function () return dataTunnel.rotation end,

        setFont = function (customFont)
            checkArg(1, customFont, "table", "nil")
            currentSettedFont = customFont
            fontIndex = 0
            if dataTunnel.customFont then
                dataTunnel.dataUpdated = true
                dataTunnel.customFont = nil
            end
            if customFont then
                if not checkedFonts[customFont] then
                    checkFont(customFont)
                    checkedFonts[customFont] = true
                end
                dFontX, dFontY = customFont.width, customFont.height
                drFontX, drFontY = customFont.returnWidth or customFont.width, customFont.returnHeight or customFont.height
                fontIndex = customFontIndexesCache[customFont]
                if not fontIndex then
                    fontIndex = 0
                    for _, v in pairs(fonts) do
                        if v == customFont then
                            fontIndex = v.index
                        end
                    end
                    customFontIndexesCache[customFont] = fontIndex
                end
                if fontIndex == 0 then
                    dataTunnel.customFont = font.optimizeFont(customFont)
                    dataTunnel.dataUpdated = true
                end
                monoFont = customFont.mono or customFont.mono == nil
            else
                dFontX, dFontY = defaultFont.width, defaultFont.height
                drFontX, drFontY = defaultFont.width, defaultFont.height
                monoFont = true
            end
            updateFontSize()
            newDataFlag = true
        end,
        getFont = function()
            return currentSettedFont
        end,

        getFontWidth = function ()
            return rFontX
        end,
        getFontHeight = function ()
            return rFontY
        end,
        getFontSize = function()
            return rFontX, rFontY
        end,

        getRealFontWidth = function ()
            return drFontX
        end,
        getRealFontHeight = function ()
            return drFontY
        end,
        getRealFontSize = function()
            return drFontX, drFontY
        end,

        setSkipAtNotSight = function (state)
            checkArg(1, state, "boolean")
            if dataTunnel.skipAtNotSight ~= state then
                dataTunnel.skipAtNotSight = state
                dataTunnel.dataUpdated = true
            end
        end,
        getSkipAtNotSight = function () return dataTunnel.skipAtNotSight end,

        getViewport = function()
            return viewport_x, viewport_y, viewport_sx, viewport_sy
        end,
        setViewport = function(x, y, sizeX, sizeY)
            if x or y or sizeX or sizeY then
                viewport_x, viewport_y, viewport_sx, viewport_sy = x or 0, y or 0, sizeX or api.getWidth(), sizeY or api.getHeight()
                stack[stackIndex] = -1
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sx)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sy)
                stackIndex = stackIndex + 1
            else
                viewport_x, viewport_y, viewport_sx, viewport_sy = nil, nil, nil, nil
                stack[stackIndex] = resetViewportCodeID
                stackIndex = stackIndex + 1
            end
        end,
        setInlineViewport = function(x, y, sizeX, sizeY)
            if viewport_x then
                local x2 = x + (sizeX - 1)
                local y2 = y + (sizeY - 1)
                local px2 = viewport_x + (viewport_sx - 1)
                local py2 = viewport_y + (viewport_sy - 1)
                if x < viewport_x then x = viewport_x elseif x > px2 then x = px2 end
                if y < viewport_y then y = viewport_y elseif y > py2 then y = py2 end
                if x2 < viewport_x then x2 = viewport_x elseif x2 > px2 then x2 = px2 end
                if y2 < viewport_y then y2 = viewport_y elseif y2 > py2 then y2 = py2 end
                api.setViewport(x, y, (x2 - x) + 1, (y2 - y) + 1)
            else
                api.setViewport(x, y, sizeX, sizeY)
            end
        end,

        setBrightness = function(value) --legacy
            checkArg(1, value, "number")
            --[[
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.brightness ~= value then
                dataTunnel.brightness = value
                dataTunnel.dataUpdated = true
            end
            ]]
        end,
        getBrightness = function() --legacy
            --return dataTunnel.brightness
            return 1
        end,

        setLight = function(value)
            checkArg(1, value, "number")
            value = math_floor(value + 0.5)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.light ~= value then
                dataTunnel.light = value
                dataTunnel.dataUpdated = true
            end
        end,
        getLight = function(value)
            return dataTunnel.light
        end,

        getDefaultResolution = function()
            return defaultResolutionX, defaultResolutionY
        end,

        getTouchs = function()
            for i = 1, MAX_CLICKS do
                local click = api.getClick()
                if not click then
                    break
                end
                local index = #currentTouchs + 1
                for lindex, lclick in reverse_ipairs(currentTouchs) do
                    if lclick.nickname == click.nickname and lclick.button == click.button then
                        index = lindex
                        break
                    end
                end
                if click.state == "released" then
                    table.remove(currentTouchs, index)
                else
                    currentTouchs[index] = click
                end
            end

            return currentTouchs
        end,

        getTouch = function()
            return api.getTouchs()[1]
        end,

        reset = function()
            currentTouchs = {}
            if api.setMaterial then api.setMaterial(api.getDefaultMaterial()) end
            if api.setFontScale then api.setFontScale(1, 1) end
            if api.setTextSpacing then api.setTextSpacing(1) end
            if api.setFont then api.setFont() end
            if api.setRotation then api.setRotation(0) end
            if api.setUtf8Support then api.setUtf8Support(false) end
            if api.setClicksAllowed then api.setClicksAllowed(false) end
            if api.setMaxClicks then api.setMaxClicks(MAX_CLICKS) end
            if api.clearClicks then api.clearClicks() end
            if api.setSkipAtNotSight then api.setSkipAtNotSight(false) end
            if api.setRenderAtDistance then api.setRenderAtDistance(false) end
            if api.setViewport then api.setViewport() end
            if api.setLight then api.setLight(DEFAULT_ALPHA_VALUE) end
            if api.setOptimizationLevel then api.setOptimizationLevel(16) end
            if api.setHoloOffset then api.setHoloOffset(0, 0, 0) end
            if api.setHoloRotation then api.setHoloRotation(0, 0, 0) end
            if api.setHoloScale then api.setHoloScale(1, 1) end
            if api.setResolution then api.setResolution(defaultResolutionX, defaultResolutionY) end
            dataTunnel.display_reset = true
        end
    }

    if materialList then
        defaultMaterial = defaultMaterial or (materialList[0] and 0 or 1)
        local currentMaterialID

        function api.setMaterial(materialId)
            checkArg(1, materialId, "number")
            currentMaterialID = materialId
            if not materialList[currentMaterialID] then
                currentMaterialID = defaultMaterial
            end
            local material = materialList[currentMaterialID]
            if material == true then
                error("this material is not supported on this display", 2)
            end
            if dataTunnel.material ~= material then
                dataTunnel.material = material
                dataTunnel.dataUpdated = true
            end
        end

        function api.getMaterial()
            return currentMaterialID
        end

        function api.getDefaultMaterial()
            return defaultMaterial
        end

        api.setMaterial(api.getDefaultMaterial())
    end

    dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z = 0, 0, 0
    dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z = 0, 0, 0
    dataTunnel.scale_x, dataTunnel.scale_y = 1, 1
    if allowHoloAPI then
        local maxOffset = 5
        local maxScale = 5
        if type(allowHoloAPI) == "table" then
            maxOffset = allowHoloAPI.maxOffset or maxOffset
            maxScale = allowHoloAPI.maxScale or maxScale
        end

        function api.setHoloOffset(x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")
            
            if x < -maxOffset then x = -maxOffset end
            if y < -maxOffset then y = -maxOffset end
            if z < -maxOffset then z = -maxOffset end
            if x > maxOffset then x = maxOffset end
            if y > maxOffset then y = maxOffset end
            if z > maxOffset then z = maxOffset end

            if x ~= dataTunnel.offset_x or y ~= dataTunnel.offset_y or z ~= dataTunnel.offset_z then
                dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z = x, y, z
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloOffset()
            return dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z
        end

        function api.setHoloRotation(x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")
            if x ~= dataTunnel.rotation_x or y ~= dataTunnel.rotation_y or z ~= dataTunnel.rotation_z then
                dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z = x, y, z
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloRotation()
            return dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z
        end

        function api.setHoloScale(x, y)
            checkArg(1, x, "number")
            checkArg(2, y, "number")

            if x < 0 then x = 0 end
            if y < 0 then y = 0 end
            if x > maxScale then x = maxScale end
            if y > maxScale then y = maxScale end

            if x ~= dataTunnel.scale_x or y ~= dataTunnel.scale_y then
                dataTunnel.scale_x, dataTunnel.scale_y = x, y
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloScale()
            return dataTunnel.scale_x, dataTunnel.scale_y
        end
    end

    dataTunnel.res_x, dataTunnel.res_y = defaultResolutionX, defaultResolutionY
    if allowSetResolution then
        if type(allowSetResolution) ~= "table" then
            allowSetResolution = {
                maxPixels = 4096 * 4096,
                maxWidth = 4096,
                maxHeight = 4096
            }
        end

        function api.setResolution(resX, resY)
            checkArg(1, resX, "number")
            checkArg(2, resY, "number")

            resX = math.floor(resX)
            resY = math.floor(resY)
            if resX < 1 then resX = 1 end
            if resY < 1 then resY = 1 end

            if allowSetResolution.maxWidth and resX > allowSetResolution.maxWidth then
                error("the width resolution has been exceeded. maximum: " .. allowSetResolution.maxWidth, 2)
            end

            if allowSetResolution.maxHeight and resX > allowSetResolution.maxHeight then
                error("the height resolution has been exceeded. maximum: " .. allowSetResolution.maxHeight, 2)
            end

            if allowSetResolution.maxPixels and (resX * resY) > allowSetResolution.maxPixels then
                error("the total maximum number of pixels has been exceeded. maximum: " .. allowSetResolution.maxPixels, 2)
            end
            
            if resX ~= dataTunnel.res_x or resY ~= dataTunnel.res_y then
                dataTunnel.res_x, dataTunnel.res_y = resX, resY
                dataTunnel.dataUpdated = true
                dataTunnel.resolutionChanged = true

                if pixelsCacheExists then
                    pixelsCache = {}
                    pixelsCacheExists = false
                end

                width, height = resX, resY
                if dataTunnel.rotation == 1 or dataTunnel.rotation == 3 then
                    rwidth = height
                    rheight = width
                else
                    rwidth = width
                    rheight = height
                end
                rmheight = rheight - 1
                rmwidth = rwidth - 1
            end
        end
    end

    api.update = api.flush
    api.getBuffer = api.get
    api.getCurrent = api.get
    api_flush = api.flush

    local internal = {
        rawPush = function(tbl)
            for i = 1, #tbl do
                stack[stackIndex] = tbl[i]
                stackIndex = stackIndex + 1
            end
        end,
        setForceFrame = setForceFrame
    }

    return api, internal
end

--adds a touch screen API (does not implement click processing)
function canvasAPI.addTouch(api, dataTunnel)
    dataTunnel = dataTunnel or {}
    dataTunnel.clicksAllowed = false
    dataTunnel.maxClicks = MAX_CLICKS
    dataTunnel.clickData = {}

    api.getClick = function ()
        return (table_remove(dataTunnel.clickData, 1))
    end

    api.setMaxClicks = function (c)
        if type(c) == "number" and c % 1 == 0 and c > 0 and c <= 16 then
            dataTunnel.maxClicks = c
        else
            error("integer must be in [1; 16]", 2)
        end
    end

    api.getMaxClicks = function ()
        return dataTunnel.maxClicks
    end

    api.clearClicks = function ()
        dataTunnel.clickData = {}
    end

    api.setClicksAllowed = function (c)
        if type(c) == "boolean" then
            if dataTunnel.clicksAllowed ~= c then
                dataTunnel.clicksAllowed = c
                dataTunnel.dataUpdated = true
            end
        else
            error("Type must be boolean", 2)
        end
    end

    api.getClicksAllowed = function ()
        return dataTunnel.clicksAllowed
    end

    return function (tbl)
        tbl.x = tbl[1] or tbl.x
        tbl.y = tbl[2] or tbl.y
        tbl.state = tbl[3] or tbl.state
        tbl.button = tbl[4] or tbl.button
        tbl.nickname = tbl[5] or tbl.nickname
        tbl[1] = tbl.x or tbl[1]
        tbl[2] = tbl.y or tbl[2]
        tbl[3] = tbl.state or tbl[3]
        tbl[4] = tbl.button or tbl[4]
        tbl[5] = tbl.nickname or tbl[5]
        if #dataTunnel.clickData < dataTunnel.maxClicks then
            table_insert(dataTunnel.clickData, tbl)
        end
    end
end

--leaves only those tunnel fields that are needed for transmission over the network
function canvasAPI.minimizeDataTunnel(dataTunnel)
    return {
        clicksAllowed = dataTunnel.clicksAllowed,
        rotation = dataTunnel.rotation,
        renderAtDistance = dataTunnel.renderAtDistance,
        skipAtNotSight = dataTunnel.skipAtNotSight,
        utf8support = dataTunnel.utf8support,
        customFont = dataTunnel.customFont,
        display_reset = dataTunnel.display_reset,
        optimizationLevel = dataTunnel.optimizationLevel,
        light = dataTunnel.light,
        material = dataTunnel.material,

        offset_x = dataTunnel.offset_x,
        offset_y = dataTunnel.offset_y,
        offset_z = dataTunnel.offset_z,

        rotation_x = dataTunnel.rotation_x,
        rotation_y = dataTunnel.rotation_y,
        rotation_z = dataTunnel.rotation_z,

        scale_x = dataTunnel.scale_x,
        scale_y = dataTunnel.scale_y,

        res_x = dataTunnel.res_x,
        res_y = dataTunnel.res_y
    }
end

-------- additional
canvasAPI.stackChecksum = stackChecksum
canvasAPI.formatColor = formatColor
canvasAPI.formatColorToNumber = formatColorToNumber
canvasAPI.formatColorToSmallNumber = formatColorToSmallNumber
canvasAPI.checkFont = checkFont
canvasAPI.simpleRemathRect = simpleRemathRect
canvasAPI.remathRect = remathRect
canvasAPI.hexToRGB = hexToRGB
canvasAPI.hexToRGB256 = hexToRGB256
canvasAPI.posCheck = posCheck
canvasAPI.mathDist = mathDist
canvasAPI.needPushStack = needPushStack
canvasAPI.font = font
canvasAPI.tableClone = tableClone
canvasAPI.canvasService = canvasService
canvasAPI.userCalls = userCalls
canvasAPI.dataSizes = dataSizes
canvasAPI.color_new_fromSmallNumber = color_new_fromSmallNumber
canvasAPI.getEffectName = getEffectName
canvasAPI.fonts = fonts
canvasAPI.utf8 = utf8

function canvasAPI.pushData(stack, ...)
    for i, v in ipairs({...}) do
        table.insert(stack, v)
    end
end

_G.canvasAPI = canvasAPI
end
function scmframework_b2f85b1aacb70707e7520584c63637c4() --$CONTENT_DATA/Scripts/canvasAPI/backup/canvas_best3.lua
print("> canvas.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/luajit.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/load.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/utf8.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/canvasService.lua")

local debugMode = false
local profileMode = false

local canvasAPI = {
    draw = {
        clear = 0,
        set   = 1,
        fill  = 2,
        rect  = 3,
        text  = 4,
        line  = 5,
        circle  = 6,
        circleF = 7,
        circleE = 8,
        circleVE = 9,
        poly = 10,
        polyF = 11,

        copyNX = 12,
        copyPX = 13,
        copyNY = 14,
        copyPY = 15,
        setI = 16
    },
    material = {
        glass = sm.uuid.new("a683f897-5b8a-4c96-9c46-7b9fbc76d186"),
        classic = sm.uuid.new("8328a29d-35e0-471b-8bfe-06952e9d916d"),
        plastic = sm.uuid.new("82d2da58-6597-4ffa-9b53-1af3b707fa7a"),
        smoothed = sm.uuid.new("a23a4ea2-96da-4bb2-a723-af8c27de2511"),
        glowing = sm.uuid.new("b46ae32a-9037-4360-9f98-3bef1cd4f366")
    },
    multi_layer = {}
}

canvasAPI.multi_layer[tostring(canvasAPI.material.classic)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.plastic)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.smoothed)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.glowing)] = true
canvasAPI.version = 55

canvasAPI.materialList = {
    [0] = canvasAPI.material.glass,
    canvasAPI.material.classic,
    canvasAPI.material.plastic,
    canvasAPI.material.smoothed,
    canvasAPI.material.glowing
}

canvasAPI.materialListWithoutGlass = {
    [0] = true,
    canvasAPI.material.classic,
    canvasAPI.material.plastic,
    canvasAPI.material.smoothed,
    canvasAPI.material.glowing
}

local MAX_DRAW_TIME = 2 --protecting the world from crashing using the display
local FONT_SIZE_LIMIT = 256
local DEFAULT_ALPHA_VALUE = 255
local MAX_CLICKS = 16
canvasAPI.DEFAULT_ALPHA_VALUE = DEFAULT_ALPHA_VALUE

local font = font
local defaultFont = font.default
local fonts = font.fonts
local fontsOptimized = font.fontsOptimized
local spaceCharCode = string.byte(" ")

local huge = math.huge
local string_len = string.len
local bit = bit or bit32
local bit_rshift = bit.rshift
local bit_lshift = bit.lshift
local utf8 = utf8
local string = string
local table_sort = table.sort
local type = type
local math_ceil = math.ceil
local math_max = math.max
local string_format = string.format
local table_insert = table.insert
local table_remove = table.remove
local math_floor = math.floor
local vec3_new = sm.vec3.new
local color_new = sm.color.new
local quat_fromEuler = sm.quat.fromEuler
local ipairs = ipairs
local pairs = pairs
local string_byte = string.byte
local defaultError = font.optimized.error
local tostring = tostring
local math_abs = math.abs
local math_min = math.min
local string_sub = string.sub
local table_concat = table.concat
local tonumber = tonumber
local utf8_len = utf8.len
local utf8_sub = utf8.sub
local sm_localPlayer_getPlayer = sm.localPlayer.getPlayer
local os_clock = os.clock
local math_sqrt = math.sqrt
local quat_new = sm.quat.new
local game_getCurrentTick = sm.game.getCurrentTick

local black = color_new(0, 0, 0)
local white = color_new(1, 1, 1)
local blackNumber = 0x000000ff
local whiteNumber = 0xffffffff
local blackSmallNumber = 0x000000
local whiteSmallNumber = 0xffffff

local getEffectName
do
    local currentEffect = 1
    local effectsNames = {}

    for i = 0, 255 do
        table_insert(effectsNames, "ShapeRenderable" .. tostring(i))
    end

    function getEffectName()
        local name = effectsNames[currentEffect]
        currentEffect = currentEffect + 1
        if currentEffect > #effectsNames then
            currentEffect = 1
        end
        return name
    end
end

local function profillerPrint(name, execTime)
    local t = execTime * 1000
    if profileMode and t > 0 then
        print("profiller", name, t)
    end
end

local function profiller(name, startTime)
    profillerPrint(name, os_clock() - startTime)
end

--[[
local sm_effect_createEffect = sm.effect.withoutHook_createEffect or sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local withoutHookEmptyEffect = emptyEffect
local whook = "withoutHook_"
if better and better.version >= 45 and better.isAvailable() then
    local mt = getmetatable(emptyEffect)
    local newMt = {}
    for k, v in pairs(mt) do
        newMt[k] = v
    end
    for k, v in pairs(mt) do
        if k:sub(1, #whook) == whook then
            newMt[k:sub(#whook + 1, #k)] = v
        end
    end
    withoutHookEmptyEffect = setmetatable({}, newMt)
end
local effect_setParameter = withoutHookEmptyEffect.setParameter
local effect_stop = withoutHookEmptyEffect.stop
local effect_destroy = withoutHookEmptyEffect.destroy
local effect_start = withoutHookEmptyEffect.start
local effect_isDone = withoutHookEmptyEffect.isDone
local effect_isPlaying = withoutHookEmptyEffect.isPlaying
local effect_setScale = withoutHookEmptyEffect.setScale
local effect_setOffsetPosition = withoutHookEmptyEffect.setOffsetPosition
local effect_setOffsetRotation = withoutHookEmptyEffect.setOffsetRotation
effect_destroy(emptyEffect)
]]

local sm_effect_createEffect = sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local effect_setParameter = emptyEffect.setParameter
local effect_stop = emptyEffect.stop
local effect_destroy = emptyEffect.destroy
local effect_start = emptyEffect.start
local effect_isDone = emptyEffect.isDone
local effect_isPlaying = emptyEffect.isPlaying
local effect_setScale = emptyEffect.setScale
local effect_setOffsetPosition = emptyEffect.setOffsetPosition
local effect_setOffsetRotation = emptyEffect.setOffsetRotation
local effect_setPosition = emptyEffect.setPosition
local effect_setRotation = emptyEffect.setRotation
effect_destroy(emptyEffect)

local function reverse_ipairs(t)
    local i = #t + 1
    return function()
        i = i - 1
        if i > 0 then
            return i, t[i]
        end
    end
end

local function round(number)
    return math_floor(number + 0.5)
end

local function checkFont(lfont)
    if type(lfont) ~= "table" then
        error("the font should be a table", 3)
    end

    if lfont.mono or lfont.mono == nil then
        if type(lfont.chars) ~= "table" or (type(lfont.width) ~= "number") or (type(lfont.height) ~= "number") then
            error("invalid basic char data", 3)
        end
        
        if lfont.width > FONT_SIZE_LIMIT then
            error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
        elseif lfont.height > FONT_SIZE_LIMIT then
            error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
        end

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data ~= lfont.height then
                error("font failed integrity check", 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" then
                    error("the char string has the wrong type", 3)
                elseif #line ~= lfont.width then
                    print(char, #line, data)
                    error("the char string has the wrong lenght", 3)
                end
            end
        end
    else
        if type(lfont.chars) ~= "table" then
            error("font failed integrity check", 3)
        end

        local oFont = font.optimizeFont(lfont)
        lfont.spaceSize = oFont.spaceSize
        lfont.width = oFont.width
        lfont.height = oFont.height

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data > FONT_SIZE_LIMIT then
                error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" or #line > FONT_SIZE_LIMIT then
                    error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
                end
            end
        end
    end
end

local function doQuat(x, y, z, w)
    local sin = math.sin(w / 2)
    return quat_new(sin * x, sin * y, sin * z, math.cos(w / 2))
end

local function custom_fromEulerYEnd(x, y, z) --custom implementation
    return doQuat(1, 0, 0, x) * doQuat(0, 0, 1, z) * doQuat(0, 1, 0, y)
end

local function tableClone(tbl)
    local newtbl = {}
    for k, v in pairs(tbl) do
        newtbl[k] = v
    end
    return newtbl
end

local function stackChecksum(stack)
    local num = -#stack
    local t, v
    for i = 1, #stack do
        v = stack[i]
        t = type(v)
        num = num - i
        if t == "number" then
            num = num + ((v * i) + v + i + (v / i))
        elseif t == "Color" then
            num = num + ((i * (v.r / i) * -4) + v.g)
            num = num - ((i * (v.g + i) * 5) + v.b)
            num = num + ((i * (v.b - i) * 8) + v.r)
        elseif t == "string" then
            for i3 = 1, #v do
                num = num + (i * (-i3 - (string_byte(v, i3) * i3)))
            end
        end
    end
    return num
end

local function checkArg(n, have, ...)
    have = type(have)
    local tbl = {...}
    for _, t in ipairs(tbl) do
        if have == t then
            return
        end
    end
    error(string_format("bad argument #%d (%s expected, got %s)", n, table_concat(tbl, " or "), have), 3)
end

local function simpleRemathRect(x, y, w, h, maxX, maxY)
    local x2, y2 = x + (w - 1), y + (h - 1)
    if x < 0 then
        x = 0
    elseif x > maxX then
        --x = maxX
        return
    end
    if y < 0 then
        y = 0
    elseif y > maxY then
        --y = maxY
        return
    end
    if x2 < 0 then
        --x2 = 0
        return
    elseif x2 > maxX then
        x2 = maxX
    end
    if y2 < 0 then
        --y2 = 0
        return
    elseif y2 > maxY then
        y2 = maxY
    end
    return x, y, x2, y2, w, h
end

local function remathRect(offset, stack, maxX, maxY)
    return simpleRemathRect(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], maxX, maxY)
end

local function posCheck(width, height, x, y)
    return x >= 0 and y >= 0 and x < width and y < height
end

local hashChar = string.byte("#")
local bit = bit or bit32
local band = bit.band
local rshift = bit.rshift
local function hexToRGB(color)
    return math_floor(color / 256 / 256) / 255, (math_floor(color / 256) % 256) / 255, (color % 256) / 255
end

local function hexToRGB256(color)
    return math_floor(color / 256 / 256), math_floor(color / 256) % 256, color % 256
end

local function optimizationLevelToValue(level)
    return (level / 255) * 0.25
end

local function formatColor(color, default)
    local t = type(color)
    if t == "Color" then
        return color
    elseif t == "string" then
        return color_new(color)
    elseif t == "number" then
        return color_new(hexToRGB(color))
    end

    return default
end

local redMul = 256 * 256 * 256
local greenMul = 256 * 256
local blueMul = 256
local function formatColorToNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * redMul) + (math_floor(color.g * 255) * greenMul) + (math_floor(color.b * 255) * blueMul) + math_floor(color.a * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return val
        end
        return (val * 256) + 255
    elseif t == "number" then
        return (color * 256) + 255
    end

    return default or 0
end

local function formatColorToSmallNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * greenMul) + (math_floor(color.g * 255) * blueMul) + math_floor(color.b * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return math_floor(val / 256)
        end
        return val
    elseif t == "number" then
        return color
    end

    return default or 0
end

local function color_new_fromSmallNumber(number, alpha)
    return color_new((number * 256) + (alpha or 255))
end

local function mathDist(pos1, pos2)
    return math.sqrt(((pos1.x - pos2.x) ^ 2) + ((pos1.y - pos2.y) ^ 2) + ((pos1.z - pos2.z) ^ 2))
end

local function needPushStack(canvas, dataTunnel) --returns true if the rendering stack should be applied
    return dataTunnel.display_forceFlush or not ((dataTunnel.skipAtNotSight and not canvas.isRendering()))
end

local resetViewportCodeID = -23124
local dataSizes = {
    [resetViewportCodeID] = 1,
    [-1] = 5,
    [0] = 2,
    4,
    6,
    7,
    9, --text
    7, --line
    5,
    5,
    5,
    6,

    4, --drawPoly
    4, --fillPoly

    2,
    2,
    2,
    2,
    3
}

local userCalls = {}

canvasAPI.yield = function() end

function canvasAPI.createDrawer(sizeX, sizeY, callback, callbackBefore, directArg, direct_clear, direct_fill, direct_set, updatedList)
    local obj = {}
    local oldStackSum
    local rSizeX, rSizeY = sizeX, sizeY
    local maxX, maxY = sizeX - 1, sizeY - 1
    local newBuffer, newBufferBase = {}, 0
    local realBuffer = {}
    local maxBuffer = maxX + (maxY * sizeX)
    local currentFont = font.optimized
    local fontWidth, fontHeight = defaultFont.width, defaultFont.height
    local rotation = 0
    local utf8Support = false
    local updated = false
    local clearOnly = false
    local clearBackplate = false
    local maxLineSize = sizeX + sizeY
    local bigSide = math_max(sizeX, sizeY)
    local drawerData = {}
    local _oldBufferBase
    local changes = {}
    local _changes = {}
    local changesIndex, changesCount = {}, 0

    local viewportEnable = false
    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local function bufferRangeUpdate() end

    local function setDot(px, py, col)
        if viewportEnable and (px < viewport_x or py < viewport_y or px >= (viewport_x + viewport_sx) or py >= (viewport_y + viewport_sy)) then
            return
        end

        --[[
        if rotation == 0 then
            index = px + (py * rSizeX)
        elseif rotation == 1 then
            index = (rSizeX - py - 1) + (px * rSizeX)
        elseif rotation == 2 then
            index = (rSizeX - px - 1) + ((rSizeY - py - 1) * rSizeX)
        else
            index = py + ((rSizeY - px - 1) * rSizeX)
        end
        ]]

        local index
        if rotation == 0 then
            index = py + (px * rSizeY)
        elseif rotation == 1 then
            index = px + ((rSizeX - py - 1) * rSizeY)
        elseif rotation == 2 then
            index = (rSizeY - py - 1) + ((rSizeX - px - 1) * rSizeY)
        else
            index = (rSizeY - px - 1) + (py * rSizeY)
        end

        if direct_set then
            newBuffer[index] = col
            direct_set(directArg, math_floor(index / rSizeY), index % rSizeY, col)
            return true
        elseif newBuffer[index] ~= col then
            if updatedList and not changes[index] then
                changes[index] = true
                changesCount = changesCount + 1
                changesIndex[changesCount] = index
            end

            newBuffer[index] = col
            return true
        end
    end

    local function check(px, py)
        return px >= 0 and py >= 0 and px < sizeX and py < sizeY
    end

    local function checkSetDot(px, py, col)
        if check(px, py) then
            setDot(px, py, col)
            return true
        end
        return false
    end

    function obj.drawerReset()
    end

    function obj.drawer_setRotation(_rotation)
        rotation = _rotation
        if rotation == 1 or rotation == 3 then
            sizeX = rSizeY
            sizeY = rSizeX
        else
            sizeX = rSizeX
            sizeY = rSizeY
        end
        maxX, maxY = sizeX - 1, sizeY - 1
    end

    function obj.drawer_setUtf8Support(state)
        utf8Support = not not state
    end

    function obj.drawer_setFont(customFont)
        if customFont then
            currentFont = customFont
            fontWidth, fontHeight = customFont.width, customFont.height
        else
            currentFont = font.optimized
            fontWidth, fontHeight = defaultFont.width, defaultFont.height
        end
    end

    function obj.setDrawerResolution(_sizeX, _sizeY)
        rSizeX, rSizeY = _sizeX, _sizeY
        obj.drawer_setRotation(rotation)
        newBuffer, newBufferBase = {}, 0
        realBuffer = {}
        maxBuffer = maxX + (maxY * sizeX)
        maxLineSize = sizeX + sizeY
        bigSide = math_max(sizeX, sizeY)
        changes = {}
        _changes = {}
        changesIndex, changesCount = {}, 0
        oldStackSum = nil
    end

    local old_rotation
    local old_utf8support
    local old_customFont
    function obj.pushDataTunnelParams(params)
        if params.rotation ~= old_rotation then
            obj.drawer_setRotation(params.rotation)
            old_rotation = params.rotation
        end
        if params.utf8support ~= old_utf8support then
            obj.drawer_setUtf8Support(params.utf8support)
            old_utf8support = params.utf8support
        end
        if params.customFont ~= old_customFont then
            obj.drawer_setFont(params.customFont)
            old_customFont = params.customFont
        end
    end

    ------------------------------------------
    
    local function rasterize_fill(x, y, sx, sy, col)
        local x, y, x2, y2 = simpleRemathRect(x, y, sx, sy, maxX, maxY)
        if not x then return end

        local ix, iy = x, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy + 1
            if iy > y2 then
                iy = y
                ix = ix + 1
            end
        end

        --[[
        local ix, iy = x, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            ix = ix + 1
            if ix > x2 then
                ix = x
                iy = iy + 1
            end
        end
        ]]

        --[[
        local ix, iy = x2, y2
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy - 1
            if iy < y then
                iy = y2
                ix = ix - 1
            end
        end
        ]]

        --[[
        local ix, iy = x2, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy + 1
            if iy > y2 then
                iy = y
                ix = ix - 1
            end
        end
        ]]
    end

    local function rasterize_circleF(px, py, r, col)
        local chr = r*r
        local sx, sy, tempInt, tempBool

        if r < bigSide and px >= 0 and py >= 0 and px < sizeX and py < sizeY then --now only a quarter of the circle is rendered
            for iy = 0, r do
                sy = iy + 0.5
                tempBool = false
                for ix = r, 0, -1 do
                    sx = ix + 0.5
                    if tempBool or (sx * sx) + (sy * sy) <= chr then
                        tempBool = true
                        checkSetDot(px + ix, py + iy, col)
                        checkSetDot(px - ix - 1, py + iy, col)
                        checkSetDot(px + ix, py - iy - 1, col)
                        checkSetDot(px - ix - 1, py - iy - 1, col)
                    end
                end
            end
        else
            for ix = math_max(-r, -px), math_min(r, (sizeX - px) - 1) do --if the starting point is not within the screen or the circle is too large, then will have to check every pixel
                sx = ix + 0.5
                for iy = math_max(-r, -py), math_min(r, (sizeY - py) - 1) do
                    sy = iy + 0.5
                    if (sx * sx) + (sy * sy) <= chr then
                        setDot(px + ix, py + iy, col)
                    end
                end
            end
        end
    end

    local function rasterize_line(px, py, px2, py2, col, width, linesInfo)
        if px2 < px or py2 < py then
            local _px, _py = px, py
            px, py = px2, py2
            px2, py2 = _px, _py
        end
        local dx = math_abs(px2 - px)
        local dy = math_abs(py2 - py)
        local sx = (px < px2) and 1 or -1
        local sy = (py < py2) and 1 or -1
        local err = dx - dy
        if width == -1 or width == 0 or width == 1 then
            local drawAllowed = false
            for _ = 1, maxLineSize do
                if check(px, py) then
                    setDot(px, py, col)
                    drawAllowed = true
                elseif drawAllowed then
                    break
                end
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        elseif width < 0 then
            width = math_ceil((-width) / 2)
            if width < 1 then
                width = 1
            end
            for _ = 1, maxLineSize do
                rasterize_circleF(px, py, width, col)
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        else
            local offsetFill = math_floor(width / 2)
            for _ = 1, maxLineSize do
                rasterize_fill(px - offsetFill, py - offsetFill, width, width, col)
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        end
    end

    ------------------------------------------

    local function render_fill(stack, offset)
        local col = stack[offset+4]
        if direct_fill then
            direct_fill(directArg, stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
        else
            rasterize_fill(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
        end
    end

    local function render_rect(stack, offset)
        local x, y, x2, y2, w, h = remathRect(offset, stack, maxX, maxY)
        if not x then return end
        local col = stack[offset+4]
        local lineWidth = stack[offset+5]
        if lineWidth == 1 then
            for ix = x, x2 do
                setDot(ix, y, col)
                setDot(ix, y2, col)
            end

            for iy = y + 1, y2 - 1 do
                setDot(x, iy, col)
                setDot(x2, iy, col)
            end
        else
            local _y, _y2, _x, _x2
            for ioff = 0, math_min(lineWidth, math_max(w, h) / 2) - 1 do
                _y = y + ioff
                _y2 = y2 - ioff
                for ix = x + ioff, x2 - ioff do
                    setDot(ix, _y, col)
                    setDot(ix, _y2, col)
                end

                _x = x + ioff
                _x2 = x2 - ioff
                for iy = y + 1 + ioff, y2 - (1 + ioff) do
                    setDot(_x, iy, col)
                    setDot(_x2, iy, col)
                end
            end
        end
    end

    local function render_text(stack, offset)
        local tx, ty = stack[offset], stack[offset+1]
        local text = stack[offset+2]
        local col = stack[offset+3]
        local scaleX = stack[offset+4]
        local scaleY = stack[offset+5]
        local spacing = stack[offset+6]
        local fontIndex = stack[offset+7]

        local localFont = currentFont
        local localFontWidth = fontWidth
        if fontIndex > 0 and fontsOptimized[fontIndex] then
            localFont = fontsOptimized[fontIndex]
            localFontWidth = localFont.width
        end

        local len, sep
        if utf8Support then
            len, sep = utf8_len, utf8_sub
        else
            len, sep = string_len, string_byte
        end
        local scaledFontWidth = math_ceil(localFontWidth * scaleX)
        if localFont.mono then
            for i = len(text), 1, -1 do
                local char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    local chrdata = localFont[char] or localFont.error or defaultError
                    local charOffset = (i - 1) * (scaledFontWidth + spacing)
                    for i2 = 1, #chrdata, 2 do
                        local px, py = chrdata[i2], chrdata[i2 + 1]
                        local lposX, lposY = round(px * scaleX), round(py * scaleY)
                        for ix = math_min(sizeX, round((px + 1) * scaleX) - lposX - 1), 0, -1 do
                            local setPosX = tx + ix + lposX + charOffset
                            for iy = math_min(sizeY, round((py + 1) * scaleY) - lposY - 1), 0, -1 do
                                checkSetDot(setPosX, ty + iy + lposY, col)
                            end
                        end
                    end
                end
            end
        else
            local charOffset = 0
            local startDrawTime = os_clock()
            for i = 1, len(text) do
                local char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    local chrdata = localFont[char] or localFont.error or defaultError
                    local charPos = tx + charOffset
                    if not chrdata[0] or charPos + round(chrdata[0] * scaleX) > 0 then
                        if charPos > maxX then
                            goto endDraw
                        end
                        for i2 = 1, #chrdata, 2 do
                            local px, py = chrdata[i2], chrdata[i2 + 1]
                            local lposX, lposY = round(px * scaleX), round(py * scaleY)
                            for ix = 0, math_min(sizeX, round((px + 1) * scaleX) - lposX - 1) do
                                local setPosX = tx + ix + lposX + charOffset
                                for iy = 0, math_min(sizeY, round((py + 1) * scaleY) - lposY - 1) do
                                    checkSetDot(setPosX, ty + iy + lposY, col)
                                end
                            end
                        end
                    end
                    charOffset = charOffset + (chrdata[0] and math_ceil(chrdata[0] * scaleX) or 0) + spacing
                else
                    charOffset = charOffset + (math_ceil(localFont.spaceSize * scaleX) or localFontWidth) + spacing
                end
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
        end
        ::endDraw::
    end

    local function render_line(stack, offset)
        rasterize_line(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4], stack[offset+5])
    end

    local function render_circle(stack, offset) --Michener’s Algorithm
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx, py + dy, col)
            checkSetDot(px + dy, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy, col)
            checkSetDot(px + dy, py - dx, col)
            checkSetDot(px + dx, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleE(stack, offset)
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx - 1, py + dy - 1, col)
            checkSetDot(px + dy - 1, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy - 1, col)
            checkSetDot(px + dy - 1, py - dx, col)
            checkSetDot(px + dx - 1, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleF(stack, offset)
        rasterize_circleF(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3])
    end

    local function render_circleVE(stack, offset) --drawCircleVeryEvenly
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local chr = e2*e2
        local col = stack[offset+3]
        local sx, sy, tempInt, tempBool

        e2 = math_min(e2, bigSide)
        for iy = 0, e2 do
            sy = iy + 0.5
            tempInt = stack[offset+4]
            for ix = e2, 0, -1 do
                sx = ix + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
        for ix = 0, e2 do
            sx = ix + 0.5
            tempInt = stack[offset+4]
            for iy = e2, 0, -1 do
                sy = iy + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
    end

    local function render_drawPoly(stack, offset, getFillInfo)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local startDrawTime = os_clock()
        local _px = stack[offset+3]
        local _py = stack[offset+4]
        local px, py
        local pointsPos
        if getFillInfo then
            pointsPos = {}

            local _setDot = setDot
            setDot = function(px, py, col)
                if not pointsPos[py] then
                    pointsPos[py] = {px, px}
                else
                    local data = pointsPos[py]
                    if px < data[1] then data[1] = px end
                    if px > data[2] then data[2] = px end
                end
            end
            
            for i = 3, points, 2 do
                px = stack[offset+2+i]
                py = stack[offset+3+i]
                rasterize_line(_px, _py, px, py, col, width)
                _px = px
                _py = py
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width)

            setDot = _setDot
        else
            for i = 3, points, 2 do
                px = stack[offset+2+i]
                py = stack[offset+3+i]
                rasterize_line(_px, _py, px, py, col, width)
                _px = px
                _py = py
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width)
        end
        
        ::endDraw::
        return points, pointsPos
    end

    local function render_fillPoly(stack, offset)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local gpoints = points
        for ii = 0, points / 2, 2 do
            local i = ii * 2
            local _, pointsPos = render_drawPoly({col, math_min(6, gpoints), width, stack[offset+3+i], stack[offset+4+i], stack[offset+5+i], stack[offset+6+i], stack[offset+7+i], stack[offset+8+i]}, 1, true)
            local startDrawTime = os_clock()
            for posY, v in pairs(pointsPos) do
                for i = v[1], v[2] do
                    setDot(i, posY, col)
                end

                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            gpoints = gpoints - 4
            if gpoints <= 0 then
                break
            end
        end

        ::endDraw::
        return points
    end

    local lastPixelX, lastPixelY, lastPixelColor
    function obj.pushStack(stack)
        local offset = 2
        local actionNum
        local addValue = 0
        local startDrawTime = os_clock()
        local idx
        while stack[offset] do
            actionNum = stack[offset-1]
            clearOnly = actionNum == 0
            addValue = 0

            if actionNum == 0 then
                newBufferBase = stack[offset]
                newBuffer = {}
                if direct_clear then
                    direct_clear(directArg, newBufferBase, changes)
                end
                updated = true
                clearBackplate = true
                if callback and newBufferBase ~= _oldBufferBase then
                    obj.fullRefresh()
                    _oldBufferBase = newBufferBase
                end
            elseif actionNum == resetViewportCodeID then
                viewportEnable = false
            elseif actionNum == -1 then
                viewportEnable = true
                viewport_x = stack[offset]
                viewport_y = stack[offset+1]
                viewport_sx = stack[offset+2]
                viewport_sy = stack[offset+3]
            elseif actionNum == 1 then
                setDot(stack[offset], stack[offset+1], stack[offset+2])
                updated = true
            elseif actionNum == 2 then
                render_fill(stack, offset)
                updated = true
            elseif actionNum == 3 then
                render_rect(stack, offset)
                updated = true
            elseif actionNum == 4 then
                render_text(stack, offset)
                updated = true
            elseif actionNum == 5 then
                render_line(stack, offset)
                updated = true
            elseif actionNum == 6 then
                render_circle(stack, offset)
                updated = true
            elseif actionNum == 8 then
                render_circleE(stack, offset)
                updated = true
            elseif actionNum == 7 then
                render_circleF(stack, offset)
                updated = true
            elseif actionNum == 9 then
                render_circleVE(stack, offset)
                updated = true
            elseif actionNum == 10 then
                addValue = render_drawPoly(stack, offset)
                updated = true
            elseif actionNum == 11 then
                addValue = render_fillPoly(stack, offset)
                updated = true
            elseif actionNum == 12 then
                for _ = 1, stack[offset] do
                    lastPixelX = lastPixelX + 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 13 then
                for _ = 1, stack[offset] do
                    lastPixelX = lastPixelX - 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 14 then
                for _ = 1, stack[offset] do
                    lastPixelY = lastPixelY + 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 15 then
                for _ = 1, stack[offset] do
                    lastPixelY = lastPixelY - 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 16 then
                idx = stack[offset]
                lastPixelX, lastPixelY, lastPixelColor = idx % rSizeX, math_floor(idx / rSizeX), stack[offset+1]
                setDot(lastPixelX, lastPixelY, lastPixelColor)
                updated = true
            elseif userCalls[actionNum] then
                if userCalls[actionNum](newBuffer, rotation, rSizeX, rSizeY, sizeX, sizeY, stack, offset, drawerData, bufferRangeUpdate, setDot, checkSetDot, rasterize_fill) then
                    updated = true
                end
            end

            if os_clock() - startDrawTime > MAX_DRAW_TIME then
                goto endDraw
            end

            offset = offset + dataSizes[actionNum] + addValue
        end

        ::endDraw::
    end

    function obj.flush(force)
        if not obj.wait and (updated or force) then
            if callbackBefore and callbackBefore(newBufferBase, clearOnly, maxBuffer, force, newBuffer, realBuffer, nil, nil, changes, changesIndex, changesCount, _changes, clearBackplate) then
                realBuffer = {}
            end

            if callback then
                --[[
                local color, px, py
                for i = bufferChangedFrom, bufferChangedTo do
                    color = newBuffer[i] or newBufferBase
                    if color ~= realBuffer[i] or force then
                        px = math_floor(i / rSizeY)
                        py = i % rSizeY
                        callback(px, py, color, newBufferBase)
                        realBuffer[i] = color
                    end
                end
                ]]

                local oldChanges
                if clearBackplate then
                    oldChanges = {}
                    for index in pairs(changes) do
                        oldChanges[index] = true
                    end

                    for index in pairs(_changes) do
                        if not changes[index] then
                            changesCount = changesCount + 1
                            changesIndex[changesCount] = index
                            changes[index] = true
                        end
                    end
                end
        
                for i2 = 1, changesCount do
                    local index = changesIndex[i2]
                    --if changes[index] then
                        callback(math_floor(index / sizeY), index % sizeY, newBuffer[index] or newBufferBase, newBufferBase)
                        _changes[index] = true
                    --end
                end

                if clearBackplate then
                    obj.setOldChanges(oldChanges)
                end
            end

            updated = false
            clearBackplate = false
            if updatedList then
                changes = {}
                changesIndex = {}
                changesCount = 0
            end
        end
    end

    function obj.setWait(state)
        obj.wait = state
        if not state then
            obj.flush()
        end
    end

    function obj.getNewBuffer(i)
        return newBuffer[i] or newBufferBase
    end

    function obj.getRealBuffer(i)
        return realBuffer[i]
    end

    function obj.getChanges()
        return changes
    end

    function obj.fullRefresh()
        changesCount = 0
        changesIndex = {}
        for i = 0, (sizeX * sizeY) - 1 do
            changes[i] = true
            changesCount = changesCount + 1
            changesIndex[changesCount] = i
        end
    end

    --[[
    function obj.flushOldChanges()
        _changes = changes
    end
    ]]

    function obj.setOldChanges(oldChanges)
        _changes = oldChanges
    end

    function obj.clearChangesBuffer()
        _changes = {}
        changes = {}
    end

    return obj
end

if better and better.isAvailable() and better.canvas and better.version >= 40 then
    local better_canvas_clear = better.canvas.clear
    local better_canvas_fill = better.canvas.fill
    local better_canvas_set = better.canvas.set

    function canvasAPI.createBetterCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation)
        local obj = {sizeX = sizeX, sizeY = sizeY}
        local maxX, maxY = sizeX - 1, sizeY - 1
        local maxEffectArrayBuffer = maxX + (maxY * sizeX)
        local dist
        local needOptimize = false
        local showState = false
        local disable = false
        local flushedDefault = false

        local betterCanvas = better.canvas.create(sizeX, sizeY)

        local drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, nil, betterCanvas, better_canvas_clear, better_canvas_fill, better_canvas_set)
        drawer.setWait(true)

        local defaultPosition = vec3_new(0, 0, 0)
        local function getSelfPos()
            local pt = type(parent)
            if pt == "Interactable" then
                return parent.shape.worldPosition
            elseif pt == "Character" then
                return parent.worldPosition
            end
            return defaultPosition
        end

        function obj.isRendering()
            return showState
        end

        function obj.disable(state)
            disable = state
        end

        function obj.setRenderDistance(_dist)
            dist = _dist
        end

        function obj.update()
            local newShowState = true
            local selfPosition
            if disable then
                newShowState = false
            elseif dist then
                if not pcall(function()
                    selfPosition = getSelfPos()
                    newShowState = mathDist(selfPosition, sm_localPlayer_getPlayer().character.worldPosition) <= dist
                end) then
                    selfPosition = selfPosition or vec3_new(0, 0, 0)
                    newShowState = false
                end
            end

            if newShowState ~= showState then
                showState = newShowState
                if newShowState then
                    drawer.setWait(false)
                    if not flushedDefault then
                        drawer.flush(true)
                        flushedDefault = true
                    end
                else
                    drawer.setWait(true)
                    better.canvas.stopUpdate(betterCanvas)
                end
            end

            if newShowState then
                better.canvas.update_3d(betterCanvas, selfPosition + (rotation * offset), -sm.quat.getRight(rotation), -sm.quat.getUp(rotation), (pixelSize.x * sizeX) / 2, (pixelSize.y * sizeY) / 2)
            end
        end

        function obj.setPixelSize(_pixelSize)
            pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
            if type(pixelSize) == "number" then
                if pixelSize < 0 then
                    pixelSize = math_abs(pixelSize)
                    local vec = vec3_new(pixelSize, pixelSize, 0)
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                else
                    local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                end
            end
        end

        function obj.setOffset(_offset)
            offset = _offset
        end

        function obj.setCanvasRotation(_rotation)
            rotation = _rotation
        end

        function obj.destroy()
            better.canvas.destroy(betterCanvas)
        end

        ---------------------------------------

        obj.setPixelSize(pixelSize)
        obj.setCanvasRotation(rotation or quat_fromEuler(vec3_new(0, 0, 0)))
        obj.setOffset(offset or vec3_new(0, 0, 0))

        --[[
        local c = 0xff0000
        local seffect = createEffect(5, 5, 16, 16, c)
        local idx = 5 + (5 * sizeX)
        for i = 0, 16 - 1 do
            effects[idx + i] = {
                seffect,
                c,
                i,
                16,
                idx,
                5,
                5,
                1, --8. sizeY
                0 --9. indexY
            }
        end
        ]]

        ---------------------------------------

        obj.drawer = drawer
        for k, v in pairs(drawer) do
            obj[k] = v
        end

        return obj
    end
end

--low level display api
function canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material, scaleAddValue, altFromEuler, autoLayerDistance)
    local hiddenOffset = vec3_new(1000000, 1000000, 1000000)
    local defaultSizeX, defaultSizeY = sizeX, sizeY
    local pixelScaleX, pixelScaleY = 1, 1
    local obj = {sizeX = sizeX, sizeY = sizeY}
    local maxX, maxY = sizeX - 1, sizeY - 1
    local maxEffectArrayBuffer = maxX + (maxY * sizeX)
    local dist
    local needOptimize = false
    local skipOptimize = false
    local showState = false
    local disable = false

    local _setPosition, _setRotation
    if parent then
        _setPosition, _setRotation = effect_setOffsetPosition, effect_setOffsetRotation
    else
        _setPosition, _setRotation = effect_setPosition, effect_setRotation
    end

    material = material or canvasAPI.material.classic
    local autoScaleAddValue = false
    if not scaleAddValue then
        autoScaleAddValue = true
    end

    local flushedDefault = false
    local oldBackplateColor
    local backplate
    if canvasAPI.multi_layer[tostring(material)] then
        oldBackplateColor = 0
        backplate = sm_effect_createEffect(getEffectName(), parent)
        effect_setParameter(backplate, "uuid", material)
        effect_setParameter(backplate, "color", black)
    end

    local additionalLayer
    local function updateAdditionalLayer()
        if material == canvasAPI.material.smoothed then
            if not additionalLayer then
                additionalLayer = sm_effect_createEffect(getEffectName(), parent)
                effect_setParameter(additionalLayer, "uuid", canvasAPI.material.glass)
                effect_setParameter(additionalLayer, "color", black)
                effect_start(additionalLayer)
                return true
            end
        elseif additionalLayer then
            effect_destroy(additionalLayer)
            additionalLayer = nil
        end
    end
    updateAdditionalLayer()

    local layerDistance
    local function updateLayerDistance(distance)
        layerDistance = math.max(0.001, autoLayerDistance and distance or 0)
    end
    updateLayerDistance()

    local effects = {}
    local nodeEffects = {}
    local effectDatas = {}
    local effectDataLen = 5

    local bufferedEffectsUpdateTime = {}
    local bufferedEffects = {}
    local bufferedEffectsIndex = 0
    local lastDrawTickTime
    local optimizationLevel = 16
    local optimizationValue = optimizationLevelToValue(optimizationLevel)
    local alpha = DEFAULT_ALPHA_VALUE

    local oldHardwareParams = {
        offset_x = 0,
        offset_y = 0,
        offset_z = 0,
        
        rotation_x = 0,
        rotation_y = 0,
        rotation_z = 0,

        scale_x = 1,
        scale_y = 1
    }

    local function getEIndex(index)
        return index * effectDataLen
    end

    local function fromEIndex(index)
        return index / effectDataLen
    end

    local function setEffectDataParams(index)
        local effect = nodeEffects[index]
        local eindex = getEIndex(index)
        local posX, posY, lSizeX, lSizeY = effectDatas[eindex+1], effectDatas[eindex+2], effectDatas[eindex+3], effectDatas[eindex+4]

        posX = posX + ((lSizeX - 1) * 0.5)
        posY = posY + ((lSizeY - 1) * 0.5)
        _setPosition(effect, rotation * (offset + vec3_new(((posX + 0.5) - (sizeX / 2)) * pixelSize.x, ((posY + 0.5) - (sizeY / 2)) * -pixelSize.y, backplate and (debugMode and 0.05 or layerDistance) or 0)))

        local localScaleAddValue = debugMode and -(pixelSize.x / 2) or scaleAddValue
        local vec = pixelSize * 1
        vec.x = (pixelSize.x * lSizeX) + localScaleAddValue
        vec.y = (pixelSize.y * lSizeY) + localScaleAddValue
        effect_setScale(effect, vec)

        effect_setParameter(effect, "color", color_new_fromSmallNumber(effectDatas[eindex], alpha))
    end

    local function createEffect()
        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            _setRotation(effect, rotation)
        end
        return effect
    end

    local function createEffectUnhide(hideList)
        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            hideList[effect] = nil
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            _setRotation(effect, rotation)
        end
        return effect
    end

    local function clearBufferedEffects()
        for i = 1, bufferedEffectsIndex do
            effect_destroy(bufferedEffects[i])
        end
        bufferedEffectsUpdateTime = {}
        bufferedEffects = {}
        bufferedEffectsIndex = 0
    end

    local lastNewBuffer, lastBase

    local lastPopularColor
    local function mathPopularColor()
        local colorUsesTable = {}
        local colorUses = 0
        local oldColorUses = 0
        local colorSum = 0
        for index in pairs(nodeEffects) do
            local eindex = getEIndex(index)
            local color = effectDatas[eindex]
            local colorSize = effectDatas[eindex+3] * effectDatas[eindex+4]
            colorUsesTable[color] = (colorUsesTable[color] or 0) + colorSize
            colorSum = colorSum + colorSize
            colorUses = colorUsesTable[color]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = color
            end
        end

        if oldBackplateColor then
            local colorSize = (sizeX * sizeY) - colorSum
            colorUsesTable[oldBackplateColor] = (colorUsesTable[oldBackplateColor] or 0) + colorSize
            colorUses = colorUsesTable[oldBackplateColor]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = oldBackplateColor
            end
        end
    end

    local function effectIndexAtPos(px, py)
        return py + (px * sizeY)
    end

    local function getRootEIndexAtPos(px, py)
        if py < 0 or py >= sizeY then return end
        local index = effects[effectIndexAtPos(px, py)]
        return index and getEIndex(index), index
    end

    local function clearEffectFromBuffer(index)
        local eindex = getEIndex(index)
        local six, ix, iy = effectDatas[eindex+1], effectDatas[eindex+1], effectDatas[eindex+2]
        local sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        nodeEffects[index] = nil
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix >= six + sizeX then
                ix = six
                iy = iy + 1
            end
        end
    end

    local function hideEffect(effect)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        bufferedEffectsUpdateTime[bufferedEffectsIndex] = game_getCurrentTick()
        _setPosition(effect, hiddenOffset)
    end

    local function hideEffectData(index)
        hideEffect(nodeEffects[index])
        clearEffectFromBuffer(index)
    end

    local function hideEffectLater(effect, hideList)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        bufferedEffectsUpdateTime[bufferedEffectsIndex] = game_getCurrentTick()
        hideList[effect] = true
        --_setPosition(effect, hiddenOffset)
    end

    local function hideEffectDataLater(index, hideList)
        hideEffectLater(nodeEffects[index], hideList)
        clearEffectFromBuffer(index)
    end    
    
    local function hideEffectsWithColor(color)
        for index in pairs(nodeEffects) do
            if effectDatas[getEIndex(index)] == color then
                hideEffectData(index)
            end
        end
    end

    local function delAllEffects()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        effects = {}
        nodeEffects = {}
    end

    --[[
    local function forceRecreateNodeEffects()
        nodeEffects = {}
        for i, effectData in pairs(effects) do
            if effectData[7] == i then
                nodeEffects[i] = effectData
            end
        end
    end
    ]]

    --local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
    local function colorEquals_smart(color1, color2)
        if color1 == color2 then return true end
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        --return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
        return ((math_abs(rVal - rVal2) + math_abs(gVal - gVal2) + math_abs(bVal - bVal2)) / 1024) <= optimizationValue
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    local function getFillZone(eindex)
        local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
        return fillX1, fillY1, fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
    end

    local sumAttachTime = 0
    local sumAttachFillTime = 0
    local function tryLongAttach(changedList, hideList, index, px, py, color, sizeX, sizeY)
        local startTime = os_clock()

        --[[
        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        local origEffect
        if origIndex then
            origEffect = nodeEffects[origIndex]
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end
        ]]

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local downParentE, downParent = getRootEIndexAtPos(px, py + sizeY)
        local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)
        local downAvailable = downParentE and nodeEffects[downParent] and effectDatas[downParentE+1] == px and effectDatas[downParentE+3] == sizeX and colorEquals(effectDatas[downParentE], color)

        local fillOptional = false
        local fillX1, fillY1, fillX2, fillY2
        local fill2X1, fill2Y1, fill2X2, fill2Y2

        --[[
        if origEffect and (upAvailable or downAvailable) then
            hideEffectLater(origEffect, hideList)
            changedList[origIndex] = nil
            changedColorList[origIndex] = nil
            nodeEffects[origIndex] = nil
        end
        ]]

        local newIndex, newEIndex
        local fillVal
        if upAvailable and downAvailable then
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

            local addSizeY = sizeY + effectDatas[downParentE+4]

            hideEffectLater(nodeEffects[downParent], hideList)
            changedList[downParent] = nil
            --changedColorList[downParent] = nil
            nodeEffects[downParent] = nil

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + addSizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
        elseif upAvailable then
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
        elseif downAvailable then
            fillOptional = true
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

            changedList[downParent] = nil
           --changedColorList[downParent] = nil

            nodeEffects[index] = nodeEffects[downParent]
            nodeEffects[downParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[downParentE]
            effectDatas[eindex+1] = effectDatas[downParentE+1]
            effectDatas[eindex+2] = py
            effectDatas[eindex+3] = effectDatas[downParentE+3]
            effectDatas[eindex+4] = effectDatas[downParentE+4] + sizeY
            
            newIndex, newEIndex = index, eindex
            fillVal = index
        end

        if fillVal then
            index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
            sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
        end

        local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
        local rightParentE, rightParent = getRootEIndexAtPos(px + sizeX, py)
        local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
        local rightAvailable = rightParentE and nodeEffects[rightParent] and effectDatas[rightParentE+2] == py and effectDatas[rightParentE+4] == sizeY and colorEquals(effectDatas[rightParentE], color)

        if nodeEffects[index] and (leftAvailable or rightAvailable) then
            hideEffectLater(nodeEffects[index], hideList)
            changedList[index] = nil
            --changedColorList[index] = nil
            nodeEffects[index] = nil
        end

        if leftAvailable and rightAvailable then
            fillOptional = false
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

            local addSizeX = sizeX + effectDatas[rightParentE+3]

            hideEffectLater(nodeEffects[rightParent], hideList)
            changedList[rightParent] = nil
            --changedColorList[rightParent] = nil
            nodeEffects[rightParent] = nil

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + addSizeX
            fillVal = leftParent
        elseif leftAvailable then
            fillOptional = false
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = nil, nil, nil, nil

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
            fillVal = leftParent
        elseif rightAvailable then
            fillOptional = not upAvailable and not downAvailable
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

            changedList[rightParent] = nil
            --changedColorList[rightParent] = nil

            nodeEffects[index] = nodeEffects[rightParent]
            nodeEffects[rightParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[rightParentE]
            effectDatas[eindex+1] = px
            effectDatas[eindex+2] = effectDatas[rightParentE+2]
            effectDatas[eindex+3] = sizeX + effectDatas[rightParentE+3]
            effectDatas[eindex+4] = effectDatas[rightParentE+4]
            
            fillVal = index
        end

        sumAttachTime = sumAttachTime + (os_clock() - startTime)

        if fillVal then
            changedList[fillVal] = true
            --changedColorList[fillVal] = true

            --[[
            local eindex = getEIndex(fillVal)
            local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
            local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = fillVal
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            ]]

            startTime = os_clock()

            --fillOptional = false
            --if not fillOptional or not origEffect then
                local ix, iy = fillX1, fillY1
                for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = fillVal
                    ix = ix + 1
                    if ix > fillX2 then
                        ix = fillX1
                        iy = iy + 1
                    end
                end
            --[[else
                local ix, iy = fillX1, fillY1
                for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                    if fillVal ~= effects[effectIndexAtPos(ix, iy)] then
                        print("WTTT", fillVal, effects[effectIndexAtPos(ix, iy)])
                    end
                    ix = ix + 1
                    if ix > fillX2 then
                        ix = fillX1
                        iy = iy + 1
                    end
                end
                ]]
            --end

            if fill2X1 then
                local ix, iy = fill2X1, fill2Y1
                for _ = 1, ((fill2X2 - fill2X1) + 1) * ((fill2Y2 - fill2Y1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = fillVal
                    ix = ix + 1
                    if ix > fill2X2 then
                        ix = fill2X1
                        iy = iy + 1
                    end
                end
            end

            sumAttachFillTime = sumAttachFillTime + (os_clock() - startTime)

            --fillVal = tryAttach(changedList, changedColorList, index, px, py, color) or fillVal
        end

        return fillVal
    end

    local function tryAttach(changedList, hideList, index, px, py, color, sizeX, sizeY)
        local startTime = os_clock()

        --[[
        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        local origEffect
        if origIndex then
            origEffect = nodeEffects[origIndex]
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end
        ]]

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)

        local fillX1, fillY1, fillX2, fillY2
        local newIndex, newEIndex, fillVal
        if upAvailable then
            --[[
            if origEffect then
                hideEffectLater(origEffect, hideList)
                changedList[origIndex] = nil
                changedColorList[origIndex] = nil
                nodeEffects[origIndex] = nil
            end
            ]]

            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent

            index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
            sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
        end

        local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
        local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
        if leftAvailable then
            if nodeEffects[index] then
                hideEffectLater(nodeEffects[index], hideList)
                changedList[index] = nil
                --changedColorList[index] = nil
                nodeEffects[index] = nil
            end

            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
            fillVal = leftParent
        end

        sumAttachTime = sumAttachTime + (os_clock() - startTime)

        if fillVal then
            changedList[fillVal] = true
            --changedColorList[fillVal] = true

            startTime = os_clock()
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = fillVal
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            sumAttachFillTime = sumAttachFillTime + (os_clock() - startTime)
        end

        return fillVal
    end

    local sumFillTime = 0
    local function fillBlock(x, y, sx, sy, changedList, hideList, color, iterate, effect)
        if sx <= 0 or sy <= 0 then
            return
        end

        local newRIndex = effectIndexAtPos(x, y)
        nodeEffects[newRIndex] = effect or createEffectUnhide(hideList)
        changedList[newRIndex] = true
        --changedColorList[newRIndex] = true

        local newEIndex = getEIndex(newRIndex)
        effectDatas[newEIndex] = color
        effectDatas[newEIndex+1] = x
        effectDatas[newEIndex+2] = y
        effectDatas[newEIndex+3] = sx
        effectDatas[newEIndex+4] = sy

        if not iterate then
            return true
        end
        
        local startTime = os_clock()
        local ix, iy = x, y
        local six = ix
        local mix = six + sx
        for _ = 1, sx * sy do
            effects[effectIndexAtPos(ix, iy)] = newRIndex
            ix = ix + 1
            if ix >= mix then
                ix = six
                iy = iy + 1
            end
        end
        sumFillTime = sumFillTime + (os_clock() - startTime)

        return true
    end

    local sumExtractTime = 0
    local function extractPixel(changedList, hideList, index, px, py, sizeX, sizeY)
        local startTime = os_clock()

        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local lx = px - rpx
        local ly = py - rpy

        local effect = nodeEffects[rindex]
        changedList[rindex] = nil
        --changedColorList[rindex] = nil
        nodeEffects[rindex] = nil

        local color = effectDatas[eindex]
        --local block1, block2, block3, block4 = false, false, false, false
        if fillBlock(rpx, rpy, lx, rsy, changedList, hideList, color, false, effect) then --[[block1 = true]] effect = nil end
        if fillBlock(rpx + lx + sizeX, rpy, rsx - lx - sizeX, rsy, changedList, hideList, color, true, effect) then --[[block2 = true]] effect = nil end
        if fillBlock(rpx + lx, rpy, sizeX, ly, changedList, hideList, color, true, effect) then --[[block3 = true]] effect = nil end
        if fillBlock(rpx + lx, rpy + ly + sizeY, sizeX, rsy - ly - sizeY, changedList, hideList, color, true, effect) then --[[block4 = true]] effect = nil end

        local ix, iy, endX = px, py, px + (sizeX - 1)
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix > endX then
                ix = px
                iy = iy + 1
            end
        end

        if effect then
            hideEffectLater(effect, hideList)
        end

        sumExtractTime = sumExtractTime + (os_clock() - startTime)

        --if block1 then tryAttach(changedList, changedColorList, effectIndexAtPos(rpx, rpy), rpx, rpy, color) end
        --if block2 then tryAttach(changedList, changedColorList, effectIndexAtPos(block2X, rpy), block2X, rpy, color) end
        --if block3 then tryAttach(changedList, changedColorList, effectIndexAtPos(block3X, rpy), block3X, rpy, color) end
        --if block4 then tryAttach(changedList, changedColorList, effectIndexAtPos(block4X, block4Y), block4X, block4Y, color) end
    end

    --[[
    local function extractXLine(changedList, changedColorList, hideList, index, px, py)
        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local ly = py - rpy

        local effect = nodeEffects[rindex]
        changedList[rindex] = nil
        changedColorList[rindex] = nil
        nodeEffects[rindex] = nil
        effects[index] = nil

        local color = effectDatas[eindex]
        if fillBlock(rpx, rpy, rsx, ly, changedList, changedColorList, hideList, color, false, effect) then effect = nil end
        if fillBlock(rpx, rpy + ly + 1, rsx, rsy - ly - 1, changedList, changedColorList, hideList, color, true, effect) then effect = nil end

        if effect then
            hideEffectLater(effect, hideList)
        end
    end
    ]]

    local function fillEffectsLinks(index, px, py, sizeX, sizeY)
        local ix, iy, endX = px, py, px + (sizeX - 1)
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = index
            ix = ix + 1
            if ix > endX then
                ix = px
                iy = iy + 1
            end
        end
    end

    --[[
    local sumIsFullChangeTime = 0
    local function isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, forDestroy)
        local effectID = nodeEffects[rindex].id
        if fullChecked[effectID] then
            return false
        end
        fullChecked[effectID] = true


        local startTime = os_clock()

        local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
        local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
        local baseColor = lastNewBuffer[effectIndexAtPos(fillX1, fillY1)] or lastBase

        local ix, iy = fillX1 + 1, fillY1
        if ix > fillX2 then
            ix = fillX1
            iy = iy + 1
        end
        for _ = 2, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
            local color = lastNewBuffer[effectIndexAtPos(ix, iy)] or lastBase
            if color ~= baseColor then
                sumIsFullChangeTime = sumIsFullChangeTime + (os_clock() - startTime)
                return false
            end
            ix = ix + 1
            if ix > fillX2 then
                ix = fillX1
                iy = iy + 1
            end
        end

        ix, iy = fillX1, fillY1
        if not forDestroy then
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                local index = effectIndexAtPos(ix, iy)
                _changes[index] = true
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
        end

        sumIsFullChangeTime = sumIsFullChangeTime + (os_clock() - startTime)
        return true
    end
    ]]

    --[[
    local function getBlockSize(rindex, index, px, py, color)
        local sizeX = 1
        --local sizeY = 1
        --[[
        for i = 1, maxY - py do
            if rindex ~= effects[index+i] or (lastNewBuffer[index+i] or lastBase) ~= color then
                break
            end
            sizeY = sizeY + 1
        end
        ] ]
        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
                --sizeY = sizeY + 1
            end
        end

        --[[
        for iy = 1, maxY - py do
            local multibrake = false
            for ix = 0, sizeX - 1 do
                local lindex = effectIndexAtPos(px+ix, py+iy)
                if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                    multibrake = true
                    break
                end
            end
            if multibrake then
                break
            end
            sizeY = sizeY + 1
        end
        ] ]

        return sizeX, iy
    end
    ]]

    local function getBlockSize(index, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local function getBlockSizeOptimization(index, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if effects[lindex] or not lastNewBuffer[lindex] or not colorEquals(lastNewBuffer[lindex], color) then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if effects[lindex] or not lastNewBuffer[lindex] or not colorEquals(lastNewBuffer[lindex], color) then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local function getChangesBlockSize(rindex, index, changes, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if rindex ~= effects[lindex] or not changes[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if rindex ~= effects[lindex] or not changes[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local _oldVirtualBackplateColor
    local drawer
    local lastDrawWithClear = true
    drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, function (base, clearOnly, maxBuffer, force, newBuffer, realBuffer, _, _, changes, changesIndex, changesCount, _changes, clearBackplate)
        lastNewBuffer, lastBase = newBuffer, base
        lastDrawWithClear = clearBackplate

        if clearOnly and backplate then
            clearBufferedEffects()
            drawer.clearChangesBuffer()
            delAllEffects()
            return
        end

        local changedList = {}
        --local changedColorList = {}
        local hideList = {}
        --local fullChecked = {}

        --print("changesCount 1", changesCount)

        local oldChanges
        if clearBackplate then
            local startTime = os_clock()

            oldChanges = {}
            for index in pairs(changes) do
                oldChanges[index] = true
            end

            for index in pairs(_changes) do
                if not changes[index] then
                    changesCount = changesCount + 1
                    changesIndex[changesCount] = index
                    changes[index] = true
                end
            end

            profiller("clear-loop", startTime)
        end

        --[[
        local _changesSize = 0
        for k, v in pairs(_changes) do
            _changesSize = _changesSize + 1
        end
        print(tostring(_changes), _changesSize)
        ]]

        --print("changesCount 2", changesCount)

        --[[
        local startTime = os_clock()
        table_sort(changesIndex, function (a, b)
            return a < b
        end)
        profiller("stack-sort", startTime)
        ]]

        --[[
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex then
                local eindex = getEIndex(rindex)
                if not colorEquals(effectDatas[eindex], color) then
                    local px = math_floor(index / sizeY)
                    local py = index % sizeY
                    local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
                    local backplateColor = color == oldBackplateColor
                    if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, backplateColor) then
                        if backplateColor then
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        elseif not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        end
                    elseif backplateColor then
                        if aSizeX or aSizeY then
                            extractPixel(changedList, changedColorList, hideList, index, px, py)
                        else
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        end
                    else
                        _changes[index] = true

                        if aSizeX or aSizeY then
                            extractPixel(changedList, changedColorList, hideList, index, px, py)
                        end

                        if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                            local eindex = getEIndex(index)

                            if not nodeEffects[index] then
                                local effect = createEffectUnhide(hideList)

                                local bSizeX, bSizeY = 1, 1
                                effectDatas[eindex+1] = px
                                effectDatas[eindex+2] = py
                                effectDatas[eindex+3] = bSizeX
                                effectDatas[eindex+4] = bSizeY
                                fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                
                                nodeEffects[index] = effect
                                changedList[index] = true
                            end

                            effectDatas[eindex] = color
                            changedColorList[index] = true
                        end
                    end
                end
            elseif color ~= oldBackplateColor then
                _changes[index] = true
                local px = math_floor(index / sizeY)
                local py = index % sizeY
                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect

                    local eindex = getEIndex(index)
                    local bSizeX, bSizeY = getBlockSize(index, px, py)
                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = bSizeX
                    effectDatas[eindex+4] = bSizeY
                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                    
                    changedList[index] = true
                    changedColorList[index] = true
                end
            end
        end
        profiller("change-loop", startTime)
        ]]

        --local localEffectsBlacklist = {}

        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex --[[and not localEffectsBlacklist[rindex] ]] then
                local eindex = getEIndex(rindex)
                --local isBackgroundColor = color == oldBackplateColor
                --if color == oldBackplateColor or not colorEquals(effectDatas[eindex], color) then
                if effectDatas[eindex] ~= color then
                    --local px = math_floor(index / sizeY)
                    --local py = index % sizeY
                    --local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
                    --[[if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, backplateColor) then
                        if backplateColor then
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        else
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        end
                    else]]
                    
                    --local aSizeX, aSizeY = effectDatas[eindex+3], effectDatas[eindex+4]
                    if effectDatas[eindex+3] > 1 or effectDatas[eindex+4] > 1 then
                        local px = math_floor(index / sizeY)
                        local py = index % sizeY
                        --local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                        --extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)
                        extractPixel(changedList, hideList, index, px, py, getChangesBlockSize(rindex, index, changes, px, py, color))

                        --[[
                        local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                        if aSizeX == bSizeX and aSizeY == bSizeY then
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        else
                            extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)
                        end
                        ]]

                        --[[
                        if not isBackgroundColor then
                            if not tryAttach(changedList, changedColorList, hideList, index, px, py, color, bSizeX, bSizeY) then
                                local effect = createEffectUnhide(hideList)

                                nodeEffects[index] = effect

                                local eindex = getEIndex(index)
                                effectDatas[eindex] = color
                                effectDatas[eindex+1] = px
                                effectDatas[eindex+2] = py
                                effectDatas[eindex+3] = bSizeX
                                effectDatas[eindex+4] = bSizeY
                                fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                
                                changedList[index] = true
                                changedColorList[index] = true
                                localEffectsBlacklist[index] = true
                            end
                        end
                        ]]
                    else
                        changedList[rindex] = nil
                        --changedColorList[rindex] = nil
                        hideEffectDataLater(rindex, hideList)
                    end
                end
            end
        end
        profiller("extract-loop", startTime)

        --local blockSizeCache = {}
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            if color ~= oldBackplateColor then
                _changes[index] = true

                if not effects[index] then
                    local px = math_floor(index / sizeY)
                    local py = index % sizeY

                    if not tryLongAttach(changedList, hideList, index, px, py, color, 1, 1) then
                        --[[
                        local blockSize
                        if blockSizeCache[index] then
                            blockSize = blockSizeCache[index]
                            print("LOAD", index, blockSize)
                        else
                            blockSize = {getBlockSize(index, px, py, color)}
                            blockSizeCache[index] = blockSize
                        end
                        ]]

                        local bSizeX, bSizeY = getBlockSize(index, px, py, color)
                        if not tryLongAttach(changedList, hideList, index, px, py, color, bSizeX, bSizeY) then
                            local effect = createEffectUnhide(hideList)

                            nodeEffects[index] = effect

                            local eindex = getEIndex(index)
                            effectDatas[eindex] = color
                            effectDatas[eindex+1] = px
                            effectDatas[eindex+2] = py
                            effectDatas[eindex+3] = bSizeX
                            effectDatas[eindex+4] = bSizeY
                            fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                            
                            changedList[index] = true
                            --changedColorList[index] = true
                        end

                        --[[
                        local effect = createEffectUnhide(hideList)

                        nodeEffects[index] = effect
                        effects[index] = index

                        local eindex = getEIndex(index)
                        effectDatas[eindex] = color
                        effectDatas[eindex+1] = px
                        effectDatas[eindex+2] = py
                        effectDatas[eindex+3] = 1
                        effectDatas[eindex+4] = 1
                        
                        changedList[index] = true
                        ]]
                    end
                end
            end
        end
        profiller("add-loop", startTime)

        --[[
        local localEffectsBlacklist = {}
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex then
                if not localEffectsBlacklist[rindex] then
                    local eindex = getEIndex(rindex)
                    local isBackgroundColor = color == oldBackplateColor
                    if isBackgroundColor or not colorEquals(effectDatas[eindex], color) then
                        if effectDatas[eindex+3] > 1 or effectDatas[eindex+4] > 1 then
                            local px = math_floor(index / sizeY)
                            local py = index % sizeY
                            local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                            extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)

                            if not isBackgroundColor then
                                _changes[index] = true

                                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                                    local effect = createEffectUnhide(hideList)

                                    nodeEffects[index] = effect

                                    local eindex = getEIndex(index)
                                    effectDatas[eindex] = color
                                    effectDatas[eindex+1] = px
                                    effectDatas[eindex+2] = py
                                    effectDatas[eindex+3] = bSizeX
                                    effectDatas[eindex+4] = bSizeY
                                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                    
                                    changedList[index] = true
                                    changedColorList[index] = true
                                    localEffectsBlacklist[index] = true
                                end
                            end
                        elseif not isBackgroundColor then
                            _changes[index] = true

                            local px = math_floor(index / sizeY)
                            local py = index % sizeY
                            if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                                effectDatas[eindex] = color
                                changedColorList[rindex] = true
                            end
                        else
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        end
                    end
                end
            elseif color ~= oldBackplateColor then
                _changes[index] = true

                local px = math_floor(index / sizeY)
                local py = index % sizeY
                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect

                    local eindex = getEIndex(index)
                    local bSizeX, bSizeY = getBlockSize(nil, index, px, py, color)
                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = bSizeX
                    effectDatas[eindex+4] = bSizeY
                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                    
                    changedList[index] = true
                    changedColorList[index] = true
                    localEffectsBlacklist[index] = true
                end
            end
        end
        profiller("change-loop", startTime)
        ]]

        local contentUpdated = false

        startTime = os_clock()
        for index in pairs(changedList) do
            setEffectDataParams(index)
            contentUpdated = true
        end
        profiller("apply-params", startTime)

        --[[
        startTime = os_clock()
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            if not colorCache[color] then
                colorCache[color] = color_new_fromSmallNumber(color, alpha)
            end
            effect_setParameter(nodeEffects[index], "color", colorCache[color])
        end
        profiller("apply-colors", startTime)
        ]]
        --[[
        startTime = os_clock()
        local colorobj = color_new(0)
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            colorobj.r, colorobj.g, colorobj.b = hexToRGB(color)
            colorobj.a = alpha / 255
            effect_setParameter(nodeEffects[index], "color", colorobj)
            contentUpdated = true
        end
        profiller("apply-colors", startTime)
        ]]

        startTime = os_clock()
        for effect in pairs(hideList) do
            _setPosition(effect, hiddenOffset)
        end
        profiller("later-hide", startTime)

        profillerPrint("fill-sum", sumFillTime)
        profillerPrint("extract-sum", sumExtractTime)
        profillerPrint("attach-sum", sumAttachTime)
        profillerPrint("attach-fill-sum", sumAttachFillTime)
        --profillerPrint("isFullChange-sum", sumIsFullChangeTime)
        --sumIsFullChangeTime = 0
        sumFillTime = 0
        sumExtractTime = 0
        sumAttachTime = 0
        sumAttachFillTime = 0
        
        if clearBackplate then
            drawer.setOldChanges(oldChanges)
            --clearBackplate = false
        end

        if clearOnly then
            clearBufferedEffects()
            return
        end

        if contentUpdated then
            lastDrawTickTime = game_getCurrentTick()
            needOptimize = true
        end
    end, nil, function (_, color, changes)
        if backplate then
            oldBackplateColor = color
            effect_setParameter(backplate, "color", color_new_fromSmallNumber(color, alpha))
        elseif color ~= _oldVirtualBackplateColor then
            drawer.fullRefresh()
            _oldVirtualBackplateColor = color
        end
    end, nil, nil, true)

    if not backplate then
        drawer.fullRefresh()
    end

    local canvasWait
    local wait_dataTunnel
    local function _setWait(wait)
        canvasWait = wait
        drawer.setWait(wait)
        if not wait and wait_dataTunnel then
            obj.realPushDataTunnelParams(wait_dataTunnel)
            wait_dataTunnel = nil
        end
    end

    _setWait(true)

    local function recreateCanvas()
        if not lastNewBuffer then
            return
        end

        if backplate and not lastDrawWithClear then --WHAT? (fixed)
            mathPopularColor()
            if lastPopularColor ~= oldBackplateColor then
                effect_setParameter(backplate, "color", color_new_fromSmallNumber(lastPopularColor, alpha))
                oldBackplateColor = lastPopularColor
                drawer.fullRefresh()
            end
        end
        
        local hideList = {}
        for i, effect in pairs(nodeEffects) do
            hideEffectLater(effect, hideList)
        end
        effects = {}
        nodeEffects = {}
        effectDatas = {}

        local changedList = {}
        --local changedColorList = {}

        --local startTime = os.clock()
        local index = 0
        while index <= maxEffectArrayBuffer do
            local px = math_floor(index / sizeY)
            local py = index % sizeY
            local color = lastNewBuffer[index] or lastBase
            if effects[index] then
                index = index + effectDatas[getEIndex(effects[index])+4]
            elseif color ~= oldBackplateColor then
                local eindex = getEIndex(index)

                --[[
                local newRootIndex = tryAttach(changedList, hideList, index, px, py, color, 1, 1)
                if newRootIndex then
                    local newRootEIndex = getEIndex(newRootIndex)
                    index = effectIndexAtPos(px, effectDatas[newRootEIndex+2] + effectDatas[newRootEIndex+4])
                else
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect
                    effects[index] = index

                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = 1
                    effectDatas[eindex+4] = 1
                    
                    changedList[index] = true
                    --changedColorList[index] = true
                    index = index + 1
                end
                ]]

                local bSizeX, bSizeY = getBlockSizeOptimization(index, px, py, color)
                local effect = createEffectUnhide(hideList)

                nodeEffects[index] = effect
                effectDatas[eindex] = color
                effectDatas[eindex+1] = px
                effectDatas[eindex+2] = py
                effectDatas[eindex+3] = bSizeX
                effectDatas[eindex+4] = bSizeY
                fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                
                changedList[index] = true
                index = index + bSizeY
            else
                index = index + 1
            end
        end
        --print("recreate-loop time:", os.clock() - startTime)

        for index in pairs(changedList) do
            setEffectDataParams(index)
        end

        --[[
        local colorobj = color_new(0)
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            colorobj.r, colorobj.g, colorobj.b = hexToRGB(color)
            colorobj.a = alpha / 255
            effect_setParameter(nodeEffects[index], "color", colorobj)
        end
        ]]

        for effect in pairs(hideList) do
            _setPosition(effect, hiddenOffset)
        end
    end

    local _s_pixelSize, _s_offset, _s_rotation
    function obj.setCanvasMaterial(_material)
        material = _material
        local newBackplateExists = not not canvasAPI.multi_layer[tostring(material)]
        local oldBackplateExists = not not backplate

        if newBackplateExists ~= oldBackplateExists then
            _oldVirtualBackplateColor = nil
        end

        local updateParameters = false
        if newBackplateExists then
            if not oldBackplateExists then
                updateParameters = true
                oldBackplateColor = 0
                backplate = sm_effect_createEffect(getEffectName(), parent)
                effect_setParameter(backplate, "color", black)
                effect_setParameter(backplate, "uuid", material)
                if showState then
                    effect_start(backplate)
                end
            else
                effect_stop(backplate)
                effect_setParameter(backplate, "uuid", material)
                effect_start(backplate)
            end
        elseif oldBackplateExists then
            effect_destroy(backplate)
            oldBackplateColor = nil
            backplate = nil
            recreateCanvas()
        end

        for _, effect in pairs(nodeEffects) do
            effect_stop(effect)
            effect_setParameter(effect, "uuid", material)
            effect_start(effect)
        end

        for i = 1, bufferedEffectsIndex do
            local effect = bufferedEffects[i]
            effect_stop(effect)
            effect_setParameter(effect, "uuid", material)
            effect_start(effect)
        end

        local layerCreated = updateAdditionalLayer()

        if updateParameters or layerCreated then
            obj.setPixelSize(_s_pixelSize)
            obj.setOffset(_s_offset, true)
            obj.setCanvasRotation(_s_rotation)
        end
    end

    local function switchHardware()
        obj.setPixelSize(_s_pixelSize)
        obj.setOffset(_s_offset, true)
        obj.setCanvasRotation(_s_rotation)
    end

    local defaultPosition = vec3_new(0, 0, 0)
    local function getSelfPos()
        local pt = type(parent)
        if pt == "Interactable" then
            return parent.shape.worldPosition
        elseif pt == "Character" then
            return parent.worldPosition
        end
        return defaultPosition
    end

    local function updateLayersPos()
        if backplate then
            _setPosition(backplate, rotation * offset)
        end
        if additionalLayer then
            _setPosition(additionalLayer, rotation * (offset + vec3_new(0, 0, 0.0015)))
        end
    end

    local longOptimizeCounter = 0
    local lastOptimizeTime = game_getCurrentTick()
    local function optimize()
        --[[
        if bufferedEffectsIndex > 4096 then
            for i = 1, bufferedEffectsIndex - 4096 do
                effect_stop(bufferedEffects[i])
                stoppedCount = stoppedCount + 1
            end

            --[[
            if bufferedEffectsIndex > 3000 then
                if debugMode then
                    print("destroy buffered effects")
                end

                for i = 3001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                end
                bufferedEffectsIndex = 3000
            end
            ] ]
        end
        ]]

        if longOptimizeCounter >= 3 then
            skipOptimize = true
            if debugMode then
                print("skip optimize")
            end
            return
        end

        local startTime = os_clock()
        recreateCanvas()

        local optimizeTime = os_clock() - startTime
        if optimizeTime > ((1 / 1000) * 50) then
            if debugMode then
                print("long optimize time", optimizeTime)
            end
            longOptimizeCounter = longOptimizeCounter + 1
        end

        lastOptimizeTime = game_getCurrentTick()
    end

    function obj.setAlpha(_alpha)
        alpha = _alpha
        for rindex, effect in pairs(nodeEffects) do
            effect_setParameter(effect, "color", color_new_fromSmallNumber(effectDatas[getEIndex(rindex)], alpha))
        end
    end

    function obj.setCanvasOptimizationLevel(value)
        optimizationLevel = value
        if value == 0 then
            colorEquals = colorEquals_raw
        else
            colorEquals = colorEquals_smart
        end
        optimizationValue = optimizationLevelToValue(optimizationLevel)
    end

    function obj.isRendering()
        return showState
    end

    function obj.disable(state)
        disable = state
    end

    function obj.setRenderDistance(_dist)
        dist = _dist
    end

    local reoptimizeTime = 20
    local reoptimizeDynamicTime = 40
    local canvasSize = sizeX * sizeY
    if canvasSize >= (512 * 512) then
        reoptimizeTime = 40
        reoptimizeDynamicTime = 80
    elseif canvasSize >= (256 * 256) then
        reoptimizeTime = 40
        reoptimizeDynamicTime = 60
    end

    local oldOptimizeTime
    local newShowState = true
    function obj.update()
        if disable then
            newShowState = false
        elseif dist then
            if not pcall(function()
                local currentDist = mathDist(getSelfPos(), sm_localPlayer_getPlayer().character.worldPosition)
                if currentDist <= dist then
                    newShowState = true
                elseif currentDist >= dist + 2 then
                    newShowState = false
                end
            end) then
                newShowState = false
            end
        end

        --recreateCanvas()

        if newShowState ~= showState then
            showState = newShowState
            if newShowState then
                obj.setWait(false)
                if not backplate and not flushedDefault then
                    drawer.flush(true)
                    flushedDefault = true
                end
                for _, effect in pairs(nodeEffects) do
                    if not effect_isPlaying(effect) then
                        effect_start(effect)
                    end
                end
                if backplate then
                    effect_start(backplate)
                end
                if additionalLayer then
                    effect_start(additionalLayer)
                end
            else
                for _, effect in pairs(nodeEffects) do
                    effect_stop(effect)
                end
                for i = 1, bufferedEffectsIndex do
                    effect_stop(bufferedEffects[i])
                end
                if backplate then
                    effect_stop(backplate)
                end
                if additionalLayer then
                    effect_stop(additionalLayer)
                end
                obj.setWait(true)
            end
        end

        local ctick = game_getCurrentTick()
        local optimizePeer = reoptimizeTime
        if lastDrawTickTime then
            if ctick - lastDrawTickTime < 20 then
                optimizePeer = reoptimizeDynamicTime
            end

            if longOptimizeCounter > 0 and (ctick - lastDrawTickTime > 40 * 5 or ctick - lastOptimizeTime > 40 * 10) then
                if debugMode then
                    print("reset longOptimizeCounter", longOptimizeCounter)
                end
                longOptimizeCounter = 0
                if skipOptimize then
                    optimize()
                    longOptimizeCounter = 0
                    skipOptimize = false
                end
            end
        end

        if ctick % 20 == 0 then
            local stoppedCount = 0
            local destroyedCount = 0

            if bufferedEffectsIndex > 6000 then
                for i = 6001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                    destroyedCount = destroyedCount + 1
                end
                bufferedEffectsIndex = 6000
            end

            for i = 1, bufferedEffectsIndex - 1024 do
                local otick = bufferedEffectsUpdateTime[i]
                if otick ~= true and ctick - otick > 160 then
                    bufferedEffectsUpdateTime[i] = true
                    effect_stop(bufferedEffects[i])
                    stoppedCount = stoppedCount + 1
                end
            end

            if debugMode then
                if destroyedCount > 0 then
                    print("destroying buffered effects", destroyedCount)
                end
                print("stoping buffered effects", stoppedCount .. " / " .. bufferedEffectsIndex)
            end
        end

        if newShowState and needOptimize and optimizePeer and (not oldOptimizeTime or ctick - oldOptimizeTime >= optimizePeer) then
            needOptimize = false
            oldOptimizeTime = ctick
            optimize()
        end

        updateLayersPos()
    end

    function obj.setPixelSize(_pixelSize)
        pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
        if type(pixelSize) == "Vec3" then
            _s_pixelSize = vec3_new(pixelSize.x, pixelSize.y, pixelSize.z)
        else
            _s_pixelSize = pixelSize
        end
        if type(pixelSize) == "number" then
            if pixelSize < 0 then
                pixelSize = math_abs(pixelSize)
                local vec = vec3_new(pixelSize, pixelSize, 0)
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            else
                local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            end
        end
        pixelSize.x = pixelSize.x * oldHardwareParams.scale_x * pixelScaleX
        pixelSize.y = pixelSize.y * oldHardwareParams.scale_y * pixelScaleY
        pixelSize.x = pixelSize.x + (0.0025 / sizeX)
        pixelSize.y = pixelSize.y + (0.0025 / sizeY)
        if backplate then
            effect_setScale(backplate, vec3_new(pixelSize.x * sizeX, pixelSize.y * sizeY, pixelSize.z))
        end
        updateLayerDistance(math.max(pixelSize.x * sizeX, pixelSize.y * sizeY) / 1000)
        if additionalLayer then
            effect_setScale(additionalLayer, vec3_new(pixelSize.x * sizeX * 1.005, pixelSize.y * sizeY * 1.005, math.min(2, layerDistance + ((pixelSize.x * sizeX) / 3 / 128))))
        end
        if autoScaleAddValue then
            scaleAddValue = math_min((pixelSize.x + pixelSize.y + pixelSize.z) / 50, 0.0001)
        end
    end

    function obj.setOffset(_offset, noUpdateParameters)
        offset = vec3_new(_offset.x, _offset.y, _offset.z)
        _s_offset = vec3_new(_offset.x, _offset.y, _offset.z)
        offset.x = offset.x + oldHardwareParams.offset_x
        offset.y = offset.y + oldHardwareParams.offset_y
        offset.z = offset.z + oldHardwareParams.offset_z
        updateLayersPos()
        if not noUpdateParameters then
            for index in pairs(nodeEffects) do
                setEffectDataParams(index)
            end
        end
    end

    function obj.setCanvasRotation(_rotation)
        _s_rotation = _rotation
        if type(_rotation) == "Quat" then
        elseif altFromEuler then
            _rotation = custom_fromEulerYEnd(math.rad(_rotation.x) + oldHardwareParams.rotation_x, math.rad(_rotation.y) + oldHardwareParams.rotation_y, math.rad(_rotation.z) + oldHardwareParams.rotation_z)
        else
            _rotation = quat_fromEuler(vec3_new(_rotation.x + math.deg(oldHardwareParams.rotation_x), _rotation.y + math.deg(oldHardwareParams.rotation_y), _rotation.z + math.deg(oldHardwareParams.rotation_z)))
        end
        rotation = _rotation
        if backplate then
            _setRotation(backplate, rotation)
        end
        if additionalLayer then
            _setRotation(additionalLayer, rotation)
        end
        for index, effect in pairs(nodeEffects) do
            _setRotation(effect, rotation)
            setEffectDataParams(index)
        end
        for _, effect in pairs(bufferedEffects) do
            _setRotation(effect, rotation)
        end
    end

    function obj.destroy()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        if backplate then
            effect_destroy(backplate)
        end
        if additionalLayer then
            effect_destroy(additionalLayer)
        end
    end

    local function raw_setResolution(_sizeX, _sizeY)
        drawer.setDrawerResolution(_sizeX, _sizeY)

        for _, effect in pairs(nodeEffects) do
            hideEffect(effect)
        end
        effects = {}
        nodeEffects = {}
        effectDatas = {}
        
        sizeX = _sizeX
        sizeY = _sizeY
        obj.sizeX = sizeX
        obj.sizeY = sizeY
        maxX, maxY = sizeX - 1, sizeY - 1
        maxEffectArrayBuffer = maxX + (maxY * sizeX)
        pixelScaleX, pixelScaleY = defaultSizeX / sizeX, defaultSizeY / sizeY
    end

    function obj.setCanvasResolution(_sizeX, _sizeY)
        raw_setResolution(_sizeX, _sizeY)
        switchHardware()
    end

    ---------------------------------------

    obj.setPixelSize(pixelSize)
    obj.setCanvasRotation(rotation or vec3_new(0, 0, 0))
    obj.setOffset(offset or vec3_new(0, 0, 0))

    ---------------------------------------

    obj.drawer = drawer
    for k, v in pairs(drawer) do
        obj[k] = v
    end
    obj.setWait = _setWait

    function obj.pushDataTunnelParams(dataTunnel)
        if canvasWait then
            wait_dataTunnel = dataTunnel
        else
            wait_dataTunnel = nil
            obj.realPushDataTunnelParams(dataTunnel)
        end
    end

    function obj.realPushDataTunnelParams(dataTunnel)
        obj.setCanvasOptimizationLevel(dataTunnel.optimizationLevel)
        drawer.pushDataTunnelParams(dataTunnel)

        local hardwareParamsChanged = false
        if dataTunnel.res_x ~= sizeX or dataTunnel.res_y ~= sizeY then
            raw_setResolution(dataTunnel.res_x, dataTunnel.res_y)

            hardwareParamsChanged = true
        end

        obj.setAlpha(dataTunnel.light)
        if dataTunnel.material and dataTunnel.material ~= material then
            obj.setCanvasMaterial(dataTunnel.material)
        end
        for key, value in pairs(oldHardwareParams) do
            if dataTunnel[key] ~= value then
                hardwareParamsChanged = true
                oldHardwareParams[key] = dataTunnel[key]
            end
        end
        if hardwareParamsChanged then
            switchHardware()
        end
    end

    return obj
end

--simulates the API of display from SComputers on the client side of your parts
--this is the easiest way to implement the display in your mod
function canvasAPI.createClientScriptableCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local dataTunnel = {}
    local canvas = canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local api = canvasAPI.createScriptableApi(sizeX, sizeY, dataTunnel, nil, canvas.drawer, canvasAPI.materialList, 1, {
        maxOffset = math.huge,
        maxScale = math.huge
    }, {
        maxPixels = math.huge
    })
    api.registerClick = canvasAPI.addTouch(api, dataTunnel)
    api.dataTunnel = dataTunnel
    api.canvas = canvas

    local renderDistance = 15

    for k, v in pairs(canvas) do
        if k ~= "flush" then
            api[k] = v
        end
    end

    function api.getAudience()
        return canvas.isRendering() and 1 or 0
    end

    function api.update()
        canvas.disable(not api.isAllow())
        if dataTunnel.renderAtDistance then
            canvas.setRenderDistance()
        else
            canvas.setRenderDistance(renderDistance)
        end
        canvas.pushDataTunnelParams(dataTunnel)
        canvas.update()
        dataTunnel.scriptableApi_update()

        if dataTunnel.display_reset then
            canvas.drawerReset()
            dataTunnel.display_reset = nil
        end

        if dataTunnel.display_flush then
            if needPushStack(canvas, dataTunnel) then
                canvas.pushStack(dataTunnel.display_stack)
                canvas.flush()
            end
            
            dataTunnel.display_flush()
            dataTunnel.display_stack = nil
            dataTunnel.display_flush = nil
            dataTunnel.display_forceFlush = nil
        end
    end

    function api.setRenderDistance(dist)
        renderDistance = dist
    end

    return api
end

local customFontIndexesCache = {}
local checkedFonts = {}

--implement the SComputers API, does not implement data transfer
function canvasAPI.createScriptableApi(width, height, dataTunnel, flushCallback, drawer, materialList, defaultMaterial, allowHoloAPI, allowSetResolution)
    local defaultResolutionX, defaultResolutionY = width, height
    
    dataTunnel = dataTunnel or {}
    dataTunnel.rotation = 0
    dataTunnel.light = DEFAULT_ALPHA_VALUE
    dataTunnel.skipAtNotSight = false
    dataTunnel.utf8support = false
    dataTunnel.renderAtDistance = false
    dataTunnel.display_forceFlush = true
    dataTunnel.dataUpdated = true
    dataTunnel.optimizationLevel = 16

    local stack = {}
    local stackIndex = 1
    local pixelsCache = {} --optimizations for cameras
    local pixelsCacheExists = false
    local oldStackSum, oldDataSum, oldStack, oldStackIndex
    local forceFlag = false

    local function clearStackForce()
        stack = {}
        stackIndex = 1
    end

    local function clearStack()
        if dataTunnel.display_stack == stack then
            clearStackForce()
        end
    end

    local function setForceFrame()
        if pixelsCacheExists then
            pixelsCache = {}
            pixelsCacheExists = false
        end
        forceFlag = true
        dataTunnel.display_forceFlush = true
    end

    local oldPlayersCount = #sm.player.getAllPlayers()
    function dataTunnel.scriptableApi_update()
        local playersCount = #sm.player.getAllPlayers()
        --local force = sm.game.getCurrentTick() % 80 == 0
        local force = false
        if oldPlayersCount ~= playersCount or force then
            --dataTunnel.display_forceForceFlush = force
            setForceFrame()
            oldPlayersCount = playersCount
        end
    end

    local rwidth, rheight = width, height
    local rmwidth, rmheight = width - 1, height - 1
    local utf8support = false
    local monoFont = true
    local newDataFlag = false
    local spacing = 1
    local fontIndex = 0
    local lastPixelX, lastPixelY, lastPixelColor, lastAction
    local currentSettedFont
    local currentTouchs = {}

    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local dFontX, dFontY = defaultFont.width, defaultFont.height
    local drFontX, drFontY = defaultFont.width, defaultFont.height
    local fontX, fontY
    local mFontX, mFontY
    local xFontX, xFontY
    local sFontX, sFontY
    local rFontX, rFontY
    local fontScaleX, fontScaleY = 1, 1
    local function updateFontSize()
        fontX, fontY = math_ceil(dFontX * fontScaleX), math_ceil(dFontY * fontScaleY)
        rFontX, rFontY = math_ceil(drFontX * fontScaleX), math_ceil(drFontY * fontScaleY)
        mFontX, mFontY = fontX - 1, fontY - 1
        xFontX, xFontY = fontX + 1, fontY + 1
        sFontX, sFontY = fontX + spacing, fontY + 1
    end
    updateFontSize()

    ---------------- color equals check
    local optimizationValue = optimizationLevelToValue(16)

    --local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
    local function colorEquals_smart(color1, color2)
        if color1 == color2 then return true end
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        --return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
        return ((math_abs(rVal - rVal2) + math_abs(gVal - gVal2) + math_abs(bVal - bVal2)) / 1024) <= optimizationValue
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    ----------------

    local api
    local api_flush
    api = {
        --[[
        getBuffer = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,
        getCurrent = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getRealBuffer(x + (y * rwidth))
        end,
        ]]
        get = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,

        -- not implemented (implement it yourself if necessary)
        isAllow = function()
            return true
        end,
        getAudience = function()
            return 1
        end,

        setOptimizationLevel = function(value)
            checkArg(1, value, "number")
            value = round(value)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.optimizationLevel ~= value then
                optimizationValue = optimizationLevelToValue(value)
                if value == 0 then
                    colorEquals = colorEquals_raw
                else
                    colorEquals = colorEquals_smart
                end

                dataTunnel.optimizationLevel = value
                dataTunnel.dataUpdated = true
            end
        end,
        getOptimizationLevel = function()
            return dataTunnel.optimizationLevel
        end,


        -- stubs (outdated methods)
        optimize = function() end,
        setFrameCheck = function () end,
        getFrameCheck = function () return false end,
        setSkipAtLags = function() end,
        getSkipAtLags = function() return false end,


        -- main
        setFontScale = function(scaleX, scaleY)
            checkArg(1, scaleX, "number")
            checkArg(2, scaleY, "number")
            if scaleX < 0 then scaleX = 0 end
            if scaleY < 0 then scaleY = 0 end
            fontScaleX, fontScaleY = scaleX, scaleY
            updateFontSize()
        end,
        getFontScale = function()
            return fontScaleX, fontScaleY
        end,
        setTextSpacing = function(_spacing)
            if _spacing < 0 then _spacing = 0 end
            spacing = _spacing
            updateFontSize()
        end,
        setFontSize = function(_width, _height)
            api.setFontScale(_width / dFontX, _height / dFontY)
        end,
        getTextSpacing = function()
            return spacing
        end,
        calcTextBox = function(text) --it will return two numbers, this will be the size of the box that your text will occupy with this font and this scale
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local totalSize = 0
            if monoFont then
                totalSize = textLen * (fontX + spacing)
            else
                local localFontWidth = dFontX
                local localFont = dataTunnel.customFont or font.optimized
                if fontIndex > 0 and fontsOptimized[fontIndex] then
                    localFont = fontsOptimized[fontIndex]
                    localFontWidth = localFont.width
                end

                local char, chrdata
                for i = 1, textLen do
                    char = sep(text, i, i)
                    if char ~= " " and char ~= spaceCharCode then
                        chrdata = localFont[char] or localFont.error or defaultError
                        totalSize = totalSize + (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                    else
                        totalSize = totalSize + (localFont.spaceSize or localFontWidth) + spacing
                    end
                    canvasAPI.yield()
                end
            end

            return totalSize - spacing, fontY
        end,
        calcCharsSize = function(text) --calculates the length of each character in a string, taking into account its spacing from the next character, and returns a table with these values
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    table_insert(lens, (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing)
                else
                    table_insert(lens, (localFont.spaceSize or localFontWidth) + spacing)
                end
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        calcDecreasingTextSizes = function(text) --it works almost like calcCharsSize. however, each value contains all the previous ones. this is used in the graphic.textBox function, but probably not applicable to any other
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}
            local otherVals = 0

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                local val
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    val = (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                else
                    val = (localFont.spaceSize or localFontWidth) + spacing
                end
                otherVals = otherVals + val
                table_insert(lens, otherVals)
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        isMonospacedFont = function()
            return not not monoFont
        end,

        getWidth = function()
            return rwidth
        end,
        getHeight = function()
            return rheight
        end,
        getSize = function()
            return rwidth, rheight
        end,
        getResolution = function()
            return rwidth, rheight
        end,

        clear = function(color)
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end

            lastAction = nil

            clearStackForce()
            stackIndex = 4
            stack[1] = resetViewportCodeID
            stack[2] = 0
            stack[3] = formatColorToSmallNumber(color, blackSmallNumber)
            
            --[[
            for i = 3, stackIndex - 1 do
                stack[i] = nil
            end
            stackIndex = 3
            ]]
        end,
        drawPixel = function(x, y, color)
            x, y = round(x), round(y)
            if x < 0 or x >= width or y < 0 or y >= height then return end
            local index = x + (y * rwidth)
            color = formatColorToSmallNumber(color, whiteSmallNumber)
            if pixelsCache[index] ~= color then
                if lastAction and x == lastPixelX + 1 and y == lastPixelY and colorEquals(lastPixelColor, color) then
                    if lastAction == 1 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 12
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 1
                elseif lastAction and x == lastPixelX - 1 and y == lastPixelY and colorEquals(lastPixelColor, color) then
                    if lastAction == 2 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 13
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 2
                elseif lastAction and x == lastPixelX and y == lastPixelY + 1 and colorEquals(lastPixelColor, color) then
                    if lastAction == 3 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 14
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 3
                elseif lastAction and x == lastPixelX and y == lastPixelY - 1 and colorEquals(lastPixelColor, color) then
                    if lastAction == 4 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 15
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 4
                else
                    lastPixelColor = color

                    stack[stackIndex] = 16
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = index
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = color
                    stackIndex = stackIndex + 1

                    lastAction = 0
                end

                lastPixelX, lastPixelY = x, y
                pixelsCache[index] = color
                pixelsCacheExists = true
            end
        end,
        fillRect = function(x, y, sizeX, sizeY, color)
            if x <= 0 and y <= 0 and x + sizeX >= width and y + sizeY >= height then
                return api.clear(color or 0xffffff)
            end

            stack[stackIndex] = 2
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawRect = function(x, y, sizeX, sizeY, color, lineWidth)
            lineWidth = round(lineWidth or 1)
            if lineWidth < 1 then
                lineWidth = 1
            end

            stack[stackIndex] = 3
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = lineWidth
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawText = function(x, y, text, color)
            if y > rmheight or y + mFontY < 0 or fontScaleX <= 0 or fontScaleY <= 0 then return end
            text = tostring(text)

            if monoFont then
                local maxTextLen = math_ceil((width - x) / sFontX)
                if maxTextLen <= 0 then return end
                local startTextFrom = math_max(1, math_floor(-x / sFontX) + 1)

                if utf8support then
                    if utf8.len(text) > maxTextLen or startTextFrom > 1 then
                        text = utf8.sub(text, startTextFrom, maxTextLen)
                    end
                else
                    if #text > maxTextLen or startTextFrom > 1 then
                        text = text:sub(startTextFrom, maxTextLen)
                    end
                end

                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x) + ((startTextFrom - 1) * sFontX)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            else
                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCenteredText = function(x, y, text, color, centerX, centerY)
            if centerX == nil then centerX = true end
            if centerY == nil then centerY = true end
            
            local sizeX, sizeY
            if centerX or centerY then
                sizeX, sizeY = api.calcTextBox(text)
            end

            if centerX then
                x = x - (sizeX / 2)
            end

            if centerY then
                y = y - (sizeY / 2)
            end

            api.drawText(x, y, text, color)
        end,
        drawLine = function(x, y, x2, y2, color, width, roundFlag)
            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            stack[stackIndex] = 5
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = width
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 6
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end
            
            stack[stackIndex] = 7
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleEvenly = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 8
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleVeryEvenly = function (x, y, r, color, stroke)
            if r > 1024 then r = 1024 end
            if not stroke or stroke < 1 then stroke = 1 end

            stack[stackIndex] = 9
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(stroke)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawPoly = function(color, ...)
            api.drawWidePoly(color, 1, false, ...)
        end,
        drawWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 10
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillPoly = function(color, ...)
            api.fillWidePoly(color, 1, false, ...)
        end,
        fillWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 11
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawTriangle = function(x1, y1, x2, y2, x3, y3, color)
            api.drawPoly(color, x1, y1, x2, y2, x3, y3)
        end,
        fillTriangle = function(x1, y1, x2, y2, x3, y3, color)
            api.fillPoly(color, x1, y1, x2, y2, x3, y3)
        end,
        flush = function()
            lastAction = nil
            api.setViewport()

            if dataTunnel.display_flush and dataTunnel.display_stack == stack then
                return
            end

            local needFlush = forceFlag
            --print("--------------------------- FLUSH 1", needFlush, stack, stackChecksum(stack), stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel)))

            if not needFlush and stackIndex ~= oldStackIndex then
                --print("FLUSH 2", stackIndex, oldStackIndex)
                needFlush = true
            end

            if not needFlush and newDataFlag then
                local dataSum = stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel))
                if dataSum ~= oldDataSum then
                    --print("FLUSH 3")
                    needFlush = true
                    oldDataSum = dataSum
                end
            end

            if not needFlush and stack ~= oldStack then
                for i = 1, stackIndex - 1 do
                    if stack[i] ~= oldStack[i] then
                        needFlush = true
                        --print("FLUSH 4", oldStack)
                        break
                    end
                end
            end

            --[[
            if needFlush then
                oldStackSum = nil
            else
                local stachSum = stackChecksum(stack)
                if stachSum ~= oldStackSum then
                    --print("FLUSH 5")
                    needFlush = true
                    oldStackSum = stachSum
                end
            end
            ]]
            
            if needFlush then
                --print("FLUSH ACTION")
                oldStack = stack
                oldStackIndex = stackIndex

                dataTunnel.display_stack = stack
                dataTunnel.display_flush = clearStack
                
                if flushCallback then
                    flushCallback()
                end
            else
                clearStackForce()
            end

            forceFlag = false
            newDataFlag = false
        end,
        forceFlush = function()
            api_flush()
            dataTunnel.display_forceFlush = true
        end,

        -- settings
        setUtf8Support = function (state)
            if type(state) == "boolean" then
                if dataTunnel.utf8support ~= state then
                    dataTunnel.utf8support = state
                    dataTunnel.dataUpdated = true
                    newDataFlag = true
                    utf8support = state
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getUtf8Support = function () return dataTunnel.utf8support end,

        setRenderAtDistance = function (c)
            if type(c) == "boolean" then
                if dataTunnel.renderAtDistance ~= c then
                    dataTunnel.renderAtDistance = c
                    dataTunnel.dataUpdated = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getRenderAtDistance = function () return dataTunnel.renderAtDistance end,

        setRotation = function (rotation)
            if type(rotation) == "number" and rotation % 1 == 0 and rotation >= 0 and rotation <= 3 then
                if rotation ~= dataTunnel.rotation then
                    dataTunnel.rotation = rotation
                    dataTunnel.dataUpdated = true
                    newDataFlag = true

                    if pixelsCacheExists then
                        pixelsCache = {}
                        pixelsCacheExists = false
                    end

                    if rotation == 1 or rotation == 3 then
                        rwidth = height
                        rheight = width
                    else
                        rwidth = width
                        rheight = height
                    end
                    rmheight = rheight - 1
                    rmwidth = rwidth - 1
                end
            else
                error("integer must be in [0; 3]", 2)
            end
        end,
        getRotation = function () return dataTunnel.rotation end,

        setFont = function (customFont)
            checkArg(1, customFont, "table", "nil")
            currentSettedFont = customFont
            fontIndex = 0
            if dataTunnel.customFont then
                dataTunnel.dataUpdated = true
                dataTunnel.customFont = nil
            end
            if customFont then
                if not checkedFonts[customFont] then
                    checkFont(customFont)
                    checkedFonts[customFont] = true
                end
                dFontX, dFontY = customFont.width, customFont.height
                drFontX, drFontY = customFont.returnWidth or customFont.width, customFont.returnHeight or customFont.height
                fontIndex = customFontIndexesCache[customFont]
                if not fontIndex then
                    fontIndex = 0
                    for _, v in pairs(fonts) do
                        if v == customFont then
                            fontIndex = v.index
                        end
                    end
                    customFontIndexesCache[customFont] = fontIndex
                end
                if fontIndex == 0 then
                    dataTunnel.customFont = font.optimizeFont(customFont)
                    dataTunnel.dataUpdated = true
                end
                monoFont = customFont.mono or customFont.mono == nil
            else
                dFontX, dFontY = defaultFont.width, defaultFont.height
                drFontX, drFontY = defaultFont.width, defaultFont.height
                monoFont = true
            end
            updateFontSize()
            newDataFlag = true
        end,
        getFont = function()
            return currentSettedFont
        end,

        getFontWidth = function ()
            return rFontX
        end,
        getFontHeight = function ()
            return rFontY
        end,
        getFontSize = function()
            return rFontX, rFontY
        end,

        getRealFontWidth = function ()
            return drFontX
        end,
        getRealFontHeight = function ()
            return drFontY
        end,
        getRealFontSize = function()
            return drFontX, drFontY
        end,

        setSkipAtNotSight = function (state)
            checkArg(1, state, "boolean")
            if dataTunnel.skipAtNotSight ~= state then
                dataTunnel.skipAtNotSight = state
                dataTunnel.dataUpdated = true
            end
        end,
        getSkipAtNotSight = function () return dataTunnel.skipAtNotSight end,

        getViewport = function()
            return viewport_x, viewport_y, viewport_sx, viewport_sy
        end,
        setViewport = function(x, y, sizeX, sizeY)
            if x or y or sizeX or sizeY then
                viewport_x, viewport_y, viewport_sx, viewport_sy = x or 0, y or 0, sizeX or api.getWidth(), sizeY or api.getHeight()
                stack[stackIndex] = -1
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sx)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sy)
                stackIndex = stackIndex + 1
            else
                viewport_x, viewport_y, viewport_sx, viewport_sy = nil, nil, nil, nil
                stack[stackIndex] = resetViewportCodeID
                stackIndex = stackIndex + 1
            end
        end,
        setInlineViewport = function(x, y, sizeX, sizeY)
            if viewport_x then
                local x2 = x + (sizeX - 1)
                local y2 = y + (sizeY - 1)
                local px2 = viewport_x + (viewport_sx - 1)
                local py2 = viewport_y + (viewport_sy - 1)
                if x < viewport_x then x = viewport_x elseif x > px2 then x = px2 end
                if y < viewport_y then y = viewport_y elseif y > py2 then y = py2 end
                if x2 < viewport_x then x2 = viewport_x elseif x2 > px2 then x2 = px2 end
                if y2 < viewport_y then y2 = viewport_y elseif y2 > py2 then y2 = py2 end
                api.setViewport(x, y, (x2 - x) + 1, (y2 - y) + 1)
            else
                api.setViewport(x, y, sizeX, sizeY)
            end
        end,

        setBrightness = function(value) --legacy
            checkArg(1, value, "number")
            --[[
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.brightness ~= value then
                dataTunnel.brightness = value
                dataTunnel.dataUpdated = true
            end
            ]]
        end,
        getBrightness = function() --legacy
            --return dataTunnel.brightness
            return 1
        end,

        setLight = function(value)
            checkArg(1, value, "number")
            value = math_floor(value + 0.5)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.light ~= value then
                dataTunnel.light = value
                dataTunnel.dataUpdated = true
            end
        end,
        getLight = function(value)
            return dataTunnel.light
        end,

        getDefaultResolution = function()
            return defaultResolutionX, defaultResolutionY
        end,

        getTouchs = function()
            for i = 1, MAX_CLICKS do
                local click = api.getClick()
                if not click then
                    break
                end
                local index = #currentTouchs + 1
                for lindex, lclick in reverse_ipairs(currentTouchs) do
                    if lclick.nickname == click.nickname and lclick.button == click.button then
                        index = lindex
                        break
                    end
                end
                if click.state == "released" then
                    table.remove(currentTouchs, index)
                else
                    currentTouchs[index] = click
                end
            end

            return currentTouchs
        end,

        getTouch = function()
            return api.getTouchs()[1]
        end,

        reset = function()
            currentTouchs = {}
            if api.setMaterial then api.setMaterial(api.getDefaultMaterial()) end
            if api.setFontScale then api.setFontScale(1, 1) end
            if api.setTextSpacing then api.setTextSpacing(1) end
            if api.setFont then api.setFont() end
            if api.setRotation then api.setRotation(0) end
            if api.setUtf8Support then api.setUtf8Support(false) end
            if api.setClicksAllowed then api.setClicksAllowed(false) end
            if api.setMaxClicks then api.setMaxClicks(MAX_CLICKS) end
            if api.clearClicks then api.clearClicks() end
            if api.setSkipAtNotSight then api.setSkipAtNotSight(false) end
            if api.setRenderAtDistance then api.setRenderAtDistance(false) end
            if api.setViewport then api.setViewport() end
            if api.setLight then api.setLight(DEFAULT_ALPHA_VALUE) end
            if api.setOptimizationLevel then api.setOptimizationLevel(16) end
            if api.setHoloOffset then api.setHoloOffset(0, 0, 0) end
            if api.setHoloRotation then api.setHoloRotation(0, 0, 0) end
            if api.setHoloScale then api.setHoloScale(1, 1) end
            if api.setResolution then api.setResolution(defaultResolutionX, defaultResolutionY) end
            dataTunnel.display_reset = true
        end
    }

    if materialList then
        defaultMaterial = defaultMaterial or (materialList[0] and 0 or 1)
        local currentMaterialID

        function api.setMaterial(materialId)
            checkArg(1, materialId, "number")
            currentMaterialID = materialId
            if not materialList[currentMaterialID] then
                currentMaterialID = defaultMaterial
            end
            local material = materialList[currentMaterialID]
            if material == true then
                error("this material is not supported on this display", 2)
            end
            if dataTunnel.material ~= material then
                dataTunnel.material = material
                dataTunnel.dataUpdated = true
            end
        end

        function api.getMaterial()
            return currentMaterialID
        end

        function api.getDefaultMaterial()
            return defaultMaterial
        end

        api.setMaterial(api.getDefaultMaterial())
    end

    dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z = 0, 0, 0
    dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z = 0, 0, 0
    dataTunnel.scale_x, dataTunnel.scale_y = 1, 1
    if allowHoloAPI then
        local maxOffset = 5
        local maxScale = 5
        if type(allowHoloAPI) == "table" then
            maxOffset = allowHoloAPI.maxOffset or maxOffset
            maxScale = allowHoloAPI.maxScale or maxScale
        end

        function api.setHoloOffset(x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")
            
            if x < -maxOffset then x = -maxOffset end
            if y < -maxOffset then y = -maxOffset end
            if z < -maxOffset then z = -maxOffset end
            if x > maxOffset then x = maxOffset end
            if y > maxOffset then y = maxOffset end
            if z > maxOffset then z = maxOffset end

            if x ~= dataTunnel.offset_x or y ~= dataTunnel.offset_y or z ~= dataTunnel.offset_z then
                dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z = x, y, z
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloOffset()
            return dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z
        end

        function api.setHoloRotation(x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")
            if x ~= dataTunnel.rotation_x or y ~= dataTunnel.rotation_y or z ~= dataTunnel.rotation_z then
                dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z = x, y, z
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloRotation()
            return dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z
        end

        function api.setHoloScale(x, y)
            checkArg(1, x, "number")
            checkArg(2, y, "number")

            if x < 0 then x = 0 end
            if y < 0 then y = 0 end
            if x > maxScale then x = maxScale end
            if y > maxScale then y = maxScale end

            if x ~= dataTunnel.scale_x or y ~= dataTunnel.scale_y then
                dataTunnel.scale_x, dataTunnel.scale_y = x, y
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloScale()
            return dataTunnel.scale_x, dataTunnel.scale_y
        end
    end

    dataTunnel.res_x, dataTunnel.res_y = defaultResolutionX, defaultResolutionY
    if allowSetResolution then
        if type(allowSetResolution) ~= "table" then
            allowSetResolution = {
                maxPixels = 4096 * 4096,
                maxWidth = 4096,
                maxHeight = 4096
            }
        end

        function api.setResolution(resX, resY)
            checkArg(1, resX, "number")
            checkArg(2, resY, "number")

            resX = math.floor(resX)
            resY = math.floor(resY)
            if resX < 1 then resX = 1 end
            if resY < 1 then resY = 1 end

            if allowSetResolution.maxWidth and resX > allowSetResolution.maxWidth then
                error("the width resolution has been exceeded. maximum: " .. allowSetResolution.maxWidth, 2)
            end

            if allowSetResolution.maxHeight and resX > allowSetResolution.maxHeight then
                error("the height resolution has been exceeded. maximum: " .. allowSetResolution.maxHeight, 2)
            end

            if allowSetResolution.maxPixels and (resX * resY) > allowSetResolution.maxPixels then
                error("the total maximum number of pixels has been exceeded. maximum: " .. allowSetResolution.maxPixels, 2)
            end
            
            if resX ~= dataTunnel.res_x or resY ~= dataTunnel.res_y then
                dataTunnel.res_x, dataTunnel.res_y = resX, resY
                dataTunnel.dataUpdated = true
                dataTunnel.resolutionChanged = true

                if pixelsCacheExists then
                    pixelsCache = {}
                    pixelsCacheExists = false
                end

                width, height = resX, resY
                if dataTunnel.rotation == 1 or dataTunnel.rotation == 3 then
                    rwidth = height
                    rheight = width
                else
                    rwidth = width
                    rheight = height
                end
                rmheight = rheight - 1
                rmwidth = rwidth - 1
            end
        end
    end

    api.update = api.flush
    api.getBuffer = api.get
    api.getCurrent = api.get
    api_flush = api.flush

    local internal = {
        rawPush = function(tbl)
            for i = 1, #tbl do
                stack[stackIndex] = tbl[i]
                stackIndex = stackIndex + 1
            end
        end,
        setForceFrame = setForceFrame
    }

    return api, internal
end

--adds a touch screen API (does not implement click processing)
function canvasAPI.addTouch(api, dataTunnel)
    dataTunnel = dataTunnel or {}
    dataTunnel.clicksAllowed = false
    dataTunnel.maxClicks = MAX_CLICKS
    dataTunnel.clickData = {}

    api.getClick = function ()
        return (table_remove(dataTunnel.clickData, 1))
    end

    api.setMaxClicks = function (c)
        if type(c) == "number" and c % 1 == 0 and c > 0 and c <= 16 then
            dataTunnel.maxClicks = c
        else
            error("integer must be in [1; 16]", 2)
        end
    end

    api.getMaxClicks = function ()
        return dataTunnel.maxClicks
    end

    api.clearClicks = function ()
        dataTunnel.clickData = {}
    end

    api.setClicksAllowed = function (c)
        if type(c) == "boolean" then
            if dataTunnel.clicksAllowed ~= c then
                dataTunnel.clicksAllowed = c
                dataTunnel.dataUpdated = true
            end
        else
            error("Type must be boolean", 2)
        end
    end

    api.getClicksAllowed = function ()
        return dataTunnel.clicksAllowed
    end

    return function (tbl)
        tbl.x = tbl[1] or tbl.x
        tbl.y = tbl[2] or tbl.y
        tbl.state = tbl[3] or tbl.state
        tbl.button = tbl[4] or tbl.button
        tbl.nickname = tbl[5] or tbl.nickname
        tbl[1] = tbl.x or tbl[1]
        tbl[2] = tbl.y or tbl[2]
        tbl[3] = tbl.state or tbl[3]
        tbl[4] = tbl.button or tbl[4]
        tbl[5] = tbl.nickname or tbl[5]
        if #dataTunnel.clickData < dataTunnel.maxClicks then
            table_insert(dataTunnel.clickData, tbl)
        end
    end
end

--leaves only those tunnel fields that are needed for transmission over the network
function canvasAPI.minimizeDataTunnel(dataTunnel)
    return {
        clicksAllowed = dataTunnel.clicksAllowed,
        rotation = dataTunnel.rotation,
        renderAtDistance = dataTunnel.renderAtDistance,
        skipAtNotSight = dataTunnel.skipAtNotSight,
        utf8support = dataTunnel.utf8support,
        customFont = dataTunnel.customFont,
        display_reset = dataTunnel.display_reset,
        optimizationLevel = dataTunnel.optimizationLevel,
        light = dataTunnel.light,
        material = dataTunnel.material,

        offset_x = dataTunnel.offset_x,
        offset_y = dataTunnel.offset_y,
        offset_z = dataTunnel.offset_z,

        rotation_x = dataTunnel.rotation_x,
        rotation_y = dataTunnel.rotation_y,
        rotation_z = dataTunnel.rotation_z,

        scale_x = dataTunnel.scale_x,
        scale_y = dataTunnel.scale_y,

        res_x = dataTunnel.res_x,
        res_y = dataTunnel.res_y
    }
end

-------- additional
canvasAPI.stackChecksum = stackChecksum
canvasAPI.formatColor = formatColor
canvasAPI.formatColorToNumber = formatColorToNumber
canvasAPI.formatColorToSmallNumber = formatColorToSmallNumber
canvasAPI.checkFont = checkFont
canvasAPI.simpleRemathRect = simpleRemathRect
canvasAPI.remathRect = remathRect
canvasAPI.hexToRGB = hexToRGB
canvasAPI.hexToRGB256 = hexToRGB256
canvasAPI.posCheck = posCheck
canvasAPI.mathDist = mathDist
canvasAPI.needPushStack = needPushStack
canvasAPI.font = font
canvasAPI.tableClone = tableClone
canvasAPI.canvasService = canvasService
canvasAPI.userCalls = userCalls
canvasAPI.dataSizes = dataSizes
canvasAPI.color_new_fromSmallNumber = color_new_fromSmallNumber
canvasAPI.getEffectName = getEffectName
canvasAPI.fonts = fonts
canvasAPI.utf8 = utf8

function canvasAPI.pushData(stack, ...)
    for i, v in ipairs({...}) do
        table.insert(stack, v)
    end
end

_G.canvasAPI = canvasAPI
end
function scmframework_3307c56d958dfe850835ec69c980b7ee() --$CONTENT_DATA/Scripts/canvasAPI/backup/canvas_best4.lua
print("> canvas.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/luajit.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/load.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/utf8.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/canvasService.lua")

local debugMode = false
local profileMode = false

local canvasAPI = {
    draw = {
        clear = 0,
        set   = 1,
        fill  = 2,
        rect  = 3,
        text  = 4,
        line  = 5,
        circle  = 6,
        circleF = 7,
        circleE = 8,
        circleVE = 9,
        poly = 10,
        polyF = 11,

        copyNX = 12,
        copyPX = 13,
        copyNY = 14,
        copyPY = 15,
        setI = 16
    },
    material = {
        glass = sm.uuid.new("a683f897-5b8a-4c96-9c46-7b9fbc76d186"),
        classic = sm.uuid.new("8328a29d-35e0-471b-8bfe-06952e9d916d"),
        plastic = sm.uuid.new("82d2da58-6597-4ffa-9b53-1af3b707fa7a"),
        smoothed = sm.uuid.new("a23a4ea2-96da-4bb2-a723-af8c27de2511"),
        glowing = sm.uuid.new("b46ae32a-9037-4360-9f98-3bef1cd4f366")
    },
    multi_layer = {}
}

canvasAPI.multi_layer[tostring(canvasAPI.material.classic)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.plastic)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.smoothed)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.glowing)] = true
canvasAPI.version = 55

canvasAPI.materialList = {
    [0] = canvasAPI.material.glass,
    canvasAPI.material.classic,
    canvasAPI.material.plastic,
    canvasAPI.material.smoothed,
    canvasAPI.material.glowing
}

canvasAPI.materialListWithoutGlass = {
    [0] = true,
    canvasAPI.material.classic,
    canvasAPI.material.plastic,
    canvasAPI.material.smoothed,
    canvasAPI.material.glowing
}

local MAX_DRAW_TIME = 2 --protecting the world from crashing using the display
local FONT_SIZE_LIMIT = 256
local DEFAULT_ALPHA_VALUE = 255
local MAX_CLICKS = 16
canvasAPI.DEFAULT_ALPHA_VALUE = DEFAULT_ALPHA_VALUE

local font = font
local defaultFont = font.default
local fonts = font.fonts
local fontsOptimized = font.fontsOptimized
local spaceCharCode = string.byte(" ")

local huge = math.huge
local string_len = string.len
local bit = bit or bit32
local bit_rshift = bit.rshift
local bit_lshift = bit.lshift
local utf8 = utf8
local string = string
local table_sort = table.sort
local type = type
local math_ceil = math.ceil
local math_max = math.max
local string_format = string.format
local table_insert = table.insert
local table_remove = table.remove
local math_floor = math.floor
local vec3_new = sm.vec3.new
local color_new = sm.color.new
local quat_fromEuler = sm.quat.fromEuler
local ipairs = ipairs
local pairs = pairs
local string_byte = string.byte
local defaultError = font.optimized.error
local tostring = tostring
local math_abs = math.abs
local math_min = math.min
local string_sub = string.sub
local table_concat = table.concat
local tonumber = tonumber
local utf8_len = utf8.len
local utf8_sub = utf8.sub
local sm_localPlayer_getPlayer = sm.localPlayer.getPlayer
local os_clock = os.clock
local math_sqrt = math.sqrt
local quat_new = sm.quat.new
local game_getCurrentTick = sm.game.getCurrentTick

local black = color_new(0, 0, 0)
local white = color_new(1, 1, 1)
local blackNumber = 0x000000ff
local whiteNumber = 0xffffffff
local blackSmallNumber = 0x000000
local whiteSmallNumber = 0xffffff

local getEffectName
do
    local currentEffect = 1
    local effectsNames = {}

    for i = 0, 255 do
        table_insert(effectsNames, "ShapeRenderable" .. tostring(i))
    end

    function getEffectName()
        local name = effectsNames[currentEffect]
        currentEffect = currentEffect + 1
        if currentEffect > #effectsNames then
            currentEffect = 1
        end
        return name
    end
end

local function profillerPrint(name, execTime)
    local t = execTime * 1000
    if profileMode and t > 0 then
        print("profiller", name, t)
    end
end

local function profiller(name, startTime)
    profillerPrint(name, os_clock() - startTime)
end

--[[
local sm_effect_createEffect = sm.effect.withoutHook_createEffect or sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local withoutHookEmptyEffect = emptyEffect
local whook = "withoutHook_"
if better and better.version >= 45 and better.isAvailable() then
    local mt = getmetatable(emptyEffect)
    local newMt = {}
    for k, v in pairs(mt) do
        newMt[k] = v
    end
    for k, v in pairs(mt) do
        if k:sub(1, #whook) == whook then
            newMt[k:sub(#whook + 1, #k)] = v
        end
    end
    withoutHookEmptyEffect = setmetatable({}, newMt)
end
local effect_setParameter = withoutHookEmptyEffect.setParameter
local effect_stop = withoutHookEmptyEffect.stop
local effect_destroy = withoutHookEmptyEffect.destroy
local effect_start = withoutHookEmptyEffect.start
local effect_isDone = withoutHookEmptyEffect.isDone
local effect_isPlaying = withoutHookEmptyEffect.isPlaying
local effect_setScale = withoutHookEmptyEffect.setScale
local effect_setOffsetPosition = withoutHookEmptyEffect.setOffsetPosition
local effect_setOffsetRotation = withoutHookEmptyEffect.setOffsetRotation
effect_destroy(emptyEffect)
]]

local sm_effect_createEffect = sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local effect_setParameter = emptyEffect.setParameter
local effect_stop = emptyEffect.stop
local effect_destroy = emptyEffect.destroy
local effect_start = emptyEffect.start
local effect_isDone = emptyEffect.isDone
local effect_isPlaying = emptyEffect.isPlaying
local effect_setScale = emptyEffect.setScale
local effect_setOffsetPosition = emptyEffect.setOffsetPosition
local effect_setOffsetRotation = emptyEffect.setOffsetRotation
local effect_setPosition = emptyEffect.setPosition
local effect_setRotation = emptyEffect.setRotation
effect_destroy(emptyEffect)

local function reverse_ipairs(t)
    local i = #t + 1
    return function()
        i = i - 1
        if i > 0 then
            return i, t[i]
        end
    end
end

local function round(number)
    return math_floor(number + 0.5)
end

local function checkFont(lfont)
    if type(lfont) ~= "table" then
        error("the font should be a table", 3)
    end

    if lfont.mono or lfont.mono == nil then
        if type(lfont.chars) ~= "table" or (type(lfont.width) ~= "number") or (type(lfont.height) ~= "number") then
            error("invalid basic char data", 3)
        end
        
        if lfont.width > FONT_SIZE_LIMIT then
            error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
        elseif lfont.height > FONT_SIZE_LIMIT then
            error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
        end

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data ~= lfont.height then
                error("font failed integrity check", 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" then
                    error("the char string has the wrong type", 3)
                elseif #line ~= lfont.width then
                    print(char, #line, data)
                    error("the char string has the wrong lenght", 3)
                end
            end
        end
    else
        if type(lfont.chars) ~= "table" then
            error("font failed integrity check", 3)
        end

        local oFont = font.optimizeFont(lfont)
        lfont.spaceSize = oFont.spaceSize
        lfont.width = oFont.width
        lfont.height = oFont.height

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data > FONT_SIZE_LIMIT then
                error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" or #line > FONT_SIZE_LIMIT then
                    error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
                end
            end
        end
    end
end

local function doQuat(x, y, z, w)
    local sin = math.sin(w / 2)
    return quat_new(sin * x, sin * y, sin * z, math.cos(w / 2))
end

local function custom_fromEulerYEnd(x, y, z) --custom implementation
    return doQuat(1, 0, 0, x) * doQuat(0, 0, 1, z) * doQuat(0, 1, 0, y)
end

local function tableClone(tbl)
    local newtbl = {}
    for k, v in pairs(tbl) do
        newtbl[k] = v
    end
    return newtbl
end

local function stackChecksum(stack)
    local num = -#stack
    local t, v
    for i = 1, #stack do
        v = stack[i]
        t = type(v)
        num = num - i
        if t == "number" then
            num = num + ((v * i) + v + i + (v / i))
        elseif t == "Color" then
            num = num + ((i * (v.r / i) * -4) + v.g)
            num = num - ((i * (v.g + i) * 5) + v.b)
            num = num + ((i * (v.b - i) * 8) + v.r)
        elseif t == "string" then
            for i3 = 1, #v do
                num = num + (i * (-i3 - (string_byte(v, i3) * i3)))
            end
        end
    end
    return num
end

local function checkArg(n, have, ...)
    have = type(have)
    local tbl = {...}
    for _, t in ipairs(tbl) do
        if have == t then
            return
        end
    end
    error(string_format("bad argument #%d (%s expected, got %s)", n, table_concat(tbl, " or "), have), 3)
end

local function simpleRemathRect(x, y, w, h, maxX, maxY)
    local x2, y2 = x + (w - 1), y + (h - 1)
    if x < 0 then
        x = 0
    elseif x > maxX then
        --x = maxX
        return
    end
    if y < 0 then
        y = 0
    elseif y > maxY then
        --y = maxY
        return
    end
    if x2 < 0 then
        --x2 = 0
        return
    elseif x2 > maxX then
        x2 = maxX
    end
    if y2 < 0 then
        --y2 = 0
        return
    elseif y2 > maxY then
        y2 = maxY
    end
    return x, y, x2, y2, w, h
end

local function remathRect(offset, stack, maxX, maxY)
    return simpleRemathRect(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], maxX, maxY)
end

local function posCheck(width, height, x, y)
    return x >= 0 and y >= 0 and x < width and y < height
end

local hashChar = string.byte("#")
local bit = bit or bit32
local band = bit.band
local rshift = bit.rshift
local function hexToRGB(color)
    return math_floor(color / 256 / 256) / 255, (math_floor(color / 256) % 256) / 255, (color % 256) / 255
end

local function hexToRGB256(color)
    return math_floor(color / 256 / 256), math_floor(color / 256) % 256, color % 256
end

local function optimizationLevelToValue(level)
    return (level / 255) * 0.25
end

local function formatColor(color, default)
    local t = type(color)
    if t == "Color" then
        return color
    elseif t == "string" then
        return color_new(color)
    elseif t == "number" then
        return color_new(hexToRGB(color))
    end

    return default
end

local redMul = 256 * 256 * 256
local greenMul = 256 * 256
local blueMul = 256
local function formatColorToNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * redMul) + (math_floor(color.g * 255) * greenMul) + (math_floor(color.b * 255) * blueMul) + math_floor(color.a * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return val
        end
        return (val * 256) + 255
    elseif t == "number" then
        return (color * 256) + 255
    end

    return default or 0
end

local function formatColorToSmallNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * greenMul) + (math_floor(color.g * 255) * blueMul) + math_floor(color.b * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return math_floor(val / 256)
        end
        return val
    elseif t == "number" then
        return color
    end

    return default or 0
end

local function color_new_fromSmallNumber(number, alpha)
    return color_new((number * 256) + (alpha or 255))
end

local function mathDist(pos1, pos2)
    return math.sqrt(((pos1.x - pos2.x) ^ 2) + ((pos1.y - pos2.y) ^ 2) + ((pos1.z - pos2.z) ^ 2))
end

local function needPushStack(canvas, dataTunnel) --returns true if the rendering stack should be applied
    return dataTunnel.display_forceFlush or not ((dataTunnel.skipAtNotSight and not canvas.isRendering()))
end

local resetViewportCodeID = -23124
local dataSizes = {
    [resetViewportCodeID] = 1,
    [-1] = 5,
    [0] = 2,
    4,
    6,
    7,
    9, --text
    7, --line
    5,
    5,
    5,
    6,

    4, --drawPoly
    4, --fillPoly

    2,
    2,
    2,
    2,
    3
}

local userCalls = {}

canvasAPI.yield = function() end

function canvasAPI.createDrawer(sizeX, sizeY, callback, callbackBefore, directArg, direct_clear, direct_fill, direct_set, updatedList)
    local obj = {}
    local oldStackSum
    local rSizeX, rSizeY = sizeX, sizeY
    local maxX, maxY = sizeX - 1, sizeY - 1
    local newBuffer, newBufferBase = {}, 0
    local realBuffer = {}
    local maxBuffer = maxX + (maxY * sizeX)
    local currentFont = font.optimized
    local fontWidth, fontHeight = defaultFont.width, defaultFont.height
    local rotation = 0
    local utf8Support = false
    local updated = false
    local clearOnly = false
    local clearBackplate = false
    local maxLineSize = sizeX + sizeY
    local bigSide = math_max(sizeX, sizeY)
    local drawerData = {}
    local _oldBufferBase
    local changes = {}
    local _changes = {}
    local changesIndex, changesCount = {}, 0

    local viewportEnable = false
    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local function bufferRangeUpdate() end

    local function setDot(px, py, col)
        if viewportEnable and (px < viewport_x or py < viewport_y or px >= (viewport_x + viewport_sx) or py >= (viewport_y + viewport_sy)) then
            return
        end

        --[[
        if rotation == 0 then
            index = px + (py * rSizeX)
        elseif rotation == 1 then
            index = (rSizeX - py - 1) + (px * rSizeX)
        elseif rotation == 2 then
            index = (rSizeX - px - 1) + ((rSizeY - py - 1) * rSizeX)
        else
            index = py + ((rSizeY - px - 1) * rSizeX)
        end
        ]]

        local index
        if rotation == 0 then
            index = py + (px * rSizeY)
        elseif rotation == 1 then
            index = px + ((rSizeX - py - 1) * rSizeY)
        elseif rotation == 2 then
            index = (rSizeY - py - 1) + ((rSizeX - px - 1) * rSizeY)
        else
            index = (rSizeY - px - 1) + (py * rSizeY)
        end

        if direct_set then
            newBuffer[index] = col
            direct_set(directArg, math_floor(index / rSizeY), index % rSizeY, col)
            return true
        elseif newBuffer[index] ~= col then
            if updatedList and not changes[index] then
                changes[index] = true
                changesCount = changesCount + 1
                changesIndex[changesCount] = index
            end

            newBuffer[index] = col
            return true
        end
    end

    local function check(px, py)
        return px >= 0 and py >= 0 and px < sizeX and py < sizeY
    end

    local function checkSetDot(px, py, col)
        if check(px, py) then
            setDot(px, py, col)
            return true
        end
        return false
    end

    function obj.drawerReset()
    end

    function obj.drawer_setRotation(_rotation)
        rotation = _rotation
        if rotation == 1 or rotation == 3 then
            sizeX = rSizeY
            sizeY = rSizeX
        else
            sizeX = rSizeX
            sizeY = rSizeY
        end
        maxX, maxY = sizeX - 1, sizeY - 1
    end

    function obj.drawer_setUtf8Support(state)
        utf8Support = not not state
    end

    function obj.drawer_setFont(customFont)
        if customFont then
            currentFont = customFont
            fontWidth, fontHeight = customFont.width, customFont.height
        else
            currentFont = font.optimized
            fontWidth, fontHeight = defaultFont.width, defaultFont.height
        end
    end

    function obj.setDrawerResolution(_sizeX, _sizeY)
        rSizeX, rSizeY = _sizeX, _sizeY
        obj.drawer_setRotation(rotation)
        newBuffer, newBufferBase = {}, 0
        realBuffer = {}
        maxBuffer = maxX + (maxY * sizeX)
        maxLineSize = sizeX + sizeY
        bigSide = math_max(sizeX, sizeY)
        changes = {}
        _changes = {}
        changesIndex, changesCount = {}, 0
        oldStackSum = nil
    end

    local old_rotation
    local old_utf8support
    local old_customFont
    function obj.pushDataTunnelParams(params)
        if params.rotation ~= old_rotation then
            obj.drawer_setRotation(params.rotation)
            old_rotation = params.rotation
        end
        if params.utf8support ~= old_utf8support then
            obj.drawer_setUtf8Support(params.utf8support)
            old_utf8support = params.utf8support
        end
        if params.customFont ~= old_customFont then
            obj.drawer_setFont(params.customFont)
            old_customFont = params.customFont
        end
    end

    ------------------------------------------
    
    local function rasterize_fill(x, y, sx, sy, col)
        local x, y, x2, y2 = simpleRemathRect(x, y, sx, sy, maxX, maxY)
        if not x then return end

        local ix, iy = x, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy + 1
            if iy > y2 then
                iy = y
                ix = ix + 1
            end
        end

        --[[
        local ix, iy = x, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            ix = ix + 1
            if ix > x2 then
                ix = x
                iy = iy + 1
            end
        end
        ]]

        --[[
        local ix, iy = x2, y2
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy - 1
            if iy < y then
                iy = y2
                ix = ix - 1
            end
        end
        ]]

        --[[
        local ix, iy = x2, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy + 1
            if iy > y2 then
                iy = y
                ix = ix - 1
            end
        end
        ]]
    end

    local function rasterize_circleF(px, py, r, col)
        local chr = r*r
        local sx, sy, tempInt, tempBool

        if r < bigSide and px >= 0 and py >= 0 and px < sizeX and py < sizeY then --now only a quarter of the circle is rendered
            for iy = 0, r do
                sy = iy + 0.5
                tempBool = false
                for ix = r, 0, -1 do
                    sx = ix + 0.5
                    if tempBool or (sx * sx) + (sy * sy) <= chr then
                        tempBool = true
                        checkSetDot(px + ix, py + iy, col)
                        checkSetDot(px - ix - 1, py + iy, col)
                        checkSetDot(px + ix, py - iy - 1, col)
                        checkSetDot(px - ix - 1, py - iy - 1, col)
                    end
                end
            end
        else
            for ix = math_max(-r, -px), math_min(r, (sizeX - px) - 1) do --if the starting point is not within the screen or the circle is too large, then will have to check every pixel
                sx = ix + 0.5
                for iy = math_max(-r, -py), math_min(r, (sizeY - py) - 1) do
                    sy = iy + 0.5
                    if (sx * sx) + (sy * sy) <= chr then
                        setDot(px + ix, py + iy, col)
                    end
                end
            end
        end
    end

    local function rasterize_line(px, py, px2, py2, col, width, linesInfo)
        if px2 < px or py2 < py then
            local _px, _py = px, py
            px, py = px2, py2
            px2, py2 = _px, _py
        end
        local dx = math_abs(px2 - px)
        local dy = math_abs(py2 - py)
        local sx = (px < px2) and 1 or -1
        local sy = (py < py2) and 1 or -1
        local err = dx - dy
        if width == -1 or width == 0 or width == 1 then
            local drawAllowed = false
            for _ = 1, maxLineSize do
                if check(px, py) then
                    setDot(px, py, col)
                    drawAllowed = true
                elseif drawAllowed then
                    break
                end
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        elseif width < 0 then
            width = math_ceil((-width) / 2)
            if width < 1 then
                width = 1
            end
            for _ = 1, maxLineSize do
                rasterize_circleF(px, py, width, col)
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        else
            local offsetFill = math_floor(width / 2)
            for _ = 1, maxLineSize do
                rasterize_fill(px - offsetFill, py - offsetFill, width, width, col)
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        end
    end

    ------------------------------------------

    local function render_fill(stack, offset)
        local col = stack[offset+4]
        if direct_fill then
            direct_fill(directArg, stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
        else
            rasterize_fill(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
        end
    end

    local function render_rect(stack, offset)
        local x, y, x2, y2, w, h = remathRect(offset, stack, maxX, maxY)
        if not x then return end
        local col = stack[offset+4]
        local lineWidth = stack[offset+5]
        if lineWidth == 1 then
            for ix = x, x2 do
                setDot(ix, y, col)
                setDot(ix, y2, col)
            end

            for iy = y + 1, y2 - 1 do
                setDot(x, iy, col)
                setDot(x2, iy, col)
            end
        else
            local _y, _y2, _x, _x2
            for ioff = 0, math_min(lineWidth, math_max(w, h) / 2) - 1 do
                _y = y + ioff
                _y2 = y2 - ioff
                for ix = x + ioff, x2 - ioff do
                    setDot(ix, _y, col)
                    setDot(ix, _y2, col)
                end

                _x = x + ioff
                _x2 = x2 - ioff
                for iy = y + 1 + ioff, y2 - (1 + ioff) do
                    setDot(_x, iy, col)
                    setDot(_x2, iy, col)
                end
            end
        end
    end

    local function render_text(stack, offset)
        local tx, ty = stack[offset], stack[offset+1]
        local text = stack[offset+2]
        local col = stack[offset+3]
        local scaleX = stack[offset+4]
        local scaleY = stack[offset+5]
        local spacing = stack[offset+6]
        local fontIndex = stack[offset+7]

        local localFont = currentFont
        local localFontWidth = fontWidth
        if fontIndex > 0 and fontsOptimized[fontIndex] then
            localFont = fontsOptimized[fontIndex]
            localFontWidth = localFont.width
        end

        local len, sep
        if utf8Support then
            len, sep = utf8_len, utf8_sub
        else
            len, sep = string_len, string_byte
        end
        local scaledFontWidth = math_ceil(localFontWidth * scaleX)
        if localFont.mono then
            for i = len(text), 1, -1 do
                local char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    local chrdata = localFont[char] or localFont.error or defaultError
                    local charOffset = (i - 1) * (scaledFontWidth + spacing)
                    for i2 = 1, #chrdata, 2 do
                        local px, py = chrdata[i2], chrdata[i2 + 1]
                        local lposX, lposY = round(px * scaleX), round(py * scaleY)
                        for ix = math_min(sizeX, round((px + 1) * scaleX) - lposX - 1), 0, -1 do
                            local setPosX = tx + ix + lposX + charOffset
                            for iy = math_min(sizeY, round((py + 1) * scaleY) - lposY - 1), 0, -1 do
                                checkSetDot(setPosX, ty + iy + lposY, col)
                            end
                        end
                    end
                end
            end
        else
            local charOffset = 0
            local startDrawTime = os_clock()
            for i = 1, len(text) do
                local char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    local chrdata = localFont[char] or localFont.error or defaultError
                    local charPos = tx + charOffset
                    if not chrdata[0] or charPos + round(chrdata[0] * scaleX) > 0 then
                        if charPos > maxX then
                            goto endDraw
                        end
                        for i2 = 1, #chrdata, 2 do
                            local px, py = chrdata[i2], chrdata[i2 + 1]
                            local lposX, lposY = round(px * scaleX), round(py * scaleY)
                            for ix = 0, math_min(sizeX, round((px + 1) * scaleX) - lposX - 1) do
                                local setPosX = tx + ix + lposX + charOffset
                                for iy = 0, math_min(sizeY, round((py + 1) * scaleY) - lposY - 1) do
                                    checkSetDot(setPosX, ty + iy + lposY, col)
                                end
                            end
                        end
                    end
                    charOffset = charOffset + (chrdata[0] and math_ceil(chrdata[0] * scaleX) or 0) + spacing
                else
                    charOffset = charOffset + (math_ceil(localFont.spaceSize * scaleX) or localFontWidth) + spacing
                end
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
        end
        ::endDraw::
    end

    local function render_line(stack, offset)
        rasterize_line(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4], stack[offset+5])
    end

    local function render_circle(stack, offset) --Michener’s Algorithm
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx, py + dy, col)
            checkSetDot(px + dy, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy, col)
            checkSetDot(px + dy, py - dx, col)
            checkSetDot(px + dx, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleE(stack, offset)
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx - 1, py + dy - 1, col)
            checkSetDot(px + dy - 1, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy - 1, col)
            checkSetDot(px + dy - 1, py - dx, col)
            checkSetDot(px + dx - 1, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleF(stack, offset)
        rasterize_circleF(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3])
    end

    local function render_circleVE(stack, offset) --drawCircleVeryEvenly
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local chr = e2*e2
        local col = stack[offset+3]
        local sx, sy, tempInt, tempBool

        e2 = math_min(e2, bigSide)
        for iy = 0, e2 do
            sy = iy + 0.5
            tempInt = stack[offset+4]
            for ix = e2, 0, -1 do
                sx = ix + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
        for ix = 0, e2 do
            sx = ix + 0.5
            tempInt = stack[offset+4]
            for iy = e2, 0, -1 do
                sy = iy + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
    end

    local function render_drawPoly(stack, offset, getFillInfo)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local startDrawTime = os_clock()
        local _px = stack[offset+3]
        local _py = stack[offset+4]
        local px, py
        local pointsPos
        if getFillInfo then
            pointsPos = {}

            local _setDot = setDot
            setDot = function(px, py, col)
                if not pointsPos[py] then
                    pointsPos[py] = {px, px}
                else
                    local data = pointsPos[py]
                    if px < data[1] then data[1] = px end
                    if px > data[2] then data[2] = px end
                end
            end
            
            for i = 3, points, 2 do
                px = stack[offset+2+i]
                py = stack[offset+3+i]
                rasterize_line(_px, _py, px, py, col, width)
                _px = px
                _py = py
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width)

            setDot = _setDot
        else
            for i = 3, points, 2 do
                px = stack[offset+2+i]
                py = stack[offset+3+i]
                rasterize_line(_px, _py, px, py, col, width)
                _px = px
                _py = py
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width)
        end
        
        ::endDraw::
        return points, pointsPos
    end

    local function render_fillPoly(stack, offset)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local gpoints = points
        for ii = 0, points / 2, 2 do
            local i = ii * 2
            local _, pointsPos = render_drawPoly({col, math_min(6, gpoints), width, stack[offset+3+i], stack[offset+4+i], stack[offset+5+i], stack[offset+6+i], stack[offset+7+i], stack[offset+8+i]}, 1, true)
            local startDrawTime = os_clock()
            for posY, v in pairs(pointsPos) do
                for i = v[1], v[2] do
                    setDot(i, posY, col)
                end

                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            gpoints = gpoints - 4
            if gpoints <= 0 then
                break
            end
        end

        ::endDraw::
        return points
    end

    local lastPixelX, lastPixelY, lastPixelColor
    function obj.pushStack(stack)
        local offset = 2
        local actionNum
        local addValue = 0
        local startDrawTime = os_clock()
        local idx
        while stack[offset] do
            actionNum = stack[offset-1]
            clearOnly = actionNum == 0
            addValue = 0

            if actionNum == 0 then
                newBufferBase = stack[offset]
                newBuffer = {}
                if direct_clear then
                    direct_clear(directArg, newBufferBase, changes)
                end
                updated = true
                clearBackplate = true
                if callback and newBufferBase ~= _oldBufferBase then
                    obj.fullRefresh()
                    _oldBufferBase = newBufferBase
                end
            elseif actionNum == resetViewportCodeID then
                viewportEnable = false
            elseif actionNum == -1 then
                viewportEnable = true
                viewport_x = stack[offset]
                viewport_y = stack[offset+1]
                viewport_sx = stack[offset+2]
                viewport_sy = stack[offset+3]
            elseif actionNum == 1 then
                setDot(stack[offset], stack[offset+1], stack[offset+2])
                updated = true
            elseif actionNum == 2 then
                render_fill(stack, offset)
                updated = true
            elseif actionNum == 3 then
                render_rect(stack, offset)
                updated = true
            elseif actionNum == 4 then
                render_text(stack, offset)
                updated = true
            elseif actionNum == 5 then
                render_line(stack, offset)
                updated = true
            elseif actionNum == 6 then
                render_circle(stack, offset)
                updated = true
            elseif actionNum == 8 then
                render_circleE(stack, offset)
                updated = true
            elseif actionNum == 7 then
                render_circleF(stack, offset)
                updated = true
            elseif actionNum == 9 then
                render_circleVE(stack, offset)
                updated = true
            elseif actionNum == 10 then
                addValue = render_drawPoly(stack, offset)
                updated = true
            elseif actionNum == 11 then
                addValue = render_fillPoly(stack, offset)
                updated = true
            elseif actionNum == 12 then
                for _ = 1, stack[offset] do
                    lastPixelX = lastPixelX + 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 13 then
                for _ = 1, stack[offset] do
                    lastPixelX = lastPixelX - 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 14 then
                for _ = 1, stack[offset] do
                    lastPixelY = lastPixelY + 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 15 then
                for _ = 1, stack[offset] do
                    lastPixelY = lastPixelY - 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 16 then
                idx = stack[offset]
                lastPixelX, lastPixelY, lastPixelColor = idx % rSizeX, math_floor(idx / rSizeX), stack[offset+1]
                setDot(lastPixelX, lastPixelY, lastPixelColor)
                updated = true
            elseif userCalls[actionNum] then
                if userCalls[actionNum](newBuffer, rotation, rSizeX, rSizeY, sizeX, sizeY, stack, offset, drawerData, bufferRangeUpdate, setDot, checkSetDot, rasterize_fill) then
                    updated = true
                end
            end

            if os_clock() - startDrawTime > MAX_DRAW_TIME then
                goto endDraw
            end

            offset = offset + dataSizes[actionNum] + addValue
        end

        ::endDraw::
    end

    function obj.flush(force)
        if not obj.wait and (updated or force) then
            if callbackBefore and callbackBefore(newBufferBase, clearOnly, maxBuffer, force, newBuffer, realBuffer, nil, nil, changes, changesIndex, changesCount, _changes, clearBackplate) then
                realBuffer = {}
            end

            if callback then
                --[[
                local color, px, py
                for i = bufferChangedFrom, bufferChangedTo do
                    color = newBuffer[i] or newBufferBase
                    if color ~= realBuffer[i] or force then
                        px = math_floor(i / rSizeY)
                        py = i % rSizeY
                        callback(px, py, color, newBufferBase)
                        realBuffer[i] = color
                    end
                end
                ]]

                local oldChanges
                if clearBackplate then
                    oldChanges = {}
                    for index in pairs(changes) do
                        oldChanges[index] = true
                    end

                    for index in pairs(_changes) do
                        if not changes[index] then
                            changesCount = changesCount + 1
                            changesIndex[changesCount] = index
                            changes[index] = true
                        end
                    end
                end
        
                for i2 = 1, changesCount do
                    local index = changesIndex[i2]
                    --if changes[index] then
                        callback(math_floor(index / sizeY), index % sizeY, newBuffer[index] or newBufferBase, newBufferBase)
                        _changes[index] = true
                    --end
                end

                if clearBackplate then
                    obj.setOldChanges(oldChanges)
                end
            end

            updated = false
            clearBackplate = false
            if updatedList then
                changes = {}
                changesIndex = {}
                changesCount = 0
            end
        end
    end

    function obj.setWait(state)
        obj.wait = state
        if not state then
            obj.flush()
        end
    end

    function obj.getNewBuffer(i)
        return newBuffer[i] or newBufferBase
    end

    function obj.getRealBuffer(i)
        return realBuffer[i]
    end

    function obj.getChanges()
        return changes
    end

    function obj.fullRefresh()
        changesCount = 0
        changesIndex = {}
        for i = 0, (sizeX * sizeY) - 1 do
            changes[i] = true
            changesCount = changesCount + 1
            changesIndex[changesCount] = i
        end
    end

    --[[
    function obj.flushOldChanges()
        _changes = changes
    end
    ]]

    function obj.setOldChanges(oldChanges)
        _changes = oldChanges
    end

    function obj.clearChangesBuffer()
        _changes = {}
        changes = {}
    end

    return obj
end

if better and better.isAvailable() and better.canvas and better.version >= 40 then
    local better_canvas_clear = better.canvas.clear
    local better_canvas_fill = better.canvas.fill
    local better_canvas_set = better.canvas.set

    function canvasAPI.createBetterCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation)
        local obj = {sizeX = sizeX, sizeY = sizeY}
        local maxX, maxY = sizeX - 1, sizeY - 1
        local maxEffectArrayBuffer = maxX + (maxY * sizeX)
        local dist
        local needOptimize = false
        local showState = false
        local disable = false
        local flushedDefault = false

        local betterCanvas = better.canvas.create(sizeX, sizeY)

        local drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, nil, betterCanvas, better_canvas_clear, better_canvas_fill, better_canvas_set)
        drawer.setWait(true)

        local defaultPosition = vec3_new(0, 0, 0)
        local function getSelfPos()
            local pt = type(parent)
            if pt == "Interactable" then
                return parent.shape.worldPosition
            elseif pt == "Character" then
                return parent.worldPosition
            end
            return defaultPosition
        end

        function obj.isRendering()
            return showState
        end

        function obj.disable(state)
            disable = state
        end

        function obj.setRenderDistance(_dist)
            dist = _dist
        end

        function obj.update()
            local newShowState = true
            local selfPosition
            if disable then
                newShowState = false
            elseif dist then
                if not pcall(function()
                    selfPosition = getSelfPos()
                    newShowState = mathDist(selfPosition, sm_localPlayer_getPlayer().character.worldPosition) <= dist
                end) then
                    selfPosition = selfPosition or vec3_new(0, 0, 0)
                    newShowState = false
                end
            end

            if newShowState ~= showState then
                showState = newShowState
                if newShowState then
                    drawer.setWait(false)
                    if not flushedDefault then
                        drawer.flush(true)
                        flushedDefault = true
                    end
                else
                    drawer.setWait(true)
                    better.canvas.stopUpdate(betterCanvas)
                end
            end

            if newShowState then
                better.canvas.update_3d(betterCanvas, selfPosition + (rotation * offset), -sm.quat.getRight(rotation), -sm.quat.getUp(rotation), (pixelSize.x * sizeX) / 2, (pixelSize.y * sizeY) / 2)
            end
        end

        function obj.setPixelSize(_pixelSize)
            pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
            if type(pixelSize) == "number" then
                if pixelSize < 0 then
                    pixelSize = math_abs(pixelSize)
                    local vec = vec3_new(pixelSize, pixelSize, 0)
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                else
                    local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                end
            end
        end

        function obj.setOffset(_offset)
            offset = _offset
        end

        function obj.setCanvasRotation(_rotation)
            rotation = _rotation
        end

        function obj.destroy()
            better.canvas.destroy(betterCanvas)
        end

        ---------------------------------------

        obj.setPixelSize(pixelSize)
        obj.setCanvasRotation(rotation or quat_fromEuler(vec3_new(0, 0, 0)))
        obj.setOffset(offset or vec3_new(0, 0, 0))

        --[[
        local c = 0xff0000
        local seffect = createEffect(5, 5, 16, 16, c)
        local idx = 5 + (5 * sizeX)
        for i = 0, 16 - 1 do
            effects[idx + i] = {
                seffect,
                c,
                i,
                16,
                idx,
                5,
                5,
                1, --8. sizeY
                0 --9. indexY
            }
        end
        ]]

        ---------------------------------------

        obj.drawer = drawer
        for k, v in pairs(drawer) do
            obj[k] = v
        end

        return obj
    end
end

--low level display api
function canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material, scaleAddValue, altFromEuler, autoLayerDistance)
    local hiddenOffset = vec3_new(1000000, 1000000, 1000000)
    local defaultSizeX, defaultSizeY = sizeX, sizeY
    local pixelScaleX, pixelScaleY = 1, 1
    local obj = {sizeX = sizeX, sizeY = sizeY}
    local maxX, maxY = sizeX - 1, sizeY - 1
    local maxEffectArrayBuffer = maxX + (maxY * sizeX)
    local dist
    local needOptimize = false
    local skipOptimize = false
    local showState = false
    local disable = false

    local _setPosition, _setRotation
    if parent then
        _setPosition, _setRotation = effect_setOffsetPosition, effect_setOffsetRotation
    else
        _setPosition, _setRotation = effect_setPosition, effect_setRotation
    end

    material = material or canvasAPI.material.classic
    local autoScaleAddValue = false
    if not scaleAddValue then
        autoScaleAddValue = true
    end

    local flushedDefault = false
    local oldBackplateColor
    local backplate
    if canvasAPI.multi_layer[tostring(material)] then
        oldBackplateColor = 0
        backplate = sm_effect_createEffect(getEffectName(), parent)
        effect_setParameter(backplate, "uuid", material)
        effect_setParameter(backplate, "color", black)
    end

    local additionalLayer
    local function updateAdditionalLayer()
        if material == canvasAPI.material.smoothed then
            if not additionalLayer then
                additionalLayer = sm_effect_createEffect(getEffectName(), parent)
                effect_setParameter(additionalLayer, "uuid", canvasAPI.material.glass)
                effect_setParameter(additionalLayer, "color", black)
                effect_start(additionalLayer)
                return true
            end
        elseif additionalLayer then
            effect_destroy(additionalLayer)
            additionalLayer = nil
        end
    end
    updateAdditionalLayer()

    local layerDistance
    local function updateLayerDistance(distance)
        layerDistance = math.max(0.001, autoLayerDistance and distance or 0)
    end
    updateLayerDistance()

    local effects = {}
    local nodeEffects = {}
    local effectDatas = {}
    local effectDataLen = 5

    local bufferedEffectsUpdateTime = {}
    local bufferedEffects = {}
    local bufferedEffectsIndex = 0
    local lastDrawTickTime
    local optimizationLevel = 16
    local optimizationValue = optimizationLevelToValue(optimizationLevel)
    local alpha = DEFAULT_ALPHA_VALUE

    local oldHardwareParams = {
        offset_x = 0,
        offset_y = 0,
        offset_z = 0,
        
        rotation_x = 0,
        rotation_y = 0,
        rotation_z = 0,

        scale_x = 1,
        scale_y = 1
    }

    local function getEIndex(index)
        return index * effectDataLen
    end

    local function fromEIndex(index)
        return index / effectDataLen
    end

    local function setEffectDataParams(index)
        local effect = nodeEffects[index]
        local eindex = getEIndex(index)
        local posX, posY, lSizeX, lSizeY = effectDatas[eindex+1], effectDatas[eindex+2], effectDatas[eindex+3], effectDatas[eindex+4]

        posX = posX + ((lSizeX - 1) * 0.5)
        posY = posY + ((lSizeY - 1) * 0.5)
        _setPosition(effect, rotation * (offset + vec3_new(((posX + 0.5) - (sizeX / 2)) * pixelSize.x, ((posY + 0.5) - (sizeY / 2)) * -pixelSize.y, backplate and (debugMode and 0.05 or layerDistance) or 0)))

        local localScaleAddValue = debugMode and -(pixelSize.x / 2) or scaleAddValue
        local vec = pixelSize * 1
        vec.x = (pixelSize.x * lSizeX) + localScaleAddValue
        vec.y = (pixelSize.y * lSizeY) + localScaleAddValue
        effect_setScale(effect, vec)

        effect_setParameter(effect, "color", color_new_fromSmallNumber(effectDatas[eindex], alpha))
    end

    local function createEffect()
        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            _setRotation(effect, rotation)
        end
        return effect
    end

    local function createEffectUnhide(hideList)
        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            hideList[effect] = nil
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            _setRotation(effect, rotation)
        end
        return effect
    end

    local function clearBufferedEffects()
        for i = 1, bufferedEffectsIndex do
            effect_destroy(bufferedEffects[i])
        end
        bufferedEffectsUpdateTime = {}
        bufferedEffects = {}
        bufferedEffectsIndex = 0
    end

    local lastNewBuffer, lastBase

    local lastPopularColor
    local function mathPopularColor()
        local colorUsesTable = {}
        local colorUses = 0
        local oldColorUses = 0
        local colorSum = 0
        for index in pairs(nodeEffects) do
            local eindex = getEIndex(index)
            local color = effectDatas[eindex]
            local colorSize = effectDatas[eindex+3] * effectDatas[eindex+4]
            colorUsesTable[color] = (colorUsesTable[color] or 0) + colorSize
            colorSum = colorSum + colorSize
            colorUses = colorUsesTable[color]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = color
            end
        end

        if oldBackplateColor then
            local colorSize = (sizeX * sizeY) - colorSum
            colorUsesTable[oldBackplateColor] = (colorUsesTable[oldBackplateColor] or 0) + colorSize
            colorUses = colorUsesTable[oldBackplateColor]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = oldBackplateColor
            end
        end
    end

    local function effectIndexAtPos(px, py)
        return py + (px * sizeY)
    end

    local function getRootEIndexAtPos(px, py)
        if py < 0 or py >= sizeY then return end
        local index = effects[effectIndexAtPos(px, py)]
        return index and getEIndex(index), index
    end

    local function clearEffectFromBuffer(index)
        local eindex = getEIndex(index)
        local six, ix, iy = effectDatas[eindex+1], effectDatas[eindex+1], effectDatas[eindex+2]
        local sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        nodeEffects[index] = nil
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix >= six + sizeX then
                ix = six
                iy = iy + 1
            end
        end
    end

    local function hideEffect(effect)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        bufferedEffectsUpdateTime[bufferedEffectsIndex] = game_getCurrentTick()
        _setPosition(effect, hiddenOffset)
    end

    local function hideEffectData(index)
        hideEffect(nodeEffects[index])
        clearEffectFromBuffer(index)
    end

    local function hideEffectLater(effect, hideList)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        bufferedEffectsUpdateTime[bufferedEffectsIndex] = game_getCurrentTick()
        hideList[effect] = true
        --_setPosition(effect, hiddenOffset)
    end

    local function hideEffectDataLater(index, hideList)
        hideEffectLater(nodeEffects[index], hideList)
        clearEffectFromBuffer(index)
    end    
    
    local function hideEffectsWithColor(color)
        for index in pairs(nodeEffects) do
            if effectDatas[getEIndex(index)] == color then
                hideEffectData(index)
            end
        end
    end

    local function delAllEffects()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        effects = {}
        nodeEffects = {}
    end

    --[[
    local function forceRecreateNodeEffects()
        nodeEffects = {}
        for i, effectData in pairs(effects) do
            if effectData[7] == i then
                nodeEffects[i] = effectData
            end
        end
    end
    ]]

    --local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
    local function colorEquals_smart(color1, color2)
        if color1 == color2 then return true end
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        --return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
        return ((math_abs(rVal - rVal2) + math_abs(gVal - gVal2) + math_abs(bVal - bVal2)) / 1024) <= optimizationValue
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    local function getFillZone(eindex)
        local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
        return fillX1, fillY1, fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
    end

    local sumAttachTime = 0
    local sumAttachFillTime = 0
    local function tryLongAttach(changedList, hideList, index, px, py, color, sizeX, sizeY)
        local startTime = os_clock()

        --[[
        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        local origEffect
        if origIndex then
            origEffect = nodeEffects[origIndex]
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end
        ]]

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local downParentE, downParent = getRootEIndexAtPos(px, py + sizeY)
        local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)
        local downAvailable = downParentE and nodeEffects[downParent] and effectDatas[downParentE+1] == px and effectDatas[downParentE+3] == sizeX and colorEquals(effectDatas[downParentE], color)

        local fillOptional = false
        local fillX1, fillY1, fillX2, fillY2
        local fill2X1, fill2Y1, fill2X2, fill2Y2

        --[[
        if origEffect and (upAvailable or downAvailable) then
            hideEffectLater(origEffect, hideList)
            changedList[origIndex] = nil
            changedColorList[origIndex] = nil
            nodeEffects[origIndex] = nil
        end
        ]]

        local newIndex, newEIndex
        local fillVal
        if upAvailable and downAvailable then
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

            local addSizeY = sizeY + effectDatas[downParentE+4]

            hideEffectLater(nodeEffects[downParent], hideList)
            changedList[downParent] = nil
            --changedColorList[downParent] = nil
            nodeEffects[downParent] = nil

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + addSizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
        elseif upAvailable then
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
        elseif downAvailable then
            fillOptional = true
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

            changedList[downParent] = nil
           --changedColorList[downParent] = nil

            nodeEffects[index] = nodeEffects[downParent]
            nodeEffects[downParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[downParentE]
            effectDatas[eindex+1] = effectDatas[downParentE+1]
            effectDatas[eindex+2] = py
            effectDatas[eindex+3] = effectDatas[downParentE+3]
            effectDatas[eindex+4] = effectDatas[downParentE+4] + sizeY
            
            newIndex, newEIndex = index, eindex
            fillVal = index
        end

        if fillVal then
            index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
            sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
        end

        local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
        local rightParentE, rightParent = getRootEIndexAtPos(px + sizeX, py)
        local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
        local rightAvailable = rightParentE and nodeEffects[rightParent] and effectDatas[rightParentE+2] == py and effectDatas[rightParentE+4] == sizeY and colorEquals(effectDatas[rightParentE], color)

        if nodeEffects[index] and (leftAvailable or rightAvailable) then
            hideEffectLater(nodeEffects[index], hideList)
            changedList[index] = nil
            --changedColorList[index] = nil
            nodeEffects[index] = nil
        end

        if leftAvailable and rightAvailable then
            fillOptional = false
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

            local addSizeX = sizeX + effectDatas[rightParentE+3]

            hideEffectLater(nodeEffects[rightParent], hideList)
            changedList[rightParent] = nil
            --changedColorList[rightParent] = nil
            nodeEffects[rightParent] = nil

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + addSizeX
            fillVal = leftParent
        elseif leftAvailable then
            fillOptional = false
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = nil, nil, nil, nil

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
            fillVal = leftParent
        elseif rightAvailable then
            fillOptional = not upAvailable and not downAvailable
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

            changedList[rightParent] = nil
            --changedColorList[rightParent] = nil

            nodeEffects[index] = nodeEffects[rightParent]
            nodeEffects[rightParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[rightParentE]
            effectDatas[eindex+1] = px
            effectDatas[eindex+2] = effectDatas[rightParentE+2]
            effectDatas[eindex+3] = sizeX + effectDatas[rightParentE+3]
            effectDatas[eindex+4] = effectDatas[rightParentE+4]
            
            fillVal = index
        end

        sumAttachTime = sumAttachTime + (os_clock() - startTime)

        if fillVal then
            changedList[fillVal] = true
            --changedColorList[fillVal] = true

            --[[
            local eindex = getEIndex(fillVal)
            local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
            local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = fillVal
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            ]]

            startTime = os_clock()

            --fillOptional = false
            --if not fillOptional or not origEffect then
                local ix, iy = fillX1, fillY1
                for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = fillVal
                    ix = ix + 1
                    if ix > fillX2 then
                        ix = fillX1
                        iy = iy + 1
                    end
                end
            --[[else
                local ix, iy = fillX1, fillY1
                for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                    if fillVal ~= effects[effectIndexAtPos(ix, iy)] then
                        print("WTTT", fillVal, effects[effectIndexAtPos(ix, iy)])
                    end
                    ix = ix + 1
                    if ix > fillX2 then
                        ix = fillX1
                        iy = iy + 1
                    end
                end
                ]]
            --end

            if fill2X1 then
                local ix, iy = fill2X1, fill2Y1
                for _ = 1, ((fill2X2 - fill2X1) + 1) * ((fill2Y2 - fill2Y1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = fillVal
                    ix = ix + 1
                    if ix > fill2X2 then
                        ix = fill2X1
                        iy = iy + 1
                    end
                end
            end

            sumAttachFillTime = sumAttachFillTime + (os_clock() - startTime)

            --fillVal = tryAttach(changedList, changedColorList, index, px, py, color) or fillVal
        end

        return fillVal
    end

    local function tryAttach(changedList, hideList, index, px, py, color, sizeX, sizeY)
        local startTime = os_clock()

        --[[
        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        local origEffect
        if origIndex then
            origEffect = nodeEffects[origIndex]
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end
        ]]

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)

        local fillX1, fillY1, fillX2, fillY2
        local newIndex, newEIndex, fillVal
        if upAvailable then
            --[[
            if origEffect then
                hideEffectLater(origEffect, hideList)
                changedList[origIndex] = nil
                changedColorList[origIndex] = nil
                nodeEffects[origIndex] = nil
            end
            ]]

            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent

            index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
            sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
        end

        local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
        local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
        if leftAvailable then
            if nodeEffects[index] then
                hideEffectLater(nodeEffects[index], hideList)
                changedList[index] = nil
                --changedColorList[index] = nil
                nodeEffects[index] = nil
            end

            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
            fillVal = leftParent
        end

        sumAttachTime = sumAttachTime + (os_clock() - startTime)

        if fillVal then
            changedList[fillVal] = true
            --changedColorList[fillVal] = true

            startTime = os_clock()
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = fillVal
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            sumAttachFillTime = sumAttachFillTime + (os_clock() - startTime)
        end

        return fillVal
    end

    local sumFillTime = 0
    local function fillBlock(x, y, sx, sy, changedList, hideList, color, iterate, effect)
        if sx <= 0 or sy <= 0 then
            return
        end

        local newRIndex = effectIndexAtPos(x, y)
        nodeEffects[newRIndex] = effect or createEffectUnhide(hideList)
        changedList[newRIndex] = true
        --changedColorList[newRIndex] = true

        local newEIndex = getEIndex(newRIndex)
        effectDatas[newEIndex] = color
        effectDatas[newEIndex+1] = x
        effectDatas[newEIndex+2] = y
        effectDatas[newEIndex+3] = sx
        effectDatas[newEIndex+4] = sy

        if not iterate then
            return true
        end
        
        local startTime = os_clock()
        local ix, iy = x, y
        local six = ix
        local mix = six + sx
        for _ = 1, sx * sy do
            effects[effectIndexAtPos(ix, iy)] = newRIndex
            ix = ix + 1
            if ix >= mix then
                ix = six
                iy = iy + 1
            end
        end
        sumFillTime = sumFillTime + (os_clock() - startTime)

        return true
    end

    local sumExtractTime = 0
    local function extractPixel(changedList, hideList, index, px, py, sizeX, sizeY)
        local startTime = os_clock()

        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local lx = px - rpx
        local ly = py - rpy

        local effect = nodeEffects[rindex]
        changedList[rindex] = nil
        --changedColorList[rindex] = nil
        nodeEffects[rindex] = nil

        local color = effectDatas[eindex]
        --local block1, block2, block3, block4 = false, false, false, false
        if fillBlock(rpx, rpy, lx, rsy, changedList, hideList, color, false, effect) then --[[block1 = true]] effect = nil end
        if fillBlock(rpx + lx + sizeX, rpy, rsx - lx - sizeX, rsy, changedList, hideList, color, true, effect) then --[[block2 = true]] effect = nil end
        if fillBlock(rpx + lx, rpy, sizeX, ly, changedList, hideList, color, true, effect) then --[[block3 = true]] effect = nil end
        if fillBlock(rpx + lx, rpy + ly + sizeY, sizeX, rsy - ly - sizeY, changedList, hideList, color, true, effect) then --[[block4 = true]] effect = nil end

        local ix, iy, endX = px, py, px + (sizeX - 1)
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix > endX then
                ix = px
                iy = iy + 1
            end
        end

        if effect then
            hideEffectLater(effect, hideList)
        end

        sumExtractTime = sumExtractTime + (os_clock() - startTime)

        --if block1 then tryAttach(changedList, changedColorList, effectIndexAtPos(rpx, rpy), rpx, rpy, color) end
        --if block2 then tryAttach(changedList, changedColorList, effectIndexAtPos(block2X, rpy), block2X, rpy, color) end
        --if block3 then tryAttach(changedList, changedColorList, effectIndexAtPos(block3X, rpy), block3X, rpy, color) end
        --if block4 then tryAttach(changedList, changedColorList, effectIndexAtPos(block4X, block4Y), block4X, block4Y, color) end
    end

    --[[
    local function extractXLine(changedList, changedColorList, hideList, index, px, py)
        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local ly = py - rpy

        local effect = nodeEffects[rindex]
        changedList[rindex] = nil
        changedColorList[rindex] = nil
        nodeEffects[rindex] = nil
        effects[index] = nil

        local color = effectDatas[eindex]
        if fillBlock(rpx, rpy, rsx, ly, changedList, changedColorList, hideList, color, false, effect) then effect = nil end
        if fillBlock(rpx, rpy + ly + 1, rsx, rsy - ly - 1, changedList, changedColorList, hideList, color, true, effect) then effect = nil end

        if effect then
            hideEffectLater(effect, hideList)
        end
    end
    ]]

    local function fillEffectsLinks(index, px, py, sizeX, sizeY)
        local ix, iy, endX = px, py, px + (sizeX - 1)
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = index
            ix = ix + 1
            if ix > endX then
                ix = px
                iy = iy + 1
            end
        end
    end

    --[[
    local sumIsFullChangeTime = 0
    local function isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, forDestroy)
        local effectID = nodeEffects[rindex].id
        if fullChecked[effectID] then
            return false
        end
        fullChecked[effectID] = true


        local startTime = os_clock()

        local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
        local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
        local baseColor = lastNewBuffer[effectIndexAtPos(fillX1, fillY1)] or lastBase

        local ix, iy = fillX1 + 1, fillY1
        if ix > fillX2 then
            ix = fillX1
            iy = iy + 1
        end
        for _ = 2, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
            local color = lastNewBuffer[effectIndexAtPos(ix, iy)] or lastBase
            if color ~= baseColor then
                sumIsFullChangeTime = sumIsFullChangeTime + (os_clock() - startTime)
                return false
            end
            ix = ix + 1
            if ix > fillX2 then
                ix = fillX1
                iy = iy + 1
            end
        end

        ix, iy = fillX1, fillY1
        if not forDestroy then
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                local index = effectIndexAtPos(ix, iy)
                _changes[index] = true
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
        end

        sumIsFullChangeTime = sumIsFullChangeTime + (os_clock() - startTime)
        return true
    end
    ]]

    --[[
    local function getBlockSize(rindex, index, px, py, color)
        local sizeX = 1
        --local sizeY = 1
        --[[
        for i = 1, maxY - py do
            if rindex ~= effects[index+i] or (lastNewBuffer[index+i] or lastBase) ~= color then
                break
            end
            sizeY = sizeY + 1
        end
        ] ]
        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
                --sizeY = sizeY + 1
            end
        end

        --[[
        for iy = 1, maxY - py do
            local multibrake = false
            for ix = 0, sizeX - 1 do
                local lindex = effectIndexAtPos(px+ix, py+iy)
                if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                    multibrake = true
                    break
                end
            end
            if multibrake then
                break
            end
            sizeY = sizeY + 1
        end
        ] ]

        return sizeX, iy
    end
    ]]

    local function getBlockSize(index, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local function getBlockSizeOptimization(index, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if effects[lindex] or not lastNewBuffer[lindex] or not colorEquals(lastNewBuffer[lindex], color) then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if effects[lindex] or not lastNewBuffer[lindex] or not colorEquals(lastNewBuffer[lindex], color) then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local function getChangesBlockSize(rindex, index, changes, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if rindex ~= effects[lindex] or not changes[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if rindex ~= effects[lindex] or not changes[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local _oldVirtualBackplateColor
    local drawer
    local lastDrawWithClear = true
    drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, function (base, clearOnly, maxBuffer, force, newBuffer, realBuffer, _, _, changes, changesIndex, changesCount, _changes, clearBackplate)
        lastNewBuffer, lastBase = newBuffer, base
        lastDrawWithClear = clearBackplate

        if clearOnly and backplate then
            clearBufferedEffects()
            drawer.clearChangesBuffer()
            delAllEffects()
            return
        end

        local changedList = {}
        --local changedColorList = {}
        local hideList = {}
        --local fullChecked = {}

        --print("changesCount 1", changesCount)

        local oldChanges
        if clearBackplate then
            local startTime = os_clock()

            oldChanges = {}
            for index in pairs(changes) do
                oldChanges[index] = true
            end

            for index in pairs(_changes) do
                if not changes[index] then
                    changesCount = changesCount + 1
                    changesIndex[changesCount] = index
                    changes[index] = true
                end
            end

            profiller("clear-loop", startTime)
        end

        --[[
        local _changesSize = 0
        for k, v in pairs(_changes) do
            _changesSize = _changesSize + 1
        end
        print(tostring(_changes), _changesSize)
        ]]

        --print("changesCount 2", changesCount)

        --[[
        local startTime = os_clock()
        table_sort(changesIndex, function (a, b)
            return a < b
        end)
        profiller("stack-sort", startTime)
        ]]

        --[[
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex then
                local eindex = getEIndex(rindex)
                if not colorEquals(effectDatas[eindex], color) then
                    local px = math_floor(index / sizeY)
                    local py = index % sizeY
                    local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
                    local backplateColor = color == oldBackplateColor
                    if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, backplateColor) then
                        if backplateColor then
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        elseif not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        end
                    elseif backplateColor then
                        if aSizeX or aSizeY then
                            extractPixel(changedList, changedColorList, hideList, index, px, py)
                        else
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        end
                    else
                        _changes[index] = true

                        if aSizeX or aSizeY then
                            extractPixel(changedList, changedColorList, hideList, index, px, py)
                        end

                        if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                            local eindex = getEIndex(index)

                            if not nodeEffects[index] then
                                local effect = createEffectUnhide(hideList)

                                local bSizeX, bSizeY = 1, 1
                                effectDatas[eindex+1] = px
                                effectDatas[eindex+2] = py
                                effectDatas[eindex+3] = bSizeX
                                effectDatas[eindex+4] = bSizeY
                                fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                
                                nodeEffects[index] = effect
                                changedList[index] = true
                            end

                            effectDatas[eindex] = color
                            changedColorList[index] = true
                        end
                    end
                end
            elseif color ~= oldBackplateColor then
                _changes[index] = true
                local px = math_floor(index / sizeY)
                local py = index % sizeY
                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect

                    local eindex = getEIndex(index)
                    local bSizeX, bSizeY = getBlockSize(index, px, py)
                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = bSizeX
                    effectDatas[eindex+4] = bSizeY
                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                    
                    changedList[index] = true
                    changedColorList[index] = true
                end
            end
        end
        profiller("change-loop", startTime)
        ]]

        --local localEffectsBlacklist = {}

        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex --[[and not localEffectsBlacklist[rindex] ]] then
                local eindex = getEIndex(rindex)
                --local isBackgroundColor = color == oldBackplateColor
                --if color == oldBackplateColor or not colorEquals(effectDatas[eindex], color) then
                if effectDatas[eindex] ~= color then
                    --local px = math_floor(index / sizeY)
                    --local py = index % sizeY
                    --local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
                    --[[if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, backplateColor) then
                        if backplateColor then
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        else
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        end
                    else]]
                    
                    --local aSizeX, aSizeY = effectDatas[eindex+3], effectDatas[eindex+4]
                    if effectDatas[eindex+3] > 1 or effectDatas[eindex+4] > 1 then
                        local px = math_floor(index / sizeY)
                        local py = index % sizeY
                        --local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                        --extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)
                        extractPixel(changedList, hideList, index, px, py, getChangesBlockSize(rindex, index, changes, px, py, color))

                        --[[
                        local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                        if aSizeX == bSizeX and aSizeY == bSizeY then
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        else
                            extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)
                        end
                        ]]

                        --[[
                        if not isBackgroundColor then
                            if not tryAttach(changedList, changedColorList, hideList, index, px, py, color, bSizeX, bSizeY) then
                                local effect = createEffectUnhide(hideList)

                                nodeEffects[index] = effect

                                local eindex = getEIndex(index)
                                effectDatas[eindex] = color
                                effectDatas[eindex+1] = px
                                effectDatas[eindex+2] = py
                                effectDatas[eindex+3] = bSizeX
                                effectDatas[eindex+4] = bSizeY
                                fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                
                                changedList[index] = true
                                changedColorList[index] = true
                                localEffectsBlacklist[index] = true
                            end
                        end
                        ]]
                    else
                        changedList[rindex] = nil
                        --changedColorList[rindex] = nil
                        hideEffectDataLater(rindex, hideList)
                    end
                end
            end
        end
        profiller("extract-loop", startTime)

        --local blockSizeCache = {}
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            if color ~= oldBackplateColor then
                _changes[index] = true

                if not effects[index] then
                    local px = math_floor(index / sizeY)
                    local py = index % sizeY

                    if not tryLongAttach(changedList, hideList, index, px, py, color, 1, 1) then
                        --[[
                        local blockSize
                        if blockSizeCache[index] then
                            blockSize = blockSizeCache[index]
                            print("LOAD", index, blockSize)
                        else
                            blockSize = {getBlockSize(index, px, py, color)}
                            blockSizeCache[index] = blockSize
                        end
                        ]]

                        local bSizeX, bSizeY = getBlockSize(index, px, py, color)
                        if not tryLongAttach(changedList, hideList, index, px, py, color, bSizeX, bSizeY) then
                            local effect = createEffectUnhide(hideList)

                            nodeEffects[index] = effect

                            local eindex = getEIndex(index)
                            effectDatas[eindex] = color
                            effectDatas[eindex+1] = px
                            effectDatas[eindex+2] = py
                            effectDatas[eindex+3] = bSizeX
                            effectDatas[eindex+4] = bSizeY
                            fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                            
                            changedList[index] = true
                            --changedColorList[index] = true
                        end

                        --[[
                        local effect = createEffectUnhide(hideList)

                        nodeEffects[index] = effect
                        effects[index] = index

                        local eindex = getEIndex(index)
                        effectDatas[eindex] = color
                        effectDatas[eindex+1] = px
                        effectDatas[eindex+2] = py
                        effectDatas[eindex+3] = 1
                        effectDatas[eindex+4] = 1
                        
                        changedList[index] = true
                        ]]
                    end
                end
            end
        end
        profiller("add-loop", startTime)

        --[[
        local localEffectsBlacklist = {}
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex then
                if not localEffectsBlacklist[rindex] then
                    local eindex = getEIndex(rindex)
                    local isBackgroundColor = color == oldBackplateColor
                    if isBackgroundColor or not colorEquals(effectDatas[eindex], color) then
                        if effectDatas[eindex+3] > 1 or effectDatas[eindex+4] > 1 then
                            local px = math_floor(index / sizeY)
                            local py = index % sizeY
                            local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                            extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)

                            if not isBackgroundColor then
                                _changes[index] = true

                                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                                    local effect = createEffectUnhide(hideList)

                                    nodeEffects[index] = effect

                                    local eindex = getEIndex(index)
                                    effectDatas[eindex] = color
                                    effectDatas[eindex+1] = px
                                    effectDatas[eindex+2] = py
                                    effectDatas[eindex+3] = bSizeX
                                    effectDatas[eindex+4] = bSizeY
                                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                    
                                    changedList[index] = true
                                    changedColorList[index] = true
                                    localEffectsBlacklist[index] = true
                                end
                            end
                        elseif not isBackgroundColor then
                            _changes[index] = true

                            local px = math_floor(index / sizeY)
                            local py = index % sizeY
                            if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                                effectDatas[eindex] = color
                                changedColorList[rindex] = true
                            end
                        else
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        end
                    end
                end
            elseif color ~= oldBackplateColor then
                _changes[index] = true

                local px = math_floor(index / sizeY)
                local py = index % sizeY
                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect

                    local eindex = getEIndex(index)
                    local bSizeX, bSizeY = getBlockSize(nil, index, px, py, color)
                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = bSizeX
                    effectDatas[eindex+4] = bSizeY
                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                    
                    changedList[index] = true
                    changedColorList[index] = true
                    localEffectsBlacklist[index] = true
                end
            end
        end
        profiller("change-loop", startTime)
        ]]

        local contentUpdated = false

        startTime = os_clock()
        for index in pairs(changedList) do
            setEffectDataParams(index)
            contentUpdated = true
        end
        profiller("apply-params", startTime)

        --[[
        startTime = os_clock()
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            if not colorCache[color] then
                colorCache[color] = color_new_fromSmallNumber(color, alpha)
            end
            effect_setParameter(nodeEffects[index], "color", colorCache[color])
        end
        profiller("apply-colors", startTime)
        ]]
        --[[
        startTime = os_clock()
        local colorobj = color_new(0)
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            colorobj.r, colorobj.g, colorobj.b = hexToRGB(color)
            colorobj.a = alpha / 255
            effect_setParameter(nodeEffects[index], "color", colorobj)
            contentUpdated = true
        end
        profiller("apply-colors", startTime)
        ]]

        startTime = os_clock()
        for effect in pairs(hideList) do
            _setPosition(effect, hiddenOffset)
        end
        profiller("later-hide", startTime)

        profillerPrint("fill-sum", sumFillTime)
        profillerPrint("extract-sum", sumExtractTime)
        profillerPrint("attach-sum", sumAttachTime)
        profillerPrint("attach-fill-sum", sumAttachFillTime)
        --profillerPrint("isFullChange-sum", sumIsFullChangeTime)
        --sumIsFullChangeTime = 0
        sumFillTime = 0
        sumExtractTime = 0
        sumAttachTime = 0
        sumAttachFillTime = 0
        
        if clearBackplate then
            drawer.setOldChanges(oldChanges)
            --clearBackplate = false
        end

        if clearOnly then
            clearBufferedEffects()
            return
        end

        if contentUpdated then
            lastDrawTickTime = game_getCurrentTick()
            needOptimize = true
        end
    end, nil, function (_, color, changes)
        if backplate then
            oldBackplateColor = color
            effect_setParameter(backplate, "color", color_new_fromSmallNumber(color, alpha))
        elseif color ~= _oldVirtualBackplateColor then
            drawer.fullRefresh()
            _oldVirtualBackplateColor = color
        end
    end, nil, nil, true)

    if not backplate then
        drawer.fullRefresh()
    end

    local canvasWait
    local wait_dataTunnel
    local function _setWait(wait)
        canvasWait = wait
        drawer.setWait(wait)
        if not wait and wait_dataTunnel then
            obj.realPushDataTunnelParams(wait_dataTunnel)
            wait_dataTunnel = nil
        end
    end

    _setWait(true)

    local function recreateCanvas()
        if not lastNewBuffer then
            return
        end

        if backplate and not lastDrawWithClear then --WHAT? (fixed)
            mathPopularColor()
            if lastPopularColor ~= oldBackplateColor then
                effect_setParameter(backplate, "color", color_new_fromSmallNumber(lastPopularColor, alpha))
                oldBackplateColor = lastPopularColor
                drawer.fullRefresh()
            end
        end
        
        local hideList = {}
        for i, effect in pairs(nodeEffects) do
            hideEffectLater(effect, hideList)
        end
        effects = {}
        nodeEffects = {}
        effectDatas = {}

        local changedList = {}
        --local changedColorList = {}

        --local startTime = os.clock()
        local index = 0
        while index <= maxEffectArrayBuffer do
            local px = math_floor(index / sizeY)
            local py = index % sizeY
            local color = lastNewBuffer[index] or lastBase
            if effects[index] then
                index = index + effectDatas[getEIndex(effects[index])+4]
            elseif color ~= oldBackplateColor then
                local eindex = getEIndex(index)

                local newRootIndex = tryAttach(changedList, hideList, index, px, py, color, 1, 1)
                if newRootIndex then
                    local newRootEIndex = getEIndex(newRootIndex)
                    index = effectIndexAtPos(px, effectDatas[newRootEIndex+2] + effectDatas[newRootEIndex+4])
                else
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect
                    effects[index] = index

                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = 1
                    effectDatas[eindex+4] = 1
                    
                    changedList[index] = true
                    --changedColorList[index] = true
                    index = index + 1
                end

                --[[
                local bSizeX, bSizeY = getBlockSizeOptimization(index, px, py, color)
                local effect = createEffectUnhide(hideList)

                nodeEffects[index] = effect
                effectDatas[eindex] = color
                effectDatas[eindex+1] = px
                effectDatas[eindex+2] = py
                effectDatas[eindex+3] = bSizeX
                effectDatas[eindex+4] = bSizeY
                fillEffectsLinks(index, px, py, bSizeX, bSizeY)

                changedList[index] = true
                index = index + bSizeY
                ]]
            else
                index = index + 1
            end
        end
        --print("recreate-loop time:", os.clock() - startTime)

        for index in pairs(changedList) do
            setEffectDataParams(index)
        end

        --[[
        local colorobj = color_new(0)
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            colorobj.r, colorobj.g, colorobj.b = hexToRGB(color)
            colorobj.a = alpha / 255
            effect_setParameter(nodeEffects[index], "color", colorobj)
        end
        ]]

        for effect in pairs(hideList) do
            _setPosition(effect, hiddenOffset)
        end
    end

    local _s_pixelSize, _s_offset, _s_rotation
    function obj.setCanvasMaterial(_material)
        material = _material
        local newBackplateExists = not not canvasAPI.multi_layer[tostring(material)]
        local oldBackplateExists = not not backplate

        if newBackplateExists ~= oldBackplateExists then
            _oldVirtualBackplateColor = nil
        end

        local updateParameters = false
        if newBackplateExists then
            if not oldBackplateExists then
                updateParameters = true
                oldBackplateColor = 0
                backplate = sm_effect_createEffect(getEffectName(), parent)
                effect_setParameter(backplate, "color", black)
                effect_setParameter(backplate, "uuid", material)
                if showState then
                    effect_start(backplate)
                end
            else
                effect_stop(backplate)
                effect_setParameter(backplate, "uuid", material)
                effect_start(backplate)
            end
        elseif oldBackplateExists then
            effect_destroy(backplate)
            oldBackplateColor = nil
            backplate = nil
            recreateCanvas()
        end

        for _, effect in pairs(nodeEffects) do
            effect_stop(effect)
            effect_setParameter(effect, "uuid", material)
            effect_start(effect)
        end

        for i = 1, bufferedEffectsIndex do
            local effect = bufferedEffects[i]
            effect_stop(effect)
            effect_setParameter(effect, "uuid", material)
            effect_start(effect)
        end

        local layerCreated = updateAdditionalLayer()

        if updateParameters or layerCreated then
            obj.setPixelSize(_s_pixelSize)
            obj.setOffset(_s_offset, true)
            obj.setCanvasRotation(_s_rotation)
        end
    end

    local function switchHardware()
        obj.setPixelSize(_s_pixelSize)
        obj.setOffset(_s_offset, true)
        obj.setCanvasRotation(_s_rotation)
    end

    local defaultPosition = vec3_new(0, 0, 0)
    local function getSelfPos()
        local pt = type(parent)
        if pt == "Interactable" then
            return parent.shape.worldPosition
        elseif pt == "Character" then
            return parent.worldPosition
        end
        return defaultPosition
    end

    local function updateLayersPos()
        if backplate then
            _setPosition(backplate, rotation * offset)
        end
        if additionalLayer then
            _setPosition(additionalLayer, rotation * (offset + vec3_new(0, 0, 0.0015)))
        end
    end

    local longOptimizeCounter = 0
    local lastOptimizeTime = game_getCurrentTick()
    local function optimize()
        --[[
        if bufferedEffectsIndex > 4096 then
            for i = 1, bufferedEffectsIndex - 4096 do
                effect_stop(bufferedEffects[i])
                stoppedCount = stoppedCount + 1
            end

            --[[
            if bufferedEffectsIndex > 3000 then
                if debugMode then
                    print("destroy buffered effects")
                end

                for i = 3001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                end
                bufferedEffectsIndex = 3000
            end
            ] ]
        end
        ]]

        if longOptimizeCounter >= 3 then
            skipOptimize = true
            if debugMode then
                print("skip optimize")
            end
            return
        end

        local startTime = os_clock()
        recreateCanvas()

        local optimizeTime = os_clock() - startTime
        if optimizeTime > ((1 / 1000) * 50) then
            if debugMode then
                print("long optimize time", optimizeTime)
            end
            longOptimizeCounter = longOptimizeCounter + 1
        end

        lastOptimizeTime = game_getCurrentTick()
    end

    function obj.setAlpha(_alpha)
        alpha = _alpha
        for rindex, effect in pairs(nodeEffects) do
            effect_setParameter(effect, "color", color_new_fromSmallNumber(effectDatas[getEIndex(rindex)], alpha))
        end
    end

    function obj.setCanvasOptimizationLevel(value)
        optimizationLevel = value
        if value == 0 then
            colorEquals = colorEquals_raw
        else
            colorEquals = colorEquals_smart
        end
        optimizationValue = optimizationLevelToValue(optimizationLevel)
    end

    function obj.isRendering()
        return showState
    end

    function obj.disable(state)
        disable = state
    end

    function obj.setRenderDistance(_dist)
        dist = _dist
    end

    local reoptimizeTime = 20
    local reoptimizeDynamicTime = 40
    local canvasSize = sizeX * sizeY
    if canvasSize >= (512 * 512) then
        reoptimizeTime = 40
        reoptimizeDynamicTime = 80
    elseif canvasSize >= (256 * 256) then
        reoptimizeTime = 40
        reoptimizeDynamicTime = 60
    end

    local oldOptimizeTime
    local newShowState = true
    function obj.update()
        if disable then
            newShowState = false
        elseif dist then
            if not pcall(function()
                local currentDist = mathDist(getSelfPos(), sm_localPlayer_getPlayer().character.worldPosition)
                if currentDist <= dist then
                    newShowState = true
                elseif currentDist >= dist + 2 then
                    newShowState = false
                end
            end) then
                newShowState = false
            end
        end

        --recreateCanvas()

        if newShowState ~= showState then
            showState = newShowState
            if newShowState then
                obj.setWait(false)
                if not backplate and not flushedDefault then
                    drawer.flush(true)
                    flushedDefault = true
                end
                for _, effect in pairs(nodeEffects) do
                    if not effect_isPlaying(effect) then
                        effect_start(effect)
                    end
                end
                if backplate then
                    effect_start(backplate)
                end
                if additionalLayer then
                    effect_start(additionalLayer)
                end
            else
                for _, effect in pairs(nodeEffects) do
                    effect_stop(effect)
                end
                for i = 1, bufferedEffectsIndex do
                    effect_stop(bufferedEffects[i])
                end
                if backplate then
                    effect_stop(backplate)
                end
                if additionalLayer then
                    effect_stop(additionalLayer)
                end
                obj.setWait(true)
            end
        end

        local ctick = game_getCurrentTick()
        local optimizePeer = reoptimizeTime
        if lastDrawTickTime then
            if ctick - lastDrawTickTime < 20 then
                optimizePeer = reoptimizeDynamicTime
            end

            if longOptimizeCounter > 0 and (ctick - lastDrawTickTime > 40 * 5 or ctick - lastOptimizeTime > 40 * 10) then
                if debugMode then
                    print("reset longOptimizeCounter", longOptimizeCounter)
                end
                longOptimizeCounter = 0
                if skipOptimize then
                    optimize()
                    longOptimizeCounter = 0
                    skipOptimize = false
                end
            end
        end

        if ctick % 20 == 0 then
            local stoppedCount = 0
            local destroyedCount = 0

            if bufferedEffectsIndex > 6000 then
                for i = 6001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                    destroyedCount = destroyedCount + 1
                end
                bufferedEffectsIndex = 6000
            end

            for i = 1, bufferedEffectsIndex - 1024 do
                local otick = bufferedEffectsUpdateTime[i]
                if otick ~= true and ctick - otick > 160 then
                    bufferedEffectsUpdateTime[i] = true
                    effect_stop(bufferedEffects[i])
                    stoppedCount = stoppedCount + 1
                end
            end

            if debugMode then
                if destroyedCount > 0 then
                    print("destroying buffered effects", destroyedCount)
                end
                print("stoping buffered effects", stoppedCount .. " / " .. bufferedEffectsIndex)
            end
        end

        if newShowState and needOptimize and optimizePeer and (not oldOptimizeTime or ctick - oldOptimizeTime >= optimizePeer) then
            needOptimize = false
            oldOptimizeTime = ctick
            optimize()
        end

        updateLayersPos()
    end

    function obj.setPixelSize(_pixelSize)
        pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
        if type(pixelSize) == "Vec3" then
            _s_pixelSize = vec3_new(pixelSize.x, pixelSize.y, pixelSize.z)
        else
            _s_pixelSize = pixelSize
        end
        if type(pixelSize) == "number" then
            if pixelSize < 0 then
                pixelSize = math_abs(pixelSize)
                local vec = vec3_new(pixelSize, pixelSize, 0)
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            else
                local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            end
        end
        pixelSize.x = pixelSize.x * oldHardwareParams.scale_x * pixelScaleX
        pixelSize.y = pixelSize.y * oldHardwareParams.scale_y * pixelScaleY
        pixelSize.x = pixelSize.x + (0.0025 / sizeX)
        pixelSize.y = pixelSize.y + (0.0025 / sizeY)
        if backplate then
            effect_setScale(backplate, vec3_new(pixelSize.x * sizeX, pixelSize.y * sizeY, pixelSize.z))
        end
        updateLayerDistance(math.max(pixelSize.x * sizeX, pixelSize.y * sizeY) / 1000)
        if additionalLayer then
            effect_setScale(additionalLayer, vec3_new(pixelSize.x * sizeX * 1.005, pixelSize.y * sizeY * 1.005, math.min(2, layerDistance + ((pixelSize.x * sizeX) / 3 / 128))))
        end
        if autoScaleAddValue then
            scaleAddValue = math_min((pixelSize.x + pixelSize.y + pixelSize.z) / 50, 0.0001)
        end
    end

    function obj.setOffset(_offset, noUpdateParameters)
        offset = vec3_new(_offset.x, _offset.y, _offset.z)
        _s_offset = vec3_new(_offset.x, _offset.y, _offset.z)
        offset.x = offset.x + oldHardwareParams.offset_x
        offset.y = offset.y + oldHardwareParams.offset_y
        offset.z = offset.z + oldHardwareParams.offset_z
        updateLayersPos()
        if not noUpdateParameters then
            for index in pairs(nodeEffects) do
                setEffectDataParams(index)
            end
        end
    end

    function obj.setCanvasRotation(_rotation)
        _s_rotation = _rotation
        if type(_rotation) == "Quat" then
        elseif altFromEuler then
            _rotation = custom_fromEulerYEnd(math.rad(_rotation.x) + oldHardwareParams.rotation_x, math.rad(_rotation.y) + oldHardwareParams.rotation_y, math.rad(_rotation.z) + oldHardwareParams.rotation_z)
        else
            _rotation = quat_fromEuler(vec3_new(_rotation.x + math.deg(oldHardwareParams.rotation_x), _rotation.y + math.deg(oldHardwareParams.rotation_y), _rotation.z + math.deg(oldHardwareParams.rotation_z)))
        end
        rotation = _rotation
        if backplate then
            _setRotation(backplate, rotation)
        end
        if additionalLayer then
            _setRotation(additionalLayer, rotation)
        end
        for index, effect in pairs(nodeEffects) do
            _setRotation(effect, rotation)
            setEffectDataParams(index)
        end
        for _, effect in pairs(bufferedEffects) do
            _setRotation(effect, rotation)
        end
    end

    function obj.destroy()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        if backplate then
            effect_destroy(backplate)
        end
        if additionalLayer then
            effect_destroy(additionalLayer)
        end
    end

    local function raw_setResolution(_sizeX, _sizeY)
        drawer.setDrawerResolution(_sizeX, _sizeY)

        for _, effect in pairs(nodeEffects) do
            hideEffect(effect)
        end
        effects = {}
        nodeEffects = {}
        effectDatas = {}
        
        sizeX = _sizeX
        sizeY = _sizeY
        obj.sizeX = sizeX
        obj.sizeY = sizeY
        maxX, maxY = sizeX - 1, sizeY - 1
        maxEffectArrayBuffer = maxX + (maxY * sizeX)
        pixelScaleX, pixelScaleY = defaultSizeX / sizeX, defaultSizeY / sizeY
    end

    function obj.setCanvasResolution(_sizeX, _sizeY)
        raw_setResolution(_sizeX, _sizeY)
        switchHardware()
    end

    ---------------------------------------

    obj.setPixelSize(pixelSize)
    obj.setCanvasRotation(rotation or vec3_new(0, 0, 0))
    obj.setOffset(offset or vec3_new(0, 0, 0))

    ---------------------------------------

    obj.drawer = drawer
    for k, v in pairs(drawer) do
        obj[k] = v
    end
    obj.setWait = _setWait

    function obj.pushDataTunnelParams(dataTunnel)
        if canvasWait then
            wait_dataTunnel = dataTunnel
        else
            wait_dataTunnel = nil
            obj.realPushDataTunnelParams(dataTunnel)
        end
    end

    function obj.realPushDataTunnelParams(dataTunnel)
        obj.setCanvasOptimizationLevel(dataTunnel.optimizationLevel)
        drawer.pushDataTunnelParams(dataTunnel)

        local hardwareParamsChanged = false
        if dataTunnel.res_x ~= sizeX or dataTunnel.res_y ~= sizeY then
            raw_setResolution(dataTunnel.res_x, dataTunnel.res_y)

            hardwareParamsChanged = true
        end

        obj.setAlpha(dataTunnel.light)
        if dataTunnel.material and dataTunnel.material ~= material then
            obj.setCanvasMaterial(dataTunnel.material)
        end
        for key, value in pairs(oldHardwareParams) do
            if dataTunnel[key] ~= value then
                hardwareParamsChanged = true
                oldHardwareParams[key] = dataTunnel[key]
            end
        end
        if hardwareParamsChanged then
            switchHardware()
        end
    end

    return obj
end

--simulates the API of display from SComputers on the client side of your parts
--this is the easiest way to implement the display in your mod
function canvasAPI.createClientScriptableCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local dataTunnel = {}
    local canvas = canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local api = canvasAPI.createScriptableApi(sizeX, sizeY, dataTunnel, nil, canvas.drawer, canvasAPI.materialList, 1, {
        maxOffset = math.huge,
        maxScale = math.huge
    }, {
        maxPixels = math.huge
    })
    api.registerClick = canvasAPI.addTouch(api, dataTunnel)
    api.dataTunnel = dataTunnel
    api.canvas = canvas

    local renderDistance = 15

    for k, v in pairs(canvas) do
        if k ~= "flush" then
            api[k] = v
        end
    end

    function api.getAudience()
        return canvas.isRendering() and 1 or 0
    end

    function api.update()
        canvas.disable(not api.isAllow())
        if dataTunnel.renderAtDistance then
            canvas.setRenderDistance()
        else
            canvas.setRenderDistance(renderDistance)
        end
        canvas.pushDataTunnelParams(dataTunnel)
        canvas.update()
        dataTunnel.scriptableApi_update()

        if dataTunnel.display_reset then
            canvas.drawerReset()
            dataTunnel.display_reset = nil
        end

        if dataTunnel.display_flush then
            if needPushStack(canvas, dataTunnel) then
                canvas.pushStack(dataTunnel.display_stack)
                canvas.flush()
            end
            
            dataTunnel.display_flush()
            dataTunnel.display_stack = nil
            dataTunnel.display_flush = nil
            dataTunnel.display_forceFlush = nil
        end
    end

    function api.setRenderDistance(dist)
        renderDistance = dist
    end

    return api
end

local customFontIndexesCache = {}
local checkedFonts = {}

--implement the SComputers API, does not implement data transfer
function canvasAPI.createScriptableApi(width, height, dataTunnel, flushCallback, drawer, materialList, defaultMaterial, allowHoloAPI, allowSetResolution)
    local defaultResolutionX, defaultResolutionY = width, height
    
    dataTunnel = dataTunnel or {}
    dataTunnel.rotation = 0
    dataTunnel.light = DEFAULT_ALPHA_VALUE
    dataTunnel.skipAtNotSight = false
    dataTunnel.utf8support = false
    dataTunnel.renderAtDistance = false
    dataTunnel.display_forceFlush = true
    dataTunnel.dataUpdated = true
    dataTunnel.optimizationLevel = 16

    local stack = {}
    local stackIndex = 1
    local pixelsCache = {} --optimizations for cameras
    local pixelsCacheExists = false
    local oldStackSum, oldDataSum, oldStack, oldStackIndex
    local forceFlag = false

    local function clearStackForce()
        stack = {}
        stackIndex = 1
    end

    local function clearStack()
        if dataTunnel.display_stack == stack then
            clearStackForce()
        end
    end

    local function setForceFrame()
        if pixelsCacheExists then
            pixelsCache = {}
            pixelsCacheExists = false
        end
        forceFlag = true
        dataTunnel.display_forceFlush = true
    end

    local oldPlayersCount = #sm.player.getAllPlayers()
    function dataTunnel.scriptableApi_update()
        local playersCount = #sm.player.getAllPlayers()
        --local force = sm.game.getCurrentTick() % 80 == 0
        local force = false
        if oldPlayersCount ~= playersCount or force then
            --dataTunnel.display_forceForceFlush = force
            setForceFrame()
            oldPlayersCount = playersCount
        end
    end

    local rwidth, rheight = width, height
    local rmwidth, rmheight = width - 1, height - 1
    local utf8support = false
    local monoFont = true
    local newDataFlag = false
    local spacing = 1
    local fontIndex = 0
    local lastPixelX, lastPixelY, lastPixelColor, lastAction
    local currentSettedFont
    local currentTouchs = {}

    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local dFontX, dFontY = defaultFont.width, defaultFont.height
    local drFontX, drFontY = defaultFont.width, defaultFont.height
    local fontX, fontY
    local mFontX, mFontY
    local xFontX, xFontY
    local sFontX, sFontY
    local rFontX, rFontY
    local fontScaleX, fontScaleY = 1, 1
    local function updateFontSize()
        fontX, fontY = math_ceil(dFontX * fontScaleX), math_ceil(dFontY * fontScaleY)
        rFontX, rFontY = math_ceil(drFontX * fontScaleX), math_ceil(drFontY * fontScaleY)
        mFontX, mFontY = fontX - 1, fontY - 1
        xFontX, xFontY = fontX + 1, fontY + 1
        sFontX, sFontY = fontX + spacing, fontY + 1
    end
    updateFontSize()

    ---------------- color equals check
    local optimizationValue = optimizationLevelToValue(16)

    --local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
    local function colorEquals_smart(color1, color2)
        if color1 == color2 then return true end
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        --return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
        return ((math_abs(rVal - rVal2) + math_abs(gVal - gVal2) + math_abs(bVal - bVal2)) / 1024) <= optimizationValue
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    ----------------

    local api
    local api_flush
    api = {
        --[[
        getBuffer = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,
        getCurrent = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getRealBuffer(x + (y * rwidth))
        end,
        ]]
        get = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,

        -- not implemented (implement it yourself if necessary)
        isAllow = function()
            return true
        end,
        getAudience = function()
            return 1
        end,

        setOptimizationLevel = function(value)
            checkArg(1, value, "number")
            value = round(value)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.optimizationLevel ~= value then
                optimizationValue = optimizationLevelToValue(value)
                if value == 0 then
                    colorEquals = colorEquals_raw
                else
                    colorEquals = colorEquals_smart
                end

                dataTunnel.optimizationLevel = value
                dataTunnel.dataUpdated = true
            end
        end,
        getOptimizationLevel = function()
            return dataTunnel.optimizationLevel
        end,


        -- stubs (outdated methods)
        optimize = function() end,
        setFrameCheck = function () end,
        getFrameCheck = function () return false end,
        setSkipAtLags = function() end,
        getSkipAtLags = function() return false end,


        -- main
        setFontScale = function(scaleX, scaleY)
            checkArg(1, scaleX, "number")
            checkArg(2, scaleY, "number")
            if scaleX < 0 then scaleX = 0 end
            if scaleY < 0 then scaleY = 0 end
            fontScaleX, fontScaleY = scaleX, scaleY
            updateFontSize()
        end,
        getFontScale = function()
            return fontScaleX, fontScaleY
        end,
        setTextSpacing = function(_spacing)
            if _spacing < 0 then _spacing = 0 end
            spacing = _spacing
            updateFontSize()
        end,
        setFontSize = function(_width, _height)
            api.setFontScale(_width / dFontX, _height / dFontY)
        end,
        getTextSpacing = function()
            return spacing
        end,
        calcTextBox = function(text) --it will return two numbers, this will be the size of the box that your text will occupy with this font and this scale
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local totalSize = 0
            if monoFont then
                totalSize = textLen * (fontX + spacing)
            else
                local localFontWidth = dFontX
                local localFont = dataTunnel.customFont or font.optimized
                if fontIndex > 0 and fontsOptimized[fontIndex] then
                    localFont = fontsOptimized[fontIndex]
                    localFontWidth = localFont.width
                end

                local char, chrdata
                for i = 1, textLen do
                    char = sep(text, i, i)
                    if char ~= " " and char ~= spaceCharCode then
                        chrdata = localFont[char] or localFont.error or defaultError
                        totalSize = totalSize + (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                    else
                        totalSize = totalSize + (localFont.spaceSize or localFontWidth) + spacing
                    end
                    canvasAPI.yield()
                end
            end

            return totalSize - spacing, fontY
        end,
        calcCharsSize = function(text) --calculates the length of each character in a string, taking into account its spacing from the next character, and returns a table with these values
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    table_insert(lens, (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing)
                else
                    table_insert(lens, (localFont.spaceSize or localFontWidth) + spacing)
                end
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        calcDecreasingTextSizes = function(text) --it works almost like calcCharsSize. however, each value contains all the previous ones. this is used in the graphic.textBox function, but probably not applicable to any other
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}
            local otherVals = 0

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                local val
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    val = (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                else
                    val = (localFont.spaceSize or localFontWidth) + spacing
                end
                otherVals = otherVals + val
                table_insert(lens, otherVals)
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        isMonospacedFont = function()
            return not not monoFont
        end,

        getWidth = function()
            return rwidth
        end,
        getHeight = function()
            return rheight
        end,
        getSize = function()
            return rwidth, rheight
        end,
        getResolution = function()
            return rwidth, rheight
        end,

        clear = function(color)
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end

            lastAction = nil

            clearStackForce()
            stackIndex = 4
            stack[1] = resetViewportCodeID
            stack[2] = 0
            stack[3] = formatColorToSmallNumber(color, blackSmallNumber)
            
            --[[
            for i = 3, stackIndex - 1 do
                stack[i] = nil
            end
            stackIndex = 3
            ]]
        end,
        drawPixel = function(x, y, color)
            x, y = round(x), round(y)
            if x < 0 or x >= width or y < 0 or y >= height then return end
            local index = x + (y * rwidth)
            color = formatColorToSmallNumber(color, whiteSmallNumber)
            if pixelsCache[index] ~= color then
                if lastAction and x == lastPixelX + 1 and y == lastPixelY and colorEquals(lastPixelColor, color) then
                    if lastAction == 1 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 12
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 1
                elseif lastAction and x == lastPixelX - 1 and y == lastPixelY and colorEquals(lastPixelColor, color) then
                    if lastAction == 2 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 13
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 2
                elseif lastAction and x == lastPixelX and y == lastPixelY + 1 and colorEquals(lastPixelColor, color) then
                    if lastAction == 3 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 14
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 3
                elseif lastAction and x == lastPixelX and y == lastPixelY - 1 and colorEquals(lastPixelColor, color) then
                    if lastAction == 4 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 15
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 4
                else
                    lastPixelColor = color

                    stack[stackIndex] = 16
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = index
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = color
                    stackIndex = stackIndex + 1

                    lastAction = 0
                end

                lastPixelX, lastPixelY = x, y
                pixelsCache[index] = color
                pixelsCacheExists = true
            end
        end,
        fillRect = function(x, y, sizeX, sizeY, color)
            if x <= 0 and y <= 0 and x + sizeX >= width and y + sizeY >= height then
                return api.clear(color or 0xffffff)
            end

            stack[stackIndex] = 2
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawRect = function(x, y, sizeX, sizeY, color, lineWidth)
            lineWidth = round(lineWidth or 1)
            if lineWidth < 1 then
                lineWidth = 1
            end

            stack[stackIndex] = 3
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = lineWidth
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawText = function(x, y, text, color)
            if y > rmheight or y + mFontY < 0 or fontScaleX <= 0 or fontScaleY <= 0 then return end
            text = tostring(text)

            if monoFont then
                local maxTextLen = math_ceil((width - x) / sFontX)
                if maxTextLen <= 0 then return end
                local startTextFrom = math_max(1, math_floor(-x / sFontX) + 1)

                if utf8support then
                    if utf8.len(text) > maxTextLen or startTextFrom > 1 then
                        text = utf8.sub(text, startTextFrom, maxTextLen)
                    end
                else
                    if #text > maxTextLen or startTextFrom > 1 then
                        text = text:sub(startTextFrom, maxTextLen)
                    end
                end

                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x) + ((startTextFrom - 1) * sFontX)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            else
                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCenteredText = function(x, y, text, color, centerX, centerY)
            if centerX == nil then centerX = true end
            if centerY == nil then centerY = true end
            
            local sizeX, sizeY
            if centerX or centerY then
                sizeX, sizeY = api.calcTextBox(text)
            end

            if centerX then
                x = x - (sizeX / 2)
            end

            if centerY then
                y = y - (sizeY / 2)
            end

            api.drawText(x, y, text, color)
        end,
        drawLine = function(x, y, x2, y2, color, width, roundFlag)
            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            stack[stackIndex] = 5
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = width
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 6
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end
            
            stack[stackIndex] = 7
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleEvenly = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 8
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleVeryEvenly = function (x, y, r, color, stroke)
            if r > 1024 then r = 1024 end
            if not stroke or stroke < 1 then stroke = 1 end

            stack[stackIndex] = 9
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(stroke)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawPoly = function(color, ...)
            api.drawWidePoly(color, 1, false, ...)
        end,
        drawWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 10
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillPoly = function(color, ...)
            api.fillWidePoly(color, 1, false, ...)
        end,
        fillWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 11
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawTriangle = function(x1, y1, x2, y2, x3, y3, color)
            api.drawPoly(color, x1, y1, x2, y2, x3, y3)
        end,
        fillTriangle = function(x1, y1, x2, y2, x3, y3, color)
            api.fillPoly(color, x1, y1, x2, y2, x3, y3)
        end,
        flush = function()
            lastAction = nil
            api.setViewport()

            if dataTunnel.display_flush and dataTunnel.display_stack == stack then
                return
            end

            local needFlush = forceFlag
            --print("--------------------------- FLUSH 1", needFlush, stack, stackChecksum(stack), stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel)))

            if not needFlush and stackIndex ~= oldStackIndex then
                --print("FLUSH 2", stackIndex, oldStackIndex)
                needFlush = true
            end

            if not needFlush and newDataFlag then
                local dataSum = stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel))
                if dataSum ~= oldDataSum then
                    --print("FLUSH 3")
                    needFlush = true
                    oldDataSum = dataSum
                end
            end

            if not needFlush and stack ~= oldStack then
                for i = 1, stackIndex - 1 do
                    if stack[i] ~= oldStack[i] then
                        needFlush = true
                        --print("FLUSH 4", oldStack)
                        break
                    end
                end
            end

            --[[
            if needFlush then
                oldStackSum = nil
            else
                local stachSum = stackChecksum(stack)
                if stachSum ~= oldStackSum then
                    --print("FLUSH 5")
                    needFlush = true
                    oldStackSum = stachSum
                end
            end
            ]]
            
            if needFlush then
                --print("FLUSH ACTION")
                oldStack = stack
                oldStackIndex = stackIndex

                dataTunnel.display_stack = stack
                dataTunnel.display_flush = clearStack
                
                if flushCallback then
                    flushCallback()
                end
            else
                clearStackForce()
            end

            forceFlag = false
            newDataFlag = false
        end,
        forceFlush = function()
            api_flush()
            dataTunnel.display_forceFlush = true
        end,

        -- settings
        setUtf8Support = function (state)
            if type(state) == "boolean" then
                if dataTunnel.utf8support ~= state then
                    dataTunnel.utf8support = state
                    dataTunnel.dataUpdated = true
                    newDataFlag = true
                    utf8support = state
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getUtf8Support = function () return dataTunnel.utf8support end,

        setRenderAtDistance = function (c)
            if type(c) == "boolean" then
                if dataTunnel.renderAtDistance ~= c then
                    dataTunnel.renderAtDistance = c
                    dataTunnel.dataUpdated = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getRenderAtDistance = function () return dataTunnel.renderAtDistance end,

        setRotation = function (rotation)
            if type(rotation) == "number" and rotation % 1 == 0 and rotation >= 0 and rotation <= 3 then
                if rotation ~= dataTunnel.rotation then
                    dataTunnel.rotation = rotation
                    dataTunnel.dataUpdated = true
                    newDataFlag = true

                    if pixelsCacheExists then
                        pixelsCache = {}
                        pixelsCacheExists = false
                    end

                    if rotation == 1 or rotation == 3 then
                        rwidth = height
                        rheight = width
                    else
                        rwidth = width
                        rheight = height
                    end
                    rmheight = rheight - 1
                    rmwidth = rwidth - 1
                end
            else
                error("integer must be in [0; 3]", 2)
            end
        end,
        getRotation = function () return dataTunnel.rotation end,

        setFont = function (customFont)
            checkArg(1, customFont, "table", "nil")
            currentSettedFont = customFont
            fontIndex = 0
            if dataTunnel.customFont then
                dataTunnel.dataUpdated = true
                dataTunnel.customFont = nil
            end
            if customFont then
                if not checkedFonts[customFont] then
                    checkFont(customFont)
                    checkedFonts[customFont] = true
                end
                dFontX, dFontY = customFont.width, customFont.height
                drFontX, drFontY = customFont.returnWidth or customFont.width, customFont.returnHeight or customFont.height
                fontIndex = customFontIndexesCache[customFont]
                if not fontIndex then
                    fontIndex = 0
                    for _, v in pairs(fonts) do
                        if v == customFont then
                            fontIndex = v.index
                        end
                    end
                    customFontIndexesCache[customFont] = fontIndex
                end
                if fontIndex == 0 then
                    dataTunnel.customFont = font.optimizeFont(customFont)
                    dataTunnel.dataUpdated = true
                end
                monoFont = customFont.mono or customFont.mono == nil
            else
                dFontX, dFontY = defaultFont.width, defaultFont.height
                drFontX, drFontY = defaultFont.width, defaultFont.height
                monoFont = true
            end
            updateFontSize()
            newDataFlag = true
        end,
        getFont = function()
            return currentSettedFont
        end,

        getFontWidth = function ()
            return rFontX
        end,
        getFontHeight = function ()
            return rFontY
        end,
        getFontSize = function()
            return rFontX, rFontY
        end,

        getRealFontWidth = function ()
            return drFontX
        end,
        getRealFontHeight = function ()
            return drFontY
        end,
        getRealFontSize = function()
            return drFontX, drFontY
        end,

        setSkipAtNotSight = function (state)
            checkArg(1, state, "boolean")
            if dataTunnel.skipAtNotSight ~= state then
                dataTunnel.skipAtNotSight = state
                dataTunnel.dataUpdated = true
            end
        end,
        getSkipAtNotSight = function () return dataTunnel.skipAtNotSight end,

        getViewport = function()
            return viewport_x, viewport_y, viewport_sx, viewport_sy
        end,
        setViewport = function(x, y, sizeX, sizeY)
            if x or y or sizeX or sizeY then
                viewport_x, viewport_y, viewport_sx, viewport_sy = x or 0, y or 0, sizeX or api.getWidth(), sizeY or api.getHeight()
                stack[stackIndex] = -1
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sx)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sy)
                stackIndex = stackIndex + 1
            else
                viewport_x, viewport_y, viewport_sx, viewport_sy = nil, nil, nil, nil
                stack[stackIndex] = resetViewportCodeID
                stackIndex = stackIndex + 1
            end
        end,
        setInlineViewport = function(x, y, sizeX, sizeY)
            if viewport_x then
                local x2 = x + (sizeX - 1)
                local y2 = y + (sizeY - 1)
                local px2 = viewport_x + (viewport_sx - 1)
                local py2 = viewport_y + (viewport_sy - 1)
                if x < viewport_x then x = viewport_x elseif x > px2 then x = px2 end
                if y < viewport_y then y = viewport_y elseif y > py2 then y = py2 end
                if x2 < viewport_x then x2 = viewport_x elseif x2 > px2 then x2 = px2 end
                if y2 < viewport_y then y2 = viewport_y elseif y2 > py2 then y2 = py2 end
                api.setViewport(x, y, (x2 - x) + 1, (y2 - y) + 1)
            else
                api.setViewport(x, y, sizeX, sizeY)
            end
        end,

        setBrightness = function(value) --legacy
            checkArg(1, value, "number")
            --[[
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.brightness ~= value then
                dataTunnel.brightness = value
                dataTunnel.dataUpdated = true
            end
            ]]
        end,
        getBrightness = function() --legacy
            --return dataTunnel.brightness
            return 1
        end,

        setLight = function(value)
            checkArg(1, value, "number")
            value = math_floor(value + 0.5)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.light ~= value then
                dataTunnel.light = value
                dataTunnel.dataUpdated = true
            end
        end,
        getLight = function(value)
            return dataTunnel.light
        end,

        getDefaultResolution = function()
            return defaultResolutionX, defaultResolutionY
        end,

        getTouchs = function()
            for i = 1, MAX_CLICKS do
                local click = api.getClick()
                if not click then
                    break
                end
                local index = #currentTouchs + 1
                for lindex, lclick in reverse_ipairs(currentTouchs) do
                    if lclick.nickname == click.nickname and lclick.button == click.button then
                        index = lindex
                        break
                    end
                end
                if click.state == "released" then
                    table.remove(currentTouchs, index)
                else
                    currentTouchs[index] = click
                end
            end

            return currentTouchs
        end,

        getTouch = function()
            return api.getTouchs()[1]
        end,

        reset = function()
            currentTouchs = {}
            if api.setMaterial then api.setMaterial(api.getDefaultMaterial()) end
            if api.setFontScale then api.setFontScale(1, 1) end
            if api.setTextSpacing then api.setTextSpacing(1) end
            if api.setFont then api.setFont() end
            if api.setRotation then api.setRotation(0) end
            if api.setUtf8Support then api.setUtf8Support(false) end
            if api.setClicksAllowed then api.setClicksAllowed(false) end
            if api.setMaxClicks then api.setMaxClicks(MAX_CLICKS) end
            if api.clearClicks then api.clearClicks() end
            if api.setSkipAtNotSight then api.setSkipAtNotSight(false) end
            if api.setRenderAtDistance then api.setRenderAtDistance(false) end
            if api.setViewport then api.setViewport() end
            if api.setLight then api.setLight(DEFAULT_ALPHA_VALUE) end
            if api.setOptimizationLevel then api.setOptimizationLevel(16) end
            if api.setHoloOffset then api.setHoloOffset(0, 0, 0) end
            if api.setHoloRotation then api.setHoloRotation(0, 0, 0) end
            if api.setHoloScale then api.setHoloScale(1, 1) end
            if api.setResolution then api.setResolution(defaultResolutionX, defaultResolutionY) end
            dataTunnel.display_reset = true
        end
    }

    if materialList then
        defaultMaterial = defaultMaterial or (materialList[0] and 0 or 1)
        local currentMaterialID

        function api.setMaterial(materialId)
            checkArg(1, materialId, "number")
            currentMaterialID = materialId
            if not materialList[currentMaterialID] then
                currentMaterialID = defaultMaterial
            end
            local material = materialList[currentMaterialID]
            if material == true then
                error("this material is not supported on this display", 2)
            end
            if dataTunnel.material ~= material then
                dataTunnel.material = material
                dataTunnel.dataUpdated = true
            end
        end

        function api.getMaterial()
            return currentMaterialID
        end

        function api.getDefaultMaterial()
            return defaultMaterial
        end

        api.setMaterial(api.getDefaultMaterial())
    end

    dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z = 0, 0, 0
    dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z = 0, 0, 0
    dataTunnel.scale_x, dataTunnel.scale_y = 1, 1
    if allowHoloAPI then
        local maxOffset = 5
        local maxScale = 5
        if type(allowHoloAPI) == "table" then
            maxOffset = allowHoloAPI.maxOffset or maxOffset
            maxScale = allowHoloAPI.maxScale or maxScale
        end

        function api.setHoloOffset(x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")
            
            if x < -maxOffset then x = -maxOffset end
            if y < -maxOffset then y = -maxOffset end
            if z < -maxOffset then z = -maxOffset end
            if x > maxOffset then x = maxOffset end
            if y > maxOffset then y = maxOffset end
            if z > maxOffset then z = maxOffset end

            if x ~= dataTunnel.offset_x or y ~= dataTunnel.offset_y or z ~= dataTunnel.offset_z then
                dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z = x, y, z
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloOffset()
            return dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z
        end

        function api.setHoloRotation(x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")
            if x ~= dataTunnel.rotation_x or y ~= dataTunnel.rotation_y or z ~= dataTunnel.rotation_z then
                dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z = x, y, z
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloRotation()
            return dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z
        end

        function api.setHoloScale(x, y)
            checkArg(1, x, "number")
            checkArg(2, y, "number")

            if x < 0 then x = 0 end
            if y < 0 then y = 0 end
            if x > maxScale then x = maxScale end
            if y > maxScale then y = maxScale end

            if x ~= dataTunnel.scale_x or y ~= dataTunnel.scale_y then
                dataTunnel.scale_x, dataTunnel.scale_y = x, y
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloScale()
            return dataTunnel.scale_x, dataTunnel.scale_y
        end
    end

    dataTunnel.res_x, dataTunnel.res_y = defaultResolutionX, defaultResolutionY
    if allowSetResolution then
        if type(allowSetResolution) ~= "table" then
            allowSetResolution = {
                maxPixels = 4096 * 4096,
                maxWidth = 4096,
                maxHeight = 4096
            }
        end

        function api.setResolution(resX, resY)
            checkArg(1, resX, "number")
            checkArg(2, resY, "number")

            resX = math.floor(resX)
            resY = math.floor(resY)
            if resX < 1 then resX = 1 end
            if resY < 1 then resY = 1 end

            if allowSetResolution.maxWidth and resX > allowSetResolution.maxWidth then
                error("the width resolution has been exceeded. maximum: " .. allowSetResolution.maxWidth, 2)
            end

            if allowSetResolution.maxHeight and resX > allowSetResolution.maxHeight then
                error("the height resolution has been exceeded. maximum: " .. allowSetResolution.maxHeight, 2)
            end

            if allowSetResolution.maxPixels and (resX * resY) > allowSetResolution.maxPixels then
                error("the total maximum number of pixels has been exceeded. maximum: " .. allowSetResolution.maxPixels, 2)
            end
            
            if resX ~= dataTunnel.res_x or resY ~= dataTunnel.res_y then
                dataTunnel.res_x, dataTunnel.res_y = resX, resY
                dataTunnel.dataUpdated = true
                dataTunnel.resolutionChanged = true

                if pixelsCacheExists then
                    pixelsCache = {}
                    pixelsCacheExists = false
                end

                width, height = resX, resY
                if dataTunnel.rotation == 1 or dataTunnel.rotation == 3 then
                    rwidth = height
                    rheight = width
                else
                    rwidth = width
                    rheight = height
                end
                rmheight = rheight - 1
                rmwidth = rwidth - 1
            end
        end
    end

    api.update = api.flush
    api.getBuffer = api.get
    api.getCurrent = api.get
    api_flush = api.flush

    local internal = {
        rawPush = function(tbl)
            for i = 1, #tbl do
                stack[stackIndex] = tbl[i]
                stackIndex = stackIndex + 1
            end
        end,
        setForceFrame = setForceFrame
    }

    return api, internal
end

--adds a touch screen API (does not implement click processing)
function canvasAPI.addTouch(api, dataTunnel)
    dataTunnel = dataTunnel or {}
    dataTunnel.clicksAllowed = false
    dataTunnel.maxClicks = MAX_CLICKS
    dataTunnel.clickData = {}

    api.getClick = function ()
        return (table_remove(dataTunnel.clickData, 1))
    end

    api.setMaxClicks = function (c)
        if type(c) == "number" and c % 1 == 0 and c > 0 and c <= 16 then
            dataTunnel.maxClicks = c
        else
            error("integer must be in [1; 16]", 2)
        end
    end

    api.getMaxClicks = function ()
        return dataTunnel.maxClicks
    end

    api.clearClicks = function ()
        dataTunnel.clickData = {}
    end

    api.setClicksAllowed = function (c)
        if type(c) == "boolean" then
            if dataTunnel.clicksAllowed ~= c then
                dataTunnel.clicksAllowed = c
                dataTunnel.dataUpdated = true
            end
        else
            error("Type must be boolean", 2)
        end
    end

    api.getClicksAllowed = function ()
        return dataTunnel.clicksAllowed
    end

    return function (tbl)
        tbl.x = tbl[1] or tbl.x
        tbl.y = tbl[2] or tbl.y
        tbl.state = tbl[3] or tbl.state
        tbl.button = tbl[4] or tbl.button
        tbl.nickname = tbl[5] or tbl.nickname
        tbl[1] = tbl.x or tbl[1]
        tbl[2] = tbl.y or tbl[2]
        tbl[3] = tbl.state or tbl[3]
        tbl[4] = tbl.button or tbl[4]
        tbl[5] = tbl.nickname or tbl[5]
        if #dataTunnel.clickData < dataTunnel.maxClicks then
            table_insert(dataTunnel.clickData, tbl)
        end
    end
end

--leaves only those tunnel fields that are needed for transmission over the network
function canvasAPI.minimizeDataTunnel(dataTunnel)
    return {
        clicksAllowed = dataTunnel.clicksAllowed,
        rotation = dataTunnel.rotation,
        renderAtDistance = dataTunnel.renderAtDistance,
        skipAtNotSight = dataTunnel.skipAtNotSight,
        utf8support = dataTunnel.utf8support,
        customFont = dataTunnel.customFont,
        display_reset = dataTunnel.display_reset,
        optimizationLevel = dataTunnel.optimizationLevel,
        light = dataTunnel.light,
        material = dataTunnel.material,

        offset_x = dataTunnel.offset_x,
        offset_y = dataTunnel.offset_y,
        offset_z = dataTunnel.offset_z,

        rotation_x = dataTunnel.rotation_x,
        rotation_y = dataTunnel.rotation_y,
        rotation_z = dataTunnel.rotation_z,

        scale_x = dataTunnel.scale_x,
        scale_y = dataTunnel.scale_y,

        res_x = dataTunnel.res_x,
        res_y = dataTunnel.res_y
    }
end

-------- additional
canvasAPI.stackChecksum = stackChecksum
canvasAPI.formatColor = formatColor
canvasAPI.formatColorToNumber = formatColorToNumber
canvasAPI.formatColorToSmallNumber = formatColorToSmallNumber
canvasAPI.checkFont = checkFont
canvasAPI.simpleRemathRect = simpleRemathRect
canvasAPI.remathRect = remathRect
canvasAPI.hexToRGB = hexToRGB
canvasAPI.hexToRGB256 = hexToRGB256
canvasAPI.posCheck = posCheck
canvasAPI.mathDist = mathDist
canvasAPI.needPushStack = needPushStack
canvasAPI.font = font
canvasAPI.tableClone = tableClone
canvasAPI.canvasService = canvasService
canvasAPI.userCalls = userCalls
canvasAPI.dataSizes = dataSizes
canvasAPI.color_new_fromSmallNumber = color_new_fromSmallNumber
canvasAPI.getEffectName = getEffectName
canvasAPI.fonts = fonts
canvasAPI.utf8 = utf8

function canvasAPI.pushData(stack, ...)
    for i, v in ipairs({...}) do
        table.insert(stack, v)
    end
end

_G.canvasAPI = canvasAPI
end
function scmframework_f0a21015ebf808a460b5c6d00b193c7d() --$CONTENT_DATA/Scripts/canvasAPI/backup/canvas_best5.lua
print("> canvas.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/luajit.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/load.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/utf8.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/canvasService.lua")

local debugMode = false
local profileMode = false

local canvasAPI = {
    draw = {
        clear = 0,
        set   = 1,
        fill  = 2,
        rect  = 3,
        text  = 4,
        line  = 5,
        circle  = 6,
        circleF = 7,
        circleE = 8,
        circleVE = 9,
        poly = 10,
        polyF = 11,

        copyNX = 12,
        copyPX = 13,
        copyNY = 14,
        copyPY = 15,
        setI = 16
    },
    material = {
        glass = sm.uuid.new("a683f897-5b8a-4c96-9c46-7b9fbc76d186"),
        classic = sm.uuid.new("8328a29d-35e0-471b-8bfe-06952e9d916d"),
        plastic = sm.uuid.new("82d2da58-6597-4ffa-9b53-1af3b707fa7a"),
        smoothed = sm.uuid.new("a23a4ea2-96da-4bb2-a723-af8c27de2511"),
        glowing = sm.uuid.new("b46ae32a-9037-4360-9f98-3bef1cd4f366")
    },
    multi_layer = {}
}

canvasAPI.multi_layer[tostring(canvasAPI.material.classic)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.plastic)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.smoothed)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.glowing)] = true
canvasAPI.version = 56

canvasAPI.materialList = {
    [0] = canvasAPI.material.glass,
    canvasAPI.material.classic,
    canvasAPI.material.plastic,
    canvasAPI.material.smoothed,
    canvasAPI.material.glowing
}

canvasAPI.materialListWithoutGlass = {
    [0] = true,
    canvasAPI.material.classic,
    canvasAPI.material.plastic,
    canvasAPI.material.smoothed,
    canvasAPI.material.glowing
}

local MAX_DRAW_TIME = 2 --protecting the world from crashing using the display
local FONT_SIZE_LIMIT = 256
local DEFAULT_ALPHA_VALUE = 255
local MAX_CLICKS = 16
canvasAPI.DEFAULT_ALPHA_VALUE = DEFAULT_ALPHA_VALUE

local font = font
local defaultFont = font.default
local fonts = font.fonts
local fontsOptimized = font.fontsOptimized
local spaceCharCode = string.byte(" ")

local huge = math.huge
local string_len = string.len
local bit = bit or bit32
local bit_rshift = bit.rshift
local bit_lshift = bit.lshift
local utf8 = utf8
local string = string
local table_sort = table.sort
local type = type
local math_ceil = math.ceil
local math_max = math.max
local string_format = string.format
local table_insert = table.insert
local table_remove = table.remove
local math_floor = math.floor
local vec3_new = sm.vec3.new
local color_new = sm.color.new
local quat_fromEuler = sm.quat.fromEuler
local ipairs = ipairs
local pairs = pairs
local string_byte = string.byte
local defaultError = font.optimized.error
local tostring = tostring
local math_abs = math.abs
local math_min = math.min
local string_sub = string.sub
local table_concat = table.concat
local tonumber = tonumber
local utf8_len = utf8.len
local utf8_sub = utf8.sub
local sm_localPlayer_getPlayer = sm.localPlayer.getPlayer
local os_clock = os.clock
local math_sqrt = math.sqrt
local quat_new = sm.quat.new
local game_getCurrentTick = sm.game.getCurrentTick

local black = color_new(0, 0, 0)
local white = color_new(1, 1, 1)
local blackNumber = 0x000000ff
local whiteNumber = 0xffffffff
local blackSmallNumber = 0x000000
local whiteSmallNumber = 0xffffff

local getEffectName
do
    local currentEffect = 1
    local effectsNames = {}

    for i = 0, 255 do
        table_insert(effectsNames, "ShapeRenderable" .. tostring(i))
    end

    function getEffectName()
        local name = effectsNames[currentEffect]
        currentEffect = currentEffect + 1
        if currentEffect > #effectsNames then
            currentEffect = 1
        end
        return name
    end
end

local function profillerPrint(name, execTime)
    local t = execTime * 1000
    if profileMode and t > 0 then
        print("profiller", name, t)
    end
end

local function profiller(name, startTime)
    profillerPrint(name, os_clock() - startTime)
end

--[[
local sm_effect_createEffect = sm.effect.withoutHook_createEffect or sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local withoutHookEmptyEffect = emptyEffect
local whook = "withoutHook_"
if better and better.version >= 45 and better.isAvailable() then
    local mt = getmetatable(emptyEffect)
    local newMt = {}
    for k, v in pairs(mt) do
        newMt[k] = v
    end
    for k, v in pairs(mt) do
        if k:sub(1, #whook) == whook then
            newMt[k:sub(#whook + 1, #k)] = v
        end
    end
    withoutHookEmptyEffect = setmetatable({}, newMt)
end
local effect_setParameter = withoutHookEmptyEffect.setParameter
local effect_stop = withoutHookEmptyEffect.stop
local effect_destroy = withoutHookEmptyEffect.destroy
local effect_start = withoutHookEmptyEffect.start
local effect_isDone = withoutHookEmptyEffect.isDone
local effect_isPlaying = withoutHookEmptyEffect.isPlaying
local effect_setScale = withoutHookEmptyEffect.setScale
local effect_setOffsetPosition = withoutHookEmptyEffect.setOffsetPosition
local effect_setOffsetRotation = withoutHookEmptyEffect.setOffsetRotation
effect_destroy(emptyEffect)
]]

local sm_effect_createEffect = sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local effect_setParameter = emptyEffect.setParameter
local effect_stop = emptyEffect.stop
local effect_destroy = emptyEffect.destroy
local effect_start = emptyEffect.start
local effect_isDone = emptyEffect.isDone
local effect_isPlaying = emptyEffect.isPlaying
local effect_setScale = emptyEffect.setScale
local effect_setOffsetPosition = emptyEffect.setOffsetPosition
local effect_setOffsetRotation = emptyEffect.setOffsetRotation
local effect_setPosition = emptyEffect.setPosition
local effect_setRotation = emptyEffect.setRotation
effect_destroy(emptyEffect)

local function reverse_ipairs(t)
    local i = #t + 1
    return function()
        i = i - 1
        if i > 0 then
            return i, t[i]
        end
    end
end

local function round(number)
    return math_floor(number + 0.5)
end

local function checkFont(lfont)
    if type(lfont) ~= "table" then
        error("the font should be a table", 3)
    end

    if lfont.mono or lfont.mono == nil then
        if type(lfont.chars) ~= "table" or (type(lfont.width) ~= "number") or (type(lfont.height) ~= "number") then
            error("invalid basic char data", 3)
        end
        
        if lfont.width > FONT_SIZE_LIMIT then
            error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
        elseif lfont.height > FONT_SIZE_LIMIT then
            error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
        end

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data ~= lfont.height then
                error("font failed integrity check", 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" then
                    error("the char string has the wrong type", 3)
                elseif #line ~= lfont.width then
                    print(char, #line, data)
                    error("the char string has the wrong lenght", 3)
                end
            end
        end
    else
        if type(lfont.chars) ~= "table" then
            error("font failed integrity check", 3)
        end

        local oFont = font.optimizeFont(lfont)
        lfont.spaceSize = oFont.spaceSize
        lfont.width = oFont.width
        lfont.height = oFont.height

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data > FONT_SIZE_LIMIT then
                error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" or #line > FONT_SIZE_LIMIT then
                    error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
                end
            end
        end
    end
end

local function doQuat(x, y, z, w)
    local sin = math.sin(w / 2)
    return quat_new(sin * x, sin * y, sin * z, math.cos(w / 2))
end

local function custom_fromEulerYEnd(x, y, z) --custom implementation
    return doQuat(1, 0, 0, x) * doQuat(0, 0, 1, z) * doQuat(0, 1, 0, y)
end

local function tableClone(tbl)
    local newtbl = {}
    for k, v in pairs(tbl) do
        newtbl[k] = v
    end
    return newtbl
end

local function stackChecksum(stack)
    local num = -#stack
    local t, v
    for i = 1, #stack do
        v = stack[i]
        t = type(v)
        num = num - i
        if t == "number" then
            num = num + ((v * i) + v + i + (v / i))
        elseif t == "Color" then
            num = num + ((i * (v.r / i) * -4) + v.g)
            num = num - ((i * (v.g + i) * 5) + v.b)
            num = num + ((i * (v.b - i) * 8) + v.r)
        elseif t == "string" then
            for i3 = 1, #v do
                num = num + (i * (-i3 - (string_byte(v, i3) * i3)))
            end
        end
    end
    return num
end

local function checkArg(n, have, ...)
    have = type(have)
    local tbl = {...}
    for _, t in ipairs(tbl) do
        if have == t then
            return
        end
    end
    error(string_format("bad argument #%d (%s expected, got %s)", n, table_concat(tbl, " or "), have), 3)
end

local function simpleRemathRect(x, y, w, h, maxX, maxY)
    local x2, y2 = x + (w - 1), y + (h - 1)
    if x < 0 then
        x = 0
    elseif x > maxX then
        --x = maxX
        return
    end
    if y < 0 then
        y = 0
    elseif y > maxY then
        --y = maxY
        return
    end
    if x2 < 0 then
        --x2 = 0
        return
    elseif x2 > maxX then
        x2 = maxX
    end
    if y2 < 0 then
        --y2 = 0
        return
    elseif y2 > maxY then
        y2 = maxY
    end
    return x, y, x2, y2, w, h
end

local function remathRect(offset, stack, maxX, maxY)
    return simpleRemathRect(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], maxX, maxY)
end

local function posCheck(width, height, x, y)
    return x >= 0 and y >= 0 and x < width and y < height
end

local hashChar = string.byte("#")
local bit = bit or bit32
local band = bit.band
local rshift = bit.rshift
local function hexToRGB(color)
    return math_floor(color / 256 / 256) / 255, (math_floor(color / 256) % 256) / 255, (color % 256) / 255
end

local function hexToRGB256(color)
    return math_floor(color / 256 / 256), math_floor(color / 256) % 256, color % 256
end

local function optimizationLevelToValue(level)
    return (level / 255) * 0.25
end

local function formatColor(color, default)
    local t = type(color)
    if t == "Color" then
        return color
    elseif t == "string" then
        return color_new(color)
    elseif t == "number" then
        return color_new(hexToRGB(color))
    end

    return default
end

local redMul = 256 * 256 * 256
local greenMul = 256 * 256
local blueMul = 256
local function formatColorToNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * redMul) + (math_floor(color.g * 255) * greenMul) + (math_floor(color.b * 255) * blueMul) + math_floor(color.a * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return val
        end
        return (val * 256) + 255
    elseif t == "number" then
        return (color * 256) + 255
    end

    return default or 0
end

local function formatColorToSmallNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * greenMul) + (math_floor(color.g * 255) * blueMul) + math_floor(color.b * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return math_floor(val / 256)
        end
        return val
    elseif t == "number" then
        return color
    end

    return default or 0
end

local function color_new_fromSmallNumber(number, alpha)
    return color_new((number * 256) + (alpha or 255))
end

local function mathDist(pos1, pos2)
    return math.sqrt(((pos1.x - pos2.x) ^ 2) + ((pos1.y - pos2.y) ^ 2) + ((pos1.z - pos2.z) ^ 2))
end

local function needPushStack(canvas, dataTunnel) --returns true if the rendering stack should be applied
    return dataTunnel.display_forceFlush or not ((dataTunnel.skipAtNotSight and not canvas.isRendering()))
end

local resetViewportCodeID = -23124
local dataSizes = {
    [resetViewportCodeID] = 1,
    [-1] = 5,
    [0] = 2,
    4,
    6,
    7,
    9, --text
    7, --line
    5,
    5,
    5,
    6,

    4, --drawPoly
    4, --fillPoly

    2,
    2,
    2,
    2,
    3
}

local userCalls = {}

canvasAPI.yield = function() end

function canvasAPI.createDrawer(sizeX, sizeY, callback, callbackBefore, directArg, direct_clear, direct_fill, direct_set, updatedList)
    local obj = {}
    local oldStackSum
    local rSizeX, rSizeY = sizeX, sizeY
    local maxX, maxY = sizeX - 1, sizeY - 1
    local newBuffer, newBufferBase = {}, 0
    local realBuffer = {}
    local maxBuffer = maxX + (maxY * sizeX)
    local currentFont = font.optimized
    local fontWidth, fontHeight = defaultFont.width, defaultFont.height
    local rotation = 0
    local utf8Support = false
    local updated = false
    local clearOnly = false
    local clearBackplate = false
    local maxLineSize = sizeX + sizeY
    local bigSide = math_max(sizeX, sizeY)
    local drawerData = {}
    local _oldBufferBase
    local changes = {}
    local _changes = {}
    local changesIndex, changesCount = {}, 0

    local viewportEnable = false
    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local function bufferRangeUpdate() end

    local function setDot(px, py, col)
        if viewportEnable and (px < viewport_x or py < viewport_y or px >= (viewport_x + viewport_sx) or py >= (viewport_y + viewport_sy)) then
            return
        end

        --[[
        if rotation == 0 then
            index = px + (py * rSizeX)
        elseif rotation == 1 then
            index = (rSizeX - py - 1) + (px * rSizeX)
        elseif rotation == 2 then
            index = (rSizeX - px - 1) + ((rSizeY - py - 1) * rSizeX)
        else
            index = py + ((rSizeY - px - 1) * rSizeX)
        end
        ]]

        local index
        if rotation == 0 then
            index = py + (px * rSizeY)
        elseif rotation == 1 then
            index = px + ((rSizeX - py - 1) * rSizeY)
        elseif rotation == 2 then
            index = (rSizeY - py - 1) + ((rSizeX - px - 1) * rSizeY)
        else
            index = (rSizeY - px - 1) + (py * rSizeY)
        end

        if direct_set then
            newBuffer[index] = col
            direct_set(directArg, math_floor(index / rSizeY), index % rSizeY, col)
            return true
        elseif newBuffer[index] ~= col then
            if updatedList and not changes[index] then
                changes[index] = true
                changesCount = changesCount + 1
                changesIndex[changesCount] = index
            end

            newBuffer[index] = col
            return true
        end
    end

    local function check(px, py)
        return px >= 0 and py >= 0 and px < sizeX and py < sizeY
    end

    local function checkSetDot(px, py, col)
        if check(px, py) then
            setDot(px, py, col)
            return true
        end
        return false
    end

    function obj.drawerReset()
    end

    function obj.drawer_setRotation(_rotation)
        rotation = _rotation
        if rotation == 1 or rotation == 3 then
            sizeX = rSizeY
            sizeY = rSizeX
        else
            sizeX = rSizeX
            sizeY = rSizeY
        end
        maxX, maxY = sizeX - 1, sizeY - 1
    end

    function obj.drawer_setUtf8Support(state)
        utf8Support = not not state
    end

    function obj.drawer_setFont(customFont)
        if customFont then
            currentFont = customFont
            fontWidth, fontHeight = customFont.width, customFont.height
        else
            currentFont = font.optimized
            fontWidth, fontHeight = defaultFont.width, defaultFont.height
        end
    end

    function obj.setDrawerResolution(_sizeX, _sizeY)
        rSizeX, rSizeY = _sizeX, _sizeY
        obj.drawer_setRotation(rotation)
        newBuffer, newBufferBase = {}, 0
        realBuffer = {}
        maxBuffer = maxX + (maxY * sizeX)
        maxLineSize = sizeX + sizeY
        bigSide = math_max(sizeX, sizeY)
        changes = {}
        _changes = {}
        changesIndex, changesCount = {}, 0
        oldStackSum = nil
    end

    local old_rotation
    local old_utf8support
    local old_customFont
    function obj.pushDataTunnelParams(params)
        if params.rotation ~= old_rotation then
            obj.drawer_setRotation(params.rotation)
            old_rotation = params.rotation
        end
        if params.utf8support ~= old_utf8support then
            obj.drawer_setUtf8Support(params.utf8support)
            old_utf8support = params.utf8support
        end
        if params.customFont ~= old_customFont then
            obj.drawer_setFont(params.customFont)
            old_customFont = params.customFont
        end
    end

    ------------------------------------------
    
    local function rasterize_fill(x, y, sx, sy, col)
        local x, y, x2, y2 = simpleRemathRect(x, y, sx, sy, maxX, maxY)
        if not x then return end

        local ix, iy = x, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy + 1
            if iy > y2 then
                iy = y
                ix = ix + 1
            end
        end

        --[[
        local ix, iy = x, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            ix = ix + 1
            if ix > x2 then
                ix = x
                iy = iy + 1
            end
        end
        ]]

        --[[
        local ix, iy = x2, y2
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy - 1
            if iy < y then
                iy = y2
                ix = ix - 1
            end
        end
        ]]

        --[[
        local ix, iy = x2, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy + 1
            if iy > y2 then
                iy = y
                ix = ix - 1
            end
        end
        ]]
    end

    local function rasterize_circleF(px, py, r, col)
        local chr = r*r
        local sx, sy, tempInt, tempBool

        if r < bigSide and px >= 0 and py >= 0 and px < sizeX and py < sizeY then --now only a quarter of the circle is rendered
            for iy = 0, r do
                sy = iy + 0.5
                tempBool = false
                for ix = r, 0, -1 do
                    sx = ix + 0.5
                    if tempBool or (sx * sx) + (sy * sy) <= chr then
                        tempBool = true
                        checkSetDot(px + ix, py + iy, col)
                        checkSetDot(px - ix - 1, py + iy, col)
                        checkSetDot(px + ix, py - iy - 1, col)
                        checkSetDot(px - ix - 1, py - iy - 1, col)
                    end
                end
            end
        else
            for ix = math_max(-r, -px), math_min(r, (sizeX - px) - 1) do --if the starting point is not within the screen or the circle is too large, then will have to check every pixel
                sx = ix + 0.5
                for iy = math_max(-r, -py), math_min(r, (sizeY - py) - 1) do
                    sy = iy + 0.5
                    if (sx * sx) + (sy * sy) <= chr then
                        setDot(px + ix, py + iy, col)
                    end
                end
            end
        end
    end

    local function rasterize_line(px, py, px2, py2, col, width, linesInfo)
        if px2 < px or py2 < py then
            local _px, _py = px, py
            px, py = px2, py2
            px2, py2 = _px, _py
        end
        local dx = math_abs(px2 - px)
        local dy = math_abs(py2 - py)
        local sx = (px < px2) and 1 or -1
        local sy = (py < py2) and 1 or -1
        local err = dx - dy
        if width == -1 or width == 0 or width == 1 then
            local drawAllowed = false
            for _ = 1, maxLineSize do
                if check(px, py) then
                    setDot(px, py, col)
                    drawAllowed = true
                elseif drawAllowed then
                    break
                end
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        elseif width < 0 then
            width = math_ceil((-width) / 2)
            if width < 1 then
                width = 1
            end
            for _ = 1, maxLineSize do
                rasterize_circleF(px, py, width, col)
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        else
            local offsetFill = math_floor(width / 2)
            for _ = 1, maxLineSize do
                rasterize_fill(px - offsetFill, py - offsetFill, width, width, col)
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        end
    end

    ------------------------------------------

    local function render_fill(stack, offset)
        local col = stack[offset+4]
        if direct_fill then
            direct_fill(directArg, stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
        else
            rasterize_fill(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
        end
    end

    local function render_rect(stack, offset)
        local x, y, x2, y2, w, h = remathRect(offset, stack, maxX, maxY)
        if not x then return end
        local col = stack[offset+4]
        local lineWidth = stack[offset+5]
        if lineWidth == 1 then
            for ix = x, x2 do
                setDot(ix, y, col)
                setDot(ix, y2, col)
            end

            for iy = y + 1, y2 - 1 do
                setDot(x, iy, col)
                setDot(x2, iy, col)
            end
        else
            local _y, _y2, _x, _x2
            for ioff = 0, math_min(lineWidth, math_max(w, h) / 2) - 1 do
                _y = y + ioff
                _y2 = y2 - ioff
                for ix = x + ioff, x2 - ioff do
                    setDot(ix, _y, col)
                    setDot(ix, _y2, col)
                end

                _x = x + ioff
                _x2 = x2 - ioff
                for iy = y + 1 + ioff, y2 - (1 + ioff) do
                    setDot(_x, iy, col)
                    setDot(_x2, iy, col)
                end
            end
        end
    end

    local function render_text(stack, offset)
        local tx, ty = stack[offset], stack[offset+1]
        local text = stack[offset+2]
        local col = stack[offset+3]
        local scaleX = stack[offset+4]
        local scaleY = stack[offset+5]
        local spacing = stack[offset+6]
        local fontIndex = stack[offset+7]

        local localFont = currentFont
        local localFontWidth = fontWidth
        if fontIndex > 0 and fontsOptimized[fontIndex] then
            localFont = fontsOptimized[fontIndex]
            localFontWidth = localFont.width
        end

        local len, sep
        if utf8Support then
            len, sep = utf8_len, utf8_sub
        else
            len, sep = string_len, string_byte
        end
        local scaledFontWidth = math_ceil(localFontWidth * scaleX)
        if localFont.mono then
            for i = len(text), 1, -1 do
                local char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    local chrdata = localFont[char] or localFont.error or defaultError
                    local charOffset = (i - 1) * (scaledFontWidth + spacing)
                    for i2 = 1, #chrdata, 2 do
                        local px, py = chrdata[i2], chrdata[i2 + 1]
                        local lposX, lposY = round(px * scaleX), round(py * scaleY)
                        for ix = math_min(sizeX, round((px + 1) * scaleX) - lposX - 1), 0, -1 do
                            local setPosX = tx + ix + lposX + charOffset
                            for iy = math_min(sizeY, round((py + 1) * scaleY) - lposY - 1), 0, -1 do
                                checkSetDot(setPosX, ty + iy + lposY, col)
                            end
                        end
                    end
                end
            end
        else
            local charOffset = 0
            local startDrawTime = os_clock()
            for i = 1, len(text) do
                local char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    local chrdata = localFont[char] or localFont.error or defaultError
                    local charPos = tx + charOffset
                    if not chrdata[0] or charPos + round(chrdata[0] * scaleX) > 0 then
                        if charPos > maxX then
                            goto endDraw
                        end
                        for i2 = 1, #chrdata, 2 do
                            local px, py = chrdata[i2], chrdata[i2 + 1]
                            local lposX, lposY = round(px * scaleX), round(py * scaleY)
                            for ix = 0, math_min(sizeX, round((px + 1) * scaleX) - lposX - 1) do
                                local setPosX = tx + ix + lposX + charOffset
                                for iy = 0, math_min(sizeY, round((py + 1) * scaleY) - lposY - 1) do
                                    checkSetDot(setPosX, ty + iy + lposY, col)
                                end
                            end
                        end
                    end
                    charOffset = charOffset + (chrdata[0] and math_ceil(chrdata[0] * scaleX) or 0) + spacing
                else
                    charOffset = charOffset + (math_ceil(localFont.spaceSize * scaleX) or localFontWidth) + spacing
                end
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
        end
        ::endDraw::
    end

    local function render_line(stack, offset)
        rasterize_line(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4], stack[offset+5])
    end

    local function render_circle(stack, offset) --Michener’s Algorithm
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx, py + dy, col)
            checkSetDot(px + dy, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy, col)
            checkSetDot(px + dy, py - dx, col)
            checkSetDot(px + dx, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleE(stack, offset)
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx - 1, py + dy - 1, col)
            checkSetDot(px + dy - 1, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy - 1, col)
            checkSetDot(px + dy - 1, py - dx, col)
            checkSetDot(px + dx - 1, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleF(stack, offset)
        rasterize_circleF(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3])
    end

    local function render_circleVE(stack, offset) --drawCircleVeryEvenly
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local chr = e2*e2
        local col = stack[offset+3]
        local sx, sy, tempInt, tempBool

        e2 = math_min(e2, bigSide)
        for iy = 0, e2 do
            sy = iy + 0.5
            tempInt = stack[offset+4]
            for ix = e2, 0, -1 do
                sx = ix + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
        for ix = 0, e2 do
            sx = ix + 0.5
            tempInt = stack[offset+4]
            for iy = e2, 0, -1 do
                sy = iy + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
    end

    local function render_drawPoly(stack, offset, getFillInfo)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local startDrawTime = os_clock()
        local _px = stack[offset+3]
        local _py = stack[offset+4]
        local px, py
        local pointsPos
        if getFillInfo then
            pointsPos = {}

            local _setDot = setDot
            setDot = function(px, py, col)
                if not pointsPos[py] then
                    pointsPos[py] = {px, px}
                else
                    local data = pointsPos[py]
                    if px < data[1] then data[1] = px end
                    if px > data[2] then data[2] = px end
                end
            end
            
            for i = 3, points, 2 do
                px = stack[offset+2+i]
                py = stack[offset+3+i]
                rasterize_line(_px, _py, px, py, col, width)
                _px = px
                _py = py
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width)

            setDot = _setDot
        else
            for i = 3, points, 2 do
                px = stack[offset+2+i]
                py = stack[offset+3+i]
                rasterize_line(_px, _py, px, py, col, width)
                _px = px
                _py = py
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width)
        end
        
        ::endDraw::
        return points, pointsPos
    end

    local function render_fillPoly(stack, offset)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local gpoints = points
        for ii = 0, points / 2, 2 do
            local i = ii * 2
            local _, pointsPos = render_drawPoly({col, math_min(6, gpoints), width, stack[offset+3+i], stack[offset+4+i], stack[offset+5+i], stack[offset+6+i], stack[offset+7+i], stack[offset+8+i]}, 1, true)
            local startDrawTime = os_clock()
            for posY, v in pairs(pointsPos) do
                for i = v[1], v[2] do
                    setDot(i, posY, col)
                end

                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            gpoints = gpoints - 4
            if gpoints <= 0 then
                break
            end
        end

        ::endDraw::
        return points
    end

    local lastPixelX, lastPixelY, lastPixelColor
    function obj.pushStack(stack)
        local offset = 2
        local actionNum
        local addValue = 0
        local startDrawTime = os_clock()
        local idx
        while stack[offset] do
            actionNum = stack[offset-1]
            clearOnly = actionNum == 0
            addValue = 0

            if actionNum == 0 then
                newBufferBase = stack[offset]
                newBuffer = {}
                if direct_clear then
                    direct_clear(directArg, newBufferBase, changes)
                end
                updated = true
                clearBackplate = true
                if callback and newBufferBase ~= _oldBufferBase then
                    obj.fullRefresh()
                    _oldBufferBase = newBufferBase
                end
            elseif actionNum == resetViewportCodeID then
                viewportEnable = false
            elseif actionNum == -1 then
                viewportEnable = true
                viewport_x = stack[offset]
                viewport_y = stack[offset+1]
                viewport_sx = stack[offset+2]
                viewport_sy = stack[offset+3]
            elseif actionNum == 1 then
                setDot(stack[offset], stack[offset+1], stack[offset+2])
                updated = true
            elseif actionNum == 2 then
                render_fill(stack, offset)
                updated = true
            elseif actionNum == 3 then
                render_rect(stack, offset)
                updated = true
            elseif actionNum == 4 then
                render_text(stack, offset)
                updated = true
            elseif actionNum == 5 then
                render_line(stack, offset)
                updated = true
            elseif actionNum == 6 then
                render_circle(stack, offset)
                updated = true
            elseif actionNum == 8 then
                render_circleE(stack, offset)
                updated = true
            elseif actionNum == 7 then
                render_circleF(stack, offset)
                updated = true
            elseif actionNum == 9 then
                render_circleVE(stack, offset)
                updated = true
            elseif actionNum == 10 then
                addValue = render_drawPoly(stack, offset)
                updated = true
            elseif actionNum == 11 then
                addValue = render_fillPoly(stack, offset)
                updated = true
            elseif actionNum == 12 then
                for _ = 1, stack[offset] do
                    lastPixelX = lastPixelX + 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 13 then
                for _ = 1, stack[offset] do
                    lastPixelX = lastPixelX - 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 14 then
                for _ = 1, stack[offset] do
                    lastPixelY = lastPixelY + 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 15 then
                for _ = 1, stack[offset] do
                    lastPixelY = lastPixelY - 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 16 then
                idx = stack[offset]
                lastPixelX, lastPixelY, lastPixelColor = idx % rSizeX, math_floor(idx / rSizeX), stack[offset+1]
                setDot(lastPixelX, lastPixelY, lastPixelColor)
                updated = true
            elseif userCalls[actionNum] then
                if userCalls[actionNum](newBuffer, rotation, rSizeX, rSizeY, sizeX, sizeY, stack, offset, drawerData, bufferRangeUpdate, setDot, checkSetDot, rasterize_fill) then
                    updated = true
                end
            end

            if os_clock() - startDrawTime > MAX_DRAW_TIME then
                goto endDraw
            end

            offset = offset + dataSizes[actionNum] + addValue
        end

        ::endDraw::
    end

    function obj.flush(force)
        if not obj.wait and (updated or force) then
            if callbackBefore and callbackBefore(newBufferBase, clearOnly, maxBuffer, force, newBuffer, realBuffer, nil, nil, changes, changesIndex, changesCount, _changes, clearBackplate) then
                realBuffer = {}
            end

            if callback then
                --[[
                local color, px, py
                for i = bufferChangedFrom, bufferChangedTo do
                    color = newBuffer[i] or newBufferBase
                    if color ~= realBuffer[i] or force then
                        px = math_floor(i / rSizeY)
                        py = i % rSizeY
                        callback(px, py, color, newBufferBase)
                        realBuffer[i] = color
                    end
                end
                ]]

                local oldChanges
                if clearBackplate then
                    oldChanges = {}
                    for index in pairs(changes) do
                        oldChanges[index] = true
                    end

                    for index in pairs(_changes) do
                        if not changes[index] then
                            changesCount = changesCount + 1
                            changesIndex[changesCount] = index
                            changes[index] = true
                        end
                    end
                end
        
                for i2 = 1, changesCount do
                    local index = changesIndex[i2]
                    --if changes[index] then
                        callback(math_floor(index / sizeY), index % sizeY, newBuffer[index] or newBufferBase, newBufferBase)
                        _changes[index] = true
                    --end
                end

                if clearBackplate then
                    obj.setOldChanges(oldChanges)
                end
            end

            updated = false
            clearBackplate = false
            if updatedList then
                changes = {}
                changesIndex = {}
                changesCount = 0
            end
        end
    end

    function obj.setWait(state)
        obj.wait = state
        if not state then
            obj.flush()
        end
    end

    function obj.getNewBuffer(i)
        return newBuffer[i] or newBufferBase
    end

    function obj.getRealBuffer(i)
        return realBuffer[i]
    end

    function obj.getChanges()
        return changes
    end

    function obj.fullRefresh()
        changesCount = 0
        changesIndex = {}
        for i = 0, (sizeX * sizeY) - 1 do
            changes[i] = true
            changesCount = changesCount + 1
            changesIndex[changesCount] = i
        end
    end

    --[[
    function obj.flushOldChanges()
        _changes = changes
    end
    ]]

    function obj.setOldChanges(oldChanges)
        _changes = oldChanges
    end

    function obj.clearChangesBuffer()
        _changes = {}
        changes = {}
    end

    return obj
end

if better and better.isAvailable() and better.canvas and better.version >= 40 then
    local better_canvas_clear = better.canvas.clear
    local better_canvas_fill = better.canvas.fill
    local better_canvas_set = better.canvas.set

    function canvasAPI.createBetterCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation)
        local obj = {sizeX = sizeX, sizeY = sizeY}
        local maxX, maxY = sizeX - 1, sizeY - 1
        local maxEffectArrayBuffer = maxX + (maxY * sizeX)
        local dist
        local needOptimize = false
        local showState = false
        local disable = false
        local flushedDefault = false

        local betterCanvas = better.canvas.create(sizeX, sizeY)

        local drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, nil, betterCanvas, better_canvas_clear, better_canvas_fill, better_canvas_set)
        drawer.setWait(true)

        local defaultPosition = vec3_new(0, 0, 0)
        local function getSelfPos()
            local pt = type(parent)
            if pt == "Interactable" then
                return parent.shape.worldPosition
            elseif pt == "Character" then
                return parent.worldPosition
            end
            return defaultPosition
        end

        function obj.isRendering()
            return showState
        end

        function obj.disable(state)
            disable = state
        end

        function obj.setRenderDistance(_dist)
            dist = _dist
        end

        function obj.update()
            local newShowState = true
            local selfPosition
            if disable then
                newShowState = false
            elseif dist then
                if not pcall(function()
                    selfPosition = getSelfPos()
                    newShowState = mathDist(selfPosition, sm_localPlayer_getPlayer().character.worldPosition) <= dist
                end) then
                    selfPosition = selfPosition or vec3_new(0, 0, 0)
                    newShowState = false
                end
            end

            if newShowState ~= showState then
                showState = newShowState
                if newShowState then
                    drawer.setWait(false)
                    if not flushedDefault then
                        drawer.flush(true)
                        flushedDefault = true
                    end
                else
                    drawer.setWait(true)
                    better.canvas.stopUpdate(betterCanvas)
                end
            end

            if newShowState then
                better.canvas.update_3d(betterCanvas, selfPosition + (rotation * offset), -sm.quat.getRight(rotation), -sm.quat.getUp(rotation), (pixelSize.x * sizeX) / 2, (pixelSize.y * sizeY) / 2)
            end
        end

        function obj.setPixelSize(_pixelSize)
            pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
            if type(pixelSize) == "number" then
                if pixelSize < 0 then
                    pixelSize = math_abs(pixelSize)
                    local vec = vec3_new(pixelSize, pixelSize, 0)
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                else
                    local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                end
            end
        end

        function obj.setOffset(_offset)
            offset = _offset
        end

        function obj.setCanvasRotation(_rotation)
            rotation = _rotation
        end

        function obj.destroy()
            better.canvas.destroy(betterCanvas)
        end

        ---------------------------------------

        obj.setPixelSize(pixelSize)
        obj.setCanvasRotation(rotation or quat_fromEuler(vec3_new(0, 0, 0)))
        obj.setOffset(offset or vec3_new(0, 0, 0))

        --[[
        local c = 0xff0000
        local seffect = createEffect(5, 5, 16, 16, c)
        local idx = 5 + (5 * sizeX)
        for i = 0, 16 - 1 do
            effects[idx + i] = {
                seffect,
                c,
                i,
                16,
                idx,
                5,
                5,
                1, --8. sizeY
                0 --9. indexY
            }
        end
        ]]

        ---------------------------------------

        obj.drawer = drawer
        for k, v in pairs(drawer) do
            obj[k] = v
        end

        return obj
    end
end

--low level display api
function canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material, scaleAddValue, altFromEuler, autoLayerDistance)
    local hiddenOffset = vec3_new(1000000, 1000000, 1000000)
    local defaultSizeX, defaultSizeY = sizeX, sizeY
    local pixelScaleX, pixelScaleY = 1, 1
    local obj = {sizeX = sizeX, sizeY = sizeY}
    local maxX, maxY = sizeX - 1, sizeY - 1
    local maxEffectArrayBuffer = maxX + (maxY * sizeX)
    local dist
    local needOptimize = false
    local skipOptimize = false
    local showState = false
    local disable = false

    local _setPosition, _setRotation
    if parent then
        _setPosition, _setRotation = effect_setOffsetPosition, effect_setOffsetRotation
    else
        _setPosition, _setRotation = effect_setPosition, effect_setRotation
    end

    material = material or canvasAPI.material.classic
    local autoScaleAddValue = false
    if not scaleAddValue then
        autoScaleAddValue = true
    end

    local flushedDefault = false
    local oldBackplateColor
    local backplate
    if canvasAPI.multi_layer[tostring(material)] then
        oldBackplateColor = 0
        backplate = sm_effect_createEffect(getEffectName(), parent)
        effect_setParameter(backplate, "uuid", material)
        effect_setParameter(backplate, "color", black)
    end

    local additionalLayer
    local function updateAdditionalLayer()
        if material == canvasAPI.material.smoothed then
            if not additionalLayer then
                additionalLayer = sm_effect_createEffect(getEffectName(), parent)
                effect_setParameter(additionalLayer, "uuid", canvasAPI.material.glass)
                effect_setParameter(additionalLayer, "color", black)
                effect_start(additionalLayer)
                return true
            end
        elseif additionalLayer then
            effect_destroy(additionalLayer)
            additionalLayer = nil
        end
    end
    updateAdditionalLayer()

    local layerDistance
    local function updateLayerDistance(distance)
        layerDistance = math.max(0.001, autoLayerDistance and distance or 0)
    end
    updateLayerDistance()

    local effects = {}
    local nodeEffects = {}
    local effectDatas = {}
    local effectDataLen = 5

    local bufferedEffectsUpdateTime = {}
    local bufferedEffects = {}
    local bufferedEffectsIndex = 0
    local lastDrawTickTime
    local optimizationLevel = 16
    local optimizationValue = optimizationLevelToValue(optimizationLevel)
    local alpha = DEFAULT_ALPHA_VALUE

    local oldHardwareParams = {
        offset_x = 0,
        offset_y = 0,
        offset_z = 0,
        
        rotation_x = 0,
        rotation_y = 0,
        rotation_z = 0,

        scale_x = 1,
        scale_y = 1
    }

    local function getEIndex(index)
        return index * effectDataLen
    end

    local function fromEIndex(index)
        return index / effectDataLen
    end

    local function setEffectDataParams(index)
        local effect = nodeEffects[index]
        local eindex = getEIndex(index)
        local posX, posY, lSizeX, lSizeY = effectDatas[eindex+1], effectDatas[eindex+2], effectDatas[eindex+3], effectDatas[eindex+4]

        posX = posX + ((lSizeX - 1) * 0.5)
        posY = posY + ((lSizeY - 1) * 0.5)
        _setPosition(effect, rotation * (offset + vec3_new(((posX + 0.5) - (sizeX / 2)) * pixelSize.x, ((posY + 0.5) - (sizeY / 2)) * -pixelSize.y, backplate and (debugMode and 0.05 or layerDistance) or 0)))

        local localScaleAddValue = debugMode and -(pixelSize.x / 2) or scaleAddValue
        local vec = pixelSize * 1
        vec.x = (pixelSize.x * lSizeX) + localScaleAddValue
        vec.y = (pixelSize.y * lSizeY) + localScaleAddValue
        effect_setScale(effect, vec)

        effect_setParameter(effect, "color", color_new_fromSmallNumber(effectDatas[eindex], alpha))
    end

    local function createEffect()
        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            _setRotation(effect, rotation)
        end
        return effect
    end

    local function createEffectUnhide(hideList)
        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            hideList[effect] = nil
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            _setRotation(effect, rotation)
        end
        return effect
    end

    local function clearBufferedEffects()
        for i = 1, bufferedEffectsIndex do
            effect_destroy(bufferedEffects[i])
        end
        bufferedEffectsUpdateTime = {}
        bufferedEffects = {}
        bufferedEffectsIndex = 0
    end

    local lastNewBuffer, lastBase

    local lastPopularColor
    local function mathPopularColor()
        local colorUsesTable = {}
        local colorUses = 0
        local oldColorUses = 0
        local colorSum = 0
        for index in pairs(nodeEffects) do
            local eindex = getEIndex(index)
            local color = effectDatas[eindex]
            local colorSize = effectDatas[eindex+3] * effectDatas[eindex+4]
            colorUsesTable[color] = (colorUsesTable[color] or 0) + colorSize
            colorSum = colorSum + colorSize
            colorUses = colorUsesTable[color]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = color
            end
        end

        if oldBackplateColor then
            local colorSize = (sizeX * sizeY) - colorSum
            colorUsesTable[oldBackplateColor] = (colorUsesTable[oldBackplateColor] or 0) + colorSize
            colorUses = colorUsesTable[oldBackplateColor]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = oldBackplateColor
            end
        end
    end

    local function effectIndexAtPos(px, py)
        return py + (px * sizeY)
    end

    local function getRootEIndexAtPos(px, py)
        if py < 0 or py >= sizeY then return end
        local index = effects[effectIndexAtPos(px, py)]
        return index and getEIndex(index), index
    end

    local function clearEffectFromBuffer(index)
        local eindex = getEIndex(index)
        local six, ix, iy = effectDatas[eindex+1], effectDatas[eindex+1], effectDatas[eindex+2]
        local sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        nodeEffects[index] = nil
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix >= six + sizeX then
                ix = six
                iy = iy + 1
            end
        end
    end

    local function hideEffect(effect)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        bufferedEffectsUpdateTime[bufferedEffectsIndex] = game_getCurrentTick()
        _setPosition(effect, hiddenOffset)
    end

    local function hideEffectData(index)
        hideEffect(nodeEffects[index])
        clearEffectFromBuffer(index)
    end

    local function hideEffectLater(effect, hideList)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        bufferedEffectsUpdateTime[bufferedEffectsIndex] = game_getCurrentTick()
        hideList[effect] = true
        --_setPosition(effect, hiddenOffset)
    end

    local function hideEffectDataLater(index, hideList)
        hideEffectLater(nodeEffects[index], hideList)
        clearEffectFromBuffer(index)
    end    
    
    local function hideEffectsWithColor(color)
        for index in pairs(nodeEffects) do
            if effectDatas[getEIndex(index)] == color then
                hideEffectData(index)
            end
        end
    end

    local function delAllEffects()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        effects = {}
        nodeEffects = {}
    end

    --[[
    local function forceRecreateNodeEffects()
        nodeEffects = {}
        for i, effectData in pairs(effects) do
            if effectData[7] == i then
                nodeEffects[i] = effectData
            end
        end
    end
    ]]

    --local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
    local function colorEquals_smart(color1, color2)
        if color1 == color2 then return true end
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        --return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
        return ((math_abs(rVal - rVal2) + math_abs(gVal - gVal2) + math_abs(bVal - bVal2)) / 1024) <= optimizationValue
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    local function getFillZone(eindex)
        local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
        return fillX1, fillY1, fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
    end

    local sumAttachTime = 0
    local sumAttachFillTime = 0
    local function tryLongAttach(changedList, hideList, index, px, py, color, sizeX, sizeY)
        local startTime = os_clock()

        --[[
        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        local origEffect
        if origIndex then
            origEffect = nodeEffects[origIndex]
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end
        ]]

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local downParentE, downParent = getRootEIndexAtPos(px, py + sizeY)
        local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)
        local downAvailable = downParentE and nodeEffects[downParent] and effectDatas[downParentE+1] == px and effectDatas[downParentE+3] == sizeX and colorEquals(effectDatas[downParentE], color)

        local fillOptional = false
        local fillX1, fillY1, fillX2, fillY2
        local fill2X1, fill2Y1, fill2X2, fill2Y2

        --[[
        if origEffect and (upAvailable or downAvailable) then
            hideEffectLater(origEffect, hideList)
            changedList[origIndex] = nil
            changedColorList[origIndex] = nil
            nodeEffects[origIndex] = nil
        end
        ]]

        local newIndex, newEIndex
        local fillVal
        if upAvailable and downAvailable then
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

            local addSizeY = sizeY + effectDatas[downParentE+4]

            hideEffectLater(nodeEffects[downParent], hideList)
            changedList[downParent] = nil
            --changedColorList[downParent] = nil
            nodeEffects[downParent] = nil

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + addSizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
        elseif upAvailable then
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
        elseif downAvailable then
            fillOptional = true
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

            changedList[downParent] = nil
           --changedColorList[downParent] = nil

            nodeEffects[index] = nodeEffects[downParent]
            nodeEffects[downParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[downParentE]
            effectDatas[eindex+1] = effectDatas[downParentE+1]
            effectDatas[eindex+2] = py
            effectDatas[eindex+3] = effectDatas[downParentE+3]
            effectDatas[eindex+4] = effectDatas[downParentE+4] + sizeY
            
            newIndex, newEIndex = index, eindex
            fillVal = index
        end

        if fillVal then
            index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
            sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
        end

        local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
        local rightParentE, rightParent = getRootEIndexAtPos(px + sizeX, py)
        local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
        local rightAvailable = rightParentE and nodeEffects[rightParent] and effectDatas[rightParentE+2] == py and effectDatas[rightParentE+4] == sizeY and colorEquals(effectDatas[rightParentE], color)

        if nodeEffects[index] and (leftAvailable or rightAvailable) then
            hideEffectLater(nodeEffects[index], hideList)
            changedList[index] = nil
            --changedColorList[index] = nil
            nodeEffects[index] = nil
        end

        if leftAvailable and rightAvailable then
            fillOptional = false
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

            local addSizeX = sizeX + effectDatas[rightParentE+3]

            hideEffectLater(nodeEffects[rightParent], hideList)
            changedList[rightParent] = nil
            --changedColorList[rightParent] = nil
            nodeEffects[rightParent] = nil

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + addSizeX
            fillVal = leftParent
        elseif leftAvailable then
            fillOptional = false
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = nil, nil, nil, nil

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
            fillVal = leftParent
        elseif rightAvailable then
            fillOptional = not upAvailable and not downAvailable
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

            changedList[rightParent] = nil
            --changedColorList[rightParent] = nil

            nodeEffects[index] = nodeEffects[rightParent]
            nodeEffects[rightParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[rightParentE]
            effectDatas[eindex+1] = px
            effectDatas[eindex+2] = effectDatas[rightParentE+2]
            effectDatas[eindex+3] = sizeX + effectDatas[rightParentE+3]
            effectDatas[eindex+4] = effectDatas[rightParentE+4]
            
            fillVal = index
        end

        sumAttachTime = sumAttachTime + (os_clock() - startTime)

        if fillVal then
            changedList[fillVal] = true
            --changedColorList[fillVal] = true

            --[[
            local eindex = getEIndex(fillVal)
            local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
            local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = fillVal
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            ]]

            startTime = os_clock()

            --fillOptional = false
            --if not fillOptional or not origEffect then
                local ix, iy = fillX1, fillY1
                for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = fillVal
                    ix = ix + 1
                    if ix > fillX2 then
                        ix = fillX1
                        iy = iy + 1
                    end
                end
            --[[else
                local ix, iy = fillX1, fillY1
                for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                    if fillVal ~= effects[effectIndexAtPos(ix, iy)] then
                        print("WTTT", fillVal, effects[effectIndexAtPos(ix, iy)])
                    end
                    ix = ix + 1
                    if ix > fillX2 then
                        ix = fillX1
                        iy = iy + 1
                    end
                end
                ]]
            --end

            if fill2X1 then
                local ix, iy = fill2X1, fill2Y1
                for _ = 1, ((fill2X2 - fill2X1) + 1) * ((fill2Y2 - fill2Y1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = fillVal
                    ix = ix + 1
                    if ix > fill2X2 then
                        ix = fill2X1
                        iy = iy + 1
                    end
                end
            end

            sumAttachFillTime = sumAttachFillTime + (os_clock() - startTime)

            --fillVal = tryAttach(changedList, changedColorList, index, px, py, color) or fillVal
        end

        return fillVal
    end

    local function tryAttach(changedList, hideList, index, px, py, color, sizeX, sizeY)
        local startTime = os_clock()

        --[[
        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        local origEffect
        if origIndex then
            origEffect = nodeEffects[origIndex]
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end
        ]]

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)

        local fillX1, fillY1, fillX2, fillY2
        local newIndex, newEIndex, fillVal
        if upAvailable then
            --[[
            if origEffect then
                hideEffectLater(origEffect, hideList)
                changedList[origIndex] = nil
                changedColorList[origIndex] = nil
                nodeEffects[origIndex] = nil
            end
            ]]

            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent

            index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
            sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
        end

        local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
        local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
        if leftAvailable then
            if nodeEffects[index] then
                hideEffectLater(nodeEffects[index], hideList)
                changedList[index] = nil
                --changedColorList[index] = nil
                nodeEffects[index] = nil
            end

            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
            fillVal = leftParent
        end

        sumAttachTime = sumAttachTime + (os_clock() - startTime)

        if fillVal then
            changedList[fillVal] = true
            --changedColorList[fillVal] = true

            startTime = os_clock()
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = fillVal
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            sumAttachFillTime = sumAttachFillTime + (os_clock() - startTime)
        end

        return fillVal
    end

    local sumFillTime = 0
    local function fillBlock(x, y, sx, sy, changedList, hideList, color, iterate, effect)
        if sx <= 0 or sy <= 0 then
            return
        end

        local newRIndex = effectIndexAtPos(x, y)
        nodeEffects[newRIndex] = effect or createEffectUnhide(hideList)
        changedList[newRIndex] = true
        --changedColorList[newRIndex] = true

        local newEIndex = getEIndex(newRIndex)
        effectDatas[newEIndex] = color
        effectDatas[newEIndex+1] = x
        effectDatas[newEIndex+2] = y
        effectDatas[newEIndex+3] = sx
        effectDatas[newEIndex+4] = sy

        if not iterate then
            return true
        end
        
        local startTime = os_clock()
        local ix, iy = x, y
        local six = ix
        local mix = six + sx
        for _ = 1, sx * sy do
            effects[effectIndexAtPos(ix, iy)] = newRIndex
            ix = ix + 1
            if ix >= mix then
                ix = six
                iy = iy + 1
            end
        end
        sumFillTime = sumFillTime + (os_clock() - startTime)

        return true
    end

    local sumExtractTime = 0
    local function extractPixel(changedList, hideList, index, px, py, sizeX, sizeY)
        local startTime = os_clock()

        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local lx = px - rpx
        local ly = py - rpy

        local effect = nodeEffects[rindex]
        changedList[rindex] = nil
        --changedColorList[rindex] = nil
        nodeEffects[rindex] = nil

        local color = effectDatas[eindex]
        --local block1, block2, block3, block4 = false, false, false, false
        if fillBlock(rpx, rpy, lx, rsy, changedList, hideList, color, false, effect) then --[[block1 = true]] effect = nil end
        if fillBlock(rpx + lx + sizeX, rpy, rsx - lx - sizeX, rsy, changedList, hideList, color, true, effect) then --[[block2 = true]] effect = nil end
        if fillBlock(rpx + lx, rpy, sizeX, ly, changedList, hideList, color, true, effect) then --[[block3 = true]] effect = nil end
        if fillBlock(rpx + lx, rpy + ly + sizeY, sizeX, rsy - ly - sizeY, changedList, hideList, color, true, effect) then --[[block4 = true]] effect = nil end

        local ix, iy, endX = px, py, px + (sizeX - 1)
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix > endX then
                ix = px
                iy = iy + 1
            end
        end

        if effect then
            hideEffectLater(effect, hideList)
        end

        sumExtractTime = sumExtractTime + (os_clock() - startTime)

        --if block1 then tryAttach(changedList, changedColorList, effectIndexAtPos(rpx, rpy), rpx, rpy, color) end
        --if block2 then tryAttach(changedList, changedColorList, effectIndexAtPos(block2X, rpy), block2X, rpy, color) end
        --if block3 then tryAttach(changedList, changedColorList, effectIndexAtPos(block3X, rpy), block3X, rpy, color) end
        --if block4 then tryAttach(changedList, changedColorList, effectIndexAtPos(block4X, block4Y), block4X, block4Y, color) end
    end

    --[[
    local function extractXLine(changedList, changedColorList, hideList, index, px, py)
        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local ly = py - rpy

        local effect = nodeEffects[rindex]
        changedList[rindex] = nil
        changedColorList[rindex] = nil
        nodeEffects[rindex] = nil
        effects[index] = nil

        local color = effectDatas[eindex]
        if fillBlock(rpx, rpy, rsx, ly, changedList, changedColorList, hideList, color, false, effect) then effect = nil end
        if fillBlock(rpx, rpy + ly + 1, rsx, rsy - ly - 1, changedList, changedColorList, hideList, color, true, effect) then effect = nil end

        if effect then
            hideEffectLater(effect, hideList)
        end
    end
    ]]

    local function fillEffectsLinks(index, px, py, sizeX, sizeY)
        local ix, iy, endX = px, py, px + (sizeX - 1)
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = index
            ix = ix + 1
            if ix > endX then
                ix = px
                iy = iy + 1
            end
        end
    end

    --[[
    local sumIsFullChangeTime = 0
    local function isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, forDestroy)
        local effectID = nodeEffects[rindex].id
        if fullChecked[effectID] then
            return false
        end
        fullChecked[effectID] = true


        local startTime = os_clock()

        local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
        local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
        local baseColor = lastNewBuffer[effectIndexAtPos(fillX1, fillY1)] or lastBase

        local ix, iy = fillX1 + 1, fillY1
        if ix > fillX2 then
            ix = fillX1
            iy = iy + 1
        end
        for _ = 2, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
            local color = lastNewBuffer[effectIndexAtPos(ix, iy)] or lastBase
            if color ~= baseColor then
                sumIsFullChangeTime = sumIsFullChangeTime + (os_clock() - startTime)
                return false
            end
            ix = ix + 1
            if ix > fillX2 then
                ix = fillX1
                iy = iy + 1
            end
        end

        ix, iy = fillX1, fillY1
        if not forDestroy then
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                local index = effectIndexAtPos(ix, iy)
                _changes[index] = true
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
        end

        sumIsFullChangeTime = sumIsFullChangeTime + (os_clock() - startTime)
        return true
    end
    ]]

    --[[
    local function getBlockSize(rindex, index, px, py, color)
        local sizeX = 1
        --local sizeY = 1
        --[[
        for i = 1, maxY - py do
            if rindex ~= effects[index+i] or (lastNewBuffer[index+i] or lastBase) ~= color then
                break
            end
            sizeY = sizeY + 1
        end
        ] ]
        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
                --sizeY = sizeY + 1
            end
        end

        --[[
        for iy = 1, maxY - py do
            local multibrake = false
            for ix = 0, sizeX - 1 do
                local lindex = effectIndexAtPos(px+ix, py+iy)
                if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                    multibrake = true
                    break
                end
            end
            if multibrake then
                break
            end
            sizeY = sizeY + 1
        end
        ] ]

        return sizeX, iy
    end
    ]]

    local function getBlockSize(index, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local function getBlockSizeOptimization(index, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if effects[lindex] or not lastNewBuffer[lindex] or not colorEquals(lastNewBuffer[lindex], color) then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if effects[lindex] or not lastNewBuffer[lindex] or not colorEquals(lastNewBuffer[lindex], color) then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local function getChangesBlockSize(rindex, index, changes, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if rindex ~= effects[lindex] or not changes[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if rindex ~= effects[lindex] or not changes[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local _oldVirtualBackplateColor
    local drawer
    local lastDrawWithClear = true
    drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, function (base, clearOnly, maxBuffer, force, newBuffer, realBuffer, _, _, changes, changesIndex, changesCount, _changes, clearBackplate)
        lastNewBuffer, lastBase = newBuffer, base
        lastDrawWithClear = clearBackplate

        if clearOnly and backplate then
            clearBufferedEffects()
            drawer.clearChangesBuffer()
            delAllEffects()
            return
        end

        local changedList = {}
        --local changedColorList = {}
        local hideList = {}
        --local fullChecked = {}

        --print("changesCount 1", changesCount)

        local oldChanges
        if clearBackplate then
            local startTime = os_clock()

            oldChanges = {}
            for index in pairs(changes) do
                oldChanges[index] = true
            end

            for index in pairs(_changes) do
                if not changes[index] then
                    changesCount = changesCount + 1
                    changesIndex[changesCount] = index
                    changes[index] = true
                end
            end

            profiller("clear-loop", startTime)
        end

        --[[
        local _changesSize = 0
        for k, v in pairs(_changes) do
            _changesSize = _changesSize + 1
        end
        print(tostring(_changes), _changesSize)
        ]]

        --print("changesCount 2", changesCount)

        --[[
        local startTime = os_clock()
        table_sort(changesIndex, function (a, b)
            return a < b
        end)
        profiller("stack-sort", startTime)
        ]]

        --[[
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex then
                local eindex = getEIndex(rindex)
                if not colorEquals(effectDatas[eindex], color) then
                    local px = math_floor(index / sizeY)
                    local py = index % sizeY
                    local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
                    local backplateColor = color == oldBackplateColor
                    if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, backplateColor) then
                        if backplateColor then
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        elseif not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        end
                    elseif backplateColor then
                        if aSizeX or aSizeY then
                            extractPixel(changedList, changedColorList, hideList, index, px, py)
                        else
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        end
                    else
                        _changes[index] = true

                        if aSizeX or aSizeY then
                            extractPixel(changedList, changedColorList, hideList, index, px, py)
                        end

                        if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                            local eindex = getEIndex(index)

                            if not nodeEffects[index] then
                                local effect = createEffectUnhide(hideList)

                                local bSizeX, bSizeY = 1, 1
                                effectDatas[eindex+1] = px
                                effectDatas[eindex+2] = py
                                effectDatas[eindex+3] = bSizeX
                                effectDatas[eindex+4] = bSizeY
                                fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                
                                nodeEffects[index] = effect
                                changedList[index] = true
                            end

                            effectDatas[eindex] = color
                            changedColorList[index] = true
                        end
                    end
                end
            elseif color ~= oldBackplateColor then
                _changes[index] = true
                local px = math_floor(index / sizeY)
                local py = index % sizeY
                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect

                    local eindex = getEIndex(index)
                    local bSizeX, bSizeY = getBlockSize(index, px, py)
                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = bSizeX
                    effectDatas[eindex+4] = bSizeY
                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                    
                    changedList[index] = true
                    changedColorList[index] = true
                end
            end
        end
        profiller("change-loop", startTime)
        ]]

        --local localEffectsBlacklist = {}

        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex --[[and not localEffectsBlacklist[rindex] ]] then
                local eindex = getEIndex(rindex)
                --local isBackgroundColor = color == oldBackplateColor
                --if color == oldBackplateColor or not colorEquals(effectDatas[eindex], color) then
                if effectDatas[eindex] ~= color then
                    --local px = math_floor(index / sizeY)
                    --local py = index % sizeY
                    --local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
                    --[[if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, backplateColor) then
                        if backplateColor then
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        else
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        end
                    else]]
                    
                    --local aSizeX, aSizeY = effectDatas[eindex+3], effectDatas[eindex+4]
                    if effectDatas[eindex+3] > 1 or effectDatas[eindex+4] > 1 then
                        local px = math_floor(index / sizeY)
                        local py = index % sizeY
                        --local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                        --extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)
                        extractPixel(changedList, hideList, index, px, py, getChangesBlockSize(rindex, index, changes, px, py, color))

                        --[[
                        local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                        if aSizeX == bSizeX and aSizeY == bSizeY then
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        else
                            extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)
                        end
                        ]]

                        --[[
                        if not isBackgroundColor then
                            if not tryAttach(changedList, changedColorList, hideList, index, px, py, color, bSizeX, bSizeY) then
                                local effect = createEffectUnhide(hideList)

                                nodeEffects[index] = effect

                                local eindex = getEIndex(index)
                                effectDatas[eindex] = color
                                effectDatas[eindex+1] = px
                                effectDatas[eindex+2] = py
                                effectDatas[eindex+3] = bSizeX
                                effectDatas[eindex+4] = bSizeY
                                fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                
                                changedList[index] = true
                                changedColorList[index] = true
                                localEffectsBlacklist[index] = true
                            end
                        end
                        ]]
                    else
                        changedList[rindex] = nil
                        --changedColorList[rindex] = nil
                        hideEffectDataLater(rindex, hideList)
                    end
                end
            end
        end
        profiller("extract-loop", startTime)

        --local blockSizeCache = {}
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            if color ~= oldBackplateColor then
                _changes[index] = true

                if not effects[index] then
                    local px = math_floor(index / sizeY)
                    local py = index % sizeY

                    if not tryLongAttach(changedList, hideList, index, px, py, color, 1, 1) then
                        --[[
                        local blockSize
                        if blockSizeCache[index] then
                            blockSize = blockSizeCache[index]
                            print("LOAD", index, blockSize)
                        else
                            blockSize = {getBlockSize(index, px, py, color)}
                            blockSizeCache[index] = blockSize
                        end
                        ]]

                        local bSizeX, bSizeY = getBlockSize(index, px, py, color)
                        if not tryLongAttach(changedList, hideList, index, px, py, color, bSizeX, bSizeY) then
                            local effect = createEffectUnhide(hideList)

                            nodeEffects[index] = effect

                            local eindex = getEIndex(index)
                            effectDatas[eindex] = color
                            effectDatas[eindex+1] = px
                            effectDatas[eindex+2] = py
                            effectDatas[eindex+3] = bSizeX
                            effectDatas[eindex+4] = bSizeY
                            fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                            
                            changedList[index] = true
                            --changedColorList[index] = true
                        end

                        --[[
                        local effect = createEffectUnhide(hideList)

                        nodeEffects[index] = effect
                        effects[index] = index

                        local eindex = getEIndex(index)
                        effectDatas[eindex] = color
                        effectDatas[eindex+1] = px
                        effectDatas[eindex+2] = py
                        effectDatas[eindex+3] = 1
                        effectDatas[eindex+4] = 1
                        
                        changedList[index] = true
                        ]]
                    end
                end
            end
        end
        profiller("add-loop", startTime)

        --[[
        local localEffectsBlacklist = {}
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex then
                if not localEffectsBlacklist[rindex] then
                    local eindex = getEIndex(rindex)
                    local isBackgroundColor = color == oldBackplateColor
                    if isBackgroundColor or not colorEquals(effectDatas[eindex], color) then
                        if effectDatas[eindex+3] > 1 or effectDatas[eindex+4] > 1 then
                            local px = math_floor(index / sizeY)
                            local py = index % sizeY
                            local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                            extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)

                            if not isBackgroundColor then
                                _changes[index] = true

                                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                                    local effect = createEffectUnhide(hideList)

                                    nodeEffects[index] = effect

                                    local eindex = getEIndex(index)
                                    effectDatas[eindex] = color
                                    effectDatas[eindex+1] = px
                                    effectDatas[eindex+2] = py
                                    effectDatas[eindex+3] = bSizeX
                                    effectDatas[eindex+4] = bSizeY
                                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                    
                                    changedList[index] = true
                                    changedColorList[index] = true
                                    localEffectsBlacklist[index] = true
                                end
                            end
                        elseif not isBackgroundColor then
                            _changes[index] = true

                            local px = math_floor(index / sizeY)
                            local py = index % sizeY
                            if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                                effectDatas[eindex] = color
                                changedColorList[rindex] = true
                            end
                        else
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        end
                    end
                end
            elseif color ~= oldBackplateColor then
                _changes[index] = true

                local px = math_floor(index / sizeY)
                local py = index % sizeY
                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect

                    local eindex = getEIndex(index)
                    local bSizeX, bSizeY = getBlockSize(nil, index, px, py, color)
                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = bSizeX
                    effectDatas[eindex+4] = bSizeY
                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                    
                    changedList[index] = true
                    changedColorList[index] = true
                    localEffectsBlacklist[index] = true
                end
            end
        end
        profiller("change-loop", startTime)
        ]]

        local contentUpdated = false

        startTime = os_clock()
        for index in pairs(changedList) do
            setEffectDataParams(index)
            contentUpdated = true
        end
        profiller("apply-params", startTime)

        --[[
        startTime = os_clock()
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            if not colorCache[color] then
                colorCache[color] = color_new_fromSmallNumber(color, alpha)
            end
            effect_setParameter(nodeEffects[index], "color", colorCache[color])
        end
        profiller("apply-colors", startTime)
        ]]
        --[[
        startTime = os_clock()
        local colorobj = color_new(0)
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            colorobj.r, colorobj.g, colorobj.b = hexToRGB(color)
            colorobj.a = alpha / 255
            effect_setParameter(nodeEffects[index], "color", colorobj)
            contentUpdated = true
        end
        profiller("apply-colors", startTime)
        ]]

        startTime = os_clock()
        for effect in pairs(hideList) do
            _setPosition(effect, hiddenOffset)
        end
        profiller("later-hide", startTime)

        profillerPrint("fill-sum", sumFillTime)
        profillerPrint("extract-sum", sumExtractTime)
        profillerPrint("attach-sum", sumAttachTime)
        profillerPrint("attach-fill-sum", sumAttachFillTime)
        --profillerPrint("isFullChange-sum", sumIsFullChangeTime)
        --sumIsFullChangeTime = 0
        sumFillTime = 0
        sumExtractTime = 0
        sumAttachTime = 0
        sumAttachFillTime = 0
        
        if clearBackplate then
            drawer.setOldChanges(oldChanges)
            --clearBackplate = false
        end

        if clearOnly then
            clearBufferedEffects()
            return
        end

        if contentUpdated then
            lastDrawTickTime = game_getCurrentTick()
            needOptimize = true
        end
    end, nil, function (_, color, changes)
        if backplate then
            oldBackplateColor = color
            effect_setParameter(backplate, "color", color_new_fromSmallNumber(color, alpha))
        elseif color ~= _oldVirtualBackplateColor then
            drawer.fullRefresh()
            _oldVirtualBackplateColor = color
        end
    end, nil, nil, true)

    if not backplate then
        drawer.fullRefresh()
    end

    local canvasWait
    local wait_dataTunnel
    local function _setWait(wait)
        canvasWait = wait
        drawer.setWait(wait)
        if not wait and wait_dataTunnel then
            obj.realPushDataTunnelParams(wait_dataTunnel)
            wait_dataTunnel = nil
        end
    end

    _setWait(true)

    local function recreateCanvas()
        if not lastNewBuffer then
            return
        end

        if backplate and not lastDrawWithClear then --WHAT? (fixed)
            mathPopularColor()
            if lastPopularColor ~= oldBackplateColor then
                effect_setParameter(backplate, "color", color_new_fromSmallNumber(lastPopularColor, alpha))
                oldBackplateColor = lastPopularColor
                drawer.fullRefresh()
            end
        end
        
        local hideList = {}
        for i, effect in pairs(nodeEffects) do
            hideEffectLater(effect, hideList)
        end
        effects = {}
        nodeEffects = {}
        effectDatas = {}

        local changedList = {}
        --local changedColorList = {}

        --local startTime = os.clock()
        local index = 0
        while index <= maxEffectArrayBuffer do
            local px = math_floor(index / sizeY)
            local py = index % sizeY
            local color = lastNewBuffer[index] or lastBase
            if effects[index] then
                index = index + effectDatas[getEIndex(effects[index])+4]
            elseif color ~= oldBackplateColor then
                local eindex = getEIndex(index)

                local newRootIndex = tryAttach(changedList, hideList, index, px, py, color, 1, 1)
                if newRootIndex then
                    local newRootEIndex = getEIndex(newRootIndex)
                    index = effectIndexAtPos(px, effectDatas[newRootEIndex+2] + effectDatas[newRootEIndex+4])
                else
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect
                    effects[index] = index

                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = 1
                    effectDatas[eindex+4] = 1
                    
                    changedList[index] = true
                    --changedColorList[index] = true
                    index = index + 1
                end

                --[[
                local bSizeX, bSizeY = getBlockSizeOptimization(index, px, py, color)
                local effect = createEffectUnhide(hideList)

                nodeEffects[index] = effect
                effectDatas[eindex] = color
                effectDatas[eindex+1] = px
                effectDatas[eindex+2] = py
                effectDatas[eindex+3] = bSizeX
                effectDatas[eindex+4] = bSizeY
                fillEffectsLinks(index, px, py, bSizeX, bSizeY)

                changedList[index] = true
                index = index + bSizeY
                ]]
            else
                index = index + 1
            end
        end
        --print("recreate-loop time:", os.clock() - startTime)

        for index in pairs(changedList) do
            setEffectDataParams(index)
        end

        --[[
        local colorobj = color_new(0)
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            colorobj.r, colorobj.g, colorobj.b = hexToRGB(color)
            colorobj.a = alpha / 255
            effect_setParameter(nodeEffects[index], "color", colorobj)
        end
        ]]

        for effect in pairs(hideList) do
            _setPosition(effect, hiddenOffset)
        end
    end

    local _s_pixelSize, _s_offset, _s_rotation
    function obj.setCanvasMaterial(_material)
        material = _material
        local newBackplateExists = not not canvasAPI.multi_layer[tostring(material)]
        local oldBackplateExists = not not backplate

        if newBackplateExists ~= oldBackplateExists then
            _oldVirtualBackplateColor = nil
        end

        local updateParameters = false
        if newBackplateExists then
            if not oldBackplateExists then
                updateParameters = true
                oldBackplateColor = 0
                backplate = sm_effect_createEffect(getEffectName(), parent)
                effect_setParameter(backplate, "color", black)
                effect_setParameter(backplate, "uuid", material)
                if showState then
                    effect_start(backplate)
                end
            else
                effect_stop(backplate)
                effect_setParameter(backplate, "uuid", material)
                effect_start(backplate)
            end
        elseif oldBackplateExists then
            effect_destroy(backplate)
            oldBackplateColor = nil
            backplate = nil
            recreateCanvas()
        end

        for _, effect in pairs(nodeEffects) do
            effect_stop(effect)
            effect_setParameter(effect, "uuid", material)
            effect_start(effect)
        end

        for i = 1, bufferedEffectsIndex do
            local effect = bufferedEffects[i]
            effect_stop(effect)
            effect_setParameter(effect, "uuid", material)
            effect_start(effect)
        end

        local layerCreated = updateAdditionalLayer()

        if updateParameters or layerCreated then
            obj.setPixelSize(_s_pixelSize)
            obj.setOffset(_s_offset, true)
            obj.setCanvasRotation(_s_rotation)
        end
    end

    local function switchHardware()
        obj.setPixelSize(_s_pixelSize)
        obj.setOffset(_s_offset, true)
        obj.setCanvasRotation(_s_rotation)
    end

    local defaultPosition = vec3_new(0, 0, 0)
    local function getSelfPos()
        local pt = type(parent)
        if pt == "Interactable" then
            return parent.shape.worldPosition
        elseif pt == "Character" then
            return parent.worldPosition
        end
        return defaultPosition
    end

    local function updateLayersPos()
        if backplate then
            _setPosition(backplate, rotation * offset)
        end
        if additionalLayer then
            _setPosition(additionalLayer, rotation * (offset + vec3_new(0, 0, 0.0015)))
        end
    end

    local longOptimizeCounter = 0
    local lastOptimizeTime = game_getCurrentTick()
    local function optimize()
        --[[
        if bufferedEffectsIndex > 4096 then
            for i = 1, bufferedEffectsIndex - 4096 do
                effect_stop(bufferedEffects[i])
                stoppedCount = stoppedCount + 1
            end

            --[[
            if bufferedEffectsIndex > 3000 then
                if debugMode then
                    print("destroy buffered effects")
                end

                for i = 3001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                end
                bufferedEffectsIndex = 3000
            end
            ] ]
        end
        ]]

        if longOptimizeCounter >= 3 then
            skipOptimize = true
            if debugMode then
                print("skip optimize")
            end
            return
        end

        local startTime = os_clock()
        recreateCanvas()

        local optimizeTime = os_clock() - startTime
        if optimizeTime > ((1 / 1000) * 50) then
            if debugMode then
                print("long optimize time", optimizeTime)
            end
            longOptimizeCounter = longOptimizeCounter + 1
        end

        lastOptimizeTime = game_getCurrentTick()
    end

    function obj.setAlpha(_alpha)
        alpha = _alpha
        for rindex, effect in pairs(nodeEffects) do
            effect_setParameter(effect, "color", color_new_fromSmallNumber(effectDatas[getEIndex(rindex)], alpha))
        end
    end

    function obj.setCanvasOptimizationLevel(value)
        optimizationLevel = value
        if value == 0 then
            colorEquals = colorEquals_raw
        else
            colorEquals = colorEquals_smart
        end
        optimizationValue = optimizationLevelToValue(optimizationLevel)
    end

    function obj.isRendering()
        return showState
    end

    function obj.disable(state)
        disable = state
    end

    function obj.setRenderDistance(_dist)
        dist = _dist
    end

    local reoptimizeTime = 20
    local reoptimizeDynamicTime = 40
    local canvasSize = sizeX * sizeY
    if canvasSize >= (512 * 512) then
        reoptimizeTime = 40
        reoptimizeDynamicTime = 80
    elseif canvasSize >= (256 * 256) then
        reoptimizeTime = 40
        reoptimizeDynamicTime = 60
    end

    local oldOptimizeTime
    local newShowState = true
    function obj.update()
        if disable then
            newShowState = false
        elseif dist then
            if not pcall(function()
                local currentDist = mathDist(getSelfPos(), sm_localPlayer_getPlayer().character.worldPosition)
                if currentDist <= dist then
                    newShowState = true
                elseif currentDist >= dist + 2 then
                    newShowState = false
                end
            end) then
                newShowState = false
            end
        end

        --recreateCanvas()

        if newShowState ~= showState then
            showState = newShowState
            if newShowState then
                obj.setWait(false)
                if not backplate and not flushedDefault then
                    drawer.flush(true)
                    flushedDefault = true
                end
                for _, effect in pairs(nodeEffects) do
                    if not effect_isPlaying(effect) then
                        effect_start(effect)
                    end
                end
                if backplate then
                    effect_start(backplate)
                end
                if additionalLayer then
                    effect_start(additionalLayer)
                end
            else
                for _, effect in pairs(nodeEffects) do
                    effect_stop(effect)
                end
                for i = 1, bufferedEffectsIndex do
                    effect_stop(bufferedEffects[i])
                end
                if backplate then
                    effect_stop(backplate)
                end
                if additionalLayer then
                    effect_stop(additionalLayer)
                end
                obj.setWait(true)
            end
        end

        local ctick = game_getCurrentTick()
        local optimizePeer = reoptimizeTime
        if lastDrawTickTime then
            if ctick - lastDrawTickTime < 20 then
                optimizePeer = reoptimizeDynamicTime
            end

            if longOptimizeCounter > 0 and (ctick - lastDrawTickTime > 40 * 5 or ctick - lastOptimizeTime > 40 * 10) then
                if debugMode then
                    print("reset longOptimizeCounter", longOptimizeCounter)
                end
                longOptimizeCounter = 0
                if skipOptimize then
                    optimize()
                    longOptimizeCounter = 0
                    skipOptimize = false
                end
            end
        end

        if ctick % 20 == 0 then
            local stoppedCount = 0
            local destroyedCount = 0

            if bufferedEffectsIndex > 6000 then
                for i = 6001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                    destroyedCount = destroyedCount + 1
                end
                bufferedEffectsIndex = 6000
            end

            for i = 1, bufferedEffectsIndex - 1024 do
                local otick = bufferedEffectsUpdateTime[i]
                if otick ~= true and ctick - otick > 160 then
                    bufferedEffectsUpdateTime[i] = true
                    effect_stop(bufferedEffects[i])
                    stoppedCount = stoppedCount + 1
                end
            end

            if debugMode then
                if destroyedCount > 0 then
                    print("destroying buffered effects", destroyedCount)
                end
                print("stoping buffered effects", stoppedCount .. " / " .. bufferedEffectsIndex)
            end
        end

        if newShowState and needOptimize and optimizePeer and (not oldOptimizeTime or ctick - oldOptimizeTime >= optimizePeer) then
            needOptimize = false
            oldOptimizeTime = ctick
            optimize()
        end

        updateLayersPos()
    end

    function obj.setPixelSize(_pixelSize)
        pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
        if type(pixelSize) == "Vec3" then
            _s_pixelSize = vec3_new(pixelSize.x, pixelSize.y, pixelSize.z)
        else
            _s_pixelSize = pixelSize
        end
        if type(pixelSize) == "number" then
            if pixelSize < 0 then
                pixelSize = math_abs(pixelSize)
                local vec = vec3_new(pixelSize, pixelSize, 0)
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            else
                local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            end
        end
        pixelSize.x = pixelSize.x * oldHardwareParams.scale_x * pixelScaleX
        pixelSize.y = pixelSize.y * oldHardwareParams.scale_y * pixelScaleY
        --pixelSize.x = pixelSize.x + 0.00025
        --pixelSize.y = pixelSize.y + 0.00025
        if backplate then
            effect_setScale(backplate, vec3_new(pixelSize.x * sizeX, pixelSize.y * sizeY, pixelSize.z))
        end
        updateLayerDistance(math.max(pixelSize.x * sizeX, pixelSize.y * sizeY) / 1000)
        if additionalLayer then
            effect_setScale(additionalLayer, vec3_new(pixelSize.x * sizeX * 1.005, pixelSize.y * sizeY * 1.005, math.min(2, layerDistance + ((pixelSize.x * sizeX) / 3 / 128))))
        end
        if autoScaleAddValue then
            scaleAddValue = math_min((pixelSize.x + pixelSize.y) / 50, 0.0002)
        end
    end

    function obj.setOffset(_offset, noUpdateParameters)
        offset = vec3_new(_offset.x, _offset.y, _offset.z)
        _s_offset = vec3_new(_offset.x, _offset.y, _offset.z)
        offset.x = offset.x + oldHardwareParams.offset_x
        offset.y = offset.y + oldHardwareParams.offset_y
        offset.z = offset.z + oldHardwareParams.offset_z
        updateLayersPos()
        if not noUpdateParameters then
            for index in pairs(nodeEffects) do
                setEffectDataParams(index)
            end
        end
    end

    function obj.setCanvasRotation(_rotation)
        _s_rotation = _rotation
        if type(_rotation) == "Quat" then
        elseif altFromEuler then
            _rotation = custom_fromEulerYEnd(math.rad(_rotation.x) + oldHardwareParams.rotation_x, math.rad(_rotation.y) + oldHardwareParams.rotation_y, math.rad(_rotation.z) + oldHardwareParams.rotation_z)
        else
            _rotation = quat_fromEuler(vec3_new(_rotation.x + math.deg(oldHardwareParams.rotation_x), _rotation.y + math.deg(oldHardwareParams.rotation_y), _rotation.z + math.deg(oldHardwareParams.rotation_z)))
        end
        rotation = _rotation
        if backplate then
            _setRotation(backplate, rotation)
        end
        if additionalLayer then
            _setRotation(additionalLayer, rotation)
        end
        for index, effect in pairs(nodeEffects) do
            _setRotation(effect, rotation)
            setEffectDataParams(index)
        end
        for _, effect in pairs(bufferedEffects) do
            _setRotation(effect, rotation)
        end
    end

    function obj.destroy()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        if backplate then
            effect_destroy(backplate)
        end
        if additionalLayer then
            effect_destroy(additionalLayer)
        end
    end

    local function raw_setResolution(_sizeX, _sizeY)
        drawer.setDrawerResolution(_sizeX, _sizeY)

        for _, effect in pairs(nodeEffects) do
            hideEffect(effect)
        end
        effects = {}
        nodeEffects = {}
        effectDatas = {}
        
        sizeX = _sizeX
        sizeY = _sizeY
        obj.sizeX = sizeX
        obj.sizeY = sizeY
        maxX, maxY = sizeX - 1, sizeY - 1
        maxEffectArrayBuffer = maxX + (maxY * sizeX)
        pixelScaleX, pixelScaleY = defaultSizeX / sizeX, defaultSizeY / sizeY
    end

    function obj.setCanvasResolution(_sizeX, _sizeY)
        raw_setResolution(_sizeX, _sizeY)
        switchHardware()
    end

    ---------------------------------------

    obj.setPixelSize(pixelSize)
    obj.setCanvasRotation(rotation or vec3_new(0, 0, 0))
    obj.setOffset(offset or vec3_new(0, 0, 0))

    ---------------------------------------

    obj.drawer = drawer
    for k, v in pairs(drawer) do
        obj[k] = v
    end
    obj.setWait = _setWait

    function obj.pushDataTunnelParams(dataTunnel)
        if canvasWait then
            wait_dataTunnel = dataTunnel
        else
            wait_dataTunnel = nil
            obj.realPushDataTunnelParams(dataTunnel)
        end
    end

    function obj.realPushDataTunnelParams(dataTunnel)
        obj.setCanvasOptimizationLevel(dataTunnel.optimizationLevel)
        drawer.pushDataTunnelParams(dataTunnel)

        local hardwareParamsChanged = false
        if dataTunnel.res_x ~= sizeX or dataTunnel.res_y ~= sizeY then
            raw_setResolution(dataTunnel.res_x, dataTunnel.res_y)

            hardwareParamsChanged = true
        end

        obj.setAlpha(dataTunnel.light)
        if dataTunnel.material and dataTunnel.material ~= material then
            obj.setCanvasMaterial(dataTunnel.material)
        end
        for key, value in pairs(oldHardwareParams) do
            if dataTunnel[key] ~= value then
                hardwareParamsChanged = true
                oldHardwareParams[key] = dataTunnel[key]
            end
        end
        if hardwareParamsChanged then
            switchHardware()
        end
    end

    return obj
end

--simulates the API of display from SComputers on the client side of your parts
--this is the easiest way to implement the display in your mod
function canvasAPI.createClientScriptableCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local dataTunnel = {}
    local canvas = canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local api = canvasAPI.createScriptableApi(sizeX, sizeY, dataTunnel, nil, canvas.drawer, canvasAPI.materialList, 1, {
        maxOffset = math.huge,
        maxScale = math.huge
    }, {
        maxPixels = math.huge
    })
    api.registerClick = canvasAPI.addTouch(api, dataTunnel)
    api.dataTunnel = dataTunnel
    api.canvas = canvas

    local renderDistance = 15

    for k, v in pairs(canvas) do
        if k ~= "flush" then
            api[k] = v
        end
    end

    function api.getAudience()
        return canvas.isRendering() and 1 or 0
    end

    function api.update()
        canvas.disable(not api.isAllow())
        if dataTunnel.renderAtDistance then
            canvas.setRenderDistance()
        else
            canvas.setRenderDistance(renderDistance)
        end
        canvas.pushDataTunnelParams(dataTunnel)
        canvas.update()
        dataTunnel.scriptableApi_update()

        if dataTunnel.display_reset then
            canvas.drawerReset()
            dataTunnel.display_reset = nil
        end

        if dataTunnel.display_flush then
            if needPushStack(canvas, dataTunnel) then
                canvas.pushStack(dataTunnel.display_stack)
                canvas.flush()
            end
            
            dataTunnel.display_flush()
            dataTunnel.display_stack = nil
            dataTunnel.display_flush = nil
            dataTunnel.display_forceFlush = nil
        end
    end

    function api.setRenderDistance(dist)
        renderDistance = dist
    end

    return api
end

local customFontIndexesCache = {}
local checkedFonts = {}

--implement the SComputers API, does not implement data transfer
function canvasAPI.createScriptableApi(width, height, dataTunnel, flushCallback, drawer, materialList, defaultMaterial, allowHoloAPI, allowSetResolution)
    local defaultResolutionX, defaultResolutionY = width, height
    
    dataTunnel = dataTunnel or {}
    dataTunnel.rotation = 0
    dataTunnel.light = DEFAULT_ALPHA_VALUE
    dataTunnel.skipAtNotSight = false
    dataTunnel.utf8support = false
    dataTunnel.renderAtDistance = false
    dataTunnel.display_forceFlush = true
    dataTunnel.dataUpdated = true
    dataTunnel.optimizationLevel = 16

    local stack = {}
    local stackIndex = 1
    local pixelsCache = {} --optimizations for cameras
    local pixelsCacheExists = false
    local oldStackSum, oldDataSum, oldStack, oldStackIndex
    local forceFlag = false

    local function clearStackForce()
        stack = {}
        stackIndex = 1
    end

    local function clearStack()
        if dataTunnel.display_stack == stack then
            clearStackForce()
        end
    end

    local function setForceFrame()
        if pixelsCacheExists then
            pixelsCache = {}
            pixelsCacheExists = false
        end
        forceFlag = true
        dataTunnel.display_forceFlush = true
    end

    local oldPlayersCount = #sm.player.getAllPlayers()
    function dataTunnel.scriptableApi_update()
        local playersCount = #sm.player.getAllPlayers()
        --local force = sm.game.getCurrentTick() % 80 == 0
        local force = false
        if oldPlayersCount ~= playersCount or force then
            --dataTunnel.display_forceForceFlush = force
            setForceFrame()
            oldPlayersCount = playersCount
        end
    end

    local rwidth, rheight = width, height
    local rmwidth, rmheight = width - 1, height - 1
    local utf8support = false
    local monoFont = true
    local newDataFlag = false
    local spacing = 1
    local fontIndex = 0
    local lastPixelX, lastPixelY, lastPixelColor, lastAction
    local currentSettedFont
    local currentTouchs = {}

    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local dFontX, dFontY = defaultFont.width, defaultFont.height
    local drFontX, drFontY = defaultFont.width, defaultFont.height
    local fontX, fontY
    local mFontX, mFontY
    local xFontX, xFontY
    local sFontX, sFontY
    local rFontX, rFontY
    local fontScaleX, fontScaleY = 1, 1
    local function updateFontSize()
        fontX, fontY = math_ceil(dFontX * fontScaleX), math_ceil(dFontY * fontScaleY)
        rFontX, rFontY = math_ceil(drFontX * fontScaleX), math_ceil(drFontY * fontScaleY)
        mFontX, mFontY = fontX - 1, fontY - 1
        xFontX, xFontY = fontX + 1, fontY + 1
        sFontX, sFontY = fontX + spacing, fontY + 1
    end
    updateFontSize()

    ---------------- color equals check
    local optimizationValue = optimizationLevelToValue(16)

    --local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
    local function colorEquals_smart(color1, color2)
        if color1 == color2 then return true end
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        --return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
        return ((math_abs(rVal - rVal2) + math_abs(gVal - gVal2) + math_abs(bVal - bVal2)) / 1024) <= optimizationValue
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    ----------------

    local api
    local api_flush
    api = {
        --[[
        getBuffer = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,
        getCurrent = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getRealBuffer(x + (y * rwidth))
        end,
        ]]
        get = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,

        -- not implemented (implement it yourself if necessary)
        isAllow = function()
            return true
        end,
        getAudience = function()
            return 1
        end,

        setOptimizationLevel = function(value)
            checkArg(1, value, "number")
            value = round(value)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.optimizationLevel ~= value then
                optimizationValue = optimizationLevelToValue(value)
                if value == 0 then
                    colorEquals = colorEquals_raw
                else
                    colorEquals = colorEquals_smart
                end

                dataTunnel.optimizationLevel = value
                dataTunnel.dataUpdated = true
            end
        end,
        getOptimizationLevel = function()
            return dataTunnel.optimizationLevel
        end,


        -- stubs (outdated methods)
        optimize = function() end,
        setFrameCheck = function () end,
        getFrameCheck = function () return false end,
        setSkipAtLags = function() end,
        getSkipAtLags = function() return false end,


        -- main
        setFontScale = function(scaleX, scaleY)
            checkArg(1, scaleX, "number")
            checkArg(2, scaleY, "number")
            if scaleX < 0 then scaleX = 0 end
            if scaleY < 0 then scaleY = 0 end
            fontScaleX, fontScaleY = scaleX, scaleY
            updateFontSize()
        end,
        getFontScale = function()
            return fontScaleX, fontScaleY
        end,
        setTextSpacing = function(_spacing)
            if _spacing < 0 then _spacing = 0 end
            spacing = _spacing
            updateFontSize()
        end,
        setFontSize = function(_width, _height)
            api.setFontScale(_width / dFontX, _height / dFontY)
        end,
        getTextSpacing = function()
            return spacing
        end,
        calcTextBox = function(text) --it will return two numbers, this will be the size of the box that your text will occupy with this font and this scale
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local totalSize = 0
            if monoFont then
                totalSize = textLen * (fontX + spacing)
            else
                local localFontWidth = dFontX
                local localFont = dataTunnel.customFont or font.optimized
                if fontIndex > 0 and fontsOptimized[fontIndex] then
                    localFont = fontsOptimized[fontIndex]
                    localFontWidth = localFont.width
                end

                local char, chrdata
                for i = 1, textLen do
                    char = sep(text, i, i)
                    if char ~= " " and char ~= spaceCharCode then
                        chrdata = localFont[char] or localFont.error or defaultError
                        totalSize = totalSize + (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                    else
                        totalSize = totalSize + (localFont.spaceSize or localFontWidth) + spacing
                    end
                    canvasAPI.yield()
                end
            end

            return totalSize - spacing, fontY
        end,
        calcCharsSize = function(text) --calculates the length of each character in a string, taking into account its spacing from the next character, and returns a table with these values
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    table_insert(lens, (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing)
                else
                    table_insert(lens, (localFont.spaceSize or localFontWidth) + spacing)
                end
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        calcDecreasingTextSizes = function(text) --it works almost like calcCharsSize. however, each value contains all the previous ones. this is used in the graphic.textBox function, but probably not applicable to any other
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}
            local otherVals = 0

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                local val
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    val = (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                else
                    val = (localFont.spaceSize or localFontWidth) + spacing
                end
                otherVals = otherVals + val
                table_insert(lens, otherVals)
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        isMonospacedFont = function()
            return not not monoFont
        end,

        getWidth = function()
            return rwidth
        end,
        getHeight = function()
            return rheight
        end,
        getSize = function()
            return rwidth, rheight
        end,
        getResolution = function()
            return rwidth, rheight
        end,

        clear = function(color)
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end

            lastAction = nil

            clearStackForce()
            stackIndex = 4
            stack[1] = resetViewportCodeID
            stack[2] = 0
            stack[3] = formatColorToSmallNumber(color, blackSmallNumber)
            
            --[[
            for i = 3, stackIndex - 1 do
                stack[i] = nil
            end
            stackIndex = 3
            ]]
        end,
        drawPixel = function(x, y, color)
            x, y = round(x), round(y)
            if x < 0 or x >= width or y < 0 or y >= height then return end
            local index = x + (y * rwidth)
            color = formatColorToSmallNumber(color, whiteSmallNumber)
            if pixelsCache[index] ~= color then
                if lastAction and x == lastPixelX + 1 and y == lastPixelY and colorEquals(lastPixelColor, color) then
                    if lastAction == 1 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 12
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 1
                elseif lastAction and x == lastPixelX - 1 and y == lastPixelY and colorEquals(lastPixelColor, color) then
                    if lastAction == 2 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 13
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 2
                elseif lastAction and x == lastPixelX and y == lastPixelY + 1 and colorEquals(lastPixelColor, color) then
                    if lastAction == 3 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 14
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 3
                elseif lastAction and x == lastPixelX and y == lastPixelY - 1 and colorEquals(lastPixelColor, color) then
                    if lastAction == 4 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 15
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 4
                else
                    lastPixelColor = color

                    stack[stackIndex] = 16
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = index
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = color
                    stackIndex = stackIndex + 1

                    lastAction = 0
                end

                lastPixelX, lastPixelY = x, y
                pixelsCache[index] = color
                pixelsCacheExists = true
            end
        end,
        fillRect = function(x, y, sizeX, sizeY, color)
            if x <= 0 and y <= 0 and x + sizeX >= width and y + sizeY >= height then
                return api.clear(color or 0xffffff)
            end

            stack[stackIndex] = 2
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawRect = function(x, y, sizeX, sizeY, color, lineWidth)
            lineWidth = round(lineWidth or 1)
            if lineWidth < 1 then
                lineWidth = 1
            end

            stack[stackIndex] = 3
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = lineWidth
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawText = function(x, y, text, color)
            if y > rmheight or y + mFontY < 0 or fontScaleX <= 0 or fontScaleY <= 0 then return end
            text = tostring(text)

            if monoFont then
                local maxTextLen = math_ceil((width - x) / sFontX)
                if maxTextLen <= 0 then return end
                local startTextFrom = math_max(1, math_floor(-x / sFontX) + 1)

                if utf8support then
                    if utf8.len(text) > maxTextLen or startTextFrom > 1 then
                        text = utf8.sub(text, startTextFrom, maxTextLen)
                    end
                else
                    if #text > maxTextLen or startTextFrom > 1 then
                        text = text:sub(startTextFrom, maxTextLen)
                    end
                end

                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x) + ((startTextFrom - 1) * sFontX)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            else
                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCenteredText = function(x, y, text, color, centerX, centerY)
            if centerX == nil then centerX = true end
            if centerY == nil then centerY = true end
            
            local sizeX, sizeY
            if centerX or centerY then
                sizeX, sizeY = api.calcTextBox(text)
            end

            if centerX then
                x = x - (sizeX / 2)
            end

            if centerY then
                y = y - (sizeY / 2)
            end

            api.drawText(x, y, text, color)
        end,
        drawLine = function(x, y, x2, y2, color, width, roundFlag)
            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            stack[stackIndex] = 5
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = width
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 6
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end
            
            stack[stackIndex] = 7
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleEvenly = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 8
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleVeryEvenly = function (x, y, r, color, stroke)
            if r > 1024 then r = 1024 end
            if not stroke or stroke < 1 then stroke = 1 end

            stack[stackIndex] = 9
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(stroke)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawPoly = function(color, ...)
            api.drawWidePoly(color, 1, false, ...)
        end,
        drawWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 10
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillPoly = function(color, ...)
            api.fillWidePoly(color, 1, false, ...)
        end,
        fillWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 11
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawTriangle = function(x1, y1, x2, y2, x3, y3, color)
            api.drawPoly(color, x1, y1, x2, y2, x3, y3)
        end,
        fillTriangle = function(x1, y1, x2, y2, x3, y3, color)
            api.fillPoly(color, x1, y1, x2, y2, x3, y3)
        end,
        flush = function()
            lastAction = nil
            api.setViewport()

            if dataTunnel.display_flush and dataTunnel.display_stack == stack then
                return
            end

            local needFlush = forceFlag
            --print("--------------------------- FLUSH 1", needFlush, stack, stackChecksum(stack), stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel)))

            if not needFlush and stackIndex ~= oldStackIndex then
                --print("FLUSH 2", stackIndex, oldStackIndex)
                needFlush = true
            end

            if not needFlush and newDataFlag then
                local dataSum = stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel))
                if dataSum ~= oldDataSum then
                    --print("FLUSH 3")
                    needFlush = true
                    oldDataSum = dataSum
                end
            end

            if not needFlush and stack ~= oldStack then
                for i = 1, stackIndex - 1 do
                    if stack[i] ~= oldStack[i] then
                        needFlush = true
                        --print("FLUSH 4", oldStack)
                        break
                    end
                end
            end

            --[[
            if needFlush then
                oldStackSum = nil
            else
                local stachSum = stackChecksum(stack)
                if stachSum ~= oldStackSum then
                    --print("FLUSH 5")
                    needFlush = true
                    oldStackSum = stachSum
                end
            end
            ]]
            
            if needFlush then
                --print("FLUSH ACTION")
                oldStack = stack
                oldStackIndex = stackIndex

                dataTunnel.display_stack = stack
                dataTunnel.display_flush = clearStack
                
                if flushCallback then
                    flushCallback()
                end
            else
                clearStackForce()
            end

            forceFlag = false
            newDataFlag = false
        end,
        forceFlush = function()
            api_flush()
            dataTunnel.display_forceFlush = true
        end,

        -- settings
        setUtf8Support = function (state)
            if type(state) == "boolean" then
                if dataTunnel.utf8support ~= state then
                    dataTunnel.utf8support = state
                    dataTunnel.dataUpdated = true
                    newDataFlag = true
                    utf8support = state
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getUtf8Support = function () return dataTunnel.utf8support end,

        setRenderAtDistance = function (c)
            if type(c) == "boolean" then
                if dataTunnel.renderAtDistance ~= c then
                    dataTunnel.renderAtDistance = c
                    dataTunnel.dataUpdated = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getRenderAtDistance = function () return dataTunnel.renderAtDistance end,

        setRotation = function (rotation)
            if type(rotation) == "number" and rotation % 1 == 0 and rotation >= 0 and rotation <= 3 then
                if rotation ~= dataTunnel.rotation then
                    dataTunnel.rotation = rotation
                    dataTunnel.dataUpdated = true
                    newDataFlag = true

                    if pixelsCacheExists then
                        pixelsCache = {}
                        pixelsCacheExists = false
                    end

                    if rotation == 1 or rotation == 3 then
                        rwidth = height
                        rheight = width
                    else
                        rwidth = width
                        rheight = height
                    end
                    rmheight = rheight - 1
                    rmwidth = rwidth - 1
                end
            else
                error("integer must be in [0; 3]", 2)
            end
        end,
        getRotation = function () return dataTunnel.rotation end,

        setFont = function (customFont)
            checkArg(1, customFont, "table", "nil")
            currentSettedFont = customFont
            fontIndex = 0
            if dataTunnel.customFont then
                dataTunnel.dataUpdated = true
                dataTunnel.customFont = nil
            end
            if customFont then
                if not checkedFonts[customFont] then
                    checkFont(customFont)
                    checkedFonts[customFont] = true
                end
                dFontX, dFontY = customFont.width, customFont.height
                drFontX, drFontY = customFont.returnWidth or customFont.width, customFont.returnHeight or customFont.height
                fontIndex = customFontIndexesCache[customFont]
                if not fontIndex then
                    fontIndex = 0
                    for _, v in pairs(fonts) do
                        if v == customFont then
                            fontIndex = v.index
                        end
                    end
                    customFontIndexesCache[customFont] = fontIndex
                end
                if fontIndex == 0 then
                    dataTunnel.customFont = font.optimizeFont(customFont)
                    dataTunnel.dataUpdated = true
                end
                monoFont = customFont.mono or customFont.mono == nil
            else
                dFontX, dFontY = defaultFont.width, defaultFont.height
                drFontX, drFontY = defaultFont.width, defaultFont.height
                monoFont = true
            end
            updateFontSize()
            newDataFlag = true
        end,
        getFont = function()
            return currentSettedFont
        end,

        getFontWidth = function ()
            return rFontX
        end,
        getFontHeight = function ()
            return rFontY
        end,
        getFontSize = function()
            return rFontX, rFontY
        end,

        getRealFontWidth = function ()
            return drFontX
        end,
        getRealFontHeight = function ()
            return drFontY
        end,
        getRealFontSize = function()
            return drFontX, drFontY
        end,

        setSkipAtNotSight = function (state)
            checkArg(1, state, "boolean")
            if dataTunnel.skipAtNotSight ~= state then
                dataTunnel.skipAtNotSight = state
                dataTunnel.dataUpdated = true
            end
        end,
        getSkipAtNotSight = function () return dataTunnel.skipAtNotSight end,

        getViewport = function()
            return viewport_x, viewport_y, viewport_sx, viewport_sy
        end,
        setViewport = function(x, y, sizeX, sizeY)
            if x or y or sizeX or sizeY then
                viewport_x, viewport_y, viewport_sx, viewport_sy = x or 0, y or 0, sizeX or api.getWidth(), sizeY or api.getHeight()
                stack[stackIndex] = -1
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sx)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sy)
                stackIndex = stackIndex + 1
            else
                viewport_x, viewport_y, viewport_sx, viewport_sy = nil, nil, nil, nil
                stack[stackIndex] = resetViewportCodeID
                stackIndex = stackIndex + 1
            end
        end,
        setInlineViewport = function(x, y, sizeX, sizeY)
            if viewport_x then
                local x2 = x + (sizeX - 1)
                local y2 = y + (sizeY - 1)
                local px2 = viewport_x + (viewport_sx - 1)
                local py2 = viewport_y + (viewport_sy - 1)
                if x < viewport_x then x = viewport_x elseif x > px2 then x = px2 end
                if y < viewport_y then y = viewport_y elseif y > py2 then y = py2 end
                if x2 < viewport_x then x2 = viewport_x elseif x2 > px2 then x2 = px2 end
                if y2 < viewport_y then y2 = viewport_y elseif y2 > py2 then y2 = py2 end
                api.setViewport(x, y, (x2 - x) + 1, (y2 - y) + 1)
            else
                api.setViewport(x, y, sizeX, sizeY)
            end
        end,

        setBrightness = function(value) --legacy
            checkArg(1, value, "number")
            --[[
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.brightness ~= value then
                dataTunnel.brightness = value
                dataTunnel.dataUpdated = true
            end
            ]]
        end,
        getBrightness = function() --legacy
            --return dataTunnel.brightness
            return 1
        end,

        setLight = function(value)
            checkArg(1, value, "number")
            value = math_floor(value + 0.5)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.light ~= value then
                dataTunnel.light = value
                dataTunnel.dataUpdated = true
            end
        end,
        getLight = function(value)
            return dataTunnel.light
        end,

        getDefaultResolution = function()
            return defaultResolutionX, defaultResolutionY
        end,

        getTouchs = function()
            for i = 1, MAX_CLICKS do
                local click = api.getClick()
                if not click then
                    break
                end
                local index = #currentTouchs + 1
                for lindex, lclick in reverse_ipairs(currentTouchs) do
                    if lclick.nickname == click.nickname and lclick.button == click.button then
                        index = lindex
                        break
                    end
                end
                if click.state == "released" then
                    table.remove(currentTouchs, index)
                else
                    currentTouchs[index] = click
                end
            end

            return currentTouchs
        end,

        getTouch = function()
            return api.getTouchs()[1]
        end,

        reset = function()
            currentTouchs = {}
            if api.setMaterial then api.setMaterial(api.getDefaultMaterial()) end
            if api.setFontScale then api.setFontScale(1, 1) end
            if api.setTextSpacing then api.setTextSpacing(1) end
            if api.setFont then api.setFont() end
            if api.setRotation then api.setRotation(0) end
            if api.setUtf8Support then api.setUtf8Support(false) end
            if api.setClicksAllowed then api.setClicksAllowed(false) end
            if api.setMaxClicks then api.setMaxClicks(MAX_CLICKS) end
            if api.clearClicks then api.clearClicks() end
            if api.setSkipAtNotSight then api.setSkipAtNotSight(false) end
            if api.setRenderAtDistance then api.setRenderAtDistance(false) end
            if api.setViewport then api.setViewport() end
            if api.setLight then api.setLight(DEFAULT_ALPHA_VALUE) end
            if api.setOptimizationLevel then api.setOptimizationLevel(16) end
            if api.setHoloOffset then api.setHoloOffset(0, 0, 0) end
            if api.setHoloRotation then api.setHoloRotation(0, 0, 0) end
            if api.setHoloScale then api.setHoloScale(1, 1) end
            if api.setResolution then api.setResolution(defaultResolutionX, defaultResolutionY) end
            dataTunnel.display_reset = true
        end
    }

    if materialList then
        defaultMaterial = defaultMaterial or (materialList[0] and 0 or 1)
        local currentMaterialID

        function api.setMaterial(materialId)
            checkArg(1, materialId, "number")
            currentMaterialID = materialId
            if not materialList[currentMaterialID] then
                currentMaterialID = defaultMaterial
            end
            local material = materialList[currentMaterialID]
            if material == true then
                error("this material is not supported on this display", 2)
            end
            if dataTunnel.material ~= material then
                dataTunnel.material = material
                dataTunnel.dataUpdated = true
            end
        end

        function api.getMaterial()
            return currentMaterialID
        end

        function api.getDefaultMaterial()
            return defaultMaterial
        end

        api.setMaterial(api.getDefaultMaterial())
    end

    dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z = 0, 0, 0
    dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z = 0, 0, 0
    dataTunnel.scale_x, dataTunnel.scale_y = 1, 1
    if allowHoloAPI then
        local maxOffset = 5
        local maxScale = 5
        if type(allowHoloAPI) == "table" then
            maxOffset = allowHoloAPI.maxOffset or maxOffset
            maxScale = allowHoloAPI.maxScale or maxScale
        end

        function api.setHoloOffset(x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")
            
            if x < -maxOffset then x = -maxOffset end
            if y < -maxOffset then y = -maxOffset end
            if z < -maxOffset then z = -maxOffset end
            if x > maxOffset then x = maxOffset end
            if y > maxOffset then y = maxOffset end
            if z > maxOffset then z = maxOffset end

            if x ~= dataTunnel.offset_x or y ~= dataTunnel.offset_y or z ~= dataTunnel.offset_z then
                dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z = x, y, z
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloOffset()
            return dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z
        end

        function api.setHoloRotation(x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")
            if x ~= dataTunnel.rotation_x or y ~= dataTunnel.rotation_y or z ~= dataTunnel.rotation_z then
                dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z = x, y, z
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloRotation()
            return dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z
        end

        function api.setHoloScale(x, y)
            checkArg(1, x, "number")
            checkArg(2, y, "number")

            if x < 0 then x = 0 end
            if y < 0 then y = 0 end
            if x > maxScale then x = maxScale end
            if y > maxScale then y = maxScale end

            if x ~= dataTunnel.scale_x or y ~= dataTunnel.scale_y then
                dataTunnel.scale_x, dataTunnel.scale_y = x, y
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloScale()
            return dataTunnel.scale_x, dataTunnel.scale_y
        end
    end

    dataTunnel.res_x, dataTunnel.res_y = defaultResolutionX, defaultResolutionY
    if allowSetResolution then
        if type(allowSetResolution) ~= "table" then
            allowSetResolution = {
                maxPixels = 4096 * 4096,
                maxWidth = 4096,
                maxHeight = 4096
            }
        end

        function api.setResolution(resX, resY)
            checkArg(1, resX, "number")
            checkArg(2, resY, "number")

            resX = math.floor(resX)
            resY = math.floor(resY)
            if resX < 1 then resX = 1 end
            if resY < 1 then resY = 1 end

            if allowSetResolution.maxWidth and resX > allowSetResolution.maxWidth then
                error("the width resolution has been exceeded. maximum: " .. allowSetResolution.maxWidth, 2)
            end

            if allowSetResolution.maxHeight and resX > allowSetResolution.maxHeight then
                error("the height resolution has been exceeded. maximum: " .. allowSetResolution.maxHeight, 2)
            end

            if allowSetResolution.maxPixels and (resX * resY) > allowSetResolution.maxPixels then
                error("the total maximum number of pixels has been exceeded. maximum: " .. allowSetResolution.maxPixels, 2)
            end
            
            if resX ~= dataTunnel.res_x or resY ~= dataTunnel.res_y then
                dataTunnel.res_x, dataTunnel.res_y = resX, resY
                dataTunnel.dataUpdated = true
                dataTunnel.resolutionChanged = true

                if pixelsCacheExists then
                    pixelsCache = {}
                    pixelsCacheExists = false
                end

                width, height = resX, resY
                if dataTunnel.rotation == 1 or dataTunnel.rotation == 3 then
                    rwidth = height
                    rheight = width
                else
                    rwidth = width
                    rheight = height
                end
                rmheight = rheight - 1
                rmwidth = rwidth - 1
            end
        end
    end

    api.update = api.flush
    api.getBuffer = api.get
    api.getCurrent = api.get
    api_flush = api.flush

    local internal = {
        rawPush = function(tbl)
            for i = 1, #tbl do
                stack[stackIndex] = tbl[i]
                stackIndex = stackIndex + 1
            end
        end,
        setForceFrame = setForceFrame
    }

    return api, internal
end

--adds a touch screen API (does not implement click processing)
function canvasAPI.addTouch(api, dataTunnel)
    dataTunnel = dataTunnel or {}
    dataTunnel.clicksAllowed = false
    dataTunnel.maxClicks = MAX_CLICKS
    dataTunnel.clickData = {}

    api.getClick = function ()
        return (table_remove(dataTunnel.clickData, 1))
    end

    api.setMaxClicks = function (c)
        if type(c) == "number" and c % 1 == 0 and c > 0 and c <= 16 then
            dataTunnel.maxClicks = c
        else
            error("integer must be in [1; 16]", 2)
        end
    end

    api.getMaxClicks = function ()
        return dataTunnel.maxClicks
    end

    api.clearClicks = function ()
        dataTunnel.clickData = {}
    end

    api.setClicksAllowed = function (c)
        if type(c) == "boolean" then
            if dataTunnel.clicksAllowed ~= c then
                dataTunnel.clicksAllowed = c
                dataTunnel.dataUpdated = true
            end
        else
            error("Type must be boolean", 2)
        end
    end

    api.getClicksAllowed = function ()
        return dataTunnel.clicksAllowed
    end

    return function (tbl)
        tbl.x = tbl[1] or tbl.x
        tbl.y = tbl[2] or tbl.y
        tbl.state = tbl[3] or tbl.state
        tbl.button = tbl[4] or tbl.button
        tbl.nickname = tbl[5] or tbl.nickname
        tbl[1] = tbl.x or tbl[1]
        tbl[2] = tbl.y or tbl[2]
        tbl[3] = tbl.state or tbl[3]
        tbl[4] = tbl.button or tbl[4]
        tbl[5] = tbl.nickname or tbl[5]
        if #dataTunnel.clickData < dataTunnel.maxClicks then
            table_insert(dataTunnel.clickData, tbl)
        end
    end
end

--leaves only those tunnel fields that are needed for transmission over the network
function canvasAPI.minimizeDataTunnel(dataTunnel)
    return {
        clicksAllowed = dataTunnel.clicksAllowed,
        rotation = dataTunnel.rotation,
        renderAtDistance = dataTunnel.renderAtDistance,
        skipAtNotSight = dataTunnel.skipAtNotSight,
        utf8support = dataTunnel.utf8support,
        customFont = dataTunnel.customFont,
        display_reset = dataTunnel.display_reset,
        optimizationLevel = dataTunnel.optimizationLevel,
        light = dataTunnel.light,
        material = dataTunnel.material,

        offset_x = dataTunnel.offset_x,
        offset_y = dataTunnel.offset_y,
        offset_z = dataTunnel.offset_z,

        rotation_x = dataTunnel.rotation_x,
        rotation_y = dataTunnel.rotation_y,
        rotation_z = dataTunnel.rotation_z,

        scale_x = dataTunnel.scale_x,
        scale_y = dataTunnel.scale_y,

        res_x = dataTunnel.res_x,
        res_y = dataTunnel.res_y
    }
end

-------- additional
canvasAPI.stackChecksum = stackChecksum
canvasAPI.formatColor = formatColor
canvasAPI.formatColorToNumber = formatColorToNumber
canvasAPI.formatColorToSmallNumber = formatColorToSmallNumber
canvasAPI.checkFont = checkFont
canvasAPI.simpleRemathRect = simpleRemathRect
canvasAPI.remathRect = remathRect
canvasAPI.hexToRGB = hexToRGB
canvasAPI.hexToRGB256 = hexToRGB256
canvasAPI.posCheck = posCheck
canvasAPI.mathDist = mathDist
canvasAPI.needPushStack = needPushStack
canvasAPI.font = font
canvasAPI.tableClone = tableClone
canvasAPI.canvasService = canvasService
canvasAPI.userCalls = userCalls
canvasAPI.dataSizes = dataSizes
canvasAPI.color_new_fromSmallNumber = color_new_fromSmallNumber
canvasAPI.getEffectName = getEffectName
canvasAPI.fonts = fonts
canvasAPI.utf8 = utf8

function canvasAPI.pushData(stack, ...)
    for i, v in ipairs({...}) do
        table.insert(stack, v)
    end
end

_G.canvasAPI = canvasAPI
end
function scmframework_e5ae258670242ba8f73542d1eeb5d496() --$CONTENT_DATA/Scripts/canvasAPI/backup/canvas_legacy.lua
--[[
this file belongs to logic/bananaPen and was completely written by me alone(logic/bananaPen)
it was the most technically difficult project in my life O_o
writing a canvas for scrap mechanic that should work quickly turned out to be VERY DIFFICULT
]]

print("> canvas.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/luajit.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/font.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/fontsLoad.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/utf8.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/canvasService.lua")

local debugMode = true
local canvasAPI = {
    draw = {
        clear = 0,
        set   = 1,
        fill  = 2,
        rect  = 3,
        text  = 4,
        line  = 5,
        circle  = 6,
        circleF = 7,
        circleE = 8,
        circleVE = 9,
        poly = 10,
        polyF = 11
    },
    material = {
        classic = sm.uuid.new("64d41b06-9b71-4e19-9f87-1e7e63845e59"),
        glass = sm.uuid.new("a683f897-5b8a-4c96-9c46-7b9fbc76d186")
    },
    multi_layer = {}
}
canvasAPI.multi_layer[tostring(canvasAPI.material.classic)] = true
canvasAPI.version = 30

canvasAPI.directList = {
    get = true,
    getCurrent = true,
    getBuffer = true,
    
    clear = true,
    drawPixel = true,
    drawRect = true,
    fillRect = true,
    drawText = true,
    drawLine = true,
    drawCircle = true,
    fillCircle = true,
    drawCircleEvenly = true,
    drawCircleVeryEvenly = true,
    drawPoly = true,
    drawWidePoly = true,
    fillPoly = true,
    fillWidePoly = true,
    getWidth = true,
    getHeight = true,
    getSize = true,

    isAllow = true,
    setFontScale = true,
    setFontSize = true,
    getFontScale = true,
    setTextSpacing = true,
    getTextSpacing = true,
    calcTextBox = true,
    calcCharsSize = true,
    calcDecreasingTextSizes = true,
    setUtf8Support = true,
    getUtf8Support = true,
    setRenderAtDistance = true,
    getRenderAtDistance = true,
    setRotation = true,
    getRotation = true,
    setFont = true,
    getFont = true,
    getFontWidth = true,
    getFontHeight = true,
    getRealFontWidth = true,
    getRealFontHeight = true,
    setSkipAtNotSight = true,
    getSkipAtNotSight = true,
    isMonospacedFont = true,
    setBrightness = true,
    getBrightness = true,
    reset = true,
    setClicksAllowed = true,
    getClicksAllowed = true,
    clearClicks = true,
    setMaxClicks = true,
    getMaxClicks = true,
    getClick = true,
    setOptimizationLevel = true,
    getOptimizationLevel = true,

    setViewport = true,
    setInlineViewport = true,
    getViewport = true
}

local MAX_DRAW_TIME = 2 --protecting the world from crashing using the display
local FONT_SIZE_LIMIT = 256
local DEFAULT_ALPHA_VALUE = 180

local fonts = fonts
local fontsOptimized = fontsOptimized
local spaceCharCode = string.byte(" ")

local huge = math.huge
local string_len = string.len
local bit = bit or bit32
local bit_rshift = bit.rshift
local bit_lshift = bit.lshift
local utf8 = utf8
local string = string
local table_sort = table.sort
local font = font
local type = type
local math_ceil = math.ceil
local math_max = math.max
local string_format = string.format
local table_insert = table.insert
local table_remove = table.remove
local math_floor = math.floor
local vec3_new = sm.vec3.new
local color_new = sm.color.new
local quat_fromEuler = sm.quat.fromEuler
local ipairs = ipairs
local pairs = pairs
local string_byte = string.byte
local defaultError = font.optimized.error
local tostring = tostring
local math_abs = math.abs
local math_min = math.min
local string_sub = string.sub
local table_concat = table.concat
local tonumber = tonumber
local utf8_len = utf8.len
local utf8_sub = utf8.sub
local sm_localPlayer_getPlayer = sm.localPlayer.getPlayer
local os_clock = os.clock

local black = color_new(0, 0, 0)
local white = color_new(1, 1, 1)
local blackNumber = 0x000000ff
local whiteNumber = 0xffffffff
local blackSmallNumber = 0x000000
local whiteSmallNumber = 0xffffff

local getEffectName
do
    local currentEffect = 1
    local effectsNames = {}

    for i = 0, 255 do
        table_insert(effectsNames, "ShapeRenderable" .. tostring(i))
    end

    function getEffectName()
        local name = effectsNames[currentEffect]
        currentEffect = currentEffect + 1
        if currentEffect > #effectsNames then
            currentEffect = 1
        end
        return name
    end
end

--[[
local sm_effect_createEffect = sm.effect.withoutHook_createEffect or sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local withoutHookEmptyEffect = emptyEffect
local whook = "withoutHook_"
if better and better.version >= 24 and better.isAvailable() then
    local mt = getmetatable(emptyEffect)
    local newMt = {}
    for k, v in pairs(mt) do
        newMt[k] = v
    end
    for k, v in pairs(mt) do
        if k:sub(1, #whook) == whook then
            newMt[k:sub(#whook + 1, #k)] = v
        end
    end
    withoutHookEmptyEffect = setmetatable({}, newMt)
end
local effect_setParameter = withoutHookEmptyEffect.setParameter
local effect_stop = withoutHookEmptyEffect.stop
local effect_destroy = withoutHookEmptyEffect.destroy
local effect_start = withoutHookEmptyEffect.start
local effect_isDone = withoutHookEmptyEffect.isDone
local effect_isPlaying = withoutHookEmptyEffect.isPlaying
local effect_setScale = withoutHookEmptyEffect.setScale
local effect_setOffsetPosition = withoutHookEmptyEffect.setOffsetPosition
local effect_setOffsetRotation = withoutHookEmptyEffect.setOffsetRotation
effect_destroy(emptyEffect)
]]

local sm_effect_createEffect = sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local effect_setParameter = emptyEffect.setParameter
local effect_stop = emptyEffect.stop
local effect_destroy = emptyEffect.destroy
local effect_start = emptyEffect.start
local effect_isDone = emptyEffect.isDone
local effect_isPlaying = emptyEffect.isPlaying
local effect_setScale = emptyEffect.setScale
local effect_setOffsetPosition = emptyEffect.setOffsetPosition
local effect_setOffsetRotation = emptyEffect.setOffsetRotation
effect_destroy(emptyEffect)

local function round(number)
    return math_floor(number + 0.5)
end

local function checkFont(lfont)
	if type(lfont) ~= "table" then
		error("the font should be a table", 3)
    end

    if lfont.mono or lfont.mono == nil then
        if type(lfont.chars) ~= "table" or (type(lfont.width) ~= "number") or (type(lfont.height) ~= "number") then
            error("font failed integrity check", 3)
        end
        
        if lfont.width > FONT_SIZE_LIMIT then
            error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
        elseif lfont.height > FONT_SIZE_LIMIT then
            error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
        end

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data ~= lfont.height then
                error("font failed integrity check", 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" or #line ~= lfont.width then
                    error("font failed integrity check", 3)
                end
            end
        end
    else
        if type(lfont.chars) ~= "table" then
            error("font failed integrity check", 3)
        end

        local oFont = font.optimizeFont(lfont)
        lfont.spaceSize = oFont.spaceSize
        lfont.width = oFont.width
        lfont.height = oFont.height

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data > FONT_SIZE_LIMIT then
                error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" or #line > FONT_SIZE_LIMIT then
                    error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
                end
            end
        end
    end
end

local function tableClone(tbl)
    local newtbl = {}
    for k, v in pairs(tbl) do
        newtbl[k] = v
    end
    return newtbl
end

local function stackChecksum(stack)
    local num = -#stack
    local t, v
    for i = 1, #stack do
        v = stack[i]
        t = type(v)
        num = num - i
        if t == "number" then
            num = num + ((v * i) + v + i + (v / i))
        elseif t == "Color" then
            num = num + ((i * (v.r / i) * -4) + v.g)
            num = num - ((i * (v.g + i) * 5) + v.b)
            num = num + ((i * (v.b - i) * 8) + v.r)
        elseif t == "string" then
            for i3 = 1, #v do
                num = num + (i * (-i3 - (string_byte(v, i3) * i3)))
            end
        end
    end
    return num
end

local function checkArg(n, have, ...)
	have = type(have)
	local tbl = {...}
	for _, t in ipairs(tbl) do
		if have == t then
			return
		end
	end
	error(string_format("bad argument #%d (%s expected, got %s)", n, table_concat(tbl, " or "), have), 3)
end

local function simpleRemathRect(x, y, w, h, maxX, maxY)
    local x2, y2 = x + (w - 1), y + (h - 1)
    if x < 0 then
        x = 0
    elseif x > maxX then
        --x = maxX
        return
    end
    if y < 0 then
        y = 0
    elseif y > maxY then
        --y = maxY
        return
    end
    if x2 < 0 then
        --x2 = 0
        return
    elseif x2 > maxX then
        x2 = maxX
    end
    if y2 < 0 then
        --y2 = 0
        return
    elseif y2 > maxY then
        y2 = maxY
    end
    return x, y, x2, y2, w, h
end

local function remathRect(offset, stack, maxX, maxY)
    return simpleRemathRect(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], maxX, maxY)
end

local function posCheck(width, height, x, y)
    return x >= 0 and y >= 0 and x < width and y < height
end

local hashChar = string.byte("#")
local bit = bit or bit32
local band = bit.band
local rshift = bit.rshift
local function hexToRGB(color)
    return band(rshift(color, 16), 0xFF) / 255, band(rshift(color, 8), 0xFF) / 255, band(color, 0xFF) / 255
end

local function hexToRGB256(color)
    return band(rshift(color, 16), 0xFF), band(rshift(color, 8), 0xFF), band(color, 0xFF)
end

local function formatColor(color, default)
    local t = type(color)
    if t == "Color" then
        return color
    elseif t == "string" then
        return color_new(color)
    elseif t == "number" then
        return color_new(hexToRGB(color))
    end

    return default
end

local redMul = 256 * 256 * 256
local greenMul = 256 * 256
local blueMul = 256
local function formatColorToNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * redMul) + (math_floor(color.g * 255) * greenMul) + (math_floor(color.b * 255) * blueMul) + math_floor(color.a * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return val
        end
        return (val * 256) + 255
    elseif t == "number" then
        return (color * 256) + 255
    end

    return default or 0
end

local function formatColorToSmallNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * greenMul) + (math_floor(color.g * 255) * blueMul) + math_floor(color.b * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return math_floor(val / 256)
        end
        return val
    elseif t == "number" then
        return color
    end

    return default or 0
end

local function color_new_fromSmallNumber(number, alpha)
    return color_new((number * 256) + (alpha or 255))
end

local function mathDist(pos1, pos2)
    return math.sqrt(((pos1.x - pos2.x) ^ 2) + ((pos1.y - pos2.y) ^ 2) + ((pos1.z - pos2.z) ^ 2))
end

local function needPushStack(canvas, dataTunnel, dt) --returns true if the rendering stack should be applied
    return dataTunnel.display_forceFlush or not ((dataTunnel.skipAtNotSight and not canvas.isRendering()))
end

local resetViewportCodeID = -23124
local dataSizes = {
    [resetViewportCodeID] = 1,
    [-1] = 5,
    [0] = 2,
    3,
    6,
    7,
    9, --text
    7, --line
    5,
    5,
    5,
    6,

    4, --drawPoly
    4 --fillPoly
}

local userCalls = {}

canvasAPI.yield = function() end

function canvasAPI.createDrawer(sizeX, sizeY, callback, callbackBefore, directArg, direct_clear, direct_fill, direct_set, updatedList)
    local obj = {}
    local oldStackSum
    local rSizeX, rSizeY = sizeX, sizeY
    local maxX, maxY = sizeX - 1, sizeY - 1
    local newBuffer, newBufferBase = {}, 0
    local realBuffer = {}
    local maxBuffer = maxX + (maxY * sizeX)
    local currentFont = font.optimized
    local fontWidth, fontHeight = font.width, font.height
    local rotation = 0
    local utf8Support = false
    local updated = false
    local clearOnly = false
    local maxLineSize = sizeX + sizeY
    local bigSide = math_max(sizeX, sizeY)
    local drawerData = {}
    local changes = {}
    local _changes = {}
    local changesIndex, changesCount = {}, 0

    local bufferChangedFrom = huge
    local bufferChangedTo = -huge

    local function bufferRangeUpdate(index)
        if index < bufferChangedFrom then bufferChangedFrom = index end
        if index > bufferChangedTo then bufferChangedTo = index end
    end

    local viewportEnable = false
    local brightnessEnable = false
    local brightness = 1
    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local function setDot(px, py, col)
        if viewportEnable and (px < viewport_x or py < viewport_y or px >= (viewport_x + viewport_sx) or py >= (viewport_y + viewport_sy)) then
            return
        end

        --[[
        if rotation == 0 then
            index = px + (py * rSizeX)
        elseif rotation == 1 then
            index = (rSizeX - py - 1) + (px * rSizeX)
        elseif rotation == 2 then
            index = (rSizeX - px - 1) + ((rSizeY - py - 1) * rSizeX)
        else
            index = py + ((rSizeY - px - 1) * rSizeX)
        end
        ]]

        if brightnessEnable then
            local r = math_floor(col / 256 / 256) % 256
            local g = math_floor(col / 256) % 256
            local b = col % 256
            col = (math_min(255, math_floor(r * brightness)) * 256 * 256) + (math_min(255, math_floor(g * brightness)) * 256) + math_min(255, math_floor(b * brightness))
        end

        local index
        if rotation == 0 then
            index = py + (px * rSizeY)
        elseif rotation == 1 then
            index = px + ((rSizeX - py - 1) * rSizeY)
        elseif rotation == 2 then
            index = (rSizeY - py - 1) + ((rSizeX - px - 1) * rSizeY)
        else
            index = (rSizeY - px - 1) + (py * rSizeY)
        end

        if updatedList and not changes[index] then
            changes[index] = true
            changesCount = changesCount + 1
            changesIndex[changesCount] = index
        end

        if direct_set then
            newBuffer[index] = col
            direct_set(directArg, math_floor(index / rSizeY), index % rSizeY, col)
            return true
        elseif newBuffer[index] ~= col then
            bufferRangeUpdate(index)
            newBuffer[index] = col
            return true
        end
    end

    local function check(px, py)
        return px >= 0 and py >= 0 and px < sizeX and py < sizeY
    end

    local function checkSetDot(px, py, col)
        if check(px, py) then
            setDot(px, py, col)
            return true
        end
        return false
    end

    function obj.drawerReset()
    end

    function obj.setSoftwareRotation(_rotation)
        rotation = _rotation
        if rotation == 1 or rotation == 3 then
            sizeX = rSizeY
            sizeY = rSizeX
        else
            sizeX = rSizeX
            sizeY = rSizeY
        end
        maxX, maxY = sizeX - 1, sizeY - 1
    end

    function obj.setUtf8Support(state)
        utf8Support = not not state
    end

    function obj.setFont(customFont)
        if customFont then
            currentFont = customFont
            fontWidth, fontHeight = customFont.width, customFont.height
        else
            currentFont = font.optimized
            fontWidth, fontHeight = font.width, font.height
        end
    end

    local old_rotation
    local old_utf8support
    local old_customFont
    function obj.pushDataTunnelParams(params)
        brightness = params.brightness
        brightnessEnable = brightness ~= 1

        if params.rotation ~= old_rotation then
            obj.setSoftwareRotation(params.rotation)
            old_rotation = params.rotation
        end
        if params.utf8support ~= old_utf8support then
            obj.setUtf8Support(params.utf8support)
            old_utf8support = params.utf8support
        end
        if params.customFont ~= old_customFont then
            obj.setFont(params.customFont)
            old_customFont = params.customFont
        end
    end

    ------------------------------------------
    
    local function rasterize_fill(x, y, sx, sy, col)
        local x, y, x2, y2 = simpleRemathRect(x, y, sx, sy, maxX, maxY)
        if not x then return end
        for ix = x, x2 do
            for iy = y, y2 do
                setDot(ix, iy, col)
            end
        end
    end

    local function rasterize_circleF(px, py, r, col)
        local chr = r*r
        local sx, sy, tempInt, tempBool

        if r < bigSide and px >= 0 and py >= 0 and px < sizeX and py < sizeY then --now only a quarter of the circle is rendered
            for iy = 0, r do
                sy = iy + 0.5
                tempBool = false
                for ix = r, 0, -1 do
                    sx = ix + 0.5
                    if tempBool or (sx * sx) + (sy * sy) <= chr then
                        tempBool = true
                        checkSetDot(px + ix, py + iy, col)
                        checkSetDot(px - ix - 1, py + iy, col)
                        checkSetDot(px + ix, py - iy - 1, col)
                        checkSetDot(px - ix - 1, py - iy - 1, col)
                    end
                end
            end
        else
            for ix = math_max(-r, -px), math_min(r, (sizeX - px) - 1) do --if the starting point is not within the screen or the circle is too large, then will have to check every pixel
                sx = ix + 0.5
                for iy = math_max(-r, -py), math_min(r, (sizeY - py) - 1) do
                    sy = iy + 0.5
                    if (sx * sx) + (sy * sy) <= chr then
                        setDot(px + ix, py + iy, col)
                    end
                end
            end
        end
    end

    local function rasterize_line(px, py, px2, py2, col, width, linesInfo)
        local dx = math_abs(px2 - px)
        local dy = math_abs(py2 - py)
        local sx = (px < px2) and 1 or -1
        local sy = (py < py2) and 1 or -1
        local err = dx - dy
        local e2
        if width == -1 or width == 0 or width == 1 then
            for _ = 1, maxLineSize do
                checkSetDot(px, py, col)
                if px == px2 and py == py2 then
                    break
                end
                e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        elseif width < 0 then
            width = math_ceil((-width) / 2)
            if width < 1 then
                width = 1
            end
            for _ = 1, maxLineSize do
                rasterize_circleF(px, py, width, col)
                if px == px2 and py == py2 then
                    break
                end
                e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        else
            local offsetFill = math_floor(width / 2)
            for _ = 1, maxLineSize do
                rasterize_fill(px - offsetFill, py - offsetFill, width, width, col)
                if px == px2 and py == py2 then
                    break
                end
                e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        end
    end

    ------------------------------------------

    local function render_fill(stack, offset)
        local col = stack[offset+4]
        if direct_fill then
            direct_fill(directArg, stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
        else
            local x, y, x2, y2 = remathRect(offset, stack, maxX, maxY)
            if not x then return end
            --[[
            for ix = x, x2 do
                for iy = y, y2 do
                    setDot(ix, iy, col)
                end
            end
            ]]
            local ix, iy = x, y
            for _ = 1, ((y2 - y) + 1) * ((x2 - x) + 1) do
                setDot(ix, iy, col)
                iy = iy + 1
                if iy > y2 then
                    iy = y
                    ix = ix + 1
                end
            end
        end
    end

    local function render_rect(stack, offset)
        local x, y, x2, y2, w, h = remathRect(offset, stack, maxX, maxY)
        if not x then return end
        local col = stack[offset+4]
        local lineWidth = stack[offset+5]
        if lineWidth == 1 then
            for ix = x, x2 do
                setDot(ix, y, col)
                setDot(ix, y2, col)
            end

            for iy = y + 1, y2 - 1 do
                setDot(x, iy, col)
                setDot(x2, iy, col)
            end
        else
            local _y, _y2, _x, _x2
            for ioff = 0, math_min(lineWidth, math_max(w, h) / 2) - 1 do
                _y = y + ioff
                _y2 = y2 - ioff
                for ix = x + ioff, x2 - ioff do
                    setDot(ix, _y, col)
                    setDot(ix, _y2, col)
                end

                _x = x + ioff
                _x2 = x2 - ioff
                for iy = y + 1 + ioff, y2 - (1 + ioff) do
                    setDot(_x, iy, col)
                    setDot(_x2, iy, col)
                end
            end
        end
    end

    local function render_text(stack, offset)
        local tx, ty = stack[offset], stack[offset+1]
        local text = stack[offset+2]
        local col = stack[offset+3]
        local scaleX = stack[offset+4]
        local scaleY = stack[offset+5]
        local spacing = stack[offset+6]
        local fontIndex = stack[offset+7]
        local chrdata

        local localFont = currentFont
        local localFontWidth = fontWidth
        if fontIndex > 0 and fontsOptimized[fontIndex] then
            localFont = fontsOptimized[fontIndex]
            localFontWidth = localFont.width
        end

        local px, py
        local len, sep
        if utf8Support then
            len, sep = utf8_len, utf8_sub
        else
            len, sep = string_len, string_byte
        end
        local lposX, lposY
        local char, charOffset
        local setPosX
        local scaledFontWidth = math_ceil(localFontWidth * scaleX)
        if localFont.mono then
            for i = 1, len(text) do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    charOffset = (i - 1) * (scaledFontWidth + spacing)
                    for i2 = 1, #chrdata, 2 do
                        px, py = chrdata[i2], chrdata[i2 + 1]
                        lposX, lposY = round(px * scaleX), round(py * scaleY)
                        for ix = 0, math_min(sizeX, round((px + 1) * scaleX) - lposX - 1) do
                            setPosX = tx + ix + lposX + charOffset
                            for iy = 0, math_min(sizeY, round((py + 1) * scaleY) - lposY - 1) do
                                checkSetDot(setPosX, ty + iy + lposY, col)
                            end
                        end
                    end
                end
            end
        else
            charOffset = 0
            local charPos
            local startDrawTime = os_clock()
            for i = 1, len(text) do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    charPos = tx + charOffset
                    if not chrdata[0] or charPos + round(chrdata[0] * scaleX) > 0 then
                        if charPos > maxX then
                            goto endDraw
                        end
                        for i2 = 1, #chrdata, 2 do
                            px, py = chrdata[i2], chrdata[i2 + 1]
                            lposX, lposY = round(px * scaleX), round(py * scaleY)
                            for ix = 0, math_min(sizeX, round((px + 1) * scaleX) - lposX - 1) do
                                setPosX = tx + ix + lposX + charOffset
                                for iy = 0, math_min(sizeY, round((py + 1) * scaleY) - lposY - 1) do
                                    checkSetDot(setPosX, ty + iy + lposY, col)
                                end
                            end
                        end
                    end
                    charOffset = charOffset + (chrdata[0] and math_ceil(chrdata[0] * scaleX) or 0) + spacing
                else
                    charOffset = charOffset + (localFont.spaceSize or localFontWidth) + spacing
                end
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
        end
        ::endDraw::
    end

    local function render_line(stack, offset)
        rasterize_line(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4], stack[offset+5])
    end

    local function render_circle(stack, offset) --Michener’s Algorithm
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx, py + dy, col)
            checkSetDot(px + dy, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy, col)
            checkSetDot(px + dy, py - dx, col)
            checkSetDot(px + dx, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleE(stack, offset)
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx - 1, py + dy - 1, col)
            checkSetDot(px + dy - 1, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy - 1, col)
            checkSetDot(px + dy - 1, py - dx, col)
            checkSetDot(px + dx - 1, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleF(stack, offset)
        rasterize_circleF(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3])
    end

    local function render_circleVE(stack, offset) --drawCircleVeryEvenly
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local chr = e2*e2
        local col = stack[offset+3]
        local sx, sy, tempInt, tempBool

        e2 = math_min(e2, bigSide)
        for iy = 0, e2 do
            sy = iy + 0.5
            tempInt = stack[offset+4]
            for ix = e2, 0, -1 do
                sx = ix + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
        for ix = 0, e2 do
            sx = ix + 0.5
            tempInt = stack[offset+4]
            for iy = e2, 0, -1 do
                sy = iy + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
    end

    local function render_drawPoly(stack, offset, linesInfo)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local startDrawTime = os_clock()
        local _px = stack[offset+3]
        local _py = stack[offset+4]
        local px, py
        for i = 3, points, 2 do
            px = stack[offset+2+i]
            py = stack[offset+3+i]
            rasterize_line(_px, _py, px, py, col, width, linesInfo)
            _px = px
            _py = py
            if os_clock() - startDrawTime > MAX_DRAW_TIME then
                goto endDraw
            end
        end
        rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width, linesInfo)

        ::endDraw::
        return points
    end

    local function render_fillPoly(stack, offset)
        local linesInfo = {}
        local points = render_drawPoly(stack, offset, linesInfo)

        return points
    end

    function obj.pushStack(stack)
        local offset = 2
        local actionNum
        local addValue = 0
        local startDrawTime = os_clock()
        local idx
        while stack[offset] do
            actionNum = stack[offset-1]
            clearOnly = actionNum == 0
            addValue = 0

            if actionNum == 0 then
                newBufferBase = stack[offset]
                newBuffer = {}
                if direct_clear then
                    direct_clear(directArg, newBufferBase, changes)
                else
                    bufferChangedFrom = 0
                    bufferChangedTo = maxBuffer
                end
                updated = true
            elseif actionNum == resetViewportCodeID then
                viewportEnable = false
            elseif actionNum == -1 then
                viewportEnable = true
                viewport_x = stack[offset]
                viewport_y = stack[offset+1]
                viewport_sx = stack[offset+2]
                viewport_sy = stack[offset+3]
            elseif actionNum == 1 then
                --[[
                local px, py, col = stack[offset], stack[offset+1], stack[offset+2]
                if px >= 0 and py >= 0 and px < sizeX and py < sizeY then
                    local index
                    if rotation == 0 then
                        index = (py + (px * rSizeY)) + 1
                    elseif rotation == 1 then
                        index = ((rSizeY - px - 1) + (py * rSizeY)) + 1
                    elseif rotation == 2 then
                        index = ((rSizeY - py - 1) + ((rSizeX - px - 1) * rSizeY)) + 1
                    else
                        index = (px + ((rSizeX - py - 1) * rSizeY)) + 1
                    end

                    if newBuffer[index] ~= col then
                        if index < bufferChangedFrom then bufferChangedFrom = index end
                        if index > bufferChangedTo then bufferChangedTo = index end
                        newBuffer[index] = col
                        updated = true
                    end
                end
                ]]
                idx = stack[offset]
                setDot(idx % rSizeX, math_floor(idx / rSizeX), stack[offset+1])
                updated = true
            elseif actionNum == 2 then
                render_fill(stack, offset)
                updated = true
            elseif actionNum == 3 then
                render_rect(stack, offset)
                updated = true
            elseif actionNum == 4 then
                render_text(stack, offset)
                updated = true
            elseif actionNum == 5 then
                render_line(stack, offset)
                updated = true
            elseif actionNum == 6 then
                render_circle(stack, offset)
                updated = true
            elseif actionNum == 8 then
                render_circleE(stack, offset)
                updated = true
            elseif actionNum == 7 then
                render_circleF(stack, offset)
                updated = true
            elseif actionNum == 9 then
                render_circleVE(stack, offset)
                updated = true
            elseif actionNum == 10 then
                addValue = render_drawPoly(stack, offset)
                updated = true
            elseif actionNum == 11 then
                addValue = render_fillPoly(stack, offset)
                updated = true
            elseif userCalls[actionNum] then
                --if sm.sc_g.freezeDetector("userCalls", userCalls[actionNum], newBuffer, rotation, rSizeX, rSizeY, sizeX, sizeY, stack, offset, drawerData, bufferRangeUpdate) then
                if userCalls[actionNum](newBuffer, rotation, rSizeX, rSizeY, sizeX, sizeY, stack, offset, drawerData, bufferRangeUpdate, setDot, checkSetDot) then
                    updated = true
                end
            end

            if os_clock() - startDrawTime > MAX_DRAW_TIME then
                goto endDraw
            end

            offset = offset + dataSizes[actionNum] + addValue
        end

        ::endDraw::
    end

    function obj.flush(force)
        if not obj.wait and (updated or force) then
            if force then
                bufferChangedFrom = 0
                bufferChangedTo = maxBuffer
            end
            if callbackBefore then
                if callbackBefore(newBufferBase, clearOnly, maxBuffer, force, newBuffer, realBuffer, bufferChangedFrom, bufferChangedTo, changes, changesIndex, changesCount, _changes) then
                    realBuffer = {}
                end
            end
            if callback then
                --[[
                local color
                local nextCount = 0
                local px, py = 0, 0
                local i = 1
                local li = 0
                local m
                while i <= maxBuffer do
                    color = newBuffer[i] or newBufferBase
                    if color ~= realBuffer[i] or force then
                        px = (i - 1) % rSizeX
                        py = math_floor((i - 1) / rSizeX)
                        nextCount = rSizeX
                        for i2 = 1, rSizeX - 1 do
                            m = i + i2
                            if (m - 1) % rSizeX == 0 or (newBuffer[m] or newBufferBase) ~= color then
                                nextCount = i2
                                break
                            end
                        end
                        li = 0
                        while nextCount > 0 do
                            if callback(px + li, py, color, newBufferBase, nextCount) then
                                while nextCount > 0 do
                                    realBuffer[i] = color
                                    i = i + 1
                                    nextCount = nextCount - 1
                                end
                                break
                            end
                            nextCount = nextCount - 1
                            realBuffer[i] = color
                            li = li + 1
                            i = i + 1
                        end
                    else
                        i = i + 1
                    end
                end
                ]]
                local color, px, py
                for i = bufferChangedFrom, bufferChangedTo do
                    color = newBuffer[i] or newBufferBase
                    if color ~= realBuffer[i] or force then
                        px = math_floor(i / rSizeY)
                        py = i % rSizeY
                        callback(px, py, color, newBufferBase)
                        realBuffer[i] = color
                    end
                end
            end
            bufferChangedFrom = huge
            bufferChangedTo = -huge
            updated = false
            if updatedList then
                changes = {}
                changesIndex = {}
                changesCount = 0
            end
        end
    end

    function obj.setWait(state)
        obj.wait = state
        if not state then
            obj.flush()
        end
    end

    function obj.getNewBuffer(i)
        return newBuffer[i] or newBufferBase
    end

    function obj.getRealBuffer(i)
        return realBuffer[i]
    end

    function obj.getChanges()
        return changes
    end

    function obj.fullRefresh()
        changesCount = 0
        changesIndex = {}
        for i = 0, (sizeX * sizeY) - 1 do
            changes[i] = true
            changesCount = changesCount + 1
            changesIndex[changesCount] = i
        end
    end

    function obj.flushOldChanges()
        _changes = changes
    end

    return obj
end

if better and better.isAvailable() and better.canvas and better.version >= 40 then
    local better_canvas_clear = better.canvas.clear
    local better_canvas_fill = better.canvas.fill
    local better_canvas_set = better.canvas.set

    function canvasAPI.createBetterCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation)
        local hiddenOffset = vec3_new(1000000, 1000000, 1000000)
        local obj = {sizeX = sizeX, sizeY = sizeY}
        local maxX, maxY = sizeX - 1, sizeY - 1
        local maxEffectArrayBuffer = maxX + (maxY * sizeX)
        local dist
        local needOptimize = false
        local showState = false
        local disable = false
        local flushedDefault = false

        local betterCanvas = better.canvas.create(sizeX, sizeY)

        local drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, nil, betterCanvas, better_canvas_clear, better_canvas_fill, better_canvas_set)
        drawer.setWait(true)

        local function getSelfPos()
            local pt = type(parent)
            if pt == "Interactable" then
                return parent.shape.worldPosition
            elseif pt == "Character" then
                return parent.worldPosition
            end
        end

        function obj.isRendering()
            return showState
        end

        function obj.disable(state)
            disable = state
        end

        function obj.setRenderDistance(_dist)
            dist = _dist
        end

        function obj.update()
            local newShowState = true
            local selfPosition
            if disable then
                newShowState = false
            elseif dist then
                if not pcall(function()
                    selfPosition = getSelfPos()
                    newShowState = mathDist(selfPosition, sm_localPlayer_getPlayer().character.worldPosition) <= dist
                end) then
                    selfPosition = selfPosition or vec3_new(0, 0, 0)
                    newShowState = false
                end
            end

            if newShowState ~= showState then
                showState = newShowState
                if newShowState then
                    drawer.setWait(false)
                    if not flushedDefault then
                        drawer.flush(true)
                        flushedDefault = true
                    end
                else
                    drawer.setWait(true)
                    better.canvas.stopUpdate(betterCanvas)
                end
            end

            if newShowState then
                better.canvas.update_3d(betterCanvas, selfPosition + (rotation * offset), -sm.quat.getRight(rotation), -sm.quat.getUp(rotation), (pixelSize.x * sizeX) / 2, (pixelSize.y * sizeY) / 2)
            end
        end

        function obj.setPixelSize(_pixelSize)
            pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
            if type(pixelSize) == "number" then
                if pixelSize < 0 then
                    pixelSize = math_abs(pixelSize)
                    local vec = vec3_new(pixelSize, pixelSize, 0)
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                else
                    local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                end
            end
        end

        function obj.setOffset(_offset)
            offset = _offset
        end

        function obj.setCanvasRotation(_rotation)
            rotation = _rotation
        end

        function obj.destroy()
            better.canvas.destroy(betterCanvas)
        end

        ---------------------------------------

        obj.setPixelSize(pixelSize)
        obj.setCanvasRotation(rotation or quat_fromEuler(vec3_new(0, 0, 0)))
        obj.setOffset(offset or vec3_new(0, 0, 0))

        --[[
        local c = 0xff0000
        local seffect = createEffect(5, 5, 16, 16, c)
        local idx = 5 + (5 * sizeX)
        for i = 0, 16 - 1 do
            effects[idx + i] = {
                seffect,
                c,
                i,
                16,
                idx,
                5,
                5,
                1, --8. sizeY
                0 --9. indexY
            }
        end
        ]]

        ---------------------------------------

        obj.drawer = drawer
        for k, v in pairs(drawer) do
            obj[k] = v
        end

        return obj
    end
end

--low level display api
function canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material, scaleAddValue)
    local hiddenOffset = vec3_new(1000000, 1000000, 1000000)
    local obj = {sizeX = sizeX, sizeY = sizeY}
    local maxX, maxY = sizeX - 1, sizeY - 1
    local maxEffectArrayBuffer = maxX + (maxY * sizeX)
    local dist
    local needOptimize = false
    local showState = false
    local disable = false
    local colorCache = {}

    material = material or canvasAPI.material.classic
    local autoScaleAddValue = false
    if not scaleAddValue then
        autoScaleAddValue = true
    end

    local flushedDefault = false
    local oldBackplateColor
    local backplate
    if canvasAPI.multi_layer[tostring(material)] then
        oldBackplateColor = 0
        backplate = sm_effect_createEffect(getEffectName(), parent)
        effect_setParameter(backplate, "uuid", material)
        effect_setParameter(backplate, "color", black)
    end

    local effects = {}
    local nodeEffects = {}
    local bufferedEffects = {}
    local bufferedEffectsIndex = 0
    local lastDrawTickTime
    local optimizationLevel = 16
    local alpha = DEFAULT_ALPHA_VALUE

    local function setEffectDataParams(effectData)
        local effect, posX, posY, lSizeX, lSizeY = effectData[1], effectData[3], effectData[4], effectData[5], effectData[6]

        posX = posX + ((lSizeX - 1) * 0.5)
        posY = posY + ((lSizeY - 1) * 0.5)
        effect_setOffsetPosition(effect, rotation * (offset + vec3_new(((posX + 0.5) - (sizeX / 2)) * pixelSize.x, ((posY + 0.5) - (sizeY / 2)) * -pixelSize.y, backplate and (debugMode and 0.05 or 0.001) or 0)))

        local localScaleAddValue = debugMode and -(pixelSize.x / 2) or scaleAddValue
        local vec = pixelSize * 1
        vec.x = (pixelSize.x * lSizeX) + localScaleAddValue
        vec.y = (pixelSize.y * lSizeY) + localScaleAddValue
        effect_setScale(effect, vec)
    end

    local function createEffect()
        --[[
        local endX = x + (sizeX - 1)
        if endX > maxX then
            print(x, y, sizeX, sizeY, tostring(color_new_fromSmallNumber(color)))
            error("outside effect create")
        end
        ]]

        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            effect_setOffsetRotation(effect, rotation)
        end
        return effect
    end

    local function clearBufferedEffects()
        for i = 1, bufferedEffectsIndex do
            effect_destroy(bufferedEffects[i])
        end
        bufferedEffects = {}
        bufferedEffectsIndex = 0
    end

    local lastNewBuffer, lastBase

    local lastPopularColorTick, lastPopularColor
    local lastPopularColorUpdatePerTick = (sizeX * sizeY) / 256
    local function mathPopularColor()
        local oldLastPopularColor = lastPopularColor

        local colorUsesTable = {}
        local colorUses = 0
        local oldColorUses = 0
        local colorSum = 0
        for _, effectData in pairs(nodeEffects) do
            local color = effectData[2]
            local colorSize = effectData[5] * effectData[6]
            colorUsesTable[color] = (colorUsesTable[color] or 0) + colorSize
            colorSum = colorSum + colorSize
            colorUses = colorUsesTable[color]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = color
            end
        end

        if oldBackplateColor then
            local colorSize = (sizeX * sizeY) - colorSum
            colorUsesTable[oldBackplateColor] = (colorUsesTable[oldBackplateColor] or 0) + colorSize
            colorSum = colorSum + colorSize
            colorUses = colorUsesTable[oldBackplateColor]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = oldBackplateColor
            end
        end

        if oldLastPopularColor and colorUses < 32 then
            lastPopularColor = oldLastPopularColor
        else
            lastPopularColorTick = sm.game.getCurrentTick()
        end
    end

    local function effectIndexAtPos(px, py)
        return py + (px * sizeY)
    end

    local function getEffectDataAtPos(px, py)
        if py < 0 or py >= sizeY then return end
        return effects[effectIndexAtPos(px, py)]
    end

    local function clearEffectFromBuffer(effectData)
        local six, ix, iy = effectData[3], effectData[3], effectData[4]
        local sizeX, sizeY = effectData[5], effectData[6]
        nodeEffects[effectData[7]] = nil
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix >= six + sizeX then
                ix = six
                iy = iy + 1
            end
        end
    end

    local function hideEffect(effect, hideList)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        if hideList then
            hideList[effect.id] = effect
        else
            effect_setOffsetPosition(effect, hiddenOffset)
        end
    end

    local function hideEffectData(effectData, hideList)
        hideEffect(effectData[1], hideList)
        clearEffectFromBuffer(effectData)
    end

    local function hideEffectsWithColor(color)
        for i, effectData in pairs(nodeEffects) do
            if effectData[2] == color then
                hideEffectData(effectData)
            end
        end
    end

    local function delAllEffects()
        for _, effectData in pairs(nodeEffects) do
            effect_destroy(effectData[1])
        end
        effects = {}
        nodeEffects = {}
    end

    local function extractVerticleLine(changedList, changedColorList, index, px, py, saveExtractionPixel)
        local effectData = effects[index]
        local lx = px - effectData[3]
        local rpx, rpy = effectData[3], effectData[4]
        if lx == 0 then --extract first line
            if saveExtractionPixel then
                local newEffectData = {
                    createEffect(),
                    effectData[2],
                    rpx,
                    rpy,
                    1,
                    effectData[6],
                    effectData[7]
                }
                for i = 0, newEffectData[6] - 1 do
                    effects[newEffectData[7] + i] = newEffectData
                end
                nodeEffects[newEffectData[7]] = newEffectData
                changedList[newEffectData] = true
                changedColorList[newEffectData[1]] = newEffectData
            else
                for i = 0, effectData[6] - 1 do
                    effects[effectData[7] + i] = nil
                end
                nodeEffects[effectData[7]] = nil
            end

            effectData[7] = effectData[7] + sizeY
            nodeEffects[effectData[7]] = effectData
            effectData[3] = effectData[3] + 1
            effectData[5] = effectData[5] - 1
            changedList[effectData] = true
        elseif lx == effectData[5] - 1 then --extract last line
            local rootIndex = effectIndexAtPos(px, rpy)
            if saveExtractionPixel then
                local newEffectData = {
                    createEffect(),
                    effectData[2],
                    px,
                    rpy,
                    1,
                    effectData[6],
                    rootIndex
                }
                nodeEffects[rootIndex] = newEffectData
                for i = 0, newEffectData[6] - 1 do
                    effects[rootIndex + i] = newEffectData
                end
                changedList[newEffectData] = true
                changedColorList[newEffectData[1]] = newEffectData
            else
                for i = 0, effectData[6] - 1 do
                    effects[rootIndex + i] = nil
                end
            end

            effectData[5] = effectData[5] - 1
            changedList[effectData] = true
        else --extract center line
            local endPartIndex = px + 1
            local newEffectData = { --end part
                createEffect(),
                effectData[2],
                endPartIndex,
                rpy,
                effectData[5] - lx - 1,
                effectData[6],
                effectIndexAtPos(endPartIndex, rpy)
            }
            nodeEffects[newEffectData[7]] = newEffectData
            local ix, iy = 0, 0
            local sizeX, sizeY = newEffectData[5], newEffectData[6]
            for _ = 1, sizeX * sizeY do
                effects[effectIndexAtPos(endPartIndex + ix, rpy + iy)] = newEffectData
                ix = ix + 1
                if ix >= sizeX then
                    ix = 0
                    iy = iy + 1
                end
            end
            --[[
            for iy = 0, newEffectData[6] - 1 do
                for i = 0, newEffectData[5] - 1 do
                    effects[effectIndexAtPos(endPartIndex + i, rpy + iy)] = newEffectData
                end
            end
            ]]
            changedList[newEffectData] = true
            changedColorList[newEffectData[1]] = newEffectData

            effectData[5] = lx --first part
            changedList[effectData] = true

            local rootIndex = effectIndexAtPos(px, rpy)
            if saveExtractionPixel then
                newEffectData = { --center part
                    createEffect(),
                    effectData[2],
                    px,
                    rpy,
                    1,
                    effectData[6],
                    rootIndex
                }
                nodeEffects[rootIndex] = newEffectData
                for i = 0, newEffectData[6] - 1 do
                    effects[rootIndex + i] = newEffectData
                end
                changedList[newEffectData] = true
                changedColorList[newEffectData[1]] = newEffectData
            else
                for i = 0, effectData[6] - 1 do
                    effects[rootIndex + i] = nil
                end
            end
        end
    end

    local function extractVerticlePixel(changedList, changedColorList, index, px, py, saveExtractionPixel)
        local effectData = effects[index]
        local ly = py - effectData[4]
        if ly == 0 then --extract first pixel
            if saveExtractionPixel then
                local newEffectData = {
                    createEffect(),
                    nil,
                    px,
                    py,
                    1,
                    1,
                    effectData[7]
                }
                effects[newEffectData[7]] = newEffectData
                nodeEffects[newEffectData[7]] = newEffectData
                changedList[newEffectData] = true
            else
                effects[effectData[7]] = nil
                nodeEffects[effectData[7]] = nil
            end

            effectData[7] = effectData[7] + 1
            effectData[4] = effectData[4] + 1
            effectData[6] = effectData[6] - 1
            nodeEffects[effectData[7]] = effectData
            changedList[effectData] = true
        elseif ly == effectData[6] - 1 then --extract last pixel
            local rootIndex = effectData[7] + ly
            if saveExtractionPixel then
                local newEffectData = {
                    createEffect(),
                    nil,
                    px,
                    py,
                    1,
                    1,
                    rootIndex
                }
                effects[rootIndex] = newEffectData
                nodeEffects[rootIndex] = newEffectData
                changedList[newEffectData] = true
            else
                effects[rootIndex] = nil
                nodeEffects[rootIndex] = nil
            end

            effectData[6] = effectData[6] - 1
            changedList[effectData] = true
        else --extract center pixel
            local newEffectData = { --end part
                createEffect(),
                effectData[2],
                px,
                py + 1,
                1,
                effectData[6] - ly - 1,
                effectIndexAtPos(px, py + 1)
            }
            nodeEffects[newEffectData[7]] = newEffectData
            for i = 1, newEffectData[6] do
                effects[effectData[7] + ly + i] = newEffectData
            end
            changedList[newEffectData] = true
            changedColorList[newEffectData[1]] = newEffectData

            effectData[6] = ly --first part
            changedList[effectData] = true

            local rootIndex = effectData[7] + ly
            if saveExtractionPixel then
                newEffectData = { --center part
                    createEffect(),
                    nil,
                    px,
                    py,
                    1,
                    1,
                    rootIndex
                }
                effects[rootIndex] = newEffectData
                nodeEffects[rootIndex] = newEffectData
                changedList[newEffectData] = true
            else
                effects[rootIndex] = nil
                nodeEffects[rootIndex] = nil
            end
        end
    end

    local function colorEquals_smart(color1, color2)
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        local rDelta = math_abs(rVal - rVal2)
        local gDelta = math_abs(gVal - gVal2)
        local bDelta = math_abs(bVal - bVal2)
        return rDelta + gDelta + bDelta <= optimizationLevel
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    local function tryAttach(changedList, index, px, py, color, hideList)
        --[[
        local origEffectData = effects[index]
        local rpx, rpy = px, py
        local currentSizeX = 1
        local currentSizeY = 1
        if origEffectData then
            index = origEffectData[7]
            rpx, rpy = origEffectData[3], origEffectData[4]
            currentSizeX = origEffectData[5]
            currentSizeY = origEffectData[6]
        end
        
        local upParent = getEffectDataAtPos(rpx, rpy - 1)
        local downParent = getEffectDataAtPos(rpx, rpy + currentSizeY)
        local upAvailable = upParent and upParent[3] == rpx and upParent[5] == currentSizeX and colorEquals(upParent[2], color)
        local downAvailable = downParent and downParent[3] == rpx and downParent[5] == currentSizeX and colorEquals(downParent[2], color)
        local fillObj
        if upAvailable and downAvailable then
            --[[
            for ix = 0, currentSizeX - 1 do
                for i = 0, downParent[6] - 1 do
                    effects[downParent[7] + i + (ix * sizeY)] = upParent
                end
            end
            ] ]
            local ix1, iy1 = 0, 0
            local ix2, iy2 = currentSizeX - 1, downParent[6] - 1
            local ix, iy = ix1, iy1
            for _ = 1, ((ix2 - ix1) + 1) * ((iy2 - iy1) + 1) do
                effects[downParent[7] + iy + (ix * sizeY)] = upParent
                ix = ix + 1
                if ix > ix2 then
                    ix = ix1
                    iy = iy + 1
                end
            end

            upParent[6] = upParent[6] + currentSizeY + downParent[6]
            fillObj = upParent
            changedList[upParent] = true

            changedList[downParent] = nil
            hideEffect(downParent[1])
        elseif upAvailable then
            upParent[6] = upParent[6] + currentSizeY
            fillObj = upParent

            changedList[upParent] = true
        elseif downAvailable then
            downParent[6] = downParent[6] + currentSizeY
            downParent[7] = downParent[7] - currentSizeY
            downParent[4] = downParent[4] - currentSizeY
            fillObj = downParent

            changedList[downParent] = true
        end

        if fillObj then
            if origEffectData then
                changedList[origEffectData] = nil
                hideEffect(origEffectData[1])
            end

            --[[
            for ix = 0, currentSizeX - 1 do
                for i = index, index + (currentSizeY - 1) do
                    effects[i + (ix * sizeY)] = fillObj
                end
            end
            ] ]
            local ix1, iy1 = 0, index
            local ix2, iy2 = currentSizeX - 1, index + (currentSizeY - 1)
            local ix, iy = ix1, iy1
            for _ = 1, ((ix2 - ix1) + 1) * ((iy2 - iy1) + 1) do
                effects[iy + (ix * sizeY)] = fillObj
                ix = ix + 1
                if ix > ix2 then
                    ix = ix1
                    iy = iy + 1
                end
            end

            index = fillObj[7]
            rpx, rpy = fillObj[3], fillObj[4]
            currentSizeX = fillObj[5]
            currentSizeY = fillObj[6]
        end

        local leftParent = getEffectDataAtPos(rpx - 1, rpy)
        local rightParent = getEffectDataAtPos(rpx + currentSizeX, rpy)
        local leftAvailable = leftParent and leftParent[4] == rpy and leftParent[6] == currentSizeY and colorEquals(leftParent[2], color)
        local rightAvailable = rightParent and rightParent[4] == rpy and rightParent[6] == currentSizeY and colorEquals(rightParent[2], color)
        local fillObj2

        if leftAvailable and rightAvailable then
            local ix1, iy1 = 0, 0
            local ix2, iy2 = rightParent[5] - 1, rightParent[6] - 1
            local ix, iy = ix1, iy1
            for _ = 1, ((ix2 - ix1) + 1) * ((iy2 - iy1) + 1) do
                effects[rightParent[7] + iy + (ix * sizeY)] = leftParent
                ix = ix + 1
                if ix > ix2 then
                    ix = ix1
                    iy = iy + 1
                end
            end

            leftParent[5] = leftParent[5] + currentSizeX + rightParent[5]
            fillObj2 = leftParent
            changedList[leftParent] = true

            changedList[rightParent] = nil
            hideEffect(rightParent[1])
        elseif leftAvailable then
            leftParent[5] = leftParent[5] + currentSizeX
            fillObj2 = leftParent

            changedList[leftParent] = true
        elseif rightAvailable then
            rightParent[5] = rightParent[5] + currentSizeX
            rightParent[3] = rightParent[3] - currentSizeX
            rightParent[7] = effectIndexAtPos(rightParent[3], rightParent[4])
            fillObj2 = rightParent

            changedList[rightParent] = true
        end

        if fillObj2 then
            origEffectData = effects[index]
            if origEffectData then
                changedList[origEffectData] = nil
                hideEffect(origEffectData[1])
            end

            --[[
            for ix = 0, currentSizeX - 1 do
                for i = index, index + (currentSizeY - 1) do
                    effects[i + (ix * sizeY)] = fillObj2
                end
            end
            ] ]

            local ix1, iy1 = 0, index
            local ix2, iy2 = currentSizeX - 1, index + (currentSizeY - 1)
            local ix, iy = ix1, iy1
            for _ = 1, ((ix2 - ix1) + 1) * ((iy2 - iy1) + 1) do
                effects[iy + (ix * sizeY)] = fillObj2
                ix = ix + 1
                if ix > ix2 then
                    ix = ix1
                    iy = iy + 1
                end
            end
        end

        return fillObj or fillObj2
        ]]

        --[[
        local origEffectData = effects[index]
        if origEffectData then
            px, py, index = origEffectData[3], origEffectData[4], attached[7]
            local upParent = getEffectDataAtPos(px, py - 1)
            local downParent = getEffectDataAtPos(px, py + origEffectData[6])
            local upAvailable = upParent and upParent[3] == px and upParent[5] == origEffectData[5] and colorEquals(upParent[2], origEffectData[2])
            local downAvailable = downParent and downParent[3] == px and downParent[5] == origEffectData[5] and colorEquals(downParent[2], origEffectData[2])

            if upAvailable and downAvailable and false then
                
            elseif upAvailable then
                hideEffect(upParent[1])
                changedList[upParent] = nil
                
                upParent[6] = upParent[6] + 1
            elseif downAvailable and false then
                
            end
        else
        ]]

        --[[
        local attached
        local origEffectData = effects[index]
        if origEffectData then --bug
            px, py, index = origEffectData[3], origEffectData[4], origEffectData[7] 
            local vSize = origEffectData[6]
            
            local upParent = getEffectDataAtPos(px, py - 1)
            local downParent = getEffectDataAtPos(px, py + vSize)
            local upAvailable = upParent and upParent[3] == px and upParent[5] == origEffectData[5] and colorEquals(upParent[2], color)
            local downAvailable = downParent and downParent[3] == px and downParent[5] == origEffectData[5] and colorEquals(downParent[2], color)
            
            local currentEffect = origEffectData
            if upAvailable and downAvailable then
                hideEffect(origEffectData[1], hideList)
                changedList[origEffectData] = nil
                nodeEffects[downParent[7] ] = nil

                upParent[6] = upParent[6] + vSize + downParent[6]
                changedList[upParent] = true

                local ix1, iy1 = px, py
                local ix2, iy2 = px + (origEffectData[5] - 1), py + ((vSize + downParent[6]) - 1)
                local ix, iy = ix1, iy1
                for _ = 1, ((ix2 - ix1) + 1) * ((iy2 - iy1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = upParent
                    ix = ix + 1
                    if ix > ix2 then
                        ix = ix1
                        iy = iy + 1
                    end
                end
                hideEffect(downParent[1], hideList)
                changedList[downParent] = nil
                attached = true
                currentEffect = upParent
            elseif upAvailable then
                hideEffect(origEffectData[1], hideList)
                changedList[origEffectData] = nil

                upParent[6] = upParent[6] + vSize
                local ix1, iy1 = px, py
                local ix2, iy2 = px + (origEffectData[5] - 1), py + (vSize - 1)
                local ix, iy = ix1, iy1
                for _ = 1, ((ix2 - ix1) + 1) * ((iy2 - iy1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = upParent
                    ix = ix + 1
                    if ix > ix2 then
                        ix = ix1
                        iy = iy + 1
                    end
                end
                changedList[upParent] = true
                attached = true
                currentEffect = upParent
            elseif downAvailable then
                hideEffect(origEffectData[1], hideList)
                changedList[origEffectData] = nil

                nodeEffects[downParent[7] ] = nil
                downParent[7] = index
                downParent[4] = downParent[4] - vSize
                downParent[6] = downParent[6] + vSize
                local ix1, iy1 = px, py
                local ix2, iy2 = px + (origEffectData[5] - 1), py + (vSize - 1)
                local ix, iy = ix1, iy1
                for _ = 1, ((ix2 - ix1) + 1) * ((iy2 - iy1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = downParent
                    ix = ix + 1
                    if ix > ix2 then
                        ix = ix1
                        iy = iy + 1
                    end
                end
                nodeEffects[index] = downParent
                changedList[downParent] = true
                attached = true
                currentEffect = downParent
            end

            px, py, index = currentEffect[3], currentEffect[4], currentEffect[7]
            vSize = currentEffect[6]
            local hSize = currentEffect[5]

            local leftParent = getEffectDataAtPos(px - 1, py)
            local rightParent = getEffectDataAtPos(px + hSize, py)
            local leftAvailable = leftParent and leftParent[4] == py and leftParent[6] == vSize and colorEquals(leftParent[2], color)
            local rightAvailable = rightParent and rightParent[4] == py and rightParent[6] == vSize and colorEquals(rightParent[2], color)

            if leftAvailable and rightAvailable then
                hideEffect(currentEffect[1], hideList)
                changedList[currentEffect] = nil
                nodeEffects[rightParent[7] ] = nil

                leftParent[5] = leftParent[5] + hSize + rightParent[5]
                changedList[leftParent] = true

                local ix1, iy1 = px, py
                local ix2, iy2 = px + ((hSize + rightParent[5]) - 1), py + (vSize - 1)
                local ix, iy = ix1, iy1
                for _ = 1, ((ix2 - ix1) + 1) * ((iy2 - iy1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = leftParent
                    ix = ix + 1
                    if ix > ix2 then
                        ix = ix1
                        iy = iy + 1
                    end
                end
                hideEffect(rightParent[1], hideList)
                changedList[rightParent] = nil
            elseif leftAvailable then
                hideEffect(currentEffect[1], hideList)
                changedList[currentEffect] = nil

                leftParent[5] = leftParent[5] + hSize
                local ix1, iy1 = px, py
                local ix2, iy2 = px + (hSize - 1), py + (vSize - 1)
                local ix, iy = ix1, iy1
                for _ = 1, ((ix2 - ix1) + 1) * ((iy2 - iy1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = leftParent
                    ix = ix + 1
                    if ix > ix2 then
                        ix = ix1
                        iy = iy + 1
                    end
                end
                changedList[leftParent] = true
            elseif rightAvailable then
                hideEffect(currentEffect[1], hideList)
                changedList[currentEffect] = nil

                nodeEffects[rightParent[7] ] = nil
                rightParent[7] = index
                rightParent[3] = px
                rightParent[5] = rightParent[5] + hSize
                local ix1, iy1 = px, py
                local ix2, iy2 = px + (hSize - 1), py + (vSize - 1)
                local ix, iy = ix1, iy1
                for _ = 1, ((ix2 - ix1) + 1) * ((iy2 - iy1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = rightParent
                    ix = ix + 1
                    if ix > ix2 then
                        ix = ix1
                        iy = iy + 1
                    end
                end
                nodeEffects[index] = rightParent
                changedList[rightParent] = true
            end

            return attached
        end

        local upParent = getEffectDataAtPos(px, py - 1)
        local downParent = getEffectDataAtPos(px, py + 1)
        local upAvailable = upParent and upParent[3] == px and upParent[5] == 1 and colorEquals(upParent[2], color)
        local downAvailable = downParent and downParent[3] == px and downParent[5] == 1 and colorEquals(downParent[2], color)

        if upAvailable and downAvailable then
            nodeEffects[downParent[7] ] = nil

            upParent[6] = upParent[6] + 1 + downParent[6]
            effects[index] = upParent
            changedList[upParent] = true

            for i = downParent[7], downParent[7] + (downParent[6] - 1) do
                effects[i] = upParent
            end
            hideEffect(downParent[1])
            changedList[downParent] = nil
            attached = upParent
        elseif upAvailable then
            upParent[6] = upParent[6] + 1
            effects[index] = upParent
            changedList[upParent] = true
            attached = upParent
        elseif downAvailable then
            nodeEffects[downParent[7] ] = nil
            downParent[7] = index
            downParent[4] = downParent[4] - 1
            downParent[6] = downParent[6] + 1
            effects[index] = downParent
            nodeEffects[index] = downParent
            changedList[downParent] = true
            attached = downParent
        end

        if attached then
            px, py, index = attached[3], attached[4], attached[7]
            local verticleSize = attached[6]

            local leftParent = getEffectDataAtPos(px - 1, py)
            local rightParent = getEffectDataAtPos(px + 1, py)
            local leftAvailable = leftParent and leftParent[4] == py and leftParent[6] == verticleSize and colorEquals(leftParent[2], color)
            local rightAvailable = rightParent and rightParent[4] == py and rightParent[6] == verticleSize and colorEquals(rightParent[2], color)

            if leftAvailable and rightAvailable then --bug
                nodeEffects[rightParent[7] ] = nil

                hideEffect(attached[1])
                changedList[attached] = nil

                leftParent[5] = leftParent[5] + 1 + rightParent[5]
                changedList[leftParent] = true

                local ix1, iy1 = rightParent[3] - 1, py
                local ix2, iy2 = rightParent[3] + (rightParent[5] - 1), py + (verticleSize - 1)
                local ix, iy = ix1, iy1
                for _ = 1, ((ix2 - ix1) + 1) * ((iy2 - iy1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = leftParent
                    ix = ix + 1
                    if ix > ix2 then
                        ix = ix1
                        iy = iy + 1
                    end
                end
                hideEffect(rightParent[1])
                changedList[rightParent] = nil
            elseif leftAvailable then
                hideEffect(attached[1])
                changedList[attached] = nil

                nodeEffects[index] = nil
                leftParent[5] = leftParent[5] + 1
                changedList[leftParent] = true
                for i = py, py + (verticleSize - 1) do
                    effects[effectIndexAtPos(px, i)] = leftParent
                end
            elseif rightAvailable then
                hideEffect(attached[1])
                changedList[attached] = nil

                nodeEffects[rightParent[7] ] = nil
                rightParent[7] = index
                rightParent[3] = rightParent[3] - 1
                rightParent[5] = rightParent[5] + 1
                nodeEffects[index] = rightParent
                for i = py, py + (verticleSize - 1) do
                    effects[effectIndexAtPos(px, i)] = rightParent
                end
                changedList[rightParent] = true
            end
        else
            local leftParent = getEffectDataAtPos(px - 1, py)
            local rightParent = getEffectDataAtPos(px + 1, py)
            local leftAvailable = leftParent and leftParent[4] == py and leftParent[6] == 1 and colorEquals(leftParent[2], color)
            local rightAvailable = rightParent and rightParent[4] == py and rightParent[6] == 1 and colorEquals(rightParent[2], color)

            if leftAvailable and rightAvailable then
                nodeEffects[rightParent[7] ] = nil

                leftParent[5] = leftParent[5] + 1 + rightParent[5]
                effects[index] = leftParent
                changedList[leftParent] = true

                for i = rightParent[3], rightParent[3] + (rightParent[5] - 1) do
                    effects[effectIndexAtPos(i, py)] = leftParent
                end
                hideEffect(rightParent[1])
                changedList[rightParent] = nil
                attached = true
            elseif leftAvailable then
                nodeEffects[index] = nil
                leftParent[5] = leftParent[5] + 1
                effects[index] = leftParent
                changedList[leftParent] = true
                attached = true
            elseif rightAvailable then
                nodeEffects[rightParent[7] ] = nil
                rightParent[7] = index
                rightParent[3] = rightParent[3] - 1
                rightParent[5] = rightParent[5] + 1
                effects[index] = rightParent
                nodeEffects[index] = rightParent
                changedList[rightParent] = true
                attached = true
            end
        end

        return attached
        ]]

        local attached

        local origEffectData = effects[index]
        local sizeX, sizeY = 1, 1
        if origEffectData then
            index, px, py = origEffectData[7], origEffectData[3], origEffectData[4]
            sizeX, sizeY = origEffectData[5], origEffectData[6]
        end

        local fillX1, fillX2, fillY1, fillY2 = px, px, py, py
        local function updateFillbox(x, y)
            if x < fillX1 then
                fillX1 = x
            elseif x > fillX2 then
                fillX2 = x
            end

            if y < fillY1 then
                fillY1 = y
            elseif y > fillY2 then
                fillY2 = y
            end
        end

        local upParent = getEffectDataAtPos(px, py - 1)
        local downParent = getEffectDataAtPos(px, py + sizeY)
        local upAvailable = upParent and upParent[3] == px and upParent[5] == sizeX and colorEquals(upParent[2], color)
        local downAvailable = downParent and downParent[3] == px and downParent[5] == sizeX and colorEquals(downParent[2], color)

        if upAvailable and downAvailable and false then
            nodeEffects[downParent[7]] = nil
            hideEffect(downParent[1], hideList)
            changedList[downParent] = nil

            upParent[6] = upParent[6] + sizeY + downParent[6]
            updateFillbox(px + (sizeX - 1), py + ((sizeY + downParent[6]) - 1))
            attached = upParent
        elseif upAvailable and false then
            upParent[6] = upParent[6] + sizeY
            updateFillbox(px + (sizeX - 1), py + (sizeY - 1))
            attached = upParent
        elseif downAvailable and false then
            nodeEffects[downParent[7]] = nil
            downParent[7] = index
            downParent[4] = py
            downParent[6] = downParent[6] + sizeY
            updateFillbox(px + (sizeX - 1), py + (sizeY - 1))
            nodeEffects[index] = downParent
            attached = downParent
        end

        if attached then
            index, px, py = attached[7], attached[3], attached[4]
            sizeX, sizeY = attached[5], attached[6]
        end

        local leftParent = getEffectDataAtPos(px - 1, py)
        local rightParent = getEffectDataAtPos(px + sizeX, py)
        local leftAvailable = leftParent and leftParent[4] == py and leftParent[6] == sizeY and colorEquals(leftParent[2], color)
        local rightAvailable = rightParent and rightParent[4] == py and rightParent[6] == sizeY and colorEquals(rightParent[2], color)
        
        if leftAvailable and false then
            if attached then
                hideEffect(attached[1], hideList)
                changedList[attached] = nil
            end
            leftParent[5] = leftParent[5] + sizeX
            updateFillbox(px, py)
            updateFillbox(px + (sizeX - 1), py + (sizeY - 1))
            attached = leftParent
        elseif rightAvailable and false then
            if attached then
                hideEffect(attached[1], hideList)
                changedList[attached] = nil
            end
            rightParent[3] = rightParent[3] - sizeX
            rightParent[5] = rightParent[5] + sizeX
            updateFillbox(px, py)
            updateFillbox(px + (sizeX - 1), py + (sizeY - 1))
            attached = rightParent
        end

        if attached then
            changedList[attached] = true
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = attached
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            if origEffectData then
                hideEffect(origEffectData[1], hideList)
                changedList[origEffectData] = nil
            end
        end

        return attached
    end

    local function fillEmptySpace(color)
        local px, py, effect, effectData
        local changedList = {}
        local changedColorList = {}
        
        for i = 0, maxEffectArrayBuffer do
            px = math_floor(i / sizeY)
            py = i % sizeY
            if not effects[i] and not tryAttach(changedList, i, px, py, color) then
                effect = createEffect()
                effectData = {
                    effect,
                    color,
                    px, --3. root pos x
                    py, --4. root pos Y
                    1,  --5. sizeX
                    1,  --6. sizeY
                    i   --7. root index
                }
                effects[i] = effectData
                changedList[effectData] = true
                changedColorList[effect] = effectData
            end
        end

        for effectData in pairs(changedList) do
            setEffectDataParams(effectData)
        end

        local color
        for _, effectData in pairs(changedColorList) do
            color = effectData[2]
            if not colorCache[color] then
                colorCache[color] = color_new_fromSmallNumber(color, alpha)
            end
            effect_setParameter(effectData[1], "color", colorCache[color])
        end
    end

    --[[
    local function checkNodeEffects()
        --[[
        for i, effectData in pairs(nodeEffects) do
            if effectData[7] ~= effectIndexAtPos(effectData[3], effectData[4]) then
                print(effectData)
                error("WTF 6")
            end
        end

        for i, effectData in pairs(effects) do
            if effectData[7] == i then
                if not nodeEffects[i] then
                    error("WTF 0")
                end

                if nodeEffects[i][7] ~= i then
                    error("WTF 1")
                end
            end
        end

        for i, effectData in pairs(nodeEffects) do
            if not effects[i] then
                print(effectData)
                error("WTF 3")
            end
        end

        for i, effectData in pairs(nodeEffects) do
            if effectData[7] ~= i then
                print(effectData)
                error("WTF 4")
            end
        end

        local exists = {}
        for i, effectData in pairs(nodeEffects) do
            if exists[effectData[1].id] then
                print(i, effectData, exists[effectData[1].id])
                error("WTF 5")
            end
            exists[effectData[1].id] = {i, effectData}
        end
        ] ]

        nodeEffects = {}
        for i, effectData in pairs(effects) do
            if effectData[7] == i then
                nodeEffects[i] = effectData
            end
        end
    end
    ]]

    --[[
    local showedNodeEffects = {}
    local function showNodeEffects()
        for _, effect in pairs(showedNodeEffects) do
            hideEffect(effect)
        end
        showedNodeEffects = {}
        for i, effectData in pairs(nodeEffects) do
            showedNodeEffects[i] = createEffect()
            local effectData = {
                showedNodeEffects[i],
                nil,
                effectData[3], --3. root pos x
                effectData[4], --4. root pos Y
                1,  --5. sizeX
                1,  --6. sizeY
                i   --7. root index
            }
            local effect, posX, posY, lSizeX, lSizeY = effectData[1], effectData[3], effectData[4], effectData[5], effectData[6]
            posX = posX + ((lSizeX - 1) * 0.5)
            posY = posY + ((lSizeY - 1) * 0.5)
            effect_setOffsetPosition(effect, rotation * (offset + vec3_new(((posX + 0.5) - (sizeX / 2)) * pixelSize.x, ((posY + 0.5) - (sizeY / 2)) * -pixelSize.y, backplate and (debugMode and 0.051 or 0.011) or 0)))
            local localScaleAddValue = debugMode and -(pixelSize.x / 2) or scaleAddValue
            local vec = pixelSize * 1
            vec.x = (pixelSize.x * lSizeX) + localScaleAddValue
            vec.y = (pixelSize.y * lSizeY) + localScaleAddValue
            effect_setScale(effect, vec)
            effect_setParameter(showedNodeEffects[i], "color", sm.color.new(1, 0, 0))
        end
    end
    ]]

    --if true then
    local clearBackplate = false
    
    local drawer
    drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, function (base, clearOnly, maxBuffer, force, newBuffer, realBuffer, bufferChangedFrom, bufferChangedTo, changes, changesIndex, changesCount, _changes)
        lastNewBuffer, lastBase = newBuffer, base
        lastDrawTickTime = sm.game.getCurrentTick()

        local changedList = {}
        local changedColorList = {}
        local hideList = {}

        if clearBackplate then
            --checkNodeEffects()
            --showNodeEffects()
            --[[
            for i, effectData in pairs(nodeEffects) do
                hideList[effectData[1].id] = effectData[1]
                hideEffectDataLater(effectData)
                --effectData[8] = true
            end
            ]]
            for index in pairs(_changes) do
                if not changes[index] then
                    changesCount = changesCount + 1
                    changesIndex[changesCount] = index
                end
            end
        end

        --for i in pairs(changes) do
        for i2 = 1, changesCount do
            local i = changesIndex[i2]
            local color = newBuffer[i] or base
            if effects[i] then
                if not colorEquals(effects[i][2], color) then
                    local px = math_floor(i / sizeY)
                    local py = i % sizeY
                    if color == oldBackplateColor then
                        local aSizeX, aSizeY = effects[i][5] > 1, effects[i][6] > 1
                        if aSizeX and aSizeY then
                            extractVerticleLine(changedList, changedColorList, i, px, py, true)
                            extractVerticlePixel(changedList, changedColorList, i, px, py)
                        elseif aSizeX then
                            extractVerticleLine(changedList, changedColorList, i, px, py)
                        elseif aSizeY then
                            extractVerticlePixel(changedList, changedColorList, i, px, py)
                        else
                            changedList[effects[i]] = nil
                            hideEffectData(effects[i])
                        end
                    else
                        _changes[i] = true
                        if effects[i][5] > 1 then
                            extractVerticleLine(changedList, changedColorList, i, px, py, true)
                        end
                        if effects[i][6] > 1 then
                            extractVerticlePixel(changedList, changedColorList, i, px, py, true)
                        end
                        if not tryAttach(changedList, i, px, py, color, hideList) then
                            effects[i][2] = color
                            changedColorList[effects[i][1]] = effects[i]
                        end
                    end
                end
            elseif color ~= oldBackplateColor then
                _changes[i] = true
                local px = math_floor(i / sizeY)
                local py = i % sizeY
                if not tryAttach(changedList, i, px, py, color, hideList) then
                    local effect = createEffect()
                    local effectData = {
                        effect,
                        color,
                        px, --3. root pos x
                        py, --4. root pos Y
                        1,  --5. sizeX
                        1,  --6. sizeY
                        i   --7. root index
                    }
                    effects[i] = effectData
                    nodeEffects[i] = effectData
                    changedList[effectData] = true
                    changedColorList[effect] = effectData
                    hideList[effect.id] = nil
                end
            end
        end

        for _, effect in pairs(hideList) do
            effect_setOffsetPosition(effect, hiddenOffset)
        end

        for effectData in pairs(changedList) do
            setEffectDataParams(effectData)
        end

        local color
        for _, effectData in pairs(changedColorList) do
            color = effectData[2]
            if not colorCache[color] then
                colorCache[color] = color_new_fromSmallNumber(color, alpha)
            end
            effect_setParameter(effectData[1], "color", colorCache[color])
        end

        if clearOnly then
            clearBufferedEffects()
        end

        if clearBackplate then
            drawer.flushOldChanges()
            clearBackplate = false
        end

        needOptimize = true
    end, nil, function (_, color, changes)
        if backplate then
            oldBackplateColor = color
            effect_setParameter(backplate, "color", color_new_fromSmallNumber(color, alpha))
            clearBackplate = true
        else
            drawer.fullRefresh()
        end
    end, nil, nil, true)

    if not backplate then
        drawer.fullRefresh()
    end

    --[[
    else
        drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, function (base, clearOnly, maxBuffer, force, newBuffer, realBuffer, bufferChangedFrom, bufferChangedTo)
            local oldBase = lastBase
            lastNewBuffer, lastBase = newBuffer, base
    
            local newBackplateColor
            local oldOldBackplateColor
            local ctick = sm.game.getCurrentTick()
            
            if backplate then
                if clearOnly then
                    newBackplateColor = base
                else
                    if not lastPopularColor or ctick - lastPopularColorTick >= lastPopularColorUpdatePerTick or base ~= oldBase then
                        mathPopularColor()
                    end
                    newBackplateColor = lastPopularColor
                end
    
                if newBackplateColor ~= oldBackplateColor then
                    effect_setParameter(backplate, "color", color_new_fromSmallNumber(newBackplateColor, alpha))
                    if not clearOnly then
                        hideEffectsWithColor(newBackplateColor)
                    end
                    oldOldBackplateColor = oldBackplateColor
                    oldBackplateColor = newBackplateColor
                end
    
                if clearOnly then
                    needOptimize = false
                    delAllEffects()
                    clearBufferedEffects()
                    return true
                end
            end
    
            if force or oldOldBackplateColor then
                bufferChangedFrom, bufferChangedTo = 0, maxBuffer
            end
    
            --print("FFFF", (bufferChangedTo - bufferChangedFrom) / 1000)
    
            local changedList = {}
            local changedColorList = {}

            local color, px, py, oldEffect, effect, effectData
            local i = bufferChangedFrom
            while i <= bufferChangedTo do
                color = newBuffer[i] or base
                if not realBuffer[i] or not colorEquals(color, realBuffer[i]) or color == oldOldBackplateColor or force then
                    lastDrawTickTime = ctick
                    needOptimize = true
    
                    px = math_floor(i / sizeY)
                    py = i % sizeY
                    if effects[i] then
                        if effects[i][5] > 1 then
                            extractVerticleLine(changedList, changedColorList, px, py)
                        end
                        if effects[i][6] > 1 then
                            extractVerticlePixel(changedList, changedColorList, px, py)
                        end
                        if color == newBackplateColor then
                            changedList[effects[i] ] = nil
                            hideEffectData(effects[i] )
                        elseif not tryAttach(changedList, i, px, py, color) then
                            effects[i][2] = color
                            changedColorList[effects[i][1] ] = effects[i]
                        end
                    elseif color ~= newBackplateColor and not tryAttach(changedList, i, px, py, color) then
                        effect = createEffect()
                        effectData = {
                            effect,
                            color,
                            px, --3. root pos x
                            py, --4. root pos Y
                            1,  --5. sizeX
                            1,  --6. sizeY
                            i   --7. root index
                        }
                        effects[i] = effectData
                        changedList[effectData] = true
                        changedColorList[effect] = effectData
                    end
                    realBuffer[i] = color
                end
                i = i + 1
            end
    
            --[[
            local cx, cy = 7, 4
            print("1", effectIndexAtPos(cx, cy), effects[effectIndexAtPos(cx, cy)])
            extractVerticleLine(changedList, changedColorList, cx, cy)
            print("2", effectIndexAtPos(cx, cy), effects[effectIndexAtPos(cx, cy)])
            print("2-", effectIndexAtPos(cx-1, cy), effects[effectIndexAtPos(cx-1, cy)])
            print("2+", effectIndexAtPos(cx+1, cy), effects[effectIndexAtPos(cx+1, cy)])
            ] ]
    
            --[[
            extractVerticleLine(changedList, changedColorList, 5, 5)
            extractVerticlePixel(changedList, changedColorList, 5, 5)
            changedColorList[effects[effectIndexAtPos(5, 5)][1] ] = effects[effectIndexAtPos(5, 5)]
            effects[effectIndexAtPos(5, 5)][2] = 0x00ff00
            tryAttach(changedList, effectIndexAtPos(5, 5), 5, 5, 0x00ff00)
            extractVerticleLine(changedList, changedColorList, 5, 5)
            extractVerticlePixel(changedList, changedColorList, 5, 5)
            ] ]
    
            for effectData in pairs(changedList) do
                setEffectDataParams(effectData)
            end
    
            for _, effectData in pairs(changedColorList) do
                effect_setParameter(effectData[1], "color", color_new_fromSmallNumber(effectData[2], alpha))
            end
    
            if clearOnly then
                clearBufferedEffects()
            end
        end)
    end
    ]]
    drawer.setWait(true)

    --[[
    local _flush = drawer.flush
    function drawer.flush(force)
        _flush(true)
    end
    ]]

    local function getSelfPos()
        local pt = type(parent)
        if pt == "Interactable" then
            return parent.shape.worldPosition
        elseif pt == "Character" then
            return parent.worldPosition
        end
    end

    local reoptimizeCanvas = sizeX * sizeY <= (256 * 256)
    if debugMode then
        print("reoptimizeCanvas", sizeX, sizeY, reoptimizeCanvas)
    end
    local function optimize()
        --[[
        if backplate then
            mathPopularColor()
            if lastPopularColor ~= oldBackplateColor then
                effect_setParameter(backplate, "color", color_new_fromSmallNumber(lastPopularColor, alpha))
                if not reoptimizeCanvas then
                    fillEmptySpace(oldBackplateColor)
                    hideEffectsWithColor(lastPopularColor)
                end
                oldBackplateColor = lastPopularColor
            end
        end
        ]]

        if debugMode then
            local usedEffects = 0
            local addedList = {}
            for k, v in pairs(effects) do
                if not addedList[v[1]] then
                    usedEffects = usedEffects + 1
                    addedList[v[1]] = true
                end
            end
            print("effect info:")
            print("used effects: ", usedEffects)
            print("buffered effects: ", bufferedEffectsIndex)
        end

        ------------------------------------------

        if reoptimizeCanvas then
            --checkNodeEffects()

            if debugMode then
                print("reoptimize canvas")
            end

            if backplate then
                mathPopularColor()
                if lastPopularColor ~= oldBackplateColor then
                    effect_setParameter(backplate, "color", color_new_fromSmallNumber(lastPopularColor, alpha))
                    oldBackplateColor = lastPopularColor
                end
            end
            
            for i, effectData in pairs(nodeEffects) do
                hideEffect(effectData[1])
            end
            effects = {}
            nodeEffects = {}

            local changedList = {}
            local changedColorList = {}
            local i = 0
            while i <= maxEffectArrayBuffer do
                local color = lastNewBuffer[i] or lastBase
                local px = math_floor(i / sizeY)
                local py = i % sizeY
                if color ~= oldBackplateColor and not tryAttach(changedList, i, px, py, color) then
                    local effect = createEffect()
                    local effectData = {
                        effect,
                        color,
                        px, --3. root pos x
                        py, --4. root pos Y
                        1,  --5. sizeX
                        1,  --6. sizeY
                        i   --7. root index
                    }
                    effects[i] = effectData
                    nodeEffects[i] = effectData
                    changedList[effectData] = true
                    changedColorList[effect] = effectData
                end
                i = i + 1
            end

            for effectData in pairs(changedList) do
                setEffectDataParams(effectData)
            end

            local color
            for _, effectData in pairs(changedColorList) do
                color = effectData[2]
                if not colorCache[color] then
                    colorCache[color] = color_new_fromSmallNumber(color, alpha)
                end
                effect_setParameter(effectData[1], "color", colorCache[color])
            end
        end

        ------------------------------------------

        if bufferedEffectsIndex > 1024 then
            if debugMode then
                print("stoping buffered effects")
            end

            for i = 1, bufferedEffectsIndex - 1024 do
                effect_stop(bufferedEffects[i])
            end

            --[[
            if bufferedEffectsIndex > 3000 then
                if debugMode then
                    print("destroy buffered effects")
                end

                for i = 3001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                end
                bufferedEffectsIndex = 3000
            end
            ]]
        end
    end

    function obj.setAlpha(_alpha)
        alpha = _alpha
        for _, effectData in pairs(nodeEffects) do
            effect_setParameter(effectData[1], "color", color_new_fromSmallNumber(effectData[2], alpha))
        end
    end

    function obj.setOptimizationLevel(value)
        optimizationLevel = value
        if value == 0 then
            colorEquals = colorEquals_raw
        else
            colorEquals = colorEquals_smart
        end
    end

    function obj.isRendering()
        return showState
    end

    function obj.disable(state)
        disable = state
    end

    function obj.setRenderDistance(_dist)
        dist = _dist
    end

    local oldOptimizeTime
    function obj.update()
        local newShowState = true
        if disable then
            newShowState = false
        elseif dist then
            if not pcall(function()
                newShowState = mathDist(getSelfPos(), sm_localPlayer_getPlayer().character.worldPosition) <= dist
            end) then
                newShowState = false
            end
        end

        if newShowState ~= showState then
            showState = newShowState
            if newShowState then
                drawer.setWait(false)
                if not backplate and not flushedDefault then
                    drawer.flush(true)
                    flushedDefault = true
                end
                for _, effect in pairs(nodeEffects) do
                    if not effect_isPlaying(effect[1]) then
                        effect_start(effect[1])
                    end
                end
                if backplate then
                    effect_start(backplate)
                end
            else
                for _, effect in pairs(nodeEffects) do
                    effect_stop(effect[1])
                end
                for i = 1, bufferedEffectsIndex do
                    effect_stop(bufferedEffects[i])
                end
                if backplate then
                    effect_stop(backplate)
                end
                drawer.setWait(true)
            end
        end

        local ctick = sm.game.getCurrentTick()
        local optimizePeer = 40
        if lastDrawTickTime and ctick - lastDrawTickTime < 20 then
            optimizePeer = 80
        end

        if newShowState and needOptimize and (not oldOptimizeTime or ctick - oldOptimizeTime >= optimizePeer) then
            needOptimize = false
            oldOptimizeTime = ctick
            optimize()
        end
    end

    function obj.setPixelSize(_pixelSize)
        pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
        if type(pixelSize) == "number" then
            if pixelSize < 0 then
                pixelSize = math_abs(pixelSize)
                local vec = vec3_new(pixelSize, pixelSize, 0)
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            else
                local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            end
        end
        if backplate then
            effect_setScale(backplate, vec3_new((pixelSize.x * sizeX) - 0.00005, (pixelSize.y * sizeY) - 0.00005, pixelSize.z))
        end
        if autoScaleAddValue then
            scaleAddValue = (pixelSize.x + pixelSize.y + pixelSize.z) / 50
        end
        --scaleAddValue = -0.003
    end

    function obj.setOffset(_offset)
        offset = _offset
        if backplate then
            effect_setOffsetPosition(backplate, rotation * offset)
        end
        for _, effectData in pairs(nodeEffects) do
            setEffectDataParams(effectData)
        end
    end

    function obj.setCanvasRotation(_rotation)
        rotation = _rotation
        if backplate then
            effect_setOffsetRotation(backplate, rotation)
        end
        for _, effectData in pairs(nodeEffects) do
            effect_setOffsetRotation(effectData[1], rotation)
            setEffectDataParams(effectData)
        end
    end

    function obj.destroy()
        for _, effectData in pairs(nodeEffects) do
            effect_destroy(effectData[1])
        end
        if backplate then
            effect_destroy(backplate)
        end
    end

    ---------------------------------------

    obj.setPixelSize(pixelSize)
    obj.setCanvasRotation(rotation or quat_fromEuler(vec3_new(0, 0, 0)))
    obj.setOffset(offset or vec3_new(0, 0, 0))

    --[[
    local c = 0xff0000
    local seffect = createEffect(5, 5, 16, 16, c)
    local idx = 5 + (5 * sizeX)
    for i = 0, 16 - 1 do
        effects[idx + i] = {
            seffect,
            c,
            i,
            16,
            idx,
            5,
            5,
            1, --8. sizeY
            0 --9. indexY
        }
    end
    ]]

    ---------------------------------------

    obj.drawer = drawer
    for k, v in pairs(drawer) do
        obj[k] = v
    end

    function obj.pushDataTunnelParams(dataTunnel)
        obj.setOptimizationLevel(dataTunnel.optimizationLevel)
        obj.setAlpha(dataTunnel.light)
        drawer.pushDataTunnelParams(dataTunnel)
    end

    return obj
end

--simulates the API of screens from SComputers on the client side of your parts
function canvasAPI.createClientScriptableCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local dataTunnel = {}
    local canvas = canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local api = canvasAPI.createScriptableApi(sizeX, sizeY, dataTunnel, nil, canvas.drawer)
    api.registerClick = canvasAPI.addTouch(api, dataTunnel)
    api.dataTunnel = dataTunnel
    api.canvas = canvas

    local renderDistance = 15

    for k, v in pairs(canvas) do
        if k ~= "flush" then
            api[k] = v
        end
    end

    function api.getAudience()
        return canvas.isRendering() and 1 or 0
    end

    function api.update(dt)
        canvas.disable(not api.isAllow())
        if dataTunnel.renderAtDistance then
            canvas.setRenderDistance()
        else
            canvas.setRenderDistance(renderDistance)
        end
        canvas.pushDataTunnelParams(dataTunnel)
        canvas.update()
        dataTunnel.scriptableApi_update()

        if dataTunnel.display_reset then
            canvas.drawerReset()
            dataTunnel.display_reset = nil
        end

        if dataTunnel.display_flush then
            if needPushStack(canvas, dataTunnel, dt) then
                canvas.pushStack(dataTunnel.display_stack)
                canvas.flush()
            end
            
            dataTunnel.display_flush()
            dataTunnel.display_stack = nil
            dataTunnel.display_flush = nil
            dataTunnel.display_forceFlush = nil
        end
    end

    function api.setRenderDistance(dist)
        renderDistance = dist
    end

    return api
end

local customFontIndexesCache = {}
local checkedFonts = {}

--simulates the SComputers API, does not implement data transfer
function canvasAPI.createScriptableApi(width, height, dataTunnel, flushCallback, drawer)
    dataTunnel = dataTunnel or {}
    dataTunnel.rotation = 0
    dataTunnel.brightness = 1
    dataTunnel.light = DEFAULT_ALPHA_VALUE
    dataTunnel.skipAtNotSight = false
    dataTunnel.utf8support = false
    dataTunnel.renderAtDistance = false
    dataTunnel.display_forceFlush = true
    dataTunnel.dataUpdated = true
    dataTunnel.optimizationLevel = 16

    local stack = {}
    local stackIndex = 1
    local pixelsCache = {} --optimizations for cameras
    local pixelsCacheExists = false
    local oldStackSum, oldDataSum, oldStack, oldStackIndex
    local forceFlag = false

    local function clearStackForce()
        stack = {}
        stackIndex = 1
    end

    local function clearStack()
        if dataTunnel.display_stack == stack then
            clearStackForce()
        end
    end

    local function setForceFrame()
        if pixelsCacheExists then
            pixelsCache = {}
            pixelsCacheExists = false
        end
        forceFlag = true
        dataTunnel.display_forceFlush = true
    end

    local oldPlayersCount = #sm.player.getAllPlayers()
    function dataTunnel.scriptableApi_update()
        local playersCount = #sm.player.getAllPlayers()
        --local force = sm.game.getCurrentTick() % 80 == 0
        local force = false
        if oldPlayersCount ~= playersCount or force then
            --dataTunnel.display_forceForceFlush = force
            setForceFrame()
            oldPlayersCount = playersCount
        end
    end

    local rwidth, rheight = width, height
    local rmwidth, rmheight = width - 1, height - 1
    local utf8support = false
    local monoFont = true
    local newDataFlag = false
    local spacing = 1
    local fontIndex = 0
    local lastPixelX, lastPixelY, lastPixelColor
    local currentSettedFont

    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local dFontX, dFontY = font.width, font.height
    local fontX, fontY
    local mFontX, mFontY
    local xFontX, xFontY
    local sFontX, sFontY
    local fontScaleX, fontScaleY = 1, 1
    local function updateFontSize()
        fontX, fontY = math_ceil(dFontX * fontScaleX), math_ceil(dFontY * fontScaleY)
        mFontX, mFontY = fontX - 1, fontY - 1
        xFontX, xFontY = fontX + 1, fontY + 1
        sFontX, sFontY = fontX + spacing, fontY + 1
    end
    updateFontSize()

    local api
    api = {
        --[[
        getBuffer = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,
        getCurrent = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getRealBuffer(x + (y * rwidth))
        end,
        ]]
        get = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,

        -- not implemented (implement it yourself if necessary)
        isAllow = function()
            return true
        end,
        getAudience = function()
            return 1
        end,

        setOptimizationLevel = function(value)
            checkArg(1, value, "number")
            value = round(value)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.optimizationLevel ~= value then
                dataTunnel.optimizationLevel = value
                dataTunnel.dataUpdated = true
            end
        end,
        getOptimizationLevel = function()
            return dataTunnel.optimizationLevel
        end,


        -- stubs (outdated methods)
        optimize = function() end,
        setFrameCheck = function () end,
        getFrameCheck = function () return false end,
        setSkipAtLags = function() end,
        getSkipAtLags = function() return false end,


        -- main
        setFontScale = function(scaleX, scaleY)
            checkArg(1, scaleX, "number")
            checkArg(2, scaleY, "number")
            if scaleX < 0 then scaleX = 0 end
            if scaleY < 0 then scaleY = 0 end
            fontScaleX, fontScaleY = scaleX, scaleY
            updateFontSize()
        end,
        getFontScale = function()
            return fontScaleX, fontScaleY
        end,
        setTextSpacing = function(_spacing)
            if _spacing < 0 then _spacing = 0 end
            spacing = _spacing
            updateFontSize()
        end,
        setFontSize = function(_width, _height)
            api.setFontScale(_width / dFontX, _height / dFontY)
        end,
        getTextSpacing = function()
            return spacing
        end,
        calcTextBox = function(text) --it will return two numbers, this will be the size of the box that your text will occupy with this font and this scale
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local totalSize = 0
            if monoFont then
                totalSize = ((textLen - 1) * (fontX + spacing)) + fontX
            else
                local localFontWidth = dFontX
                local localFont = dataTunnel.customFont or font.optimized
                if fontIndex > 0 and fontsOptimized[fontIndex] then
                    localFont = fontsOptimized[fontIndex]
                    localFontWidth = localFont.width
                end

                local char, chrdata
                for i = 1, textLen do
                    char = sep(text, i, i)
                    if char ~= " " and char ~= spaceCharCode then
                        chrdata = localFont[char] or localFont.error or defaultError
                        totalSize = totalSize + (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                    else
                        totalSize = totalSize + (localFont.spaceSize or localFontWidth) + spacing
                    end
                    canvasAPI.yield()
                end
            end

            return totalSize - spacing, fontY
        end,
        calcCharsSize = function(text) --calculates the length of each character in a string, taking into account its spacing from the next character, and returns a table with these values
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    table_insert(lens, (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing)
                else
                    table_insert(lens, (localFont.spaceSize or localFontWidth) + spacing)
                end
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        calcDecreasingTextSizes = function(text) --it works almost like calcCharsSize. however, each value contains all the previous ones. this is used in the graphic.textBox function, but probably not applicable to any other
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}
            local otherVals = 0

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                local val
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    val = (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                else
                    val = (localFont.spaceSize or localFontWidth) + spacing
                end
                otherVals = otherVals + val
                table_insert(lens, otherVals)
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        isMonospacedFont = function()
            return not not monoFont
        end,

        getWidth = function()
            return rwidth
        end,
        getHeight = function()
            return rheight
        end,
        getSize = function()
            return rwidth, rheight
        end,

        clear = function(color)
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end

            clearStackForce()
            stackIndex = 4
            stack[1] = resetViewportCodeID
            stack[2] = 0
            stack[3] = formatColorToSmallNumber(color, blackSmallNumber)
            
            --[[
            for i = 3, stackIndex - 1 do
                stack[i] = nil
            end
            stackIndex = 3
            ]]
        end,
        drawPixel = function(x, y, color)
            x, y = round(x), round(y)
            if x < 0 or x >= width or y < 0 or y >= height then return end
            local index = x + (y * rwidth)
            color = color or false
            if pixelsCache[index] ~= color then
                if false and pixelsCacheExists and x == lastPixelX + 1 then
                    
                else
                    --[[
                    stack[stackIndex] = -index - 20
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                    stackIndex = stackIndex + 1
                    ]]
                    stack[stackIndex] = 1
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = index
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                    stackIndex = stackIndex + 1
                end

                lastPixelX, lastPixelY, lastPixelColor = x, y, color

                pixelsCache[index] = color
                pixelsCacheExists = true
            end
        end,
        fillRect = function(x, y, sizeX, sizeY, color)
            stack[stackIndex] = 2
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawRect = function(x, y, sizeX, sizeY, color, lineWidth)
            lineWidth = round(lineWidth or 1)
            if lineWidth < 1 then
                lineWidth = 1
            end

            stack[stackIndex] = 3
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = lineWidth
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawText = function(x, y, text, color)
            if y > rmheight or y + mFontY < 0 or fontScaleX <= 0 or fontScaleY <= 0 then return end
            text = tostring(text)

            if monoFont then
                local maxTextLen = math_ceil((width - x) / sFontX)
                if maxTextLen <= 0 then return end
                local startTextFrom = math_max(1, math_floor(-x / sFontX) + 1)

                if utf8support then
                    if utf8.len(text) > maxTextLen or startTextFrom > 1 then
                        text = utf8.sub(text, startTextFrom, maxTextLen)
                    end
                else
                    if #text > maxTextLen or startTextFrom > 1 then
                        text = text:sub(startTextFrom, maxTextLen)
                    end
                end

                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x) + ((startTextFrom - 1) * sFontX)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            else
                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawLine = function(x, y, x2, y2, color, width, roundFlag)
            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            stack[stackIndex] = 5
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = width
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 6
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end
            
            stack[stackIndex] = 7
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleEvenly = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 8
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleVeryEvenly = function (x, y, r, color, stroke)
            if r > 1024 then r = 1024 end
            if not stroke or stroke < 1 then stroke = 1 end

            stack[stackIndex] = 9
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(stroke)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawPoly = function(color, ...)
            api.drawWidePoly(color, 1, false, ...)
        end,
        drawWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 10
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillPoly = function(color, ...)
            api.fillWidePoly(color, 1, false, ...)
        end,
        fillWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 11
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        flush = function()
            api.setViewport()

            if dataTunnel.display_flush and dataTunnel.display_stack == stack then
                return
            end

            local needFlush = forceFlag
            --print("--------------------------- FLUSH 1", needFlush, stack, stackChecksum(stack), stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel)))

            if not needFlush and stackIndex ~= oldStackIndex then
                --print("FLUSH 2", stackIndex, oldStackIndex)
                needFlush = true
            end

            if not needFlush and newDataFlag then
                local dataSum = stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel))
                if dataSum ~= oldDataSum then
                    --print("FLUSH 3")
                    needFlush = true
                    oldDataSum = dataSum
                end
            end

            if not needFlush and stack ~= oldStack then
                for i = 1, stackIndex - 1 do
                    if stack[i] ~= oldStack[i] then
                        needFlush = true
                        --print("FLUSH 4", oldStack)
                        break
                    end
                end
            end

            --[[
            if needFlush then
                oldStackSum = nil
            else
                local stachSum = stackChecksum(stack)
                if stachSum ~= oldStackSum then
                    --print("FLUSH 5")
                    needFlush = true
                    oldStackSum = stachSum
                end
            end
            ]]
            
            if needFlush then
                --print("FLUSH ACTION")
                oldStack = stack
                oldStackIndex = stackIndex

                dataTunnel.display_stack = stack
                dataTunnel.display_flush = clearStack
                
                if flushCallback then
                    flushCallback()
                end
            else
                clearStackForce()
            end

            forceFlag = false
            newDataFlag = false
        end,
        forceFlush = function()
            api.flush()
            dataTunnel.display_forceFlush = true
        end,

        -- settings
        setUtf8Support = function (state)
            if type(state) == "boolean" then
                if dataTunnel.utf8support ~= state then
                    dataTunnel.utf8support = state
                    dataTunnel.dataUpdated = true
                    newDataFlag = true
                    utf8support = state
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getUtf8Support = function () return dataTunnel.utf8support end,

        setRenderAtDistance = function (c)
            if type(c) == "boolean" then
                if dataTunnel.renderAtDistance ~= c then
                    dataTunnel.renderAtDistance = c
                    dataTunnel.dataUpdated = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getRenderAtDistance = function () return dataTunnel.renderAtDistance end,

        setRotation = function (rotation)
            if type(rotation) == "number" and rotation % 1 == 0 and rotation >= 0 and rotation <= 3 then
                if rotation ~= dataTunnel.rotation then
                    dataTunnel.rotation = rotation
                    dataTunnel.dataUpdated = true
                    newDataFlag = true

                    if pixelsCacheExists then
                        pixelsCache = {}
                        pixelsCacheExists = false
                    end

                    if rotation == 1 or rotation == 3 then
                        rwidth = height
                        rheight = width
                    else
                        rwidth = width
                        rheight = height
                    end
                    rmheight = rheight - 1
                    rmwidth = rwidth - 1
                end
            else
                error("integer must be in [0 3]", 2)
            end
        end,
        getRotation = function () return dataTunnel.rotation end,

        setFont = function (customFont)
            checkArg(1, customFont, "table", "nil")
            currentSettedFont = customFont
            fontIndex = 0
            if dataTunnel.customFont then
                dataTunnel.dataUpdated = true
                dataTunnel.customFont = nil
            end
            if customFont then
                if not checkedFonts[customFont] then
                    checkFont(customFont)
                    checkedFonts[customFont] = true
                end
                dFontX, dFontY = customFont.width, customFont.height
                fontIndex = customFontIndexesCache[customFont]
                if not fontIndex then
                    for _, v in pairs(fonts) do
                        if v == customFont then
                            fontIndex = v.index
                        end
                    end
                    customFontIndexesCache[customFont] = fontIndex
                end
                if fontIndex == 0 then
                    dataTunnel.customFont = font.optimizeFont(customFont)
                    dataTunnel.dataUpdated = true
                end
                monoFont = customFont.mono or customFont.mono == nil
            else
                dFontX, dFontY = font.width, font.height
                monoFont = true
            end
            updateFontSize()
            newDataFlag = true
        end,
        getFont = function()
            return currentSettedFont
        end,

        getFontWidth = function ()
            return fontX
        end,
        getFontHeight = function ()
            return fontY
        end,
        getRealFontWidth = function ()
            return dFontX
        end,
        getRealFontHeight = function ()
            return dFontY
        end,

        setSkipAtNotSight = function (state)
            checkArg(1, state, "boolean")
            if dataTunnel.skipAtNotSight ~= state then
                dataTunnel.skipAtNotSight = state
                dataTunnel.dataUpdated = true
            end
        end,
        getSkipAtNotSight = function () return dataTunnel.skipAtNotSight end,

        getViewport = function()
            return viewport_x, viewport_y, viewport_sx, viewport_sy
        end,
        setViewport = function(x, y, sizeX, sizeY)
            if x or y or sizeX or sizeY then
                viewport_x, viewport_y, viewport_sx, viewport_sy = x or 0, y or 0, sizeX or api.getWidth(), sizeY or api.getHeight()
                stack[stackIndex] = -1
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sx)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sy)
                stackIndex = stackIndex + 1
            else
                viewport_x, viewport_y, viewport_sx, viewport_sy = nil, nil, nil, nil
                stack[stackIndex] = resetViewportCodeID
                stackIndex = stackIndex + 1
            end
        end,
        setInlineViewport = function(x, y, sizeX, sizeY)
            if viewport_x then
                local x2 = x + (sizeX - 1)
                local y2 = y + (sizeY - 1)
                local px2 = viewport_x + (viewport_sx - 1)
                local py2 = viewport_y + (viewport_sy - 1)
                if x < viewport_x then x = viewport_x elseif x > px2 then x = px2 end
                if y < viewport_y then y = viewport_y elseif y > py2 then y = py2 end
                if x2 < viewport_x then x2 = viewport_x elseif x2 > px2 then x2 = px2 end
                if y2 < viewport_y then y2 = viewport_y elseif y2 > py2 then y2 = py2 end
                api.setViewport(x, y, (x2 - x) + 1, (y2 - y) + 1)
            else
                api.setViewport(x, y, sizeX, sizeY)
            end
        end,

        setBrightness = function(value) --float from 0
            checkArg(1, value, "number")
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.brightness ~= value then
                dataTunnel.brightness = value
                dataTunnel.dataUpdated = true
            end
        end,
        getBrightness = function(value)
            return dataTunnel.brightness
        end,

        setLight = function(value)
            checkArg(1, value, "number")
            value = math.floor(value + 0.5)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.light ~= value then
                dataTunnel.light = value
                dataTunnel.dataUpdated = true
            end
        end,
        getLight = function(value)
            return dataTunnel.light
        end,

        reset = function()
            if api.setFontScale then api.setFontScale(1, 1) end
            if api.setTextSpacing then api.setTextSpacing(1) end
            if api.setFont then api.setFont() end
            if api.setRotation then api.setRotation(0) end
            if api.setUtf8Support then api.setUtf8Support(false) end
            if api.setClicksAllowed then api.setClicksAllowed(false) end
            if api.setMaxClicks then api.setMaxClicks(16) end
            if api.clearClicks then api.clearClicks() end
            if api.setSkipAtNotSight then api.setSkipAtNotSight(false) end
            if api.setRenderAtDistance then api.setRenderAtDistance(false) end
            if api.setViewport then api.setViewport() end
            if api.setBrightness then api.setBrightness(1) end
            if api.setLight then api.setLight(DEFAULT_ALPHA_VALUE) end
            if api.setOptimizationLevel then api.setOptimizationLevel(16) end
            dataTunnel.display_reset = true
        end
    }

    api.update = api.flush
    api.getBuffer = api.get
    api.getCurrent = api.get

    local internal = {
        rawPush = function(tbl)
            for i = 1, #tbl do
                stack[stackIndex] = tbl[i]
                stackIndex = stackIndex + 1
            end
        end
    }

    return api, internal
end

--adds a touch screen API (does not implement click processing)
function canvasAPI.addTouch(api, dataTunnel)
    dataTunnel = dataTunnel or {}
    dataTunnel.clicksAllowed = false
    dataTunnel.maxClicks = 16
    dataTunnel.clickData = {}

    api.getClick = function ()
        return (table_remove(dataTunnel.clickData, 1))
    end

    api.setMaxClicks = function (c)
        if type(c) == "number" and c % 1 == 0 and c > 0 and c <= 16 then
            dataTunnel.maxClicks = c
        else
            error("integer must be in [1; 16]", 2)
        end
    end

    api.getMaxClicks = function ()
        return dataTunnel.maxClicks
    end

    api.clearClicks = function ()
        dataTunnel.clickData = {}
    end

    api.setClicksAllowed = function (c)
        if type(c) == "boolean" then
            if dataTunnel.clicksAllowed ~= c then
                dataTunnel.clicksAllowed = c
                dataTunnel.dataUpdated = true
            end
        else
            error("Type must be boolean", 2)
        end
    end

    api.getClicksAllowed = function ()
        return dataTunnel.clicksAllowed
    end

    return function (tbl)
        tbl.x = tbl[1] or tbl.x
        tbl.y = tbl[2] or tbl.y
        tbl.state = tbl[3] or tbl.state
        tbl.button = tbl[4] or tbl.button
        tbl.nickname = tbl[5] or tbl.nickname
        tbl[1] = tbl.x or tbl[1]
        tbl[2] = tbl.y or tbl[2]
        tbl[3] = tbl.state or tbl[3]
        tbl[4] = tbl.button or tbl[4]
        tbl[5] = tbl.nickname or tbl[5]
        table_insert(dataTunnel.clickData, tbl)
    end
end

--leaves only those tunnel fields that are needed for transmission over the network
function canvasAPI.minimizeDataTunnel(dataTunnel)
    return {
        clicksAllowed = dataTunnel.clicksAllowed,
        rotation = dataTunnel.rotation,
        renderAtDistance = dataTunnel.renderAtDistance,
        skipAtNotSight = dataTunnel.skipAtNotSight,
        utf8support = dataTunnel.utf8support,
        customFont = dataTunnel.customFont,
        display_reset = dataTunnel.display_reset,
        brightness = dataTunnel.brightness,
        optimizationLevel = dataTunnel.optimizationLevel,
        light = dataTunnel.light
    }
end

-------- additional
canvasAPI.stackChecksum = stackChecksum
canvasAPI.formatColor = formatColor
canvasAPI.formatColorToNumber = formatColorToNumber
canvasAPI.formatColorToSmallNumber = formatColorToSmallNumber
canvasAPI.checkFont = checkFont
canvasAPI.simpleRemathRect = simpleRemathRect
canvasAPI.remathRect = remathRect
canvasAPI.hexToRGB = hexToRGB
canvasAPI.hexToRGB256 = hexToRGB256
canvasAPI.posCheck = posCheck
canvasAPI.mathDist = mathDist
canvasAPI.needPushStack = needPushStack
canvasAPI.font = font
canvasAPI.tableClone = tableClone
canvasAPI.canvasService = canvasService
canvasAPI.userCalls = userCalls
canvasAPI.dataSizes = dataSizes
canvasAPI.color_new_fromSmallNumber = color_new_fromSmallNumber
canvasAPI.getEffectName = getEffectName
canvasAPI.fonts = fonts
canvasAPI.utf8 = utf8

function canvasAPI.pushData(stack, ...)
    for i, v in ipairs({...}) do
        table.insert(stack, v)
    end
end

_G.canvasAPI = canvasAPI
end
function scmframework_6d1d31660cfdf58e4bca02111a75376c() --$CONTENT_DATA/Scripts/canvasAPI/backup/canvas_oldFuncs.lua
print("> canvas.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/luajit.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/load.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/utf8.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/canvasService.lua")

local debugMode = true
local canvasAPI = {
    draw = {
        clear = 0,
        set   = 1,
        fill  = 2,
        rect  = 3,
        text  = 4,
        line  = 5,
        circle  = 6,
        circleF = 7,
        circleE = 8,
        circleVE = 9,
        poly = 10,
        polyF = 11
    },
    material = {
        classic = sm.uuid.new("64d41b06-9b71-4e19-9f87-1e7e63845e59"),
        glass = sm.uuid.new("a683f897-5b8a-4c96-9c46-7b9fbc76d186")
    },
    multi_layer = {}
}
canvasAPI.multi_layer[tostring(canvasAPI.material.classic)] = true
canvasAPI.version = 31

canvasAPI.directList = {
    get = true,
    getCurrent = true,
    getBuffer = true,
    
    clear = true,
    drawPixel = true,
    drawRect = true,
    fillRect = true,
    drawText = true,
    drawLine = true,
    drawCircle = true,
    fillCircle = true,
    drawCircleEvenly = true,
    drawCircleVeryEvenly = true,
    drawPoly = true,
    drawWidePoly = true,
    fillPoly = true,
    fillWidePoly = true,
    getWidth = true,
    getHeight = true,
    getSize = true,

    isAllow = true,
    setFontScale = true,
    setFontSize = true,
    getFontScale = true,
    setTextSpacing = true,
    getTextSpacing = true,
    calcTextBox = true,
    calcCharsSize = true,
    calcDecreasingTextSizes = true,
    setUtf8Support = true,
    getUtf8Support = true,
    setRenderAtDistance = true,
    getRenderAtDistance = true,
    setRotation = true,
    getRotation = true,
    setFont = true,
    getFont = true,
    getFontWidth = true,
    getFontHeight = true,
    getRealFontWidth = true,
    getRealFontHeight = true,
    setSkipAtNotSight = true,
    getSkipAtNotSight = true,
    isMonospacedFont = true,
    setBrightness = true,
    getBrightness = true,
    reset = true,
    setClicksAllowed = true,
    getClicksAllowed = true,
    clearClicks = true,
    setMaxClicks = true,
    getMaxClicks = true,
    getClick = true,
    setOptimizationLevel = true,
    getOptimizationLevel = true,

    setViewport = true,
    setInlineViewport = true,
    getViewport = true
}

local MAX_DRAW_TIME = 2 --protecting the world from crashing using the display
local FONT_SIZE_LIMIT = 256
local DEFAULT_ALPHA_VALUE = 180

local font = font
local defaultFont = font.default
local fonts = font.fonts
local fontsOptimized = font.fontsOptimized
local spaceCharCode = string.byte(" ")

local huge = math.huge
local string_len = string.len
local bit = bit or bit32
local bit_rshift = bit.rshift
local bit_lshift = bit.lshift
local utf8 = utf8
local string = string
local table_sort = table.sort
local type = type
local math_ceil = math.ceil
local math_max = math.max
local string_format = string.format
local table_insert = table.insert
local table_remove = table.remove
local math_floor = math.floor
local vec3_new = sm.vec3.new
local color_new = sm.color.new
local quat_fromEuler = sm.quat.fromEuler
local ipairs = ipairs
local pairs = pairs
local string_byte = string.byte
local defaultError = font.optimized.error
local tostring = tostring
local math_abs = math.abs
local math_min = math.min
local string_sub = string.sub
local table_concat = table.concat
local tonumber = tonumber
local utf8_len = utf8.len
local utf8_sub = utf8.sub
local sm_localPlayer_getPlayer = sm.localPlayer.getPlayer
local os_clock = os.clock
local math_sqrt = math.sqrt

local black = color_new(0, 0, 0)
local white = color_new(1, 1, 1)
local blackNumber = 0x000000ff
local whiteNumber = 0xffffffff
local blackSmallNumber = 0x000000
local whiteSmallNumber = 0xffffff

local getEffectName
do
    local currentEffect = 1
    local effectsNames = {}

    for i = 0, 255 do
        table_insert(effectsNames, "ShapeRenderable" .. tostring(i))
    end

    function getEffectName()
        local name = effectsNames[currentEffect]
        currentEffect = currentEffect + 1
        if currentEffect > #effectsNames then
            currentEffect = 1
        end
        return name
    end
end

--[[
local sm_effect_createEffect = sm.effect.withoutHook_createEffect or sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local withoutHookEmptyEffect = emptyEffect
local whook = "withoutHook_"
if better and better.version >= 24 and better.isAvailable() then
    local mt = getmetatable(emptyEffect)
    local newMt = {}
    for k, v in pairs(mt) do
        newMt[k] = v
    end
    for k, v in pairs(mt) do
        if k:sub(1, #whook) == whook then
            newMt[k:sub(#whook + 1, #k)] = v
        end
    end
    withoutHookEmptyEffect = setmetatable({}, newMt)
end
local effect_setParameter = withoutHookEmptyEffect.setParameter
local effect_stop = withoutHookEmptyEffect.stop
local effect_destroy = withoutHookEmptyEffect.destroy
local effect_start = withoutHookEmptyEffect.start
local effect_isDone = withoutHookEmptyEffect.isDone
local effect_isPlaying = withoutHookEmptyEffect.isPlaying
local effect_setScale = withoutHookEmptyEffect.setScale
local effect_setOffsetPosition = withoutHookEmptyEffect.setOffsetPosition
local effect_setOffsetRotation = withoutHookEmptyEffect.setOffsetRotation
effect_destroy(emptyEffect)
]]

local sm_effect_createEffect = sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local effect_setParameter = emptyEffect.setParameter
local effect_stop = emptyEffect.stop
local effect_destroy = emptyEffect.destroy
local effect_start = emptyEffect.start
local effect_isDone = emptyEffect.isDone
local effect_isPlaying = emptyEffect.isPlaying
local effect_setScale = emptyEffect.setScale
local effect_setOffsetPosition = emptyEffect.setOffsetPosition
local effect_setOffsetRotation = emptyEffect.setOffsetRotation
effect_destroy(emptyEffect)

local function round(number)
    return math_floor(number + 0.5)
end

local function checkFont(lfont)
	if type(lfont) ~= "table" then
		error("the font should be a table", 3)
    end

    if lfont.mono or lfont.mono == nil then
        if type(lfont.chars) ~= "table" or (type(lfont.width) ~= "number") or (type(lfont.height) ~= "number") then
            error("invalid basic char data", 3)
        end
        
        if lfont.width > FONT_SIZE_LIMIT then
            error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
        elseif lfont.height > FONT_SIZE_LIMIT then
            error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
        end

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data ~= lfont.height then
                error("font failed integrity check", 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" then
                    error("the char string has the wrong type", 3)
                elseif #line ~= lfont.width then
                    print(char, #line, data)
                    error("the char string has the wrong lenght", 3)
                end
            end
        end
    else
        if type(lfont.chars) ~= "table" then
            error("font failed integrity check", 3)
        end

        local oFont = font.optimizeFont(lfont)
        lfont.spaceSize = oFont.spaceSize
        lfont.width = oFont.width
        lfont.height = oFont.height

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data > FONT_SIZE_LIMIT then
                error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" or #line > FONT_SIZE_LIMIT then
                    error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
                end
            end
        end
    end
end

local function tableClone(tbl)
    local newtbl = {}
    for k, v in pairs(tbl) do
        newtbl[k] = v
    end
    return newtbl
end

local function stackChecksum(stack)
    local num = -#stack
    local t, v
    for i = 1, #stack do
        v = stack[i]
        t = type(v)
        num = num - i
        if t == "number" then
            num = num + ((v * i) + v + i + (v / i))
        elseif t == "Color" then
            num = num + ((i * (v.r / i) * -4) + v.g)
            num = num - ((i * (v.g + i) * 5) + v.b)
            num = num + ((i * (v.b - i) * 8) + v.r)
        elseif t == "string" then
            for i3 = 1, #v do
                num = num + (i * (-i3 - (string_byte(v, i3) * i3)))
            end
        end
    end
    return num
end

local function checkArg(n, have, ...)
	have = type(have)
	local tbl = {...}
	for _, t in ipairs(tbl) do
		if have == t then
			return
		end
	end
	error(string_format("bad argument #%d (%s expected, got %s)", n, table_concat(tbl, " or "), have), 3)
end

local function simpleRemathRect(x, y, w, h, maxX, maxY)
    local x2, y2 = x + (w - 1), y + (h - 1)
    if x < 0 then
        x = 0
    elseif x > maxX then
        --x = maxX
        return
    end
    if y < 0 then
        y = 0
    elseif y > maxY then
        --y = maxY
        return
    end
    if x2 < 0 then
        --x2 = 0
        return
    elseif x2 > maxX then
        x2 = maxX
    end
    if y2 < 0 then
        --y2 = 0
        return
    elseif y2 > maxY then
        y2 = maxY
    end
    return x, y, x2, y2, w, h
end

local function remathRect(offset, stack, maxX, maxY)
    return simpleRemathRect(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], maxX, maxY)
end

local function posCheck(width, height, x, y)
    return x >= 0 and y >= 0 and x < width and y < height
end

local hashChar = string.byte("#")
local bit = bit or bit32
local band = bit.band
local rshift = bit.rshift
local function hexToRGB(color)
    return band(rshift(color, 16), 0xFF) / 255, band(rshift(color, 8), 0xFF) / 255, band(color, 0xFF) / 255
end

local function hexToRGB256(color)
    return band(rshift(color, 16), 0xFF), band(rshift(color, 8), 0xFF), band(color, 0xFF)
end

local function optimizationLevelToValue(level)
    return (level / 255) * 0.25
end

local function formatColor(color, default)
    local t = type(color)
    if t == "Color" then
        return color
    elseif t == "string" then
        return color_new(color)
    elseif t == "number" then
        return color_new(hexToRGB(color))
    end

    return default
end

local redMul = 256 * 256 * 256
local greenMul = 256 * 256
local blueMul = 256
local function formatColorToNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * redMul) + (math_floor(color.g * 255) * greenMul) + (math_floor(color.b * 255) * blueMul) + math_floor(color.a * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return val
        end
        return (val * 256) + 255
    elseif t == "number" then
        return (color * 256) + 255
    end

    return default or 0
end

local function formatColorToSmallNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * greenMul) + (math_floor(color.g * 255) * blueMul) + math_floor(color.b * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return math_floor(val / 256)
        end
        return val
    elseif t == "number" then
        return color
    end

    return default or 0
end

local function color_new_fromSmallNumber(number, alpha)
    return color_new((number * 256) + (alpha or 255))
end

local function mathDist(pos1, pos2)
    return math.sqrt(((pos1.x - pos2.x) ^ 2) + ((pos1.y - pos2.y) ^ 2) + ((pos1.z - pos2.z) ^ 2))
end

local function needPushStack(canvas, dataTunnel, dt) --returns true if the rendering stack should be applied
    return dataTunnel.display_forceFlush or not ((dataTunnel.skipAtNotSight and not canvas.isRendering()))
end

local resetViewportCodeID = -23124
local dataSizes = {
    [resetViewportCodeID] = 1,
    [-1] = 5,
    [0] = 2,
    3,
    6,
    7,
    9, --text
    7, --line
    5,
    5,
    5,
    6,

    4, --drawPoly
    4 --fillPoly
}

local userCalls = {}

canvasAPI.yield = function() end

function canvasAPI.createDrawer(sizeX, sizeY, callback, callbackBefore, directArg, direct_clear, direct_fill, direct_set, updatedList)
    local obj = {}
    local oldStackSum
    local rSizeX, rSizeY = sizeX, sizeY
    local maxX, maxY = sizeX - 1, sizeY - 1
    local newBuffer, newBufferBase = {}, 0
    local realBuffer = {}
    local maxBuffer = maxX + (maxY * sizeX)
    local currentFont = font.optimized
    local fontWidth, fontHeight = defaultFont.width, defaultFont.height
    local rotation = 0
    local utf8Support = false
    local updated = false
    local clearOnly = false
    local maxLineSize = sizeX + sizeY
    local bigSide = math_max(sizeX, sizeY)
    local drawerData = {}
    local changes = {}
    local _changes = {}
    local changesIndex, changesCount = {}, 0

    local bufferChangedFrom = huge
    local bufferChangedTo = -huge

    local function bufferRangeUpdate(index)
        if index < bufferChangedFrom then bufferChangedFrom = index end
        if index > bufferChangedTo then bufferChangedTo = index end
    end

    local viewportEnable = false
    local brightnessEnable = false
    local brightness = 1
    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local function setDot(px, py, col)
        if viewportEnable and (px < viewport_x or py < viewport_y or px >= (viewport_x + viewport_sx) or py >= (viewport_y + viewport_sy)) then
            return
        end

        --[[
        if rotation == 0 then
            index = px + (py * rSizeX)
        elseif rotation == 1 then
            index = (rSizeX - py - 1) + (px * rSizeX)
        elseif rotation == 2 then
            index = (rSizeX - px - 1) + ((rSizeY - py - 1) * rSizeX)
        else
            index = py + ((rSizeY - px - 1) * rSizeX)
        end
        ]]

        if brightnessEnable then
            local r = math_floor(col / 256 / 256) % 256
            local g = math_floor(col / 256) % 256
            local b = col % 256
            col = (math_min(255, math_floor(r * brightness)) * 256 * 256) + (math_min(255, math_floor(g * brightness)) * 256) + math_min(255, math_floor(b * brightness))
        end

        local index
        if rotation == 0 then
            index = py + (px * rSizeY)
        elseif rotation == 1 then
            index = px + ((rSizeX - py - 1) * rSizeY)
        elseif rotation == 2 then
            index = (rSizeY - py - 1) + ((rSizeX - px - 1) * rSizeY)
        else
            index = (rSizeY - px - 1) + (py * rSizeY)
        end

        if updatedList and not changes[index] then
            changes[index] = true
            changesCount = changesCount + 1
            changesIndex[changesCount] = index
        end

        if direct_set then
            newBuffer[index] = col
            direct_set(directArg, math_floor(index / rSizeY), index % rSizeY, col)
            return true
        elseif newBuffer[index] ~= col then
            bufferRangeUpdate(index)
            newBuffer[index] = col
            return true
        end
    end

    local function check(px, py)
        return px >= 0 and py >= 0 and px < sizeX and py < sizeY
    end

    local function checkSetDot(px, py, col)
        if check(px, py) then
            setDot(px, py, col)
            return true
        end
        return false
    end

    function obj.drawerReset()
    end

    function obj.setSoftwareRotation(_rotation)
        rotation = _rotation
        if rotation == 1 or rotation == 3 then
            sizeX = rSizeY
            sizeY = rSizeX
        else
            sizeX = rSizeX
            sizeY = rSizeY
        end
        maxX, maxY = sizeX - 1, sizeY - 1
    end

    function obj.setUtf8Support(state)
        utf8Support = not not state
    end

    function obj.setFont(customFont)
        if customFont then
            currentFont = customFont
            fontWidth, fontHeight = customFont.width, customFont.height
        else
            currentFont = font.optimized
            fontWidth, fontHeight = defaultFont.width, defaultFont.height
        end
    end

    local old_rotation
    local old_utf8support
    local old_customFont
    function obj.pushDataTunnelParams(params)
        brightness = params.brightness
        brightnessEnable = brightness ~= 1

        if params.rotation ~= old_rotation then
            obj.setSoftwareRotation(params.rotation)
            old_rotation = params.rotation
        end
        if params.utf8support ~= old_utf8support then
            obj.setUtf8Support(params.utf8support)
            old_utf8support = params.utf8support
        end
        if params.customFont ~= old_customFont then
            obj.setFont(params.customFont)
            old_customFont = params.customFont
        end
    end

    ------------------------------------------
    
    local function rasterize_fill(x, y, sx, sy, col)
        local x, y, x2, y2 = simpleRemathRect(x, y, sx, sy, maxX, maxY)
        if not x then return end
        for ix = x, x2 do
            for iy = y, y2 do
                setDot(ix, iy, col)
            end
        end
    end

    local function rasterize_circleF(px, py, r, col)
        local chr = r*r
        local sx, sy, tempInt, tempBool

        if r < bigSide and px >= 0 and py >= 0 and px < sizeX and py < sizeY then --now only a quarter of the circle is rendered
            for iy = 0, r do
                sy = iy + 0.5
                tempBool = false
                for ix = r, 0, -1 do
                    sx = ix + 0.5
                    if tempBool or (sx * sx) + (sy * sy) <= chr then
                        tempBool = true
                        checkSetDot(px + ix, py + iy, col)
                        checkSetDot(px - ix - 1, py + iy, col)
                        checkSetDot(px + ix, py - iy - 1, col)
                        checkSetDot(px - ix - 1, py - iy - 1, col)
                    end
                end
            end
        else
            for ix = math_max(-r, -px), math_min(r, (sizeX - px) - 1) do --if the starting point is not within the screen or the circle is too large, then will have to check every pixel
                sx = ix + 0.5
                for iy = math_max(-r, -py), math_min(r, (sizeY - py) - 1) do
                    sy = iy + 0.5
                    if (sx * sx) + (sy * sy) <= chr then
                        setDot(px + ix, py + iy, col)
                    end
                end
            end
        end
    end

    local function rasterize_line(px, py, px2, py2, col, width, linesInfo)
        local dx = math_abs(px2 - px)
        local dy = math_abs(py2 - py)
        local sx = (px < px2) and 1 or -1
        local sy = (py < py2) and 1 or -1
        local err = dx - dy
        local e2
        if width == -1 or width == 0 or width == 1 then
            for _ = 1, maxLineSize do
                checkSetDot(px, py, col)
                if px == px2 and py == py2 then
                    break
                end
                e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        elseif width < 0 then
            width = math_ceil((-width) / 2)
            if width < 1 then
                width = 1
            end
            for _ = 1, maxLineSize do
                rasterize_circleF(px, py, width, col)
                if px == px2 and py == py2 then
                    break
                end
                e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        else
            local offsetFill = math_floor(width / 2)
            for _ = 1, maxLineSize do
                rasterize_fill(px - offsetFill, py - offsetFill, width, width, col)
                if px == px2 and py == py2 then
                    break
                end
                e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        end
    end

    ------------------------------------------

    local function render_fill(stack, offset)
        local col = stack[offset+4]
        if direct_fill then
            direct_fill(directArg, stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], col)
        else
            local x, y, x2, y2 = remathRect(offset, stack, maxX, maxY)
            if not x then return end
            --[[
            for ix = x, x2 do
                for iy = y, y2 do
                    setDot(ix, iy, col)
                end
            end
            ]]
            local ix, iy = x, y
            for _ = 1, ((y2 - y) + 1) * ((x2 - x) + 1) do
                setDot(ix, iy, col)
                iy = iy + 1
                if iy > y2 then
                    iy = y
                    ix = ix + 1
                end
            end
        end
    end

    local function render_rect(stack, offset)
        local x, y, x2, y2, w, h = remathRect(offset, stack, maxX, maxY)
        if not x then return end
        local col = stack[offset+4]
        local lineWidth = stack[offset+5]
        if lineWidth == 1 then
            for ix = x, x2 do
                setDot(ix, y, col)
                setDot(ix, y2, col)
            end

            for iy = y + 1, y2 - 1 do
                setDot(x, iy, col)
                setDot(x2, iy, col)
            end
        else
            local _y, _y2, _x, _x2
            for ioff = 0, math_min(lineWidth, math_max(w, h) / 2) - 1 do
                _y = y + ioff
                _y2 = y2 - ioff
                for ix = x + ioff, x2 - ioff do
                    setDot(ix, _y, col)
                    setDot(ix, _y2, col)
                end

                _x = x + ioff
                _x2 = x2 - ioff
                for iy = y + 1 + ioff, y2 - (1 + ioff) do
                    setDot(_x, iy, col)
                    setDot(_x2, iy, col)
                end
            end
        end
    end

    local function render_text(stack, offset)
        local tx, ty = stack[offset], stack[offset+1]
        local text = stack[offset+2]
        local col = stack[offset+3]
        local scaleX = stack[offset+4]
        local scaleY = stack[offset+5]
        local spacing = stack[offset+6]
        local fontIndex = stack[offset+7]
        local chrdata

        local localFont = currentFont
        local localFontWidth = fontWidth
        if fontIndex > 0 and fontsOptimized[fontIndex] then
            localFont = fontsOptimized[fontIndex]
            localFontWidth = localFont.width
        end

        local px, py
        local len, sep
        if utf8Support then
            len, sep = utf8_len, utf8_sub
        else
            len, sep = string_len, string_byte
        end
        local lposX, lposY
        local char, charOffset
        local setPosX
        local scaledFontWidth = math_ceil(localFontWidth * scaleX)
        if localFont.mono then
            for i = 1, len(text) do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    charOffset = (i - 1) * (scaledFontWidth + spacing)
                    for i2 = 1, #chrdata, 2 do
                        px, py = chrdata[i2], chrdata[i2 + 1]
                        lposX, lposY = round(px * scaleX), round(py * scaleY)
                        for ix = 0, math_min(sizeX, round((px + 1) * scaleX) - lposX - 1) do
                            setPosX = tx + ix + lposX + charOffset
                            for iy = 0, math_min(sizeY, round((py + 1) * scaleY) - lposY - 1) do
                                checkSetDot(setPosX, ty + iy + lposY, col)
                            end
                        end
                    end
                end
            end
        else
            charOffset = 0
            local charPos
            local startDrawTime = os_clock()
            for i = 1, len(text) do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    charPos = tx + charOffset
                    if not chrdata[0] or charPos + round(chrdata[0] * scaleX) > 0 then
                        if charPos > maxX then
                            goto endDraw
                        end
                        for i2 = 1, #chrdata, 2 do
                            px, py = chrdata[i2], chrdata[i2 + 1]
                            lposX, lposY = round(px * scaleX), round(py * scaleY)
                            for ix = 0, math_min(sizeX, round((px + 1) * scaleX) - lposX - 1) do
                                setPosX = tx + ix + lposX + charOffset
                                for iy = 0, math_min(sizeY, round((py + 1) * scaleY) - lposY - 1) do
                                    checkSetDot(setPosX, ty + iy + lposY, col)
                                end
                            end
                        end
                    end
                    charOffset = charOffset + (chrdata[0] and math_ceil(chrdata[0] * scaleX) or 0) + spacing
                else
                    charOffset = charOffset + (localFont.spaceSize or localFontWidth) + spacing
                end
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
        end
        ::endDraw::
    end

    local function render_line(stack, offset)
        rasterize_line(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4], stack[offset+5])
    end

    local function render_circle(stack, offset) --Michener’s Algorithm
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx, py + dy, col)
            checkSetDot(px + dy, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy, col)
            checkSetDot(px + dy, py - dx, col)
            checkSetDot(px + dx, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleE(stack, offset)
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx - 1, py + dy - 1, col)
            checkSetDot(px + dy - 1, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy - 1, col)
            checkSetDot(px + dy - 1, py - dx, col)
            checkSetDot(px + dx - 1, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleF(stack, offset)
        rasterize_circleF(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3])
    end

    local function render_circleVE(stack, offset) --drawCircleVeryEvenly
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local chr = e2*e2
        local col = stack[offset+3]
        local sx, sy, tempInt, tempBool

        e2 = math_min(e2, bigSide)
        for iy = 0, e2 do
            sy = iy + 0.5
            tempInt = stack[offset+4]
            for ix = e2, 0, -1 do
                sx = ix + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
        for ix = 0, e2 do
            sx = ix + 0.5
            tempInt = stack[offset+4]
            for iy = e2, 0, -1 do
                sy = iy + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
    end

    local function render_drawPoly(stack, offset, linesInfo)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local startDrawTime = os_clock()
        local _px = stack[offset+3]
        local _py = stack[offset+4]
        local px, py
        for i = 3, points, 2 do
            px = stack[offset+2+i]
            py = stack[offset+3+i]
            rasterize_line(_px, _py, px, py, col, width, linesInfo)
            _px = px
            _py = py
            if os_clock() - startDrawTime > MAX_DRAW_TIME then
                goto endDraw
            end
        end
        rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width, linesInfo)

        ::endDraw::
        return points
    end

    local function render_fillPoly(stack, offset)
        local linesInfo = {}
        local points = render_drawPoly(stack, offset, linesInfo)

        return points
    end

    function obj.pushStack(stack)
        local offset = 2
        local actionNum
        local addValue = 0
        local startDrawTime = os_clock()
        local idx
        while stack[offset] do
            actionNum = stack[offset-1]
            clearOnly = actionNum == 0
            addValue = 0

            if actionNum == 0 then
                newBufferBase = stack[offset]
                newBuffer = {}
                if direct_clear then
                    direct_clear(directArg, newBufferBase, changes)
                else
                    bufferChangedFrom = 0
                    bufferChangedTo = maxBuffer
                end
                updated = true
            elseif actionNum == resetViewportCodeID then
                viewportEnable = false
            elseif actionNum == -1 then
                viewportEnable = true
                viewport_x = stack[offset]
                viewport_y = stack[offset+1]
                viewport_sx = stack[offset+2]
                viewport_sy = stack[offset+3]
            elseif actionNum == 1 then
                idx = stack[offset]
                setDot(idx % rSizeX, math_floor(idx / rSizeX), stack[offset+1])
                updated = true
            elseif actionNum == 2 then
                render_fill(stack, offset)
                updated = true
            elseif actionNum == 3 then
                render_rect(stack, offset)
                updated = true
            elseif actionNum == 4 then
                render_text(stack, offset)
                updated = true
            elseif actionNum == 5 then
                render_line(stack, offset)
                updated = true
            elseif actionNum == 6 then
                render_circle(stack, offset)
                updated = true
            elseif actionNum == 8 then
                render_circleE(stack, offset)
                updated = true
            elseif actionNum == 7 then
                render_circleF(stack, offset)
                updated = true
            elseif actionNum == 9 then
                render_circleVE(stack, offset)
                updated = true
            elseif actionNum == 10 then
                addValue = render_drawPoly(stack, offset)
                updated = true
            elseif actionNum == 11 then
                addValue = render_fillPoly(stack, offset)
                updated = true
            elseif userCalls[actionNum] then
                if userCalls[actionNum](newBuffer, rotation, rSizeX, rSizeY, sizeX, sizeY, stack, offset, drawerData, bufferRangeUpdate, setDot, checkSetDot) then
                    updated = true
                end
            end

            if os_clock() - startDrawTime > MAX_DRAW_TIME then
                goto endDraw
            end

            offset = offset + dataSizes[actionNum] + addValue
        end

        ::endDraw::
    end

    function obj.flush(force)
        if not obj.wait and (updated or force) then
            if force then
                bufferChangedFrom = 0
                bufferChangedTo = maxBuffer
            end
            if callbackBefore then
                if callbackBefore(newBufferBase, clearOnly, maxBuffer, force, newBuffer, realBuffer, bufferChangedFrom, bufferChangedTo, changes, changesIndex, changesCount, _changes) then
                    realBuffer = {}
                end
            end
            if callback then
                local color, px, py
                for i = bufferChangedFrom, bufferChangedTo do
                    color = newBuffer[i] or newBufferBase
                    if color ~= realBuffer[i] or force then
                        px = math_floor(i / rSizeY)
                        py = i % rSizeY
                        callback(px, py, color, newBufferBase)
                        realBuffer[i] = color
                    end
                end
            end
            bufferChangedFrom = huge
            bufferChangedTo = -huge
            updated = false
            if updatedList then
                changes = {}
                changesIndex = {}
                changesCount = 0
            end
        end
    end

    function obj.setWait(state)
        obj.wait = state
        if not state then
            obj.flush()
        end
    end

    function obj.getNewBuffer(i)
        return newBuffer[i] or newBufferBase
    end

    function obj.getRealBuffer(i)
        return realBuffer[i]
    end

    function obj.getChanges()
        return changes
    end

    function obj.fullRefresh()
        changesCount = 0
        changesIndex = {}
        for i = 0, (sizeX * sizeY) - 1 do
            changes[i] = true
            changesCount = changesCount + 1
            changesIndex[changesCount] = i
        end
    end

    function obj.flushOldChanges()
        _changes = changes
    end

    function obj.clearChangesBuffer()
        _changes = {}
        changes = {}
    end

    return obj
end

if better and better.isAvailable() and better.canvas and better.version >= 40 then
    local better_canvas_clear = better.canvas.clear
    local better_canvas_fill = better.canvas.fill
    local better_canvas_set = better.canvas.set

    function canvasAPI.createBetterCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation)
        local obj = {sizeX = sizeX, sizeY = sizeY}
        local maxX, maxY = sizeX - 1, sizeY - 1
        local maxEffectArrayBuffer = maxX + (maxY * sizeX)
        local dist
        local needOptimize = false
        local showState = false
        local disable = false
        local flushedDefault = false

        local betterCanvas = better.canvas.create(sizeX, sizeY)

        local drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, nil, betterCanvas, better_canvas_clear, better_canvas_fill, better_canvas_set)
        drawer.setWait(true)

        local function getSelfPos()
            local pt = type(parent)
            if pt == "Interactable" then
                return parent.shape.worldPosition
            elseif pt == "Character" then
                return parent.worldPosition
            end
        end

        function obj.isRendering()
            return showState
        end

        function obj.disable(state)
            disable = state
        end

        function obj.setRenderDistance(_dist)
            dist = _dist
        end

        function obj.update()
            local newShowState = true
            local selfPosition
            if disable then
                newShowState = false
            elseif dist then
                if not pcall(function()
                    selfPosition = getSelfPos()
                    newShowState = mathDist(selfPosition, sm_localPlayer_getPlayer().character.worldPosition) <= dist
                end) then
                    selfPosition = selfPosition or vec3_new(0, 0, 0)
                    newShowState = false
                end
            end

            if newShowState ~= showState then
                showState = newShowState
                if newShowState then
                    drawer.setWait(false)
                    if not flushedDefault then
                        drawer.flush(true)
                        flushedDefault = true
                    end
                else
                    drawer.setWait(true)
                    better.canvas.stopUpdate(betterCanvas)
                end
            end

            if newShowState then
                better.canvas.update_3d(betterCanvas, selfPosition + (rotation * offset), -sm.quat.getRight(rotation), -sm.quat.getUp(rotation), (pixelSize.x * sizeX) / 2, (pixelSize.y * sizeY) / 2)
            end
        end

        function obj.setPixelSize(_pixelSize)
            pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
            if type(pixelSize) == "number" then
                if pixelSize < 0 then
                    pixelSize = math_abs(pixelSize)
                    local vec = vec3_new(pixelSize, pixelSize, 0)
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                else
                    local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                end
            end
        end

        function obj.setOffset(_offset)
            offset = _offset
        end

        function obj.setCanvasRotation(_rotation)
            rotation = _rotation
        end

        function obj.destroy()
            better.canvas.destroy(betterCanvas)
        end

        ---------------------------------------

        obj.setPixelSize(pixelSize)
        obj.setCanvasRotation(rotation or quat_fromEuler(vec3_new(0, 0, 0)))
        obj.setOffset(offset or vec3_new(0, 0, 0))

        --[[
        local c = 0xff0000
        local seffect = createEffect(5, 5, 16, 16, c)
        local idx = 5 + (5 * sizeX)
        for i = 0, 16 - 1 do
            effects[idx + i] = {
                seffect,
                c,
                i,
                16,
                idx,
                5,
                5,
                1, --8. sizeY
                0 --9. indexY
            }
        end
        ]]

        ---------------------------------------

        obj.drawer = drawer
        for k, v in pairs(drawer) do
            obj[k] = v
        end

        return obj
    end
end

--low level display api
function canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material, scaleAddValue)
    local hiddenOffset = vec3_new(1000000, 1000000, 1000000)
    local obj = {sizeX = sizeX, sizeY = sizeY}
    local maxX, maxY = sizeX - 1, sizeY - 1
    local maxEffectArrayBuffer = maxX + (maxY * sizeX)
    local dist
    local needOptimize = false
    local showState = false
    local disable = false
    local colorCache = {}

    material = material or canvasAPI.material.classic
    local autoScaleAddValue = false
    if not scaleAddValue then
        autoScaleAddValue = true
    end

    local flushedDefault = false
    local oldBackplateColor
    local backplate
    if canvasAPI.multi_layer[tostring(material)] then
        oldBackplateColor = 0
        backplate = sm_effect_createEffect(getEffectName(), parent)
        effect_setParameter(backplate, "uuid", material)
        effect_setParameter(backplate, "color", black)
    end

    local effects = {}
    local nodeEffects = {}
    local effectDatas = {}
    local effectDataLen = 5

    local bufferedEffects = {}
    local bufferedEffectsIndex = 0
    local lastDrawTickTime
    local optimizationLevel = 16
    local optimizationValue = optimizationLevelToValue(optimizationLevel)
    local alpha = DEFAULT_ALPHA_VALUE

    local function getEIndex(index)
        return index * effectDataLen
    end

    local function fromEIndex(index)
        return index / effectDataLen
    end

    local function setEffectDataParams(index)
        local effect = nodeEffects[index]
        local eindex = getEIndex(index)
        local posX, posY, lSizeX, lSizeY = effectDatas[eindex+1], effectDatas[eindex+2], effectDatas[eindex+3], effectDatas[eindex+4]

        posX = posX + ((lSizeX - 1) * 0.5)
        posY = posY + ((lSizeY - 1) * 0.5)
        effect_setOffsetPosition(effect, rotation * (offset + vec3_new(((posX + 0.5) - (sizeX / 2)) * pixelSize.x, ((posY + 0.5) - (sizeY / 2)) * -pixelSize.y, backplate and (debugMode and 0.05 or 0.001) or 0)))

        local localScaleAddValue = debugMode and -(pixelSize.x / 2) or scaleAddValue
        local vec = pixelSize * 1
        vec.x = (pixelSize.x * lSizeX) + localScaleAddValue
        vec.y = (pixelSize.y * lSizeY) + localScaleAddValue
        effect_setScale(effect, vec)
    end

    local function createEffect()
        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            effect_setOffsetRotation(effect, rotation)
        end
        return effect
    end

    local function clearBufferedEffects()
        for i = 1, bufferedEffectsIndex do
            effect_destroy(bufferedEffects[i])
        end
        bufferedEffects = {}
        bufferedEffectsIndex = 0
    end

    local lastNewBuffer, lastBase

    local lastPopularColorTick, lastPopularColor
    local lastPopularColorUpdatePerTick = (sizeX * sizeY) / 256
    local function mathPopularColor()
        local oldLastPopularColor = lastPopularColor

        local colorUsesTable = {}
        local colorUses = 0
        local oldColorUses = 0
        local colorSum = 0
        for index in pairs(nodeEffects) do
            local eindex = getEIndex(index)
            local color = effectDatas[eindex]
            local colorSize = effectDatas[eindex+3] * effectDatas[eindex+4]
            colorUsesTable[color] = (colorUsesTable[color] or 0) + colorSize
            colorSum = colorSum + colorSize
            colorUses = colorUsesTable[color]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = color
            end
        end

        if oldBackplateColor then
            local colorSize = (sizeX * sizeY) - colorSum
            colorUsesTable[oldBackplateColor] = (colorUsesTable[oldBackplateColor] or 0) + colorSize
            colorUses = colorUsesTable[oldBackplateColor]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = oldBackplateColor
            end
        end

        if oldLastPopularColor and colorUses < 4 then
            lastPopularColor = oldLastPopularColor
        else
            lastPopularColorTick = sm.game.getCurrentTick()
        end
    end

    local function effectIndexAtPos(px, py)
        return py + (px * sizeY)
    end

    local function getRootEIndexAtPos(px, py)
        if py < 0 or py >= sizeY then return end
        local index = effects[effectIndexAtPos(px, py)]
        return index and getEIndex(index), index
    end

    local function clearEffectFromBuffer(index)
        local eindex = getEIndex(index)
        local six, ix, iy = effectDatas[eindex+1], effectDatas[eindex+1], effectDatas[eindex+2]
        local sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        nodeEffects[index] = nil
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix >= six + sizeX then
                ix = six
                iy = iy + 1
            end
        end
    end

    local function hideEffect(effect)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        effect_setOffsetPosition(effect, hiddenOffset)
    end

    local function hideEffectData(index)
        hideEffect(nodeEffects[index])
        clearEffectFromBuffer(index)
    end

    local function hideEffectsWithColor(color)
        for index in pairs(nodeEffects) do
            if effectDatas[getEIndex(index)] == color then
                hideEffectData(index)
            end
        end
    end

    local function delAllEffects()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        effects = {}
        nodeEffects = {}
    end

    --[[
    local function forceRecreateNodeEffects()
        nodeEffects = {}
        for i, effectData in pairs(effects) do
            if effectData[7] == i then
                nodeEffects[i] = effectData
            end
        end
    end
    ]]

    local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
    local function colorEquals_smart(color1, color2)
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    local function extractVerticleLine(changedList, changedColorList, index, px, py, saveExtractionLine)
        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local lx = px - rpx
        if lx == 0 then --extract first line
            changedList[rindex] = nil
            changedColorList[rindex] = nil

            local newRIndex = effectIndexAtPos(rpx + 1, rpy)
            local newEIndex = getEIndex(newRIndex)
            effectDatas[newEIndex] = effectDatas[eindex]
            effectDatas[newEIndex+1] = rpx + 1
            effectDatas[newEIndex+2] = rpy
            effectDatas[newEIndex+3] = rsx - 1
            effectDatas[newEIndex+4] = rsy

            nodeEffects[newRIndex] = nodeEffects[rindex]
            nodeEffects[rindex] = nil

            local fillX1, fillY1 = rpx + 1, rpy
            local fillX2, fillY2 = fillX1 + (rsx - 2), fillY1 + (rsy - 1)
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = newRIndex
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end

            changedList[newRIndex] = true
            changedColorList[newRIndex] = true
        elseif lx == rsx - 1 then --extract last line
            changedList[rindex] = true
            effectDatas[eindex+3] = lx
        else --extract center line
            changedList[rindex] = true
            effectDatas[eindex+3] = lx

            local posX = rpx + lx + 1
            local sizeX = rsx - lx - 1
            local newRIndex = effectIndexAtPos(posX, rpy)
            local newEIndex = getEIndex(newRIndex)
            effectDatas[newEIndex] = effectDatas[eindex]
            effectDatas[newEIndex+1] = posX
            effectDatas[newEIndex+2] = rpy
            effectDatas[newEIndex+3] = sizeX
            effectDatas[newEIndex+4] = rsy

            nodeEffects[newRIndex] = createEffect()

            local fillX1, fillY1 = posX, rpy
            local fillX2, fillY2 = fillX1 + (sizeX - 1), fillY1 + (rsy - 1)
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = newRIndex
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end

            changedList[newRIndex] = true
            changedColorList[newRIndex] = true
        end

        local newRIndex = effectIndexAtPos(px, rpy)
        if saveExtractionLine then
            local newEIndex = getEIndex(newRIndex)

            effectDatas[newEIndex] = effectDatas[eindex]
            effectDatas[newEIndex+1] = px
            effectDatas[newEIndex+2] = rpy
            effectDatas[newEIndex+3] = 1
            effectDatas[newEIndex+4] = rsy

            nodeEffects[newRIndex] = createEffect()
            for i = newRIndex, newRIndex + (rsy - 1) do
                effects[i] = newRIndex
            end
        else
            nodeEffects[newRIndex] = nil
            for i = newRIndex, newRIndex + (rsy - 1) do
                effects[i] = nil
            end
        end
    end

    local function extractVerticlePixel(changedList, changedColorList, index, px, py)
        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local ly = py - rpy
        if ly == 0 then --extract first pixel
            changedList[rindex] = nil
            changedColorList[rindex] = nil

            local newRIndex = rindex + 1
            local newEIndex = getEIndex(newRIndex)

            nodeEffects[newRIndex] = nodeEffects[rindex]
            nodeEffects[rindex] = nil

            changedList[newRIndex] = true
            changedColorList[newRIndex] = true
            
            effectDatas[newEIndex] = effectDatas[eindex]
            effectDatas[newEIndex+1] = rpx
            effectDatas[newEIndex+2] = rpy + 1
            effectDatas[newEIndex+3] = rsx
            effectDatas[newEIndex+4] = rsy - 1

            effects[rindex] = nil
            for i = newRIndex, newRIndex + (rsy - 2) do
                effects[i] = newRIndex
            end
        elseif ly == rsy - 1 then --extract last pixel
            changedList[rindex] = true
            changedColorList[rindex] = true
            effectDatas[eindex+4] = ly
            effects[effectIndexAtPos(rpx, rpy + (rsy - 1))] = nil
        else --extract center pixel
            changedList[rindex] = true
            changedColorList[rindex] = true
            effectDatas[eindex+4] = ly
            effects[effectIndexAtPos(rpx, rpy + ly)] = nil

            local newRIndex = rindex + ly + 1
            local newEIndex = getEIndex(newRIndex)

            local sy = rsy - ly - 1
            effectDatas[newEIndex] = effectDatas[eindex]
            effectDatas[newEIndex+1] = rpx
            effectDatas[newEIndex+2] = rpy + ly + 1
            effectDatas[newEIndex+3] = rsx
            effectDatas[newEIndex+4] = sy

            nodeEffects[newRIndex] = createEffect()
            changedList[newRIndex] = true
            changedColorList[newRIndex] = true

            for i = newRIndex, newRIndex + (sy - 1) do
                effects[i] = newRIndex
            end
        end
    end

    local function fillBlock(x, y, sx, sy, changedList, changedColorList, color, iterate)
        if sx <= 0 or sy <= 0 then
            return
        end

        local newRIndex = effectIndexAtPos(x, y)
        nodeEffects[newRIndex] = createEffect()
        changedList[newRIndex] = true
        changedColorList[newRIndex] = true

        local newEIndex = getEIndex(newRIndex)
        effectDatas[newEIndex] = color
        effectDatas[newEIndex+1] = x
        effectDatas[newEIndex+2] = y
        effectDatas[newEIndex+3] = sx
        effectDatas[newEIndex+4] = sy

        if not iterate then
            return
        end
        
        local ix, iy = x, y
        local six = ix
        local mix = six + sx
        for _ = 1, sx * sy do
            effects[effectIndexAtPos(ix, iy)] = newRIndex
            ix = ix + 1
            if ix >= mix then
                ix = six
                iy = iy + 1
            end
        end
    end

    local function extractPixel(changedList, changedColorList, index, px, py)
        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local lx = px - rpx
        local ly = py - rpy

        --extractVerticleLine(changedList, changedColorList, index, px, py, true)
        --extractVerticlePixel(changedList, changedColorList, index, px, py)

        changedList[rindex] = nil
        changedColorList[rindex] = nil
        effects[index] = nil
        hideEffect(nodeEffects[rindex])
        nodeEffects[rindex] = nil

        local color = effectDatas[eindex]
        fillBlock(rpx, rpy, lx, rsy, changedList, changedColorList, color, false)
        fillBlock(rpx + lx + 1, rpy, rsx - lx - 1, rsy, changedList, changedColorList, color, true)
        fillBlock(rpx + lx, rpy, 1, ly, changedList, changedColorList, color, true)
        fillBlock(rpx + lx, rpy + ly + 1, 1, rsy - ly - 1, changedList, changedColorList, color, true)
    end

    local function getFillZone(eindex)
        local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
        return fillX1, fillY1, fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
    end

    local function tryAttach(changedList, changedColorList, index, px, py, color)
        local attached = false

        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        local origEffect
        if origIndex then
            origEffect = nodeEffects[origIndex]
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local downParentE, downParent = getRootEIndexAtPos(px, py + sizeY)
        local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)
        local downAvailable = downParentE and nodeEffects[downParent] and effectDatas[downParentE+1] == px and effectDatas[downParentE+3] == sizeX and colorEquals(effectDatas[downParentE], color)

        local fillOptional = false
        local fillX1, fillY1, fillX2, fillY2
        local fill2X1, fill2Y1, fill2X2, fill2Y2

        if origEffect and (upAvailable or downAvailable) then
            hideEffect(origEffect)
            changedList[origIndex] = nil
            changedColorList[origIndex] = nil
            nodeEffects[origIndex] = nil
        end

        local newIndex, newEIndex
        local fillVal
        if upAvailable and downAvailable then
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

            local addSizeY = sizeY + effectDatas[downParentE+4]

            hideEffect(nodeEffects[downParent])
            changedList[downParent] = nil
            changedColorList[downParent] = nil
            nodeEffects[downParent] = nil

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + addSizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
            attached = true
        elseif upAvailable then
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
            attached = true
        elseif downAvailable then
            fillOptional = true
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

            changedList[downParent] = nil
            changedColorList[downParent] = nil

            nodeEffects[index] = nodeEffects[downParent]
            nodeEffects[downParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[downParentE]
            effectDatas[eindex+1] = effectDatas[downParentE+1]
            effectDatas[eindex+2] = py
            effectDatas[eindex+3] = effectDatas[downParentE+3]
            effectDatas[eindex+4] = effectDatas[downParentE+4] + sizeY
            
            newIndex, newEIndex = index, eindex
            fillVal = index
            attached = true
        end

        if attached then
            index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
            sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
        end

        local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
        local rightParentE, rightParent = getRootEIndexAtPos(px + sizeX, py)
        local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
        local rightAvailable = rightParentE and nodeEffects[rightParent] and effectDatas[rightParentE+2] == py and effectDatas[rightParentE+4] == sizeY and colorEquals(effectDatas[rightParentE], color)

        if nodeEffects[index] and (leftAvailable or rightAvailable) then
            hideEffect(nodeEffects[index])
            changedList[index] = nil
            changedColorList[index] = nil
            nodeEffects[index] = nil
        end

        if leftAvailable and rightAvailable then
            fillOptional = false
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

            local addSizeX = sizeX + effectDatas[rightParentE+3]

            hideEffect(nodeEffects[rightParent])
            changedList[rightParent] = nil
            changedColorList[rightParent] = nil
            nodeEffects[rightParent] = nil

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + addSizeX
            fillVal = leftParent
            attached = true
        elseif leftAvailable then
            fillOptional = false
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = nil, nil, nil, nil

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
            fillVal = leftParent
            attached = true
        elseif rightAvailable then
            fillOptional = not upAvailable and not downAvailable
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

            changedList[rightParent] = nil
            changedColorList[rightParent] = nil

            nodeEffects[index] = nodeEffects[rightParent]
            nodeEffects[rightParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[rightParentE]
            effectDatas[eindex+1] = px
            effectDatas[eindex+2] = effectDatas[rightParentE+2]
            effectDatas[eindex+3] = sizeX + effectDatas[rightParentE+3]
            effectDatas[eindex+4] = effectDatas[rightParentE+4]
            
            fillVal = index
            attached = true
        end

        if fillVal then
            changedList[fillVal] = true
            changedColorList[fillVal] = true

            --[[
            local eindex = getEIndex(fillVal)
            local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
            local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = fillVal
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            ]]

            --fillOptional = false
            if not fillOptional or not origEffect then
                local ix, iy = fillX1, fillY1
                for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = fillVal
                    ix = ix + 1
                    if ix > fillX2 then
                        ix = fillX1
                        iy = iy + 1
                    end
                end
            --[[else
                local ix, iy = fillX1, fillY1
                for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                    if fillVal ~= effects[effectIndexAtPos(ix, iy)] then
                        print("WTTT", fillVal, effects[effectIndexAtPos(ix, iy)])
                    end
                    ix = ix + 1
                    if ix > fillX2 then
                        ix = fillX1
                        iy = iy + 1
                    end
                end
                ]]
            end

            if fill2X1 then
                local ix, iy = fill2X1, fill2Y1
                for _ = 1, ((fill2X2 - fill2X1) + 1) * ((fill2Y2 - fill2Y1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = fillVal
                    ix = ix + 1
                    if ix > fill2X2 then
                        ix = fill2X1
                        iy = iy + 1
                    end
                end
            end
        end

        return attached
    end

    local function fillEmptySpace(color)
        local changedList = {}
        local changedColorList = {}
        
        for i = 0, maxEffectArrayBuffer do
            local px = math_floor(i / sizeY)
            local py = i % sizeY
            if not effects[i] and not tryAttach(changedList, i, px, py, color) then
                local effect = createEffect()
                local effectData = {
                    effect,
                    color,
                    px, --3. root pos x
                    py, --4. root pos Y
                    1,  --5. sizeX
                    1,  --6. sizeY
                    i   --7. root index
                }
                effects[i] = effectData
                changedList[effectData] = true
                changedColorList[effect] = effectData
            end
        end

        for effectData in pairs(changedList) do
            setEffectDataParams(effectData)
        end

        for _, effectData in pairs(changedColorList) do
            local color = effectData[2]
            if not colorCache[color] then
                colorCache[color] = color_new_fromSmallNumber(color, alpha)
            end
            effect_setParameter(effectData[1], "color", colorCache[color])
        end
    end

    local function isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, forDestroy)
        local effectID = nodeEffects[rindex].id
        if fullChecked[effectID] then
            return false
        end
        fullChecked[effectID] = true

        local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
        local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
        local baseColor

        local ix, iy = fillX1, fillY1
        for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
            local color = lastNewBuffer[effectIndexAtPos(ix, iy)] or lastBase
            baseColor = baseColor or color
            if color ~= baseColor then
                return false
            end
            ix = ix + 1
            if ix > fillX2 then
                ix = fillX1
                iy = iy + 1
            end
        end

        ix, iy = fillX1, fillY1
        if not forDestroy then
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                local index = effectIndexAtPos(ix, iy)
                _changes[index] = true
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
        end

        return true
    end

    local clearBackplate = false
    local drawer
    drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, function (base, clearOnly, maxBuffer, force, newBuffer, realBuffer, bufferChangedFrom, bufferChangedTo, changes, changesIndex, changesCount, _changes)
        lastNewBuffer, lastBase = newBuffer, base
        lastDrawTickTime = sm.game.getCurrentTick()

        if clearOnly then
            delAllEffects()
            clearBufferedEffects()
            drawer.clearChangesBuffer()
            return
        end

        local changedList = {}
        local changedColorList = {}
        local fullChecked = {}

        if clearBackplate then
            for index in pairs(_changes) do
                if not changes[index] then
                    changesCount = changesCount + 1
                    changesIndex[changesCount] = index
                    changes[index] = true
                end
            end
        end

        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            if changes[index] then
                local color = newBuffer[index] or base
                local rindex = effects[index]
                if rindex then
                    local eindex = getEIndex(rindex)
                    if not colorEquals(effectDatas[eindex], color) then
                        local px = math_floor(index / sizeY)
                        local py = index % sizeY
                        local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
                        if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, color == oldBackplateColor) then
                            if color == oldBackplateColor then
                                changedList[rindex] = nil
                                changedColorList[rindex] = nil
                                hideEffectData(rindex)
                            elseif not tryAttach(changedList, changedColorList, index, px, py, color) then
                                effectDatas[eindex] = color
                                changedColorList[rindex] = true
                            end
                        elseif color == oldBackplateColor then
                            if aSizeX and aSizeY then
                                extractPixel(changedList, changedColorList, index, px, py)
                            elseif aSizeX then
                                extractVerticleLine(changedList, changedColorList, index, px, py)
                            elseif aSizeY then
                                extractVerticlePixel(changedList, changedColorList, index, px, py)
                            else
                                changedList[rindex] = nil
                                changedColorList[rindex] = nil
                                hideEffectData(rindex)
                            end
                        else
                            _changes[index] = true

                            if aSizeX and aSizeY then
                                extractPixel(changedList, changedColorList, index, px, py)
                            elseif aSizeX then
                                extractVerticleLine(changedList, changedColorList, index, px, py)
                            elseif aSizeY then
                                extractVerticlePixel(changedList, changedColorList, index, px, py)
                            end

                            if not tryAttach(changedList, changedColorList, index, px, py, color) then
                                local eindex = getEIndex(index)
                                if nodeEffects[index] then
                                    effectDatas[eindex] = color
                                    changedColorList[index] = true
                                else
                                    local effect = createEffect()

                                    nodeEffects[index] = effect
                                    effects[index] = index

                                    effectDatas[eindex] = color
                                    effectDatas[eindex+1] = px
                                    effectDatas[eindex+2] = py
                                    effectDatas[eindex+3] = 1
                                    effectDatas[eindex+4] = 1
                                    
                                    changedList[index] = true
                                    changedColorList[index] = true
                                end
                            end
                        end
                    end
                elseif color ~= oldBackplateColor then
                    _changes[index] = true
                    local px = math_floor(index / sizeY)
                    local py = index % sizeY
                    if not tryAttach(changedList, changedColorList, index, px, py, color) then
                        local effect = createEffect()

                        nodeEffects[index] = effect
                        effects[index] = index

                        local eindex = getEIndex(index)
                        effectDatas[eindex] = color
                        effectDatas[eindex+1] = px
                        effectDatas[eindex+2] = py
                        effectDatas[eindex+3] = 1
                        effectDatas[eindex+4] = 1
                        
                        changedList[index] = true
                        changedColorList[index] = true
                    end
                end
            end
        end

        for index in pairs(changedList) do
            setEffectDataParams(index)
        end

        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            if not colorCache[color] then
                colorCache[color] = color_new_fromSmallNumber(color, alpha)
            end
            effect_setParameter(nodeEffects[index], "color", colorCache[color])
        end

        if clearBackplate then
            drawer.flushOldChanges()
            clearBackplate = false
        end

        needOptimize = true
    end, nil, function (_, color, changes)
        if backplate then
            oldBackplateColor = color
            effect_setParameter(backplate, "color", color_new_fromSmallNumber(color, alpha))
            clearBackplate = true
        else
            drawer.fullRefresh()
        end
    end, nil, nil, true)

    if not backplate then
        drawer.fullRefresh()
    end

    drawer.setWait(true)


    local function getSelfPos()
        local pt = type(parent)
        if pt == "Interactable" then
            return parent.shape.worldPosition
        elseif pt == "Character" then
            return parent.worldPosition
        end
    end

    local reoptimizeCanvas = sizeX * sizeY <= (256 * 256)
    if debugMode then
        print("reoptimizeCanvas", sizeX, sizeY, reoptimizeCanvas)
    end

    local function optimize()
        if reoptimizeCanvas then
            if debugMode then
                print("reoptimize canvas")
            end

            if backplate then
                mathPopularColor()
                if lastPopularColor ~= oldBackplateColor then
                    effect_setParameter(backplate, "color", color_new_fromSmallNumber(lastPopularColor, alpha))
                    oldBackplateColor = lastPopularColor
                end
            end
            
            for i, effect in pairs(nodeEffects) do
                hideEffect(effect)
            end
            effects = {}
            nodeEffects = {}
            effectDatas = {}

            local changedList = {}
            local changedColorList = {}

            for index = 0, maxEffectArrayBuffer do
                local px = math_floor(index / sizeY)
                local py = index % sizeY
                local color = lastNewBuffer[index] or lastBase
                local eindex = getEIndex(index)
                if not effects[index] and color ~= oldBackplateColor and not tryAttach(changedList, changedColorList, index, px, py, color) then
                    local effect = createEffect()

                    nodeEffects[index] = effect
                    effects[index] = index
    
                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = 1
                    effectDatas[eindex+4] = 1
                    
                    changedList[index] = true
                    changedColorList[index] = true
                end
            end

            for index in pairs(changedList) do
                setEffectDataParams(index)
            end

            for index in pairs(changedColorList) do
                local color = effectDatas[getEIndex(index)]
                if not colorCache[color] then
                    colorCache[color] = color_new_fromSmallNumber(color, alpha)
                end
                effect_setParameter(nodeEffects[index], "color", colorCache[color])
            end
        end

        ------------------------------------------

        if bufferedEffectsIndex > 1024 then
            if debugMode then
                print("stoping buffered effects")
            end

            for i = 1, bufferedEffectsIndex - 1024 do
                effect_stop(bufferedEffects[i])
            end

            --[[
            if bufferedEffectsIndex > 3000 then
                if debugMode then
                    print("destroy buffered effects")
                end

                for i = 3001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                end
                bufferedEffectsIndex = 3000
            end
            ]]
        end
    end

    function obj.setAlpha(_alpha)
        alpha = _alpha
        for rindex, effect in pairs(nodeEffects) do
            effect_setParameter(effect, "color", color_new_fromSmallNumber(effectDatas[getEIndex(rindex)], alpha))
        end
    end

    function obj.setOptimizationLevel(value)
        optimizationLevel = value
        if value == 0 then
            colorEquals = colorEquals_raw
        else
            colorEquals = colorEquals_smart
        end
        optimizationValue = optimizationLevelToValue(optimizationLevel)
    end

    function obj.isRendering()
        return showState
    end

    function obj.disable(state)
        disable = state
    end

    function obj.setRenderDistance(_dist)
        dist = _dist
    end

    local oldOptimizeTime
    function obj.update()
        local newShowState = true
        if disable then
            newShowState = false
        elseif dist then
            if not pcall(function()
                newShowState = mathDist(getSelfPos(), sm_localPlayer_getPlayer().character.worldPosition) <= dist
            end) then
                newShowState = false
            end
        end

        if newShowState ~= showState then
            showState = newShowState
            if newShowState then
                drawer.setWait(false)
                if not backplate and not flushedDefault then
                    drawer.flush(true)
                    flushedDefault = true
                end
                for _, effect in pairs(nodeEffects) do
                    if not effect_isPlaying(effect) then
                        effect_start(effect)
                    end
                end
                if backplate then
                    effect_start(backplate)
                end
            else
                for _, effect in pairs(nodeEffects) do
                    effect_stop(effect)
                end
                for i = 1, bufferedEffectsIndex do
                    effect_stop(bufferedEffects[i])
                end
                if backplate then
                    effect_stop(backplate)
                end
                drawer.setWait(true)
            end
        end

        local ctick = sm.game.getCurrentTick()
        local optimizePeer = 40
        if lastDrawTickTime and ctick - lastDrawTickTime < 20 then
            optimizePeer = 80
        end

        if newShowState and needOptimize and (not oldOptimizeTime or ctick - oldOptimizeTime >= optimizePeer) then
            needOptimize = false
            oldOptimizeTime = ctick
            optimize()
        end
    end

    function obj.setPixelSize(_pixelSize)
        pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
        if type(pixelSize) == "number" then
            if pixelSize < 0 then
                pixelSize = math_abs(pixelSize)
                local vec = vec3_new(pixelSize, pixelSize, 0)
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            else
                local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            end
        end
        if backplate then
            effect_setScale(backplate, vec3_new((pixelSize.x * sizeX) - 0.00005, (pixelSize.y * sizeY) - 0.00005, pixelSize.z))
        end
        if autoScaleAddValue then
            scaleAddValue = math.min((pixelSize.x + pixelSize.y + pixelSize.z) / 50, 0.0001)
        end
        --scaleAddValue = -0.003
    end

    function obj.setOffset(_offset)
        offset = _offset
        if backplate then
            effect_setOffsetPosition(backplate, rotation * offset)
        end
        for index in pairs(nodeEffects) do
            setEffectDataParams(index)
        end
    end

    function obj.setCanvasRotation(_rotation)
        rotation = _rotation
        if backplate then
            effect_setOffsetRotation(backplate, rotation)
        end
        for index, effect in pairs(nodeEffects) do
            effect_setOffsetRotation(effect, rotation)
            setEffectDataParams(index)
        end
    end

    function obj.destroy()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        if backplate then
            effect_destroy(backplate)
        end
    end

    ---------------------------------------

    obj.setPixelSize(pixelSize)
    obj.setCanvasRotation(rotation or quat_fromEuler(vec3_new(0, 0, 0)))
    obj.setOffset(offset or vec3_new(0, 0, 0))

    ---------------------------------------

    obj.drawer = drawer
    for k, v in pairs(drawer) do
        obj[k] = v
    end

    function obj.pushDataTunnelParams(dataTunnel)
        obj.setOptimizationLevel(dataTunnel.optimizationLevel)
        obj.setAlpha(dataTunnel.light)
        drawer.pushDataTunnelParams(dataTunnel)
    end

    return obj
end

--simulates the API of screens from SComputers on the client side of your parts
function canvasAPI.createClientScriptableCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local dataTunnel = {}
    local canvas = canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local api = canvasAPI.createScriptableApi(sizeX, sizeY, dataTunnel, nil, canvas.drawer)
    api.registerClick = canvasAPI.addTouch(api, dataTunnel)
    api.dataTunnel = dataTunnel
    api.canvas = canvas

    local renderDistance = 15

    for k, v in pairs(canvas) do
        if k ~= "flush" then
            api[k] = v
        end
    end

    function api.getAudience()
        return canvas.isRendering() and 1 or 0
    end

    function api.update(dt)
        canvas.disable(not api.isAllow())
        if dataTunnel.renderAtDistance then
            canvas.setRenderDistance()
        else
            canvas.setRenderDistance(renderDistance)
        end
        canvas.pushDataTunnelParams(dataTunnel)
        canvas.update()
        dataTunnel.scriptableApi_update()

        if dataTunnel.display_reset then
            canvas.drawerReset()
            dataTunnel.display_reset = nil
        end

        if dataTunnel.display_flush then
            if needPushStack(canvas, dataTunnel, dt) then
                canvas.pushStack(dataTunnel.display_stack)
                canvas.flush()
            end
            
            dataTunnel.display_flush()
            dataTunnel.display_stack = nil
            dataTunnel.display_flush = nil
            dataTunnel.display_forceFlush = nil
        end
    end

    function api.setRenderDistance(dist)
        renderDistance = dist
    end

    return api
end

local customFontIndexesCache = {}
local checkedFonts = {}

--simulates the SComputers API, does not implement data transfer
function canvasAPI.createScriptableApi(width, height, dataTunnel, flushCallback, drawer)
    dataTunnel = dataTunnel or {}
    dataTunnel.rotation = 0
    dataTunnel.brightness = 1
    dataTunnel.light = DEFAULT_ALPHA_VALUE
    dataTunnel.skipAtNotSight = false
    dataTunnel.utf8support = false
    dataTunnel.renderAtDistance = false
    dataTunnel.display_forceFlush = true
    dataTunnel.dataUpdated = true
    dataTunnel.optimizationLevel = 16

    local stack = {}
    local stackIndex = 1
    local pixelsCache = {} --optimizations for cameras
    local pixelsCacheExists = false
    local oldStackSum, oldDataSum, oldStack, oldStackIndex
    local forceFlag = false

    local function clearStackForce()
        stack = {}
        stackIndex = 1
    end

    local function clearStack()
        if dataTunnel.display_stack == stack then
            clearStackForce()
        end
    end

    local function setForceFrame()
        if pixelsCacheExists then
            pixelsCache = {}
            pixelsCacheExists = false
        end
        forceFlag = true
        dataTunnel.display_forceFlush = true
    end

    local oldPlayersCount = #sm.player.getAllPlayers()
    function dataTunnel.scriptableApi_update()
        local playersCount = #sm.player.getAllPlayers()
        --local force = sm.game.getCurrentTick() % 80 == 0
        local force = false
        if oldPlayersCount ~= playersCount or force then
            --dataTunnel.display_forceForceFlush = force
            setForceFrame()
            oldPlayersCount = playersCount
        end
    end

    local rwidth, rheight = width, height
    local rmwidth, rmheight = width - 1, height - 1
    local utf8support = false
    local monoFont = true
    local newDataFlag = false
    local spacing = 1
    local fontIndex = 0
    local lastPixelX, lastPixelY, lastPixelColor
    local currentSettedFont

    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local dFontX, dFontY = defaultFont.width, defaultFont.height
    local fontX, fontY
    local mFontX, mFontY
    local xFontX, xFontY
    local sFontX, sFontY
    local fontScaleX, fontScaleY = 1, 1
    local function updateFontSize()
        fontX, fontY = math_ceil(dFontX * fontScaleX), math_ceil(dFontY * fontScaleY)
        mFontX, mFontY = fontX - 1, fontY - 1
        xFontX, xFontY = fontX + 1, fontY + 1
        sFontX, sFontY = fontX + spacing, fontY + 1
    end
    updateFontSize()

    local api
    local api_flush
    api = {
        --[[
        getBuffer = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,
        getCurrent = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getRealBuffer(x + (y * rwidth))
        end,
        ]]
        get = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,

        -- not implemented (implement it yourself if necessary)
        isAllow = function()
            return true
        end,
        getAudience = function()
            return 1
        end,

        setOptimizationLevel = function(value)
            checkArg(1, value, "number")
            value = round(value)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.optimizationLevel ~= value then
                dataTunnel.optimizationLevel = value
                dataTunnel.dataUpdated = true
            end
        end,
        getOptimizationLevel = function()
            return dataTunnel.optimizationLevel
        end,


        -- stubs (outdated methods)
        optimize = function() end,
        setFrameCheck = function () end,
        getFrameCheck = function () return false end,
        setSkipAtLags = function() end,
        getSkipAtLags = function() return false end,


        -- main
        setFontScale = function(scaleX, scaleY)
            checkArg(1, scaleX, "number")
            checkArg(2, scaleY, "number")
            if scaleX < 0 then scaleX = 0 end
            if scaleY < 0 then scaleY = 0 end
            fontScaleX, fontScaleY = scaleX, scaleY
            updateFontSize()
        end,
        getFontScale = function()
            return fontScaleX, fontScaleY
        end,
        setTextSpacing = function(_spacing)
            if _spacing < 0 then _spacing = 0 end
            spacing = _spacing
            updateFontSize()
        end,
        setFontSize = function(_width, _height)
            api.setFontScale(_width / dFontX, _height / dFontY)
        end,
        getTextSpacing = function()
            return spacing
        end,
        calcTextBox = function(text) --it will return two numbers, this will be the size of the box that your text will occupy with this font and this scale
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local totalSize = 0
            if monoFont then
                totalSize = textLen * (fontX + spacing)
            else
                local localFontWidth = dFontX
                local localFont = dataTunnel.customFont or font.optimized
                if fontIndex > 0 and fontsOptimized[fontIndex] then
                    localFont = fontsOptimized[fontIndex]
                    localFontWidth = localFont.width
                end

                local char, chrdata
                for i = 1, textLen do
                    char = sep(text, i, i)
                    if char ~= " " and char ~= spaceCharCode then
                        chrdata = localFont[char] or localFont.error or defaultError
                        totalSize = totalSize + (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                    else
                        totalSize = totalSize + (localFont.spaceSize or localFontWidth) + spacing
                    end
                    canvasAPI.yield()
                end
            end

            return totalSize - spacing, fontY
        end,
        calcCharsSize = function(text) --calculates the length of each character in a string, taking into account its spacing from the next character, and returns a table with these values
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    table_insert(lens, (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing)
                else
                    table_insert(lens, (localFont.spaceSize or localFontWidth) + spacing)
                end
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        calcDecreasingTextSizes = function(text) --it works almost like calcCharsSize. however, each value contains all the previous ones. this is used in the graphic.textBox function, but probably not applicable to any other
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}
            local otherVals = 0

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                local val
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    val = (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                else
                    val = (localFont.spaceSize or localFontWidth) + spacing
                end
                otherVals = otherVals + val
                table_insert(lens, otherVals)
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        isMonospacedFont = function()
            return not not monoFont
        end,

        getWidth = function()
            return rwidth
        end,
        getHeight = function()
            return rheight
        end,
        getSize = function()
            return rwidth, rheight
        end,

        clear = function(color)
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end

            clearStackForce()
            stackIndex = 4
            stack[1] = resetViewportCodeID
            stack[2] = 0
            stack[3] = formatColorToSmallNumber(color, blackSmallNumber)
            
            --[[
            for i = 3, stackIndex - 1 do
                stack[i] = nil
            end
            stackIndex = 3
            ]]
        end,
        drawPixel = function(x, y, color)
            x, y = round(x), round(y)
            if x < 0 or x >= width or y < 0 or y >= height then return end
            local index = x + (y * rwidth)
            color = color or false
            if pixelsCache[index] ~= color then
                if false and pixelsCacheExists and x == lastPixelX + 1 then
                    
                else
                    --[[
                    stack[stackIndex] = -index - 20
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                    stackIndex = stackIndex + 1
                    ]]
                    stack[stackIndex] = 1
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = index
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                    stackIndex = stackIndex + 1
                end

                lastPixelX, lastPixelY, lastPixelColor = x, y, color

                pixelsCache[index] = color
                pixelsCacheExists = true
            end
        end,
        fillRect = function(x, y, sizeX, sizeY, color)
            if x <= 0 and y <= 0 and x + sizeX >= width and y + sizeY >= height then
                return api.clear(color or 0xffffff)
            end

            stack[stackIndex] = 2
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawRect = function(x, y, sizeX, sizeY, color, lineWidth)
            lineWidth = round(lineWidth or 1)
            if lineWidth < 1 then
                lineWidth = 1
            end

            stack[stackIndex] = 3
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = lineWidth
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawText = function(x, y, text, color)
            if y > rmheight or y + mFontY < 0 or fontScaleX <= 0 or fontScaleY <= 0 then return end
            text = tostring(text)

            if monoFont then
                local maxTextLen = math_ceil((width - x) / sFontX)
                if maxTextLen <= 0 then return end
                local startTextFrom = math_max(1, math_floor(-x / sFontX) + 1)

                if utf8support then
                    if utf8.len(text) > maxTextLen or startTextFrom > 1 then
                        text = utf8.sub(text, startTextFrom, maxTextLen)
                    end
                else
                    if #text > maxTextLen or startTextFrom > 1 then
                        text = text:sub(startTextFrom, maxTextLen)
                    end
                end

                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x) + ((startTextFrom - 1) * sFontX)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            else
                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawLine = function(x, y, x2, y2, color, width, roundFlag)
            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            stack[stackIndex] = 5
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = width
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 6
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillCircle = function (x, y, r, color)
            if r > 1024 then r = 1024 end
            
            stack[stackIndex] = 7
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleEvenly = function (x, y, r, color)
            if r > 1024 then r = 1024 end

            stack[stackIndex] = 8
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleVeryEvenly = function (x, y, r, color, stroke)
            if r > 1024 then r = 1024 end
            if not stroke or stroke < 1 then stroke = 1 end

            stack[stackIndex] = 9
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(stroke)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawPoly = function(color, ...)
            api.drawWidePoly(color, 1, false, ...)
        end,
        drawWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 10
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillPoly = function(color, ...)
            api.fillWidePoly(color, 1, false, ...)
        end,
        fillWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 11
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        flush = function()
            api.setViewport()

            if dataTunnel.display_flush and dataTunnel.display_stack == stack then
                return
            end

            local needFlush = forceFlag
            --print("--------------------------- FLUSH 1", needFlush, stack, stackChecksum(stack), stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel)))

            if not needFlush and stackIndex ~= oldStackIndex then
                --print("FLUSH 2", stackIndex, oldStackIndex)
                needFlush = true
            end

            if not needFlush and newDataFlag then
                local dataSum = stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel))
                if dataSum ~= oldDataSum then
                    --print("FLUSH 3")
                    needFlush = true
                    oldDataSum = dataSum
                end
            end

            if not needFlush and stack ~= oldStack then
                for i = 1, stackIndex - 1 do
                    if stack[i] ~= oldStack[i] then
                        needFlush = true
                        --print("FLUSH 4", oldStack)
                        break
                    end
                end
            end

            --[[
            if needFlush then
                oldStackSum = nil
            else
                local stachSum = stackChecksum(stack)
                if stachSum ~= oldStackSum then
                    --print("FLUSH 5")
                    needFlush = true
                    oldStackSum = stachSum
                end
            end
            ]]
            
            if needFlush then
                --print("FLUSH ACTION")
                oldStack = stack
                oldStackIndex = stackIndex

                dataTunnel.display_stack = stack
                dataTunnel.display_flush = clearStack
                
                if flushCallback then
                    flushCallback()
                end
            else
                clearStackForce()
            end

            forceFlag = false
            newDataFlag = false
        end,
        forceFlush = function()
            api_flush()
            dataTunnel.display_forceFlush = true
        end,

        -- settings
        setUtf8Support = function (state)
            if type(state) == "boolean" then
                if dataTunnel.utf8support ~= state then
                    dataTunnel.utf8support = state
                    dataTunnel.dataUpdated = true
                    newDataFlag = true
                    utf8support = state
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getUtf8Support = function () return dataTunnel.utf8support end,

        setRenderAtDistance = function (c)
            if type(c) == "boolean" then
                if dataTunnel.renderAtDistance ~= c then
                    dataTunnel.renderAtDistance = c
                    dataTunnel.dataUpdated = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getRenderAtDistance = function () return dataTunnel.renderAtDistance end,

        setRotation = function (rotation)
            if type(rotation) == "number" and rotation % 1 == 0 and rotation >= 0 and rotation <= 3 then
                if rotation ~= dataTunnel.rotation then
                    dataTunnel.rotation = rotation
                    dataTunnel.dataUpdated = true
                    newDataFlag = true

                    if pixelsCacheExists then
                        pixelsCache = {}
                        pixelsCacheExists = false
                    end

                    if rotation == 1 or rotation == 3 then
                        rwidth = height
                        rheight = width
                    else
                        rwidth = width
                        rheight = height
                    end
                    rmheight = rheight - 1
                    rmwidth = rwidth - 1
                end
            else
                error("integer must be in [0; 3]", 2)
            end
        end,
        getRotation = function () return dataTunnel.rotation end,

        setFont = function (customFont)
            checkArg(1, customFont, "table", "nil")
            currentSettedFont = customFont
            fontIndex = 0
            if dataTunnel.customFont then
                dataTunnel.dataUpdated = true
                dataTunnel.customFont = nil
            end
            if customFont then
                if not checkedFonts[customFont] then
                    checkFont(customFont)
                    checkedFonts[customFont] = true
                end
                dFontX, dFontY = customFont.width, customFont.height
                fontIndex = customFontIndexesCache[customFont]
                if not fontIndex then
                    fontIndex = 0
                    for _, v in pairs(fonts) do
                        if v == customFont then
                            fontIndex = v.index
                        end
                    end
                    customFontIndexesCache[customFont] = fontIndex
                end
                if fontIndex == 0 then
                    dataTunnel.customFont = font.optimizeFont(customFont)
                    dataTunnel.dataUpdated = true
                end
                monoFont = customFont.mono or customFont.mono == nil
            else
                dFontX, dFontY = defaultFont.width, defaultFont.height
                monoFont = true
            end
            updateFontSize()
            newDataFlag = true
        end,
        getFont = function()
            return currentSettedFont
        end,

        getFontWidth = function ()
            return fontX
        end,
        getFontHeight = function ()
            return fontY
        end,
        getRealFontWidth = function ()
            return dFontX
        end,
        getRealFontHeight = function ()
            return dFontY
        end,

        setSkipAtNotSight = function (state)
            checkArg(1, state, "boolean")
            if dataTunnel.skipAtNotSight ~= state then
                dataTunnel.skipAtNotSight = state
                dataTunnel.dataUpdated = true
            end
        end,
        getSkipAtNotSight = function () return dataTunnel.skipAtNotSight end,

        getViewport = function()
            return viewport_x, viewport_y, viewport_sx, viewport_sy
        end,
        setViewport = function(x, y, sizeX, sizeY)
            if x or y or sizeX or sizeY then
                viewport_x, viewport_y, viewport_sx, viewport_sy = x or 0, y or 0, sizeX or api.getWidth(), sizeY or api.getHeight()
                stack[stackIndex] = -1
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sx)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sy)
                stackIndex = stackIndex + 1
            else
                viewport_x, viewport_y, viewport_sx, viewport_sy = nil, nil, nil, nil
                stack[stackIndex] = resetViewportCodeID
                stackIndex = stackIndex + 1
            end
        end,
        setInlineViewport = function(x, y, sizeX, sizeY)
            if viewport_x then
                local x2 = x + (sizeX - 1)
                local y2 = y + (sizeY - 1)
                local px2 = viewport_x + (viewport_sx - 1)
                local py2 = viewport_y + (viewport_sy - 1)
                if x < viewport_x then x = viewport_x elseif x > px2 then x = px2 end
                if y < viewport_y then y = viewport_y elseif y > py2 then y = py2 end
                if x2 < viewport_x then x2 = viewport_x elseif x2 > px2 then x2 = px2 end
                if y2 < viewport_y then y2 = viewport_y elseif y2 > py2 then y2 = py2 end
                api.setViewport(x, y, (x2 - x) + 1, (y2 - y) + 1)
            else
                api.setViewport(x, y, sizeX, sizeY)
            end
        end,

        setBrightness = function(value) --float from 0
            checkArg(1, value, "number")
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.brightness ~= value then
                dataTunnel.brightness = value
                dataTunnel.dataUpdated = true
            end
        end,
        getBrightness = function(value)
            return dataTunnel.brightness
        end,

        setLight = function(value)
            checkArg(1, value, "number")
            value = math_floor(value + 0.5)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.light ~= value then
                dataTunnel.light = value
                dataTunnel.dataUpdated = true
            end
        end,
        getLight = function(value)
            return dataTunnel.light
        end,

        reset = function()
            if api.setFontScale then api.setFontScale(1, 1) end
            if api.setTextSpacing then api.setTextSpacing(1) end
            if api.setFont then api.setFont() end
            if api.setRotation then api.setRotation(0) end
            if api.setUtf8Support then api.setUtf8Support(false) end
            if api.setClicksAllowed then api.setClicksAllowed(false) end
            if api.setMaxClicks then api.setMaxClicks(16) end
            if api.clearClicks then api.clearClicks() end
            if api.setSkipAtNotSight then api.setSkipAtNotSight(false) end
            if api.setRenderAtDistance then api.setRenderAtDistance(false) end
            if api.setViewport then api.setViewport() end
            if api.setBrightness then api.setBrightness(1) end
            if api.setLight then api.setLight(DEFAULT_ALPHA_VALUE) end
            if api.setOptimizationLevel then api.setOptimizationLevel(16) end
            dataTunnel.display_reset = true
        end
    }

    api.update = api.flush
    api.getBuffer = api.get
    api.getCurrent = api.get
    api_flush = api.flush

    local internal = {
        rawPush = function(tbl)
            for i = 1, #tbl do
                stack[stackIndex] = tbl[i]
                stackIndex = stackIndex + 1
            end
        end
    }

    return api, internal
end

--adds a touch screen API (does not implement click processing)
function canvasAPI.addTouch(api, dataTunnel)
    dataTunnel = dataTunnel or {}
    dataTunnel.clicksAllowed = false
    dataTunnel.maxClicks = 16
    dataTunnel.clickData = {}

    api.getClick = function ()
        return (table_remove(dataTunnel.clickData, 1))
    end

    api.setMaxClicks = function (c)
        if type(c) == "number" and c % 1 == 0 and c > 0 and c <= 16 then
            dataTunnel.maxClicks = c
        else
            error("integer must be in [1; 16]", 2)
        end
    end

    api.getMaxClicks = function ()
        return dataTunnel.maxClicks
    end

    api.clearClicks = function ()
        dataTunnel.clickData = {}
    end

    api.setClicksAllowed = function (c)
        if type(c) == "boolean" then
            if dataTunnel.clicksAllowed ~= c then
                dataTunnel.clicksAllowed = c
                dataTunnel.dataUpdated = true
            end
        else
            error("Type must be boolean", 2)
        end
    end

    api.getClicksAllowed = function ()
        return dataTunnel.clicksAllowed
    end

    return function (tbl)
        tbl.x = tbl[1] or tbl.x
        tbl.y = tbl[2] or tbl.y
        tbl.state = tbl[3] or tbl.state
        tbl.button = tbl[4] or tbl.button
        tbl.nickname = tbl[5] or tbl.nickname
        tbl[1] = tbl.x or tbl[1]
        tbl[2] = tbl.y or tbl[2]
        tbl[3] = tbl.state or tbl[3]
        tbl[4] = tbl.button or tbl[4]
        tbl[5] = tbl.nickname or tbl[5]
        table_insert(dataTunnel.clickData, tbl)
    end
end

--leaves only those tunnel fields that are needed for transmission over the network
function canvasAPI.minimizeDataTunnel(dataTunnel)
    return {
        clicksAllowed = dataTunnel.clicksAllowed,
        rotation = dataTunnel.rotation,
        renderAtDistance = dataTunnel.renderAtDistance,
        skipAtNotSight = dataTunnel.skipAtNotSight,
        utf8support = dataTunnel.utf8support,
        customFont = dataTunnel.customFont,
        display_reset = dataTunnel.display_reset,
        brightness = dataTunnel.brightness,
        optimizationLevel = dataTunnel.optimizationLevel,
        light = dataTunnel.light
    }
end

-------- additional
canvasAPI.stackChecksum = stackChecksum
canvasAPI.formatColor = formatColor
canvasAPI.formatColorToNumber = formatColorToNumber
canvasAPI.formatColorToSmallNumber = formatColorToSmallNumber
canvasAPI.checkFont = checkFont
canvasAPI.simpleRemathRect = simpleRemathRect
canvasAPI.remathRect = remathRect
canvasAPI.hexToRGB = hexToRGB
canvasAPI.hexToRGB256 = hexToRGB256
canvasAPI.posCheck = posCheck
canvasAPI.mathDist = mathDist
canvasAPI.needPushStack = needPushStack
canvasAPI.font = font
canvasAPI.tableClone = tableClone
canvasAPI.canvasService = canvasService
canvasAPI.userCalls = userCalls
canvasAPI.dataSizes = dataSizes
canvasAPI.color_new_fromSmallNumber = color_new_fromSmallNumber
canvasAPI.getEffectName = getEffectName
canvasAPI.fonts = fonts
canvasAPI.utf8 = utf8

function canvasAPI.pushData(stack, ...)
    for i, v in ipairs({...}) do
        table.insert(stack, v)
    end
end

_G.canvasAPI = canvasAPI
end
function scmframework_a4eb02eddaaff8f194ca31ccff3f0dbf() --$CONTENT_DATA/Scripts/canvasAPI/canvas.lua
print("> canvas.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/luajit.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/load.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/utf8.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/canvasService.lua")

local debugMode = false
local profileMode = false

local canvasAPI = {
    draw = {
        clear = 0,
        set   = 1,
        fill  = 2,
        rect  = 3,
        text  = 4,
        line  = 5,
        circle  = 6,
        circleF = 7,
        circleE = 8,
        circleVE = 9,
        poly = 10,
        polyF = 11,

        copyNX = 12,
        copyPX = 13,
        copyNY = 14,
        copyPY = 15,
        setI = 16,

        ellipse = 17,
        ellipseF = 18
    },
    material = {
        glass = sm.uuid.new("a683f897-5b8a-4c96-9c46-7b9fbc76d186"),
        classic = sm.uuid.new("8328a29d-35e0-471b-8bfe-06952e9d916d"),
        plastic = sm.uuid.new("82d2da58-6597-4ffa-9b53-1af3b707fa7a"),
        smoothed = sm.uuid.new("a23a4ea2-96da-4bb2-a723-af8c27de2511"),
        glowing = sm.uuid.new("b46ae32a-9037-4360-9f98-3bef1cd4f366")
    },
    multi_layer = {}
}

canvasAPI.multi_layer[tostring(canvasAPI.material.classic)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.plastic)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.smoothed)] = true
canvasAPI.multi_layer[tostring(canvasAPI.material.glowing)] = true
canvasAPI.version = 58

canvasAPI.materialList = {
    [0] = canvasAPI.material.glass,
    canvasAPI.material.classic,
    canvasAPI.material.plastic,
    canvasAPI.material.smoothed,
    canvasAPI.material.glowing
}

canvasAPI.materialListWithoutGlass = {
    [0] = true,
    canvasAPI.material.classic,
    canvasAPI.material.plastic,
    canvasAPI.material.smoothed,
    canvasAPI.material.glowing
}

local MAX_DRAW_TIME = 2 --protecting the world from crashing using the display
local FONT_SIZE_LIMIT = 256
local DEFAULT_ALPHA_VALUE = 255
local MAX_CLICKS = 16
canvasAPI.DEFAULT_ALPHA_VALUE = DEFAULT_ALPHA_VALUE

local font = font
local defaultFont = font.default
local fonts = font.fonts
local fontsOptimized = font.fontsOptimized
local spaceCharCode = string.byte(" ")

local huge = math.huge
local string_len = string.len
local bit = bit or bit32
local bit_rshift = bit.rshift
local bit_lshift = bit.lshift
local utf8 = utf8
local string = string
local table_sort = table.sort
local type = type
local math_ceil = math.ceil
local math_max = math.max
local string_format = string.format
local table_insert = table.insert
local table_remove = table.remove
local math_floor = math.floor
local vec3_new = sm.vec3.new
local color_new = sm.color.new
local quat_fromEuler = sm.quat.fromEuler
local ipairs = ipairs
local pairs = pairs
local string_byte = string.byte
local defaultError = font.optimized.error
local tostring = tostring
local math_abs = math.abs
local math_min = math.min
local string_sub = string.sub
local table_concat = table.concat
local tonumber = tonumber
local utf8_len = utf8.len
local utf8_sub = utf8.sub
local sm_localPlayer_getPlayer = sm.localPlayer.getPlayer
local os_clock = os.clock
local math_sqrt = math.sqrt
local quat_new = sm.quat.new
local game_getCurrentTick = sm.game.getCurrentTick

local black = color_new(0, 0, 0)
local white = color_new(1, 1, 1)
local blackNumber = 0x000000ff
local whiteNumber = 0xffffffff
local blackSmallNumber = 0x000000
local whiteSmallNumber = 0xffffff

local getEffectName
do
    local currentEffect = 1
    local effectsNames = {}

    for i = 0, 255 do
        table_insert(effectsNames, "ShapeRenderable" .. tostring(i))
    end

    function getEffectName()
        local name = effectsNames[currentEffect]
        currentEffect = currentEffect + 1
        if currentEffect > #effectsNames then
            currentEffect = 1
        end
        return name
    end
end

local function profillerPrint(name, execTime)
    local t = execTime * 1000
    if profileMode and t > 0 then
        print("profiller", name, t)
    end
end

local function profiller(name, startTime)
    profillerPrint(name, os_clock() - startTime)
end

--[[
local sm_effect_createEffect = sm.effect.withoutHook_createEffect or sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local withoutHookEmptyEffect = emptyEffect
local whook = "withoutHook_"
if better and better.version >= 45 and better.isAvailable() then
    local mt = getmetatable(emptyEffect)
    local newMt = {}
    for k, v in pairs(mt) do
        newMt[k] = v
    end
    for k, v in pairs(mt) do
        if k:sub(1, #whook) == whook then
            newMt[k:sub(#whook + 1, #k)] = v
        end
    end
    withoutHookEmptyEffect = setmetatable({}, newMt)
end
local effect_setParameter = withoutHookEmptyEffect.setParameter
local effect_stop = withoutHookEmptyEffect.stop
local effect_destroy = withoutHookEmptyEffect.destroy
local effect_start = withoutHookEmptyEffect.start
local effect_isDone = withoutHookEmptyEffect.isDone
local effect_isPlaying = withoutHookEmptyEffect.isPlaying
local effect_setScale = withoutHookEmptyEffect.setScale
local effect_setOffsetPosition = withoutHookEmptyEffect.setOffsetPosition
local effect_setOffsetRotation = withoutHookEmptyEffect.setOffsetRotation
effect_destroy(emptyEffect)
]]

local sm_effect_createEffect = sm.effect.createEffect
local emptyEffect = sm_effect_createEffect(getEffectName())
local effect_setParameter = emptyEffect.setParameter
local effect_stop = emptyEffect.stop
local effect_destroy = emptyEffect.destroy
local effect_start = emptyEffect.start
local effect_isDone = emptyEffect.isDone
local effect_isPlaying = emptyEffect.isPlaying
local effect_setScale = emptyEffect.setScale
local effect_setOffsetPosition = emptyEffect.setOffsetPosition
local effect_setOffsetRotation = emptyEffect.setOffsetRotation
local effect_setPosition = emptyEffect.setPosition
local effect_setRotation = emptyEffect.setRotation
effect_destroy(emptyEffect)

local function reverse_ipairs(t)
    local i = #t + 1
    return function()
        i = i - 1
        if i > 0 then
            return i, t[i]
        end
    end
end

local function round(number)
    return math_floor(number + 0.5)
end

local function checkFont(lfont)
    if type(lfont) ~= "table" then
        error("the font should be a table", 3)
    end

    if lfont.mono or lfont.mono == nil then
        if type(lfont.chars) ~= "table" or (type(lfont.width) ~= "number") or (type(lfont.height) ~= "number") then
            error("invalid basic char data", 3)
        end
        
        if lfont.width > FONT_SIZE_LIMIT then
            error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
        elseif lfont.height > FONT_SIZE_LIMIT then
            error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
        end

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data ~= lfont.height then
                error("font failed integrity check", 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" then
                    error("the char string has the wrong type", 3)
                elseif #line ~= lfont.width then
                    print(char, #line, data)
                    error("the char string has the wrong lenght", 3)
                end
            end
        end
    else
        if type(lfont.chars) ~= "table" then
            error("font failed integrity check", 3)
        end

        local oFont = font.optimizeFont(lfont)
        lfont.spaceSize = oFont.spaceSize
        lfont.width = oFont.width
        lfont.height = oFont.height

        for char, data in pairs(lfont.chars) do
            if type(char) ~= "string" or type(data) ~= "table" or #data > FONT_SIZE_LIMIT then
                error("the font height should not exceed " .. FONT_SIZE_LIMIT, 3)
            end
            for _, line in ipairs(data) do
                if type(line) ~= "string" or #line > FONT_SIZE_LIMIT then
                    error("the font width should not exceed " .. FONT_SIZE_LIMIT, 3)
                end
            end
        end
    end
end

local function doQuat(x, y, z, w)
    local sin = math.sin(w / 2)
    return quat_new(sin * x, sin * y, sin * z, math.cos(w / 2))
end

local function custom_fromEulerYEnd(x, y, z) --custom implementation
    return doQuat(1, 0, 0, x) * doQuat(0, 0, 1, z) * doQuat(0, 1, 0, y)
end

local function tableClone(tbl)
    local newtbl = {}
    for k, v in pairs(tbl) do
        newtbl[k] = v
    end
    return newtbl
end

local function stackChecksum(stack)
    local num = -#stack
    local t, v
    for i = 1, #stack do
        v = stack[i]
        t = type(v)
        num = num - i
        if t == "number" then
            num = num + ((v * i) + v + i + (v / i))
        elseif t == "Color" then
            num = num + ((i * (v.r / i) * -4) + v.g)
            num = num - ((i * (v.g + i) * 5) + v.b)
            num = num + ((i * (v.b - i) * 8) + v.r)
        elseif t == "string" then
            for i3 = 1, #v do
                num = num + (i * (-i3 - (string_byte(v, i3) * i3)))
            end
        end
    end
    return num
end

local function checkArg(n, have, ...)
    have = type(have)
    local tbl = {...}
    for _, t in ipairs(tbl) do
        if have == t then
            return
        end
    end
    error(string_format("bad argument #%d (%s expected, got %s)", n, table_concat(tbl, " or "), have), 3)
end

local function simpleRemathRect(x, y, w, h, maxX, maxY)
    local x2, y2 = x + (w - 1), y + (h - 1)
    if x < 0 then
        x = 0
    elseif x > maxX then
        --x = maxX
        return
    end
    if y < 0 then
        y = 0
    elseif y > maxY then
        --y = maxY
        return
    end
    if x2 < 0 then
        --x2 = 0
        return
    elseif x2 > maxX then
        x2 = maxX
    end
    if y2 < 0 then
        --y2 = 0
        return
    elseif y2 > maxY then
        y2 = maxY
    end
    return x, y, x2, y2, w, h
end

local function remathRect(offset, stack, maxX, maxY)
    return simpleRemathRect(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], maxX, maxY)
end

local function posCheck(width, height, x, y)
    return x >= 0 and y >= 0 and x < width and y < height
end

local hashChar = string.byte("#")
local bit = bit or bit32
local band = bit.band
local rshift = bit.rshift
local function hexToRGB(color)
    return math_floor(color / 256 / 256) / 255, (math_floor(color / 256) % 256) / 255, (color % 256) / 255
end

local function hexToRGB256(color)
    return math_floor(color / 256 / 256), math_floor(color / 256) % 256, color % 256
end

local function optimizationLevelToValue(level)
    return (level / 255) * 0.25
end

local function formatColor(color, default)
    local t = type(color)
    if t == "Color" then
        return color
    elseif t == "string" then
        return color_new(color)
    elseif t == "number" then
        return color_new(hexToRGB(color))
    end

    return default
end

local redMul = 256 * 256 * 256
local greenMul = 256 * 256
local blueMul = 256
local function formatColorToNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * redMul) + (math_floor(color.g * 255) * greenMul) + (math_floor(color.b * 255) * blueMul) + math_floor(color.a * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return val
        end
        return (val * 256) + 255
    elseif t == "number" then
        return (color * 256) + 255
    end

    return default or 0
end

local function formatColorToSmallNumber(color, default)
    local t = type(color)
    if t == "Color" then
        return (math_floor(color.r * 255) * greenMul) + (math_floor(color.g * 255) * blueMul) + math_floor(color.b * 255)
    elseif t == "string" then
        local val
        if string_byte(color) == hashChar then
            val = tonumber(string_sub(color, 2, -1), 16) or 0
        else
            val = tonumber(color, 16) or 0
        end
        if #color > 7 then
            return math_floor(val / 256)
        end
        return val
    elseif t == "number" then
        return color
    end

    return default or 0
end

local function color_new_fromSmallNumber(number, alpha)
    return color_new((number * 256) + (alpha or 255))
end

local function mathDist(pos1, pos2)
    return math.sqrt(((pos1.x - pos2.x) ^ 2) + ((pos1.y - pos2.y) ^ 2) + ((pos1.z - pos2.z) ^ 2))
end

local function needPushStack(canvas, dataTunnel) --returns true if the rendering stack should be applied
    return dataTunnel.display_forceFlush or not ((dataTunnel.skipAtNotSight and not canvas.isRendering()))
end

local resetViewportCodeID = -23124
local dataSizes = {
    [resetViewportCodeID] = 1,
    [-1] = 5,
    [0] = 2,
    4,
    6,
    7,
    9, --text
    7, --line
    5,
    5,
    5,
    6,

    4, --drawPoly
    4, --fillPoly

    2,
    2,
    2,
    2,
    3,

    7,
    7
}

local userCalls = {}

canvasAPI.yield = function() end

function canvasAPI.createDrawer(sizeX, sizeY, callback, callbackBefore, directArg, direct_clear, direct_fill, direct_set, updatedList)
    local obj = {}
    local oldStackSum
    local rSizeX, rSizeY = sizeX, sizeY
    local maxX, maxY = sizeX - 1, sizeY - 1
    local newBuffer, newBufferBase = {}, 0
    local realBuffer = {}
    local maxBuffer = maxX + (maxY * sizeX)
    local currentFont = font.optimized
    local fontWidth, fontHeight = defaultFont.width, defaultFont.height
    local rotation = 0
    local utf8Support = false
    local updated = false
    local clearOnly = false
    local clearBackplate = false
    local maxLineSize = sizeX + sizeY
    local bigSide = math_max(sizeX, sizeY)
    local drawerData = {}
    local _oldBufferBase
    local changes = {}
    local _changes = {}
    local changesIndex, changesCount = {}, 0

    local viewportEnable = false
    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local function bufferRangeUpdate() end

    local function setDot(px, py, col)
        if viewportEnable and (px < viewport_x or py < viewport_y or px >= (viewport_x + viewport_sx) or py >= (viewport_y + viewport_sy)) then
            return
        end

        --[[
        if rotation == 0 then
            index = px + (py * rSizeX)
        elseif rotation == 1 then
            index = (rSizeX - py - 1) + (px * rSizeX)
        elseif rotation == 2 then
            index = (rSizeX - px - 1) + ((rSizeY - py - 1) * rSizeX)
        else
            index = py + ((rSizeY - px - 1) * rSizeX)
        end
        ]]

        local index
        if rotation == 0 then
            index = py + (px * rSizeY)
        elseif rotation == 1 then
            index = px + ((rSizeX - py - 1) * rSizeY)
        elseif rotation == 2 then
            index = (rSizeY - py - 1) + ((rSizeX - px - 1) * rSizeY)
        else
            index = (rSizeY - px - 1) + (py * rSizeY)
        end

        if direct_set then
            newBuffer[index] = col
            direct_set(directArg, math_floor(index / rSizeY), index % rSizeY, col)
            return true
        elseif newBuffer[index] ~= col then
            if updatedList and not changes[index] then
                changes[index] = true
                changesCount = changesCount + 1
                changesIndex[changesCount] = index
            end

            newBuffer[index] = col
            return true
        end
    end

    local function check(px, py)
        return px >= 0 and py >= 0 and px < sizeX and py < sizeY
    end

    local function checkSetDot(px, py, col)
        if check(px, py) then
            setDot(px, py, col)
            return true
        end
        return false
    end

    function obj.drawerReset()
    end

    function obj.drawer_setRotation(_rotation)
        rotation = _rotation
        if rotation == 1 or rotation == 3 then
            sizeX = rSizeY
            sizeY = rSizeX
        else
            sizeX = rSizeX
            sizeY = rSizeY
        end
        maxX, maxY = sizeX - 1, sizeY - 1
    end

    function obj.drawer_setUtf8Support(state)
        utf8Support = not not state
    end

    function obj.drawer_setFont(customFont)
        if customFont then
            currentFont = customFont
            fontWidth, fontHeight = customFont.width, customFont.height
        else
            currentFont = font.optimized
            fontWidth, fontHeight = defaultFont.width, defaultFont.height
        end
    end

    function obj.setDrawerResolution(_sizeX, _sizeY)
        rSizeX, rSizeY = _sizeX, _sizeY
        obj.drawer_setRotation(rotation)
        newBuffer, newBufferBase = {}, 0
        realBuffer = {}
        maxBuffer = maxX + (maxY * sizeX)
        maxLineSize = sizeX + sizeY
        bigSide = math_max(sizeX, sizeY)
        changes = {}
        _changes = {}
        changesIndex, changesCount = {}, 0
        oldStackSum = nil
    end

    local old_rotation
    local old_utf8support
    local old_customFont
    function obj.pushDataTunnelParams(params)
        if params.rotation ~= old_rotation then
            obj.drawer_setRotation(params.rotation)
            old_rotation = params.rotation
        end
        if params.utf8support ~= old_utf8support then
            obj.drawer_setUtf8Support(params.utf8support)
            old_utf8support = params.utf8support
        end
        if params.customFont ~= old_customFont then
            obj.drawer_setFont(params.customFont)
            old_customFont = params.customFont
        end
    end

    ------------------------------------------
    
    local function rasterize_fill(x, y, sx, sy, col)
        local x, y, x2, y2, w, h = simpleRemathRect(x, y, sx, sy, maxX, maxY)
        if not x then return end

        if direct_fill then
            direct_fill(directArg, x, y, w, h, col)
        end

        local ix, iy = x, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy + 1
            if iy > y2 then
                iy = y
                ix = ix + 1
            end
        end

        --[[
        local ix, iy = x, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            ix = ix + 1
            if ix > x2 then
                ix = x
                iy = iy + 1
            end
        end
        ]]

        --[[
        local ix, iy = x2, y2
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy - 1
            if iy < y then
                iy = y2
                ix = ix - 1
            end
        end
        ]]

        --[[
        local ix, iy = x2, y
        for _ = 1, ((x2 - x) + 1) * ((y2 - y) + 1) do
            setDot(ix, iy, col)
            iy = iy + 1
            if iy > y2 then
                iy = y
                ix = ix - 1
            end
        end
        ]]
    end

    local function rasterize_rect(x, y, sx, sy, col, lineWidth)
        local x, y, x2, y2, w, h = simpleRemathRect(x, y, sx, sy, maxX, maxY)
        if not x then return end
        if lineWidth == 1 then
            for ix = x, x2 do
                setDot(ix, y, col)
                setDot(ix, y2, col)
            end

            for iy = y + 1, y2 - 1 do
                setDot(x, iy, col)
                setDot(x2, iy, col)
            end
        else
            local _y, _y2, _x, _x2
            for ioff = 0, math_min(lineWidth, math_max(w, h) / 2) - 1 do
                _y = y + ioff
                _y2 = y2 - ioff
                for ix = x + ioff, x2 - ioff do
                    setDot(ix, _y, col)
                    setDot(ix, _y2, col)
                end

                _x = x + ioff
                _x2 = x2 - ioff
                for iy = y + 1 + ioff, y2 - (1 + ioff) do
                    setDot(_x, iy, col)
                    setDot(_x2, iy, col)
                end
            end
        end
    end

    local function rasterize_circleF(px, py, r, col)
        local chr = r*r
        local sx, sy, tempInt, tempBool

        if r < bigSide and px >= 0 and py >= 0 and px < sizeX and py < sizeY then --now only a quarter of the circle is rendered
            for iy = 0, r do
                sy = iy + 0.5
                tempBool = false
                for ix = r, 0, -1 do
                    sx = ix + 0.5
                    if tempBool or (sx * sx) + (sy * sy) <= chr then
                        tempBool = true
                        checkSetDot(px + ix, py + iy, col)
                        checkSetDot(px - ix - 1, py + iy, col)
                        checkSetDot(px + ix, py - iy - 1, col)
                        checkSetDot(px - ix - 1, py - iy - 1, col)
                    end
                end
            end
        else
            for ix = math_max(-r, -px), math_min(r, (sizeX - px) - 1) do --if the starting point is not within the screen or the circle is too large, then will have to check every pixel
                sx = ix + 0.5
                for iy = math_max(-r, -py), math_min(r, (sizeY - py) - 1) do
                    sy = iy + 0.5
                    if (sx * sx) + (sy * sy) <= chr then
                        setDot(px + ix, py + iy, col)
                    end
                end
            end
        end
    end

    local function rasterize_line(px, py, px2, py2, col, width, linesInfo)
        if px2 < px or py2 < py then
            local _px, _py = px, py
            px, py = px2, py2
            px2, py2 = _px, _py
        end
        local dx = math_abs(px2 - px)
        local dy = math_abs(py2 - py)
        local sx = (px < px2) and 1 or -1
        local sy = (py < py2) and 1 or -1
        local err = dx - dy
        if width == -1 or width == 0 or width == 1 then
            local drawAllowed = false
            for _ = 1, maxLineSize do
                if check(px, py) then
                    setDot(px, py, col)
                    drawAllowed = true
                elseif drawAllowed then
                    break
                end
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        elseif width < 0 then
            width = math_ceil((-width) / 2)
            if width < 1 then
                width = 1
            end
            for _ = 1, maxLineSize do
                rasterize_circleF(px, py, width, col)
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        else
            local offsetFill = math_floor(width / 2)
            for _ = 1, maxLineSize do
                rasterize_fill(px - offsetFill, py - offsetFill, width, width, col)
                if px == px2 and py == py2 then
                    break
                end
                local e2 = bit_lshift(err, 1)
                if e2 > -dy then
                    err = err - dy
                    px = px + sx
                end
                if e2 < dx then
                    err = err + dx
                    py = py + sy
                end
            end
        end
    end

    local function rasterize_hline(x, y, len, color)
        rasterize_fill(x, y, len, 1, color)
    end

    local function rasterize_vline(x, y, len, color)
        rasterize_fill(x, y, 1, len, color)
    end

    local function rasterize_filledRoundedCorners(centerX, centerY, radius, upper, delta, color)
        local f = 1 - radius
        local ddF_x = 1
        local ddF_y = -radius - radius
        local y = 0
        local lineLength

        while y < radius do
            if f >= 0 then
                lineLength = y + y + delta

                if lineLength > 0 then
                    rasterize_hline(centerX - y, upper and (centerY - radius) or (centerY + radius), lineLength, color)
                end

                radius = radius - 1
                ddF_y = ddF_y + 2
                f = f + ddF_y
            end

            y = y + 1
            ddF_x = ddF_x + 2
            f = f + ddF_x
            lineLength = radius + radius + delta

            if lineLength > 0 then
                rasterize_hline(centerX - radius, upper and (centerY - y) or (centerY + y), lineLength, color)
            end
        end
    end

    local function rasterize_roundedCorners(centerX, centerY, radius, corner, color)
        local f = 1 - radius
        local ddF_x = 1
        local ddF_y = -2 * radius
        local xe = 0
        local xs = 0
        local len = 0

        while true do
            while f < 0 do
                xe = xe + 1
                f = f + ddF_x
                ddF_x = ddF_x + 2
            end
            f = f + ddF_y
            ddF_y = ddF_y + 2

            if xe - xs == 1 then
                if bit.band(corner, 0x1) ~= 0 then -- left top
                    checkSetDot(centerX - xe, centerY - radius, color)
                    checkSetDot(centerX - radius, centerY - xe, color)
                end

                if bit.band(corner, 0x2) ~= 0 then -- right top
                    checkSetDot(centerX + radius, centerY - xe, color)
                    checkSetDot(centerX + xs + 1, centerY - radius, color)
                end

                if bit.band(corner, 0x4) ~= 0 then -- right bottom
                    checkSetDot(centerX + xs + 1, centerY + radius, color)
                    checkSetDot(centerX + radius, centerY + xs + 1, color)
                end

                if bit.band(corner, 0x8) ~= 0 then -- left bottom
                    checkSetDot(centerX - radius, centerY + xs + 1, color)
                    checkSetDot(centerX - xe, centerY + radius, color)
                end
            else
                len = xe - xs
                xs = xs + 1

                if bit.band(corner, 0x1) ~= 0 then -- left top
                    rasterize_hline(centerX - xe, centerY - radius, len, color)
                    rasterize_vline(centerX - radius, centerY - xe, len, color)
                end

                if bit.band(corner, 0x2) ~= 0 then -- right top
                    rasterize_vline(centerX + radius, centerY - xe, len, color)
                    rasterize_hline(centerX + xs, centerY - radius, len, color)
                end

                if bit.band(corner, 0x4) ~= 0 then -- right bottom
                    rasterize_hline(centerX + xs, centerY + radius, len, color)
                    rasterize_vline(centerX + radius, centerY + xs, len, color)
                end

                if bit.band(corner, 0x8) ~= 0 then -- left bottom
                    rasterize_vline(centerX - radius, centerY + xs, len, color)
                    rasterize_hline(centerX - xe, centerY + radius, len, color)
                end
            end
            xs = xe

            if xe >= radius then break end
            radius = radius - 1
        end
    end

    ------------------------------------------

    local function render_fill(stack, offset)
        rasterize_fill(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4])
    end

    local function render_drawEllipse(stack, offset)
        local x, y, x2, y2, w, h = remathRect(offset, stack, maxX, maxY)
        if not x then return end
        local cornerRadius = stack[offset+4]
        local col = stack[offset+5]

        local maxCornerRadius = math.min(w / 2, h / 2)
        if cornerRadius > maxCornerRadius then cornerRadius = maxCornerRadius end

        if cornerRadius <= 0 then
            rasterize_rect(x, y, w, h, col, 1)
            return
        end

        rasterize_hline(
            x + cornerRadius, y,
            w - cornerRadius - cornerRadius,
            col
        )

        rasterize_hline(
            x + cornerRadius, y + h - 1,
            w - cornerRadius - cornerRadius,
            col
        )

        rasterize_vline(
            x , y + cornerRadius,
            h - cornerRadius - cornerRadius,
            col
        )

        rasterize_vline(
            x + w - 1, y + cornerRadius,
            h - cornerRadius - cornerRadius,
            col
        )

        rasterize_roundedCorners(
            x + cornerRadius, y + cornerRadius,
            cornerRadius,
            1,
            col
        )

        rasterize_roundedCorners(
            x + w - cornerRadius - 1, y + cornerRadius,
            cornerRadius,
            2,
            col
        )

        rasterize_roundedCorners(
            x + w - cornerRadius - 1, y + h - cornerRadius - 1,
            cornerRadius,
            4,
            col
        )

        rasterize_roundedCorners(
            x + cornerRadius, y + h - cornerRadius - 1,
            cornerRadius,
            8,
            col
        )
    end

    local function render_fillEllipse(stack, offset)
        local x, y, x2, y2, w, h = remathRect(offset, stack, maxX, maxY)
        if not x then return end
        local cornerRadius = stack[offset+4]
        local col = stack[offset+5]

        local maxCornerRadius = math.min(w / 2, h / 2)
        if cornerRadius > maxCornerRadius then cornerRadius = maxCornerRadius end

        if cornerRadius <= 0 then
            rasterize_fill(x, y, w, h, col, 1)
            return
        end

        rasterize_fill(
            x,
            y + cornerRadius,
            w,
            h - cornerRadius - cornerRadius,
            col
        )

        rasterize_filledRoundedCorners(
            x + cornerRadius,
            y + cornerRadius,
            cornerRadius,
            true,
            w - cornerRadius - cornerRadius,
            col
        )

        rasterize_filledRoundedCorners(
            x + cornerRadius,
            y + h - cornerRadius - 1,
            cornerRadius,
            false,
            w - cornerRadius - cornerRadius,
            col
        )
    end

    local function render_rect(stack, offset)
        rasterize_rect(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4], stack[offset+5])
    end

    local function render_text(stack, offset)
        local tx, ty = stack[offset], stack[offset+1]
        local text = stack[offset+2]
        local col = stack[offset+3]
        local scaleX = stack[offset+4]
        local scaleY = stack[offset+5]
        local spacing = stack[offset+6]
        local fontIndex = stack[offset+7]

        local localFont = currentFont
        local localFontWidth = fontWidth
        if fontIndex > 0 and fontsOptimized[fontIndex] then
            localFont = fontsOptimized[fontIndex]
            localFontWidth = localFont.width
        end

        local len, sep
        if utf8Support then
            len, sep = utf8_len, utf8_sub
        else
            len, sep = string_len, string_byte
        end
        local scaledFontWidth = math_ceil(localFontWidth * scaleX)
        if localFont.mono then
            for i = len(text), 1, -1 do
                local char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    local chrdata = localFont[char] or localFont.error or defaultError
                    local charOffset = (i - 1) * (scaledFontWidth + spacing)
                    for i2 = 1, #chrdata, 2 do
                        local px, py = chrdata[i2], chrdata[i2 + 1]
                        local lposX, lposY = round(px * scaleX), round(py * scaleY)
                        for ix = math_min(sizeX, round((px + 1) * scaleX) - lposX - 1), 0, -1 do
                            local setPosX = tx + ix + lposX + charOffset
                            for iy = math_min(sizeY, round((py + 1) * scaleY) - lposY - 1), 0, -1 do
                                checkSetDot(setPosX, ty + iy + lposY, col)
                            end
                        end
                    end
                end
            end
        else
            local charOffset = 0
            local startDrawTime = os_clock()
            for i = 1, len(text) do
                local char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    local chrdata = localFont[char] or localFont.error or defaultError
                    local charPos = tx + charOffset
                    if not chrdata[0] or charPos + round(chrdata[0] * scaleX) > 0 then
                        if charPos > maxX then
                            goto endDraw
                        end
                        for i2 = 1, #chrdata, 2 do
                            local px, py = chrdata[i2], chrdata[i2 + 1]
                            local lposX, lposY = round(px * scaleX), round(py * scaleY)
                            for ix = 0, math_min(sizeX, round((px + 1) * scaleX) - lposX - 1) do
                                local setPosX = tx + ix + lposX + charOffset
                                for iy = 0, math_min(sizeY, round((py + 1) * scaleY) - lposY - 1) do
                                    checkSetDot(setPosX, ty + iy + lposY, col)
                                end
                            end
                        end
                    end
                    charOffset = charOffset + (chrdata[0] and math_ceil(chrdata[0] * scaleX) or 0) + spacing
                else
                    charOffset = charOffset + (math_ceil(localFont.spaceSize * scaleX) or localFontWidth) + spacing
                end
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
        end
        ::endDraw::
    end

    local function render_line(stack, offset)
        rasterize_line(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4], stack[offset+5])
    end

    local function render_circle(stack, offset) --Michener’s Algorithm
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx, py + dy, col)
            checkSetDot(px + dy, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy, col)
            checkSetDot(px + dy, py - dx, col)
            checkSetDot(px + dx, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleE(stack, offset)
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local col = stack[offset+3]
        local dx = 0
        local dy = e2
        local chr = 3 - 2 * e2

        while dx <= dy do
            checkSetDot(px + dx - 1, py + dy - 1, col)
            checkSetDot(px + dy - 1, py + dx, col)
            checkSetDot(px - dy, py + dx, col)
            checkSetDot(px - dx, py + dy - 1, col)
            checkSetDot(px + dy - 1, py - dx, col)
            checkSetDot(px + dx - 1, py - dy, col)
            checkSetDot(px - dy, py - dx, col)
            checkSetDot(px - dx, py - dy, col)

            if chr < 0 then
                chr = chr + 4 * dx + 6
            else
                chr = chr + 4 * (dx - dy) + 10
                dy = dy - 1
            end
            dx = dx + 1
        end
    end

    local function render_circleF(stack, offset)
        rasterize_circleF(stack[offset], stack[offset+1], stack[offset+2], stack[offset+3])
    end

    local function render_circleVE(stack, offset) --drawCircleVeryEvenly
        local px = stack[offset]
        local py = stack[offset+1]
        local e2 = stack[offset+2]
        local chr = e2*e2
        local col = stack[offset+3]
        local sx, sy, tempInt, tempBool

        e2 = math_min(e2, bigSide)
        for iy = 0, e2 do
            sy = iy + 0.5
            tempInt = stack[offset+4]
            for ix = e2, 0, -1 do
                sx = ix + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
        for ix = 0, e2 do
            sx = ix + 0.5
            tempInt = stack[offset+4]
            for iy = e2, 0, -1 do
                sy = iy + 0.5
                if (sx * sx) + (sy * sy) <= chr then
                    checkSetDot(px + ix, py + iy, col)
                    checkSetDot(px - ix - 1, py + iy, col)
                    checkSetDot(px + ix, py - iy - 1, col)
                    checkSetDot(px - ix - 1, py - iy - 1, col)

                    tempInt = tempInt - 1
                    if tempInt == 0 then
                        break
                    end
                end
            end
        end
    end

    local function render_drawPoly(stack, offset, getFillInfo)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local startDrawTime = os_clock()
        local _px = stack[offset+3]
        local _py = stack[offset+4]
        local px, py
        local pointsPos
        if getFillInfo then
            pointsPos = {}

            local _setDot = setDot
            setDot = function(px, py, col)
                if not pointsPos[py] then
                    pointsPos[py] = {px, px}
                else
                    local data = pointsPos[py]
                    if px < data[1] then data[1] = px end
                    if px > data[2] then data[2] = px end
                end
            end
            
            for i = 3, points, 2 do
                px = stack[offset+2+i]
                py = stack[offset+3+i]
                rasterize_line(_px, _py, px, py, col, width)
                _px = px
                _py = py
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width)

            setDot = _setDot
        else
            for i = 3, points, 2 do
                px = stack[offset+2+i]
                py = stack[offset+3+i]
                rasterize_line(_px, _py, px, py, col, width)
                _px = px
                _py = py
                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            rasterize_line(_px, _py, stack[offset+3], stack[offset+4], col, width)
        end
        
        ::endDraw::
        return points, pointsPos
    end

    local function render_fillPoly(stack, offset)
        local col = stack[offset]
        local points = stack[offset+1]
        local width = stack[offset+2]

        local gpoints = points
        for ii = 0, points / 2, 2 do
            local i = ii * 2
            local _, pointsPos = render_drawPoly({col, math_min(6, gpoints), width, stack[offset+3+i], stack[offset+4+i], stack[offset+5+i], stack[offset+6+i], stack[offset+7+i], stack[offset+8+i]}, 1, true)
            local startDrawTime = os_clock()
            for posY, v in pairs(pointsPos) do
                for i = v[1], v[2] do
                    setDot(i, posY, col)
                end

                if os_clock() - startDrawTime > MAX_DRAW_TIME then
                    goto endDraw
                end
            end
            gpoints = gpoints - 4
            if gpoints <= 0 then
                break
            end
        end

        ::endDraw::
        return points
    end

    local lastPixelX, lastPixelY, lastPixelColor
    function obj.pushStack(stack)
        local offset = 2
        local actionNum
        local addValue = 0
        local startDrawTime = os_clock()
        local idx
        while stack[offset] do
            actionNum = stack[offset-1]
            clearOnly = actionNum == 0
            addValue = 0

            if actionNum == 0 then
                newBufferBase = stack[offset]
                newBuffer = {}
                if direct_clear then
                    direct_clear(directArg, newBufferBase, changes)
                end
                updated = true
                clearBackplate = true
                if callback and newBufferBase ~= _oldBufferBase then
                    obj.fullRefresh()
                    _oldBufferBase = newBufferBase
                end
            elseif actionNum == resetViewportCodeID then
                viewportEnable = false
            elseif actionNum == -1 then
                viewportEnable = true
                viewport_x = stack[offset]
                viewport_y = stack[offset+1]
                viewport_sx = stack[offset+2]
                viewport_sy = stack[offset+3]
            elseif actionNum == 1 then
                setDot(stack[offset], stack[offset+1], stack[offset+2])
                updated = true
            elseif actionNum == 2 then
                render_fill(stack, offset)
                updated = true
            elseif actionNum == 3 then
                render_rect(stack, offset)
                updated = true
            elseif actionNum == 4 then
                render_text(stack, offset)
                updated = true
            elseif actionNum == 5 then
                render_line(stack, offset)
                updated = true
            elseif actionNum == 6 then
                render_circle(stack, offset)
                updated = true
            elseif actionNum == 8 then
                render_circleE(stack, offset)
                updated = true
            elseif actionNum == 7 then
                render_circleF(stack, offset)
                updated = true
            elseif actionNum == 9 then
                render_circleVE(stack, offset)
                updated = true
            elseif actionNum == 10 then
                addValue = render_drawPoly(stack, offset)
                updated = true
            elseif actionNum == 11 then
                addValue = render_fillPoly(stack, offset)
                updated = true
            elseif actionNum == 12 then
                for _ = 1, stack[offset] do
                    lastPixelX = lastPixelX + 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 13 then
                for _ = 1, stack[offset] do
                    lastPixelX = lastPixelX - 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 14 then
                for _ = 1, stack[offset] do
                    lastPixelY = lastPixelY + 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 15 then
                for _ = 1, stack[offset] do
                    lastPixelY = lastPixelY - 1
                    setDot(lastPixelX, lastPixelY, lastPixelColor)
                end
                updated = true
            elseif actionNum == 16 then
                idx = stack[offset]
                lastPixelX, lastPixelY, lastPixelColor = idx % rSizeX, math_floor(idx / rSizeX), stack[offset+1]
                setDot(lastPixelX, lastPixelY, lastPixelColor)
                updated = true
            elseif actionNum == 17 then
                render_drawEllipse(stack, offset)
                updated = true
            elseif actionNum == 18 then
                render_fillEllipse(stack, offset)
                updated = true
            elseif userCalls[actionNum] then
                if userCalls[actionNum](newBuffer, rotation, rSizeX, rSizeY, sizeX, sizeY, stack, offset, drawerData, bufferRangeUpdate, setDot, checkSetDot, rasterize_fill) then
                    updated = true
                end
            end

            if os_clock() - startDrawTime > MAX_DRAW_TIME then
                goto endDraw
            end

            offset = offset + dataSizes[actionNum] + addValue
        end

        ::endDraw::
    end

    function obj.flush(force)
        if not obj.wait and (updated or force) then
            if callbackBefore then
                callbackBefore(newBufferBase, clearOnly, maxBuffer, force, newBuffer, realBuffer, nil, nil, changes, changesIndex, changesCount, _changes, clearBackplate)
            end

            if callback then
                --[[
                local color, px, py
                for i = bufferChangedFrom, bufferChangedTo do
                    color = newBuffer[i] or newBufferBase
                    if color ~= realBuffer[i] or force then
                        px = math_floor(i / rSizeY)
                        py = i % rSizeY
                        callback(px, py, color, newBufferBase)
                        realBuffer[i] = color
                    end
                end
                ]]

                local oldChanges
                if clearBackplate then
                    oldChanges = {}
                    for index in pairs(changes) do
                        oldChanges[index] = true
                    end

                    for index in pairs(_changes) do
                        if not changes[index] then
                            changesCount = changesCount + 1
                            changesIndex[changesCount] = index
                            changes[index] = true
                        end
                    end
                end
        
                for i2 = 1, changesCount do
                    local index = changesIndex[i2]
                    --if changes[index] then
                        callback(math_floor(index / sizeY), index % sizeY, newBuffer[index] or newBufferBase, newBufferBase)
                        _changes[index] = true
                    --end
                end

                if clearBackplate then
                    obj.setOldChanges(oldChanges)
                end
            end

            updated = false
            clearBackplate = false
            if updatedList then
                changes = {}
                changesIndex = {}
                changesCount = 0
            end
        end
    end

    function obj.setWait(state)
        obj.wait = state
        if not state then
            obj.flush()
        end
    end

    function obj.getNewBuffer(i)
        return newBuffer[i] or newBufferBase
    end

    function obj.getRealBuffer(i)
        return realBuffer[i]
    end

    function obj.getChanges()
        return changes
    end

    function obj.fullRefresh()
        changesCount = 0
        changesIndex = {}
        for i = 0, (sizeX * sizeY) - 1 do
            changes[i] = true
            changesCount = changesCount + 1
            changesIndex[changesCount] = i
        end
    end

    --[[
    function obj.flushOldChanges()
        _changes = changes
    end
    ]]

    function obj.setOldChanges(oldChanges)
        _changes = oldChanges
    end

    function obj.clearChangesBuffer()
        _changes = {}
        changes = {}
    end

    return obj
end

if better and better.isAvailable() and better.canvas and better.version >= 40 then
    local better_canvas_clear = better.canvas.clear
    local better_canvas_fill = better.canvas.fill
    local better_canvas_set = better.canvas.set

    function canvasAPI.createBetterCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation)
        local obj = {sizeX = sizeX, sizeY = sizeY}
        local maxX, maxY = sizeX - 1, sizeY - 1
        local maxEffectArrayBuffer = maxX + (maxY * sizeX)
        local dist
        local needOptimize = false
        local showState = false
        local disable = false
        local flushedDefault = false

        local betterCanvas = better.canvas.create(sizeX, sizeY)

        local drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, nil, betterCanvas, better_canvas_clear, better_canvas_fill, better_canvas_set)
        drawer.setWait(true)

        local defaultPosition = vec3_new(0, 0, 0)
        local function getSelfPos()
            local pt = type(parent)
            if pt == "Interactable" then
                return parent.shape.worldPosition
            elseif pt == "Character" then
                return parent.worldPosition
            end
            return defaultPosition
        end

        function obj.isRendering()
            return showState
        end

        function obj.disable(state)
            disable = state
        end

        function obj.setRenderDistance(_dist)
            dist = _dist
        end

        function obj.update()
            local newShowState = true
            local selfPosition
            if disable then
                newShowState = false
            elseif dist then
                if not pcall(function()
                    selfPosition = getSelfPos()
                    newShowState = mathDist(selfPosition, sm_localPlayer_getPlayer().character.worldPosition) <= dist
                end) then
                    selfPosition = selfPosition or vec3_new(0, 0, 0)
                    newShowState = false
                end
            end

            if newShowState ~= showState then
                showState = newShowState
                if newShowState then
                    drawer.setWait(false)
                    if not flushedDefault then
                        drawer.flush(true)
                        flushedDefault = true
                    end
                else
                    drawer.setWait(true)
                    better.canvas.stopUpdate(betterCanvas)
                end
            end

            if newShowState then
                better.canvas.update_3d(betterCanvas, selfPosition + (rotation * offset), -sm.quat.getRight(rotation), -sm.quat.getUp(rotation), (pixelSize.x * sizeX) / 2, (pixelSize.y * sizeY) / 2)
            end
        end

        function obj.setPixelSize(_pixelSize)
            pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
            if type(pixelSize) == "number" then
                if pixelSize < 0 then
                    pixelSize = math_abs(pixelSize)
                    local vec = vec3_new(pixelSize, pixelSize, 0)
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                else
                    local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                    vec.z = 0.00025
                    obj.setPixelSize(vec)
                end
            end
        end

        function obj.setOffset(_offset)
            offset = _offset
        end

        function obj.setCanvasRotation(_rotation)
            rotation = _rotation
        end

        function obj.destroy()
            better.canvas.destroy(betterCanvas)
        end

        ---------------------------------------

        obj.setPixelSize(pixelSize)
        obj.setCanvasRotation(rotation or quat_fromEuler(vec3_new(0, 0, 0)))
        obj.setOffset(offset or vec3_new(0, 0, 0))

        --[[
        local c = 0xff0000
        local seffect = createEffect(5, 5, 16, 16, c)
        local idx = 5 + (5 * sizeX)
        for i = 0, 16 - 1 do
            effects[idx + i] = {
                seffect,
                c,
                i,
                16,
                idx,
                5,
                5,
                1, --8. sizeY
                0 --9. indexY
            }
        end
        ]]

        ---------------------------------------

        obj.drawer = drawer
        for k, v in pairs(drawer) do
            obj[k] = v
        end

        return obj
    end
end

--low level display api
function canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material, scaleAddValue, altFromEuler, autoLayerDistance)
    local hiddenOffset = vec3_new(1000000, 1000000, 1000000)
    local defaultSizeX, defaultSizeY = sizeX, sizeY
    local pixelScaleX, pixelScaleY = 1, 1
    local obj = {sizeX = sizeX, sizeY = sizeY}
    local maxX, maxY = sizeX - 1, sizeY - 1
    local maxEffectArrayBuffer = maxX + (maxY * sizeX)
    local dist
    local needOptimize = false
    local skipOptimize = false
    local showState = false
    local disable = false

    local _setPosition, _setRotation
    if parent then
        _setPosition, _setRotation = effect_setOffsetPosition, effect_setOffsetRotation
    else
        _setPosition, _setRotation = effect_setPosition, effect_setRotation
    end

    material = material or canvasAPI.material.classic
    local autoScaleAddValue = false
    if not scaleAddValue then
        autoScaleAddValue = true
    end

    local flushedDefault = false
    local oldBackplateColor
    local backplate
    if canvasAPI.multi_layer[tostring(material)] then
        oldBackplateColor = 0
        backplate = sm_effect_createEffect(getEffectName(), parent)
        effect_setParameter(backplate, "uuid", material)
        effect_setParameter(backplate, "color", black)
    end

    local additionalLayer
    local function updateAdditionalLayer()
        if material == canvasAPI.material.smoothed then
            if not additionalLayer then
                additionalLayer = sm_effect_createEffect(getEffectName(), parent)
                effect_setParameter(additionalLayer, "uuid", canvasAPI.material.glass)
                effect_setParameter(additionalLayer, "color", black)
                effect_start(additionalLayer)
                return true
            end
        elseif additionalLayer then
            effect_destroy(additionalLayer)
            additionalLayer = nil
        end
    end
    updateAdditionalLayer()

    local layerDistance
    local function updateLayerDistance(distance)
        layerDistance = math.max(0.001, autoLayerDistance and distance or 0)
    end
    updateLayerDistance()

    local effects = {}
    local nodeEffects = {}
    local effectDatas = {}
    local effectDataLen = 5

    local bufferedEffectsUpdateTime = {}
    local bufferedEffects = {}
    local bufferedEffectsIndex = 0
    local lastDrawTickTime
    local optimizationLevel = 16
    local optimizationValue = optimizationLevelToValue(optimizationLevel)
    local alpha = DEFAULT_ALPHA_VALUE

    local oldHardwareParams = {
        offset_x = 0,
        offset_y = 0,
        offset_z = 0,
        
        rotation_x = 0,
        rotation_y = 0,
        rotation_z = 0,

        scale_x = 1,
        scale_y = 1
    }

    local function getEIndex(index)
        return index * effectDataLen
    end

    local function fromEIndex(index)
        return index / effectDataLen
    end

    local function setEffectDataParams(index)
        local effect = nodeEffects[index]
        local eindex = getEIndex(index)
        local posX, posY, lSizeX, lSizeY = effectDatas[eindex+1], effectDatas[eindex+2], effectDatas[eindex+3], effectDatas[eindex+4]

        posX = posX + ((lSizeX - 1) * 0.5)
        posY = posY + ((lSizeY - 1) * 0.5)
        _setPosition(effect, rotation * (offset + vec3_new(((posX + 0.5) - (sizeX / 2)) * pixelSize.x, ((posY + 0.5) - (sizeY / 2)) * -pixelSize.y, backplate and (debugMode and 0.05 or layerDistance) or 0)))

        local localScaleAddValue = debugMode and -(pixelSize.x / 2) or scaleAddValue
        local vec = pixelSize * 1
        vec.x = (pixelSize.x * lSizeX) + localScaleAddValue
        vec.y = (pixelSize.y * lSizeY) + localScaleAddValue
        effect_setScale(effect, vec)

        effect_setParameter(effect, "color", color_new_fromSmallNumber(effectDatas[eindex], alpha))
    end

    local function createEffect()
        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            _setRotation(effect, rotation)
        end
        return effect
    end

    local function createEffectUnhide(hideList)
        local effect
        if bufferedEffectsIndex > 0 then
            effect = bufferedEffects[bufferedEffectsIndex]
            hideList[effect] = nil
            bufferedEffectsIndex = bufferedEffectsIndex - 1
            if not effect_isPlaying(effect) then
                effect_start(effect)
            end
        else
            effect = sm_effect_createEffect(getEffectName(), parent)
            effect_setParameter(effect, "uuid", material)
            if showState then
                effect_start(effect)
            end
            _setRotation(effect, rotation)
        end
        return effect
    end

    local function clearBufferedEffects()
        for i = 1, bufferedEffectsIndex do
            effect_destroy(bufferedEffects[i])
        end
        bufferedEffectsUpdateTime = {}
        bufferedEffects = {}
        bufferedEffectsIndex = 0
    end

    local lastNewBuffer, lastBase

    local lastPopularColor
    local function mathPopularColor()
        local colorUsesTable = {}
        local colorUses = 0
        local oldColorUses = 0
        local colorSum = 0
        for index in pairs(nodeEffects) do
            local eindex = getEIndex(index)
            local color = effectDatas[eindex]
            local colorSize = effectDatas[eindex+3] * effectDatas[eindex+4]
            colorUsesTable[color] = (colorUsesTable[color] or 0) + colorSize
            colorSum = colorSum + colorSize
            colorUses = colorUsesTable[color]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = color
            end
        end

        if oldBackplateColor then
            local colorSize = (sizeX * sizeY) - colorSum
            colorUsesTable[oldBackplateColor] = (colorUsesTable[oldBackplateColor] or 0) + colorSize
            colorUses = colorUsesTable[oldBackplateColor]
            if colorUses > oldColorUses then
                oldColorUses = colorUses
                lastPopularColor = oldBackplateColor
            end
        end
    end

    local function effectIndexAtPos(px, py)
        return py + (px * sizeY)
    end

    local function getRootEIndexAtPos(px, py)
        if py < 0 or py >= sizeY then return end
        local index = effects[effectIndexAtPos(px, py)]
        return index and getEIndex(index), index
    end

    local function clearEffectFromBuffer(index)
        local eindex = getEIndex(index)
        local six, ix, iy = effectDatas[eindex+1], effectDatas[eindex+1], effectDatas[eindex+2]
        local sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        nodeEffects[index] = nil
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix >= six + sizeX then
                ix = six
                iy = iy + 1
            end
        end
    end

    local function hideEffect(effect)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        bufferedEffectsUpdateTime[bufferedEffectsIndex] = game_getCurrentTick()
        _setPosition(effect, hiddenOffset)
    end

    local function hideEffectData(index)
        hideEffect(nodeEffects[index])
        clearEffectFromBuffer(index)
    end

    local function hideEffectLater(effect, hideList)
        bufferedEffectsIndex = bufferedEffectsIndex + 1
        bufferedEffects[bufferedEffectsIndex] = effect
        bufferedEffectsUpdateTime[bufferedEffectsIndex] = game_getCurrentTick()
        hideList[effect] = true
        --_setPosition(effect, hiddenOffset)
    end

    local function hideEffectDataLater(index, hideList)
        hideEffectLater(nodeEffects[index], hideList)
        clearEffectFromBuffer(index)
    end    
    
    local function hideEffectsWithColor(color)
        for index in pairs(nodeEffects) do
            if effectDatas[getEIndex(index)] == color then
                hideEffectData(index)
            end
        end
    end

    local function delAllEffects()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        effects = {}
        nodeEffects = {}
    end

    --[[
    local function forceRecreateNodeEffects()
        nodeEffects = {}
        for i, effectData in pairs(effects) do
            if effectData[7] == i then
                nodeEffects[i] = effectData
            end
        end
    end
    ]]

    --local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
    local function colorEquals_smart(color1, color2)
        if color1 == color2 then return true end
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        --return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
        return ((math_abs(rVal - rVal2) + math_abs(gVal - gVal2) + math_abs(bVal - bVal2)) / 1024) <= optimizationValue
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    local function getFillZone(eindex)
        local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
        return fillX1, fillY1, fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
    end

    local sumAttachTime = 0
    local sumAttachFillTime = 0
    local function tryLongAttach(changedList, hideList, index, px, py, color, sizeX, sizeY)
        local startTime = os_clock()

        --[[
        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        local origEffect
        if origIndex then
            origEffect = nodeEffects[origIndex]
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end
        ]]

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local downParentE, downParent = getRootEIndexAtPos(px, py + sizeY)
        local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)
        local downAvailable = downParentE and nodeEffects[downParent] and effectDatas[downParentE+1] == px and effectDatas[downParentE+3] == sizeX and colorEquals(effectDatas[downParentE], color)

        local fillOptional = false
        local fillX1, fillY1, fillX2, fillY2
        local fill2X1, fill2Y1, fill2X2, fill2Y2

        --[[
        if origEffect and (upAvailable or downAvailable) then
            hideEffectLater(origEffect, hideList)
            changedList[origIndex] = nil
            changedColorList[origIndex] = nil
            nodeEffects[origIndex] = nil
        end
        ]]

        local newIndex, newEIndex
        local fillVal
        if upAvailable and downAvailable then
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

            local addSizeY = sizeY + effectDatas[downParentE+4]

            hideEffectLater(nodeEffects[downParent], hideList)
            changedList[downParent] = nil
            --changedColorList[downParent] = nil
            nodeEffects[downParent] = nil

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + addSizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
        elseif upAvailable then
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent
        elseif downAvailable then
            fillOptional = true
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(downParentE)

            changedList[downParent] = nil
           --changedColorList[downParent] = nil

            nodeEffects[index] = nodeEffects[downParent]
            nodeEffects[downParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[downParentE]
            effectDatas[eindex+1] = effectDatas[downParentE+1]
            effectDatas[eindex+2] = py
            effectDatas[eindex+3] = effectDatas[downParentE+3]
            effectDatas[eindex+4] = effectDatas[downParentE+4] + sizeY
            
            newIndex, newEIndex = index, eindex
            fillVal = index
        end

        if fillVal then
            index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
            sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
        end

        local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
        local rightParentE, rightParent = getRootEIndexAtPos(px + sizeX, py)
        local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
        local rightAvailable = rightParentE and nodeEffects[rightParent] and effectDatas[rightParentE+2] == py and effectDatas[rightParentE+4] == sizeY and colorEquals(effectDatas[rightParentE], color)

        if nodeEffects[index] and (leftAvailable or rightAvailable) then
            hideEffectLater(nodeEffects[index], hideList)
            changedList[index] = nil
            --changedColorList[index] = nil
            nodeEffects[index] = nil
        end

        if leftAvailable and rightAvailable then
            fillOptional = false
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

            local addSizeX = sizeX + effectDatas[rightParentE+3]

            hideEffectLater(nodeEffects[rightParent], hideList)
            changedList[rightParent] = nil
            --changedColorList[rightParent] = nil
            nodeEffects[rightParent] = nil

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + addSizeX
            fillVal = leftParent
        elseif leftAvailable then
            fillOptional = false
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = nil, nil, nil, nil

            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
            fillVal = leftParent
        elseif rightAvailable then
            fillOptional = not upAvailable and not downAvailable
            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            fill2X1, fill2Y1, fill2X2, fill2Y2 = getFillZone(rightParentE)

            changedList[rightParent] = nil
            --changedColorList[rightParent] = nil

            nodeEffects[index] = nodeEffects[rightParent]
            nodeEffects[rightParent] = nil

            local eindex = getEIndex(index)
            effectDatas[eindex] = effectDatas[rightParentE]
            effectDatas[eindex+1] = px
            effectDatas[eindex+2] = effectDatas[rightParentE+2]
            effectDatas[eindex+3] = sizeX + effectDatas[rightParentE+3]
            effectDatas[eindex+4] = effectDatas[rightParentE+4]
            
            fillVal = index
        end

        sumAttachTime = sumAttachTime + (os_clock() - startTime)

        if fillVal then
            changedList[fillVal] = true
            --changedColorList[fillVal] = true

            --[[
            local eindex = getEIndex(fillVal)
            local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
            local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = fillVal
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            ]]

            startTime = os_clock()

            --fillOptional = false
            --if not fillOptional or not origEffect then
                local ix, iy = fillX1, fillY1
                for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = fillVal
                    ix = ix + 1
                    if ix > fillX2 then
                        ix = fillX1
                        iy = iy + 1
                    end
                end
            --[[else
                local ix, iy = fillX1, fillY1
                for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                    if fillVal ~= effects[effectIndexAtPos(ix, iy)] then
                        print("WTTT", fillVal, effects[effectIndexAtPos(ix, iy)])
                    end
                    ix = ix + 1
                    if ix > fillX2 then
                        ix = fillX1
                        iy = iy + 1
                    end
                end
                ]]
            --end

            if fill2X1 then
                local ix, iy = fill2X1, fill2Y1
                for _ = 1, ((fill2X2 - fill2X1) + 1) * ((fill2Y2 - fill2Y1) + 1) do
                    effects[effectIndexAtPos(ix, iy)] = fillVal
                    ix = ix + 1
                    if ix > fill2X2 then
                        ix = fill2X1
                        iy = iy + 1
                    end
                end
            end

            sumAttachFillTime = sumAttachFillTime + (os_clock() - startTime)

            --fillVal = tryAttach(changedList, changedColorList, index, px, py, color) or fillVal
        end

        return fillVal
    end

    local function tryAttach(changedList, hideList, index, px, py, color, sizeX, sizeY)
        local startTime = os_clock()

        --[[
        local origIndex = effects[index]
        local sizeX, sizeY = 1, 1
        local origEffect
        if origIndex then
            origEffect = nodeEffects[origIndex]
            local eindex = getEIndex(origIndex)
            index, px, py = origIndex, effectDatas[eindex+1], effectDatas[eindex+2]
            sizeX, sizeY = effectDatas[eindex+3], effectDatas[eindex+4]
        end
        ]]

        local upParentE, upParent = getRootEIndexAtPos(px, py - 1)
        local upAvailable = upParentE and nodeEffects[upParent] and effectDatas[upParentE+1] == px and effectDatas[upParentE+3] == sizeX and colorEquals(effectDatas[upParentE], color)

        local fillX1, fillY1, fillX2, fillY2
        local newIndex, newEIndex, fillVal
        if upAvailable then
            --[[
            if origEffect then
                hideEffectLater(origEffect, hideList)
                changedList[origIndex] = nil
                changedColorList[origIndex] = nil
                nodeEffects[origIndex] = nil
            end
            ]]

            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)

            effectDatas[upParentE+4] = effectDatas[upParentE+4] + sizeY
            newIndex, newEIndex = upParent, upParentE
            fillVal = upParent

            index, px, py = newIndex, effectDatas[newEIndex+1], effectDatas[newEIndex+2]
            sizeX, sizeY = effectDatas[newEIndex+3], effectDatas[newEIndex+4]
        end

        local leftParentE, leftParent = getRootEIndexAtPos(px - 1, py)
        local leftAvailable = leftParentE and nodeEffects[leftParent] and effectDatas[leftParentE+2] == py and effectDatas[leftParentE+4] == sizeY and colorEquals(effectDatas[leftParentE], color)
        if leftAvailable then
            if nodeEffects[index] then
                hideEffectLater(nodeEffects[index], hideList)
                changedList[index] = nil
                --changedColorList[index] = nil
                nodeEffects[index] = nil
            end

            fillX1, fillY1, fillX2, fillY2 = px, py, px + (sizeX - 1), py + (sizeY - 1)
            effectDatas[leftParentE+3] = effectDatas[leftParentE+3] + sizeX
            fillVal = leftParent
        end

        sumAttachTime = sumAttachTime + (os_clock() - startTime)

        if fillVal then
            changedList[fillVal] = true
            --changedColorList[fillVal] = true

            startTime = os_clock()
            local ix, iy = fillX1, fillY1
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                effects[effectIndexAtPos(ix, iy)] = fillVal
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
            sumAttachFillTime = sumAttachFillTime + (os_clock() - startTime)
        end

        return fillVal
    end

    local sumFillTime = 0
    local function fillBlock(x, y, sx, sy, changedList, hideList, color, iterate, effect)
        if sx <= 0 or sy <= 0 then
            return
        end

        local newRIndex = effectIndexAtPos(x, y)
        nodeEffects[newRIndex] = effect or createEffectUnhide(hideList)
        changedList[newRIndex] = true
        --changedColorList[newRIndex] = true

        local newEIndex = getEIndex(newRIndex)
        effectDatas[newEIndex] = color
        effectDatas[newEIndex+1] = x
        effectDatas[newEIndex+2] = y
        effectDatas[newEIndex+3] = sx
        effectDatas[newEIndex+4] = sy

        if not iterate then
            return true
        end
        
        local startTime = os_clock()
        local ix, iy = x, y
        local six = ix
        local mix = six + sx
        for _ = 1, sx * sy do
            effects[effectIndexAtPos(ix, iy)] = newRIndex
            ix = ix + 1
            if ix >= mix then
                ix = six
                iy = iy + 1
            end
        end
        sumFillTime = sumFillTime + (os_clock() - startTime)

        return true
    end

    local sumExtractTime = 0
    local function extractPixel(changedList, hideList, index, px, py, sizeX, sizeY)
        local startTime = os_clock()

        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local lx = px - rpx
        local ly = py - rpy

        local effect = nodeEffects[rindex]
        changedList[rindex] = nil
        --changedColorList[rindex] = nil
        nodeEffects[rindex] = nil

        local color = effectDatas[eindex]
        --local block1, block2, block3, block4 = false, false, false, false
        if fillBlock(rpx, rpy, lx, rsy, changedList, hideList, color, false, effect) then --[[block1 = true]] effect = nil end
        if fillBlock(rpx + lx + sizeX, rpy, rsx - lx - sizeX, rsy, changedList, hideList, color, true, effect) then --[[block2 = true]] effect = nil end
        if fillBlock(rpx + lx, rpy, sizeX, ly, changedList, hideList, color, true, effect) then --[[block3 = true]] effect = nil end
        if fillBlock(rpx + lx, rpy + ly + sizeY, sizeX, rsy - ly - sizeY, changedList, hideList, color, true, effect) then --[[block4 = true]] effect = nil end

        local ix, iy, endX = px, py, px + (sizeX - 1)
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = nil
            ix = ix + 1
            if ix > endX then
                ix = px
                iy = iy + 1
            end
        end

        if effect then
            hideEffectLater(effect, hideList)
        end

        sumExtractTime = sumExtractTime + (os_clock() - startTime)

        --if block1 then tryAttach(changedList, changedColorList, effectIndexAtPos(rpx, rpy), rpx, rpy, color) end
        --if block2 then tryAttach(changedList, changedColorList, effectIndexAtPos(block2X, rpy), block2X, rpy, color) end
        --if block3 then tryAttach(changedList, changedColorList, effectIndexAtPos(block3X, rpy), block3X, rpy, color) end
        --if block4 then tryAttach(changedList, changedColorList, effectIndexAtPos(block4X, block4Y), block4X, block4Y, color) end
    end

    --[[
    local function extractXLine(changedList, changedColorList, hideList, index, px, py)
        local rindex = effects[index]
        local eindex = getEIndex(rindex)
        local rpx, rpy = effectDatas[eindex+1], effectDatas[eindex+2]
        local rsx, rsy = effectDatas[eindex+3], effectDatas[eindex+4]
        local ly = py - rpy

        local effect = nodeEffects[rindex]
        changedList[rindex] = nil
        changedColorList[rindex] = nil
        nodeEffects[rindex] = nil
        effects[index] = nil

        local color = effectDatas[eindex]
        if fillBlock(rpx, rpy, rsx, ly, changedList, changedColorList, hideList, color, false, effect) then effect = nil end
        if fillBlock(rpx, rpy + ly + 1, rsx, rsy - ly - 1, changedList, changedColorList, hideList, color, true, effect) then effect = nil end

        if effect then
            hideEffectLater(effect, hideList)
        end
    end
    ]]

    local function fillEffectsLinks(index, px, py, sizeX, sizeY)
        local ix, iy, endX = px, py, px + (sizeX - 1)
        for _ = 1, sizeX * sizeY do
            effects[effectIndexAtPos(ix, iy)] = index
            ix = ix + 1
            if ix > endX then
                ix = px
                iy = iy + 1
            end
        end
    end

    --[[
    local sumIsFullChangeTime = 0
    local function isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, forDestroy)
        local effectID = nodeEffects[rindex].id
        if fullChecked[effectID] then
            return false
        end
        fullChecked[effectID] = true


        local startTime = os_clock()

        local fillX1, fillY1 = effectDatas[eindex+1], effectDatas[eindex+2]
        local fillX2, fillY2 = fillX1 + (effectDatas[eindex+3] - 1), fillY1 + (effectDatas[eindex+4] - 1)
        local baseColor = lastNewBuffer[effectIndexAtPos(fillX1, fillY1)] or lastBase

        local ix, iy = fillX1 + 1, fillY1
        if ix > fillX2 then
            ix = fillX1
            iy = iy + 1
        end
        for _ = 2, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
            local color = lastNewBuffer[effectIndexAtPos(ix, iy)] or lastBase
            if color ~= baseColor then
                sumIsFullChangeTime = sumIsFullChangeTime + (os_clock() - startTime)
                return false
            end
            ix = ix + 1
            if ix > fillX2 then
                ix = fillX1
                iy = iy + 1
            end
        end

        ix, iy = fillX1, fillY1
        if not forDestroy then
            for _ = 1, ((fillX2 - fillX1) + 1) * ((fillY2 - fillY1) + 1) do
                local index = effectIndexAtPos(ix, iy)
                _changes[index] = true
                ix = ix + 1
                if ix > fillX2 then
                    ix = fillX1
                    iy = iy + 1
                end
            end
        end

        sumIsFullChangeTime = sumIsFullChangeTime + (os_clock() - startTime)
        return true
    end
    ]]

    --[[
    local function getBlockSize(rindex, index, px, py, color)
        local sizeX = 1
        --local sizeY = 1
        --[[
        for i = 1, maxY - py do
            if rindex ~= effects[index+i] or (lastNewBuffer[index+i] or lastBase) ~= color then
                break
            end
            sizeY = sizeY + 1
        end
        ] ]
        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
                --sizeY = sizeY + 1
            end
        end

        --[[
        for iy = 1, maxY - py do
            local multibrake = false
            for ix = 0, sizeX - 1 do
                local lindex = effectIndexAtPos(px+ix, py+iy)
                if rindex ~= effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                    multibrake = true
                    break
                end
            end
            if multibrake then
                break
            end
            sizeY = sizeY + 1
        end
        ] ]

        return sizeX, iy
    end
    ]]

    local function getBlockSize(index, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if effects[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local function getBlockSizeOptimization(index, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if effects[lindex] or not lastNewBuffer[lindex] or not colorEquals(lastNewBuffer[lindex], color) then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if effects[lindex] or not lastNewBuffer[lindex] or not colorEquals(lastNewBuffer[lindex], color) then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local function getChangesBlockSize(rindex, index, changes, px, py, color)
        local sizeX = 1

        for i = 1, maxX - px do
            local lindex = effectIndexAtPos(px+i, py)
            if rindex ~= effects[lindex] or not changes[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            sizeX = sizeX + 1
        end

        local ix, iy, endX = 0, 1, sizeX - 1
        for _ = 1, sizeX * (maxY - py) do
            local lindex = effectIndexAtPos(px+ix, py+iy)
            if rindex ~= effects[lindex] or not changes[lindex] or (lastNewBuffer[lindex] or lastBase) ~= color then
                break
            end
            
            ix = ix + 1
            if ix > endX then
                ix = 0
                iy = iy + 1
            end
        end

        return sizeX, iy
    end

    local _oldVirtualBackplateColor
    local drawer
    local lastDrawWithClear = true
    drawer = canvasAPI.createDrawer(sizeX, sizeY, nil, function (base, clearOnly, maxBuffer, force, newBuffer, realBuffer, _, _, changes, changesIndex, changesCount, _changes, clearBackplate)
        lastNewBuffer, lastBase = newBuffer, base
        lastDrawWithClear = clearBackplate

        if clearOnly and backplate then
            clearBufferedEffects()
            drawer.clearChangesBuffer()
            delAllEffects()
            return
        end

        local changedList = {}
        --local changedColorList = {}
        local hideList = {}
        --local fullChecked = {}

        --print("changesCount 1", changesCount)

        local oldChanges
        if clearBackplate then
            local startTime = os_clock()

            oldChanges = {}
            for index in pairs(changes) do
                oldChanges[index] = true
            end

            for index in pairs(_changes) do
                if not changes[index] then
                    changesCount = changesCount + 1
                    changesIndex[changesCount] = index
                    changes[index] = true
                end
            end

            profiller("clear-loop", startTime)
        end

        --[[
        local _changesSize = 0
        for k, v in pairs(_changes) do
            _changesSize = _changesSize + 1
        end
        print(tostring(_changes), _changesSize)
        ]]

        --print("changesCount 2", changesCount)

        --[[
        local startTime = os_clock()
        table_sort(changesIndex, function (a, b)
            return a < b
        end)
        profiller("stack-sort", startTime)
        ]]

        --[[
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex then
                local eindex = getEIndex(rindex)
                if not colorEquals(effectDatas[eindex], color) then
                    local px = math_floor(index / sizeY)
                    local py = index % sizeY
                    local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
                    local backplateColor = color == oldBackplateColor
                    if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, backplateColor) then
                        if backplateColor then
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        elseif not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        end
                    elseif backplateColor then
                        if aSizeX or aSizeY then
                            extractPixel(changedList, changedColorList, hideList, index, px, py)
                        else
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        end
                    else
                        _changes[index] = true

                        if aSizeX or aSizeY then
                            extractPixel(changedList, changedColorList, hideList, index, px, py)
                        end

                        if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                            local eindex = getEIndex(index)

                            if not nodeEffects[index] then
                                local effect = createEffectUnhide(hideList)

                                local bSizeX, bSizeY = 1, 1
                                effectDatas[eindex+1] = px
                                effectDatas[eindex+2] = py
                                effectDatas[eindex+3] = bSizeX
                                effectDatas[eindex+4] = bSizeY
                                fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                
                                nodeEffects[index] = effect
                                changedList[index] = true
                            end

                            effectDatas[eindex] = color
                            changedColorList[index] = true
                        end
                    end
                end
            elseif color ~= oldBackplateColor then
                _changes[index] = true
                local px = math_floor(index / sizeY)
                local py = index % sizeY
                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect

                    local eindex = getEIndex(index)
                    local bSizeX, bSizeY = getBlockSize(index, px, py)
                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = bSizeX
                    effectDatas[eindex+4] = bSizeY
                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                    
                    changedList[index] = true
                    changedColorList[index] = true
                end
            end
        end
        profiller("change-loop", startTime)
        ]]

        --local localEffectsBlacklist = {}

        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex --[[and not localEffectsBlacklist[rindex] ]] then
                local eindex = getEIndex(rindex)
                --local isBackgroundColor = color == oldBackplateColor
                --if color == oldBackplateColor or not colorEquals(effectDatas[eindex], color) then
                if realBuffer[index] ~= color then
                    --local px = math_floor(index / sizeY)
                    --local py = index % sizeY
                    --local aSizeX, aSizeY = effectDatas[eindex+3] > 1, effectDatas[eindex+4] > 1
                    --[[if isFullChangeAvailable(fullChecked, changes, _changes, rindex, eindex, backplateColor) then
                        if backplateColor then
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        else
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        end
                    else]]
                    
                    --local aSizeX, aSizeY = effectDatas[eindex+3], effectDatas[eindex+4]
                    if effectDatas[eindex+3] > 1 or effectDatas[eindex+4] > 1 then
                        local px = math_floor(index / sizeY)
                        local py = index % sizeY
                        --local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                        --extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)
                        extractPixel(changedList, hideList, index, px, py, getChangesBlockSize(rindex, index, changes, px, py, color))

                        --[[
                        local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                        if aSizeX == bSizeX and aSizeY == bSizeY then
                            effectDatas[eindex] = color
                            changedColorList[rindex] = true
                        else
                            extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)
                        end
                        ]]

                        --[[
                        if not isBackgroundColor then
                            if not tryAttach(changedList, changedColorList, hideList, index, px, py, color, bSizeX, bSizeY) then
                                local effect = createEffectUnhide(hideList)

                                nodeEffects[index] = effect

                                local eindex = getEIndex(index)
                                effectDatas[eindex] = color
                                effectDatas[eindex+1] = px
                                effectDatas[eindex+2] = py
                                effectDatas[eindex+3] = bSizeX
                                effectDatas[eindex+4] = bSizeY
                                fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                
                                changedList[index] = true
                                changedColorList[index] = true
                                localEffectsBlacklist[index] = true
                            end
                        end
                        ]]
                    else
                        changedList[rindex] = nil
                        --changedColorList[rindex] = nil
                        hideEffectDataLater(rindex, hideList)
                    end
                end
            end
            realBuffer[index] = color
        end
        profiller("extract-loop", startTime)

        --local blockSizeCache = {}
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            if color ~= oldBackplateColor then
                _changes[index] = true

                if not effects[index] then
                    local px = math_floor(index / sizeY)
                    local py = index % sizeY

                    if not tryLongAttach(changedList, hideList, index, px, py, color, 1, 1) then
                        --[[
                        local blockSize
                        if blockSizeCache[index] then
                            blockSize = blockSizeCache[index]
                            print("LOAD", index, blockSize)
                        else
                            blockSize = {getBlockSize(index, px, py, color)}
                            blockSizeCache[index] = blockSize
                        end
                        ]]

                        local bSizeX, bSizeY = getBlockSize(index, px, py, color)
                        if not tryLongAttach(changedList, hideList, index, px, py, color, bSizeX, bSizeY) then
                            local effect = createEffectUnhide(hideList)

                            nodeEffects[index] = effect

                            local eindex = getEIndex(index)
                            effectDatas[eindex] = color
                            effectDatas[eindex+1] = px
                            effectDatas[eindex+2] = py
                            effectDatas[eindex+3] = bSizeX
                            effectDatas[eindex+4] = bSizeY
                            fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                            
                            changedList[index] = true
                            --changedColorList[index] = true
                        end

                        --[[
                        local effect = createEffectUnhide(hideList)

                        nodeEffects[index] = effect
                        effects[index] = index

                        local eindex = getEIndex(index)
                        effectDatas[eindex] = color
                        effectDatas[eindex+1] = px
                        effectDatas[eindex+2] = py
                        effectDatas[eindex+3] = 1
                        effectDatas[eindex+4] = 1
                        
                        changedList[index] = true
                        ]]
                    end
                end
            end
        end
        profiller("add-loop", startTime)

        --[[
        local localEffectsBlacklist = {}
        local startTime = os_clock()
        for i2 = 1, changesCount do
            local index = changesIndex[i2]
            local color = newBuffer[index] or base
            local rindex = effects[index]
            if rindex then
                if not localEffectsBlacklist[rindex] then
                    local eindex = getEIndex(rindex)
                    local isBackgroundColor = color == oldBackplateColor
                    if isBackgroundColor or not colorEquals(effectDatas[eindex], color) then
                        if effectDatas[eindex+3] > 1 or effectDatas[eindex+4] > 1 then
                            local px = math_floor(index / sizeY)
                            local py = index % sizeY
                            local bSizeX, bSizeY = getBlockSize(rindex, index, px, py, color)
                            extractPixel(changedList, changedColorList, hideList, index, px, py, bSizeX, bSizeY)

                            if not isBackgroundColor then
                                _changes[index] = true

                                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                                    local effect = createEffectUnhide(hideList)

                                    nodeEffects[index] = effect

                                    local eindex = getEIndex(index)
                                    effectDatas[eindex] = color
                                    effectDatas[eindex+1] = px
                                    effectDatas[eindex+2] = py
                                    effectDatas[eindex+3] = bSizeX
                                    effectDatas[eindex+4] = bSizeY
                                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                                    
                                    changedList[index] = true
                                    changedColorList[index] = true
                                    localEffectsBlacklist[index] = true
                                end
                            end
                        elseif not isBackgroundColor then
                            _changes[index] = true

                            local px = math_floor(index / sizeY)
                            local py = index % sizeY
                            if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                                effectDatas[eindex] = color
                                changedColorList[rindex] = true
                            end
                        else
                            changedList[rindex] = nil
                            changedColorList[rindex] = nil
                            hideEffectDataLater(rindex, hideList)
                        end
                    end
                end
            elseif color ~= oldBackplateColor then
                _changes[index] = true

                local px = math_floor(index / sizeY)
                local py = index % sizeY
                if not tryAttach(changedList, changedColorList, hideList, index, px, py, color) then
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect

                    local eindex = getEIndex(index)
                    local bSizeX, bSizeY = getBlockSize(nil, index, px, py, color)
                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = bSizeX
                    effectDatas[eindex+4] = bSizeY
                    fillEffectsLinks(index, px, py, bSizeX, bSizeY)
                    
                    changedList[index] = true
                    changedColorList[index] = true
                    localEffectsBlacklist[index] = true
                end
            end
        end
        profiller("change-loop", startTime)
        ]]

        local contentUpdated = false

        startTime = os_clock()
        for index in pairs(changedList) do
            setEffectDataParams(index)
            contentUpdated = true
        end
        profiller("apply-params", startTime)

        --[[
        startTime = os_clock()
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            if not colorCache[color] then
                colorCache[color] = color_new_fromSmallNumber(color, alpha)
            end
            effect_setParameter(nodeEffects[index], "color", colorCache[color])
        end
        profiller("apply-colors", startTime)
        ]]
        --[[
        startTime = os_clock()
        local colorobj = color_new(0)
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            colorobj.r, colorobj.g, colorobj.b = hexToRGB(color)
            colorobj.a = alpha / 255
            effect_setParameter(nodeEffects[index], "color", colorobj)
            contentUpdated = true
        end
        profiller("apply-colors", startTime)
        ]]

        startTime = os_clock()
        for effect in pairs(hideList) do
            _setPosition(effect, hiddenOffset)
        end
        profiller("later-hide", startTime)

        profillerPrint("fill-sum", sumFillTime)
        profillerPrint("extract-sum", sumExtractTime)
        profillerPrint("attach-sum", sumAttachTime)
        profillerPrint("attach-fill-sum", sumAttachFillTime)
        --profillerPrint("isFullChange-sum", sumIsFullChangeTime)
        --sumIsFullChangeTime = 0
        sumFillTime = 0
        sumExtractTime = 0
        sumAttachTime = 0
        sumAttachFillTime = 0
        
        if clearBackplate then
            drawer.setOldChanges(oldChanges)
            --clearBackplate = false
        end

        if clearOnly then
            clearBufferedEffects()
            return
        end

        if contentUpdated then
            lastDrawTickTime = game_getCurrentTick()
            needOptimize = true
        end
    end, nil, function (_, color, changes)
        if backplate then
            oldBackplateColor = color
            effect_setParameter(backplate, "color", color_new_fromSmallNumber(color, alpha))
        elseif color ~= _oldVirtualBackplateColor then
            drawer.fullRefresh()
            _oldVirtualBackplateColor = color
        end
    end, nil, nil, true)

    if not backplate then
        drawer.fullRefresh()
    end

    local canvasWait
    local wait_dataTunnel
    local function _setWait(wait)
        canvasWait = wait
        drawer.setWait(wait)
        if not wait and wait_dataTunnel then
            obj.realPushDataTunnelParams(wait_dataTunnel)
            wait_dataTunnel = nil
        end
    end

    _setWait(true)

    local function recreateCanvas()
        if not lastNewBuffer then
            return
        end

        if backplate and not lastDrawWithClear then --WHAT? (fixed)
            mathPopularColor()
            if lastPopularColor ~= oldBackplateColor then
                effect_setParameter(backplate, "color", color_new_fromSmallNumber(lastPopularColor, alpha))
                oldBackplateColor = lastPopularColor
                drawer.fullRefresh()
            end
        end
        
        local hideList = {}
        for i, effect in pairs(nodeEffects) do
            hideEffectLater(effect, hideList)
        end
        effects = {}
        nodeEffects = {}
        effectDatas = {}

        local changedList = {}
        --local changedColorList = {}

        --local startTime = os.clock()
        local index = 0
        while index <= maxEffectArrayBuffer do
            local px = math_floor(index / sizeY)
            local py = index % sizeY
            local color = lastNewBuffer[index] or lastBase
            if effects[index] then
                index = index + effectDatas[getEIndex(effects[index])+4]
            elseif color ~= oldBackplateColor then
                local eindex = getEIndex(index)

                local newRootIndex = tryAttach(changedList, hideList, index, px, py, color, 1, 1)
                if newRootIndex then
                    local newRootEIndex = getEIndex(newRootIndex)
                    index = effectIndexAtPos(px, effectDatas[newRootEIndex+2] + effectDatas[newRootEIndex+4])
                else
                    local effect = createEffectUnhide(hideList)

                    nodeEffects[index] = effect
                    effects[index] = index

                    effectDatas[eindex] = color
                    effectDatas[eindex+1] = px
                    effectDatas[eindex+2] = py
                    effectDatas[eindex+3] = 1
                    effectDatas[eindex+4] = 1
                    
                    changedList[index] = true
                    --changedColorList[index] = true
                    index = index + 1
                end

                --[[
                local bSizeX, bSizeY = getBlockSizeOptimization(index, px, py, color)
                local effect = createEffectUnhide(hideList)

                nodeEffects[index] = effect
                effectDatas[eindex] = color
                effectDatas[eindex+1] = px
                effectDatas[eindex+2] = py
                effectDatas[eindex+3] = bSizeX
                effectDatas[eindex+4] = bSizeY
                fillEffectsLinks(index, px, py, bSizeX, bSizeY)

                changedList[index] = true
                index = index + bSizeY
                ]]
            else
                index = index + 1
            end
        end
        --print("recreate-loop time:", os.clock() - startTime)

        for index in pairs(changedList) do
            setEffectDataParams(index)
        end

        --[[
        local colorobj = color_new(0)
        for index in pairs(changedColorList) do
            local color = effectDatas[getEIndex(index)]
            colorobj.r, colorobj.g, colorobj.b = hexToRGB(color)
            colorobj.a = alpha / 255
            effect_setParameter(nodeEffects[index], "color", colorobj)
        end
        ]]

        for effect in pairs(hideList) do
            _setPosition(effect, hiddenOffset)
        end
    end

    local _s_pixelSize, _s_offset, _s_rotation
    function obj.setCanvasMaterial(_material)
        material = _material
        local newBackplateExists = not not canvasAPI.multi_layer[tostring(material)]
        local oldBackplateExists = not not backplate

        if newBackplateExists ~= oldBackplateExists then
            _oldVirtualBackplateColor = nil
        end

        local updateParameters = false
        if newBackplateExists then
            if not oldBackplateExists then
                updateParameters = true
                oldBackplateColor = 0
                backplate = sm_effect_createEffect(getEffectName(), parent)
                effect_setParameter(backplate, "color", black)
                effect_setParameter(backplate, "uuid", material)
                if showState then
                    effect_start(backplate)
                end
            else
                effect_stop(backplate)
                effect_setParameter(backplate, "uuid", material)
                effect_start(backplate)
            end
        elseif oldBackplateExists then
            effect_destroy(backplate)
            oldBackplateColor = nil
            backplate = nil
            recreateCanvas()
        end

        for _, effect in pairs(nodeEffects) do
            effect_stop(effect)
            effect_setParameter(effect, "uuid", material)
            effect_start(effect)
        end

        for i = 1, bufferedEffectsIndex do
            local effect = bufferedEffects[i]
            effect_stop(effect)
            effect_setParameter(effect, "uuid", material)
            effect_start(effect)
        end

        local layerCreated = updateAdditionalLayer()

        if updateParameters or layerCreated then
            obj.setPixelSize(_s_pixelSize)
            obj.setOffset(_s_offset, true)
            obj.setCanvasRotation(_s_rotation)
        end
    end

    local function switchHardware()
        obj.setPixelSize(_s_pixelSize)
        obj.setOffset(_s_offset, true)
        obj.setCanvasRotation(_s_rotation)
    end

    local defaultPosition = vec3_new(0, 0, 0)
    local function getSelfPos()
        local pt = type(parent)
        if pt == "Interactable" then
            return parent.shape.worldPosition
        elseif pt == "Character" then
            return parent.worldPosition
        end
        return defaultPosition
    end

    local function updateLayersPos()
        if backplate then
            _setPosition(backplate, rotation * offset)
        end
        if additionalLayer then
            _setPosition(additionalLayer, rotation * (offset + vec3_new(0, 0, 0.0015)))
        end
    end

    local longOptimizeCounter = 0
    local lastOptimizeTime = game_getCurrentTick()
    local function optimize()
        --[[
        if bufferedEffectsIndex > 4096 then
            for i = 1, bufferedEffectsIndex - 4096 do
                effect_stop(bufferedEffects[i])
                stoppedCount = stoppedCount + 1
            end

            --[[
            if bufferedEffectsIndex > 3000 then
                if debugMode then
                    print("destroy buffered effects")
                end

                for i = 3001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                end
                bufferedEffectsIndex = 3000
            end
            ] ]
        end
        ]]

        if longOptimizeCounter >= 3 then
            skipOptimize = true
            if debugMode then
                print("skip optimize")
            end
            return
        end

        local startTime = os_clock()
        recreateCanvas()

        local optimizeTime = os_clock() - startTime
        if optimizeTime > ((1 / 1000) * 50) then
            if debugMode then
                print("long optimize time", optimizeTime)
            end
            longOptimizeCounter = longOptimizeCounter + 1
        end

        lastOptimizeTime = game_getCurrentTick()
    end

    function obj.setAlpha(_alpha)
        alpha = _alpha
        for rindex, effect in pairs(nodeEffects) do
            effect_setParameter(effect, "color", color_new_fromSmallNumber(effectDatas[getEIndex(rindex)], alpha))
        end
    end

    function obj.setCanvasOptimizationLevel(value)
        optimizationLevel = value
        if value == 0 then
            colorEquals = colorEquals_raw
        else
            colorEquals = colorEquals_smart
        end
        optimizationValue = optimizationLevelToValue(optimizationLevel)
    end

    function obj.isRendering()
        return showState
    end

    function obj.disable(state)
        disable = state
    end

    function obj.setRenderDistance(_dist)
        dist = _dist
    end

    local reoptimizeTime = 20
    local reoptimizeDynamicTime = 40
    local canvasSize = sizeX * sizeY
    if canvasSize >= (512 * 512) then
        reoptimizeTime = 40
        reoptimizeDynamicTime = 80
    elseif canvasSize >= (256 * 256) then
        reoptimizeTime = 40
        reoptimizeDynamicTime = 60
    end

    local oldOptimizeTime
    local newShowState = true
    function obj.update()
        if disable then
            newShowState = false
        elseif dist then
            if not pcall(function()
                local currentDist = mathDist(getSelfPos(), sm_localPlayer_getPlayer().character.worldPosition)
                if currentDist <= dist then
                    newShowState = true
                elseif currentDist >= dist + 2 then
                    newShowState = false
                end
            end) then
                newShowState = false
            end
        end

        --recreateCanvas()

        if newShowState ~= showState then
            showState = newShowState
            if newShowState then
                obj.setWait(false)
                if not backplate and not flushedDefault then
                    drawer.flush(true)
                    flushedDefault = true
                end
                for _, effect in pairs(nodeEffects) do
                    if not effect_isPlaying(effect) then
                        effect_start(effect)
                    end
                end
                if backplate then
                    effect_start(backplate)
                end
                if additionalLayer then
                    effect_start(additionalLayer)
                end
            else
                for _, effect in pairs(nodeEffects) do
                    effect_stop(effect)
                end
                for i = 1, bufferedEffectsIndex do
                    effect_stop(bufferedEffects[i])
                end
                if backplate then
                    effect_stop(backplate)
                end
                if additionalLayer then
                    effect_stop(additionalLayer)
                end
                obj.setWait(true)
            end
        end

        local ctick = game_getCurrentTick()
        local optimizePeer = reoptimizeTime
        if lastDrawTickTime then
            if ctick - lastDrawTickTime < 20 then
                optimizePeer = reoptimizeDynamicTime
            end

            if longOptimizeCounter > 0 and (ctick - lastDrawTickTime > 40 * 5 or ctick - lastOptimizeTime > 40 * 10) then
                if debugMode then
                    print("reset longOptimizeCounter", longOptimizeCounter)
                end
                longOptimizeCounter = 0
                if skipOptimize then
                    optimize()
                    longOptimizeCounter = 0
                    skipOptimize = false
                end
            end
        end

        if ctick % 20 == 0 then
            local stoppedCount = 0
            local destroyedCount = 0

            if bufferedEffectsIndex > 6000 then
                for i = 6001, bufferedEffectsIndex do
                    effect_destroy(bufferedEffects[i])
                    bufferedEffects[i] = nil
                    destroyedCount = destroyedCount + 1
                end
                bufferedEffectsIndex = 6000
            end

            for i = 1, bufferedEffectsIndex - 1024 do
                local otick = bufferedEffectsUpdateTime[i]
                if otick ~= true and ctick - otick > 160 then
                    bufferedEffectsUpdateTime[i] = true
                    effect_stop(bufferedEffects[i])
                    stoppedCount = stoppedCount + 1
                end
            end

            if debugMode then
                if destroyedCount > 0 then
                    print("destroying buffered effects", destroyedCount)
                end
                print("stoping buffered effects", stoppedCount .. " / " .. bufferedEffectsIndex)
            end
        end

        if newShowState and needOptimize and optimizePeer and (not oldOptimizeTime or ctick - oldOptimizeTime >= optimizePeer) then
            needOptimize = false
            oldOptimizeTime = ctick
            optimize()
        end

        updateLayersPos()
    end

    function obj.setPixelSize(_pixelSize)
        pixelSize = _pixelSize or vec3_new(0.25 / 4, 0.25 / 4, 0.05 / 4)
        if type(pixelSize) == "Vec3" then
            _s_pixelSize = vec3_new(pixelSize.x, pixelSize.y, pixelSize.z)
        else
            _s_pixelSize = pixelSize
        end
        if type(pixelSize) == "number" then
            if pixelSize < 0 then
                pixelSize = math_abs(pixelSize)
                local vec = vec3_new(pixelSize, pixelSize, 0)
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            else
                local vec = vec3_new(0.0072, 0.0072, 0) * pixelSize
                vec.z = 0.00025
                obj.setPixelSize(vec)
                return
            end
        end
        pixelSize.x = pixelSize.x * oldHardwareParams.scale_x * pixelScaleX
        pixelSize.y = pixelSize.y * oldHardwareParams.scale_y * pixelScaleY
        --pixelSize.x = pixelSize.x + 0.00025
        --pixelSize.y = pixelSize.y + 0.00025
        if backplate then
            effect_setScale(backplate, vec3_new(pixelSize.x * sizeX, pixelSize.y * sizeY, pixelSize.z))
        end
        updateLayerDistance(math.max(pixelSize.x * sizeX, pixelSize.y * sizeY) / 1000)
        if additionalLayer then
            effect_setScale(additionalLayer, vec3_new(pixelSize.x * sizeX * 1.005, pixelSize.y * sizeY * 1.005, math.min(2, layerDistance + ((pixelSize.x * sizeX) / 3 / 128))))
        end
        if autoScaleAddValue then
            scaleAddValue = math_min((pixelSize.x + pixelSize.y) / 50, 0.0002)
        end
    end

    function obj.setOffset(_offset, noUpdateParameters)
        offset = vec3_new(_offset.x, _offset.y, _offset.z)
        _s_offset = vec3_new(_offset.x, _offset.y, _offset.z)
        offset.x = offset.x + oldHardwareParams.offset_x
        offset.y = offset.y + oldHardwareParams.offset_y
        offset.z = offset.z + oldHardwareParams.offset_z
        updateLayersPos()
        if not noUpdateParameters then
            for index in pairs(nodeEffects) do
                setEffectDataParams(index)
            end
        end
    end

    function obj.setCanvasRotation(_rotation)
        _s_rotation = _rotation
        if type(_rotation) == "Quat" then
        elseif altFromEuler then
            _rotation = custom_fromEulerYEnd(math.rad(_rotation.x) + oldHardwareParams.rotation_x, math.rad(_rotation.y) + oldHardwareParams.rotation_y, math.rad(_rotation.z) + oldHardwareParams.rotation_z)
        else
            _rotation = quat_fromEuler(vec3_new(_rotation.x + math.deg(oldHardwareParams.rotation_x), _rotation.y + math.deg(oldHardwareParams.rotation_y), _rotation.z + math.deg(oldHardwareParams.rotation_z)))
        end
        rotation = _rotation
        if backplate then
            _setRotation(backplate, rotation)
        end
        if additionalLayer then
            _setRotation(additionalLayer, rotation)
        end
        for index, effect in pairs(nodeEffects) do
            _setRotation(effect, rotation)
            setEffectDataParams(index)
        end
        for _, effect in pairs(bufferedEffects) do
            _setRotation(effect, rotation)
        end
    end

    function obj.destroy()
        for _, effect in pairs(nodeEffects) do
            effect_destroy(effect)
        end
        if backplate then
            effect_destroy(backplate)
        end
        if additionalLayer then
            effect_destroy(additionalLayer)
        end
    end

    local function raw_setResolution(_sizeX, _sizeY)
        drawer.setDrawerResolution(_sizeX, _sizeY)

        for _, effect in pairs(nodeEffects) do
            hideEffect(effect)
        end
        effects = {}
        nodeEffects = {}
        effectDatas = {}
        
        sizeX = _sizeX
        sizeY = _sizeY
        obj.sizeX = sizeX
        obj.sizeY = sizeY
        maxX, maxY = sizeX - 1, sizeY - 1
        maxEffectArrayBuffer = maxX + (maxY * sizeX)
        pixelScaleX, pixelScaleY = defaultSizeX / sizeX, defaultSizeY / sizeY
    end

    function obj.setCanvasResolution(_sizeX, _sizeY)
        raw_setResolution(_sizeX, _sizeY)
        switchHardware()
    end

    ---------------------------------------

    obj.setPixelSize(pixelSize)
    obj.setCanvasRotation(rotation or vec3_new(0, 0, 0))
    obj.setOffset(offset or vec3_new(0, 0, 0))

    ---------------------------------------

    obj.drawer = drawer
    for k, v in pairs(drawer) do
        obj[k] = v
    end
    obj.setWait = _setWait

    function obj.pushDataTunnelParams(dataTunnel)
        if canvasWait then
            wait_dataTunnel = dataTunnel
        else
            wait_dataTunnel = nil
            obj.realPushDataTunnelParams(dataTunnel)
        end
    end

    function obj.realPushDataTunnelParams(dataTunnel)
        obj.setCanvasOptimizationLevel(dataTunnel.optimizationLevel)
        drawer.pushDataTunnelParams(dataTunnel)

        local hardwareParamsChanged = false
        if dataTunnel.res_x ~= sizeX or dataTunnel.res_y ~= sizeY then
            raw_setResolution(dataTunnel.res_x, dataTunnel.res_y)

            hardwareParamsChanged = true
        end

        obj.setAlpha(dataTunnel.light)
        if dataTunnel.material and dataTunnel.material ~= material then
            obj.setCanvasMaterial(dataTunnel.material)
        end
        for key, value in pairs(oldHardwareParams) do
            if dataTunnel[key] ~= value then
                hardwareParamsChanged = true
                oldHardwareParams[key] = dataTunnel[key]
            end
        end
        if hardwareParamsChanged then
            switchHardware()
        end
    end

    return obj
end

--simulates the API of display from SComputers on the client side of your parts
--this is the easiest way to implement the display in your mod
function canvasAPI.createClientScriptableCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local dataTunnel = {}
    local canvas = canvasAPI.createCanvas(parent, sizeX, sizeY, pixelSize, offset, rotation, material)
    local api = canvasAPI.createScriptableApi(sizeX, sizeY, dataTunnel, nil, canvas.drawer, canvasAPI.materialList, 1, {
        maxOffset = math.huge,
        maxScale = math.huge
    }, {
        maxPixels = math.huge
    })
    api.registerClick = canvasAPI.addTouch(api, dataTunnel)
    api.dataTunnel = dataTunnel
    api.canvas = canvas

    local renderDistance = 15

    for k, v in pairs(canvas) do
        if k ~= "flush" then
            api[k] = v
        end
    end

    function api.getAudience()
        return canvas.isRendering() and 1 or 0
    end

    function api.update()
        canvas.disable(not api.isAllow())
        if dataTunnel.renderAtDistance then
            canvas.setRenderDistance()
        else
            canvas.setRenderDistance(renderDistance)
        end
        canvas.pushDataTunnelParams(dataTunnel)
        canvas.update()
        dataTunnel.scriptableApi_update()

        if dataTunnel.display_reset then
            canvas.drawerReset()
            dataTunnel.display_reset = nil
        end

        if dataTunnel.display_flush then
            if needPushStack(canvas, dataTunnel) then
                canvas.pushStack(dataTunnel.display_stack)
                canvas.flush()
            end
            
            dataTunnel.display_flush()
            dataTunnel.display_stack = nil
            dataTunnel.display_flush = nil
            dataTunnel.display_forceFlush = nil
        end
    end

    function api.setRenderDistance(dist)
        renderDistance = dist
    end

    return api
end

local customFontIndexesCache = {}
local checkedFonts = {}

--implement the SComputers API, does not implement data transfer
function canvasAPI.createScriptableApi(width, height, dataTunnel, flushCallback, drawer, materialList, defaultMaterial, allowHoloAPI, allowSetResolution)
    local defaultResolutionX, defaultResolutionY = width, height
    
    dataTunnel = dataTunnel or {}
    dataTunnel.rotation = 0
    dataTunnel.light = DEFAULT_ALPHA_VALUE
    dataTunnel.skipAtNotSight = false
    dataTunnel.utf8support = false
    dataTunnel.renderAtDistance = false
    dataTunnel.display_forceFlush = true
    dataTunnel.dataUpdated = true
    dataTunnel.optimizationLevel = 16

    local stack = {}
    local stackIndex = 1
    local pixelsCache = {} --optimizations for cameras
    local pixelsCacheExists = false
    local oldStackSum, oldDataSum, oldStack, oldStackIndex
    local forceFlag = false

    local function clearStackForce()
        stack = {}
        stackIndex = 1
    end

    local function clearStack()
        if dataTunnel.display_stack == stack then
            clearStackForce()
        end
    end

    local function setForceFrame()
        if pixelsCacheExists then
            pixelsCache = {}
            pixelsCacheExists = false
        end
        forceFlag = true
        dataTunnel.display_forceFlush = true
    end

    local oldPlayersCount = #sm.player.getAllPlayers()
    function dataTunnel.scriptableApi_update()
        local playersCount = #sm.player.getAllPlayers()
        --local force = sm.game.getCurrentTick() % 80 == 0
        local force = false
        if oldPlayersCount ~= playersCount or force then
            --dataTunnel.display_forceForceFlush = force
            setForceFrame()
            oldPlayersCount = playersCount
        end
    end

    local rwidth, rheight = width, height
    local rmwidth, rmheight = width - 1, height - 1
    local utf8support = false
    local monoFont = true
    local newDataFlag = false
    local spacing = 1
    local fontIndex = 0
    local lastPixelX, lastPixelY, lastPixelColor, lastAction
    local currentSettedFont
    local currentTouchs = {}

    local viewport_x, viewport_y, viewport_sx, viewport_sy

    local dFontX, dFontY = defaultFont.width, defaultFont.height
    local drFontX, drFontY = defaultFont.width, defaultFont.height
    local fontX, fontY
    local mFontX, mFontY
    local xFontX, xFontY
    local sFontX, sFontY
    local rFontX, rFontY
    local fontScaleX, fontScaleY = 1, 1
    local function updateFontSize()
        fontX, fontY = math_ceil(dFontX * fontScaleX), math_ceil(dFontY * fontScaleY)
        rFontX, rFontY = math_ceil(drFontX * fontScaleX), math_ceil(drFontY * fontScaleY)
        mFontX, mFontY = fontX - 1, fontY - 1
        xFontX, xFontY = fontX + 1, fontY + 1
        sFontX, sFontY = fontX + spacing, fontY + 1
    end
    updateFontSize()

    ---------------- color equals check
    local optimizationValue = optimizationLevelToValue(16)

    --local maxVal = math_sqrt((255 ^ 2) + (255 ^ 2) + (255 ^ 2))
    local function colorEquals_smart(color1, color2)
        if color1 == color2 then return true end
        local rVal, gVal, bVal = hexToRGB256(color1)
        local rVal2, gVal2, bVal2 = hexToRGB256(color2)
        --return (math_sqrt(((rVal - rVal2) ^ 2) + ((gVal - gVal2) ^ 2) + ((bVal - bVal2) ^ 2)) / maxVal) <= optimizationValue
        return ((math_abs(rVal - rVal2) + math_abs(gVal - gVal2) + math_abs(bVal - bVal2)) / 1024) <= optimizationValue
    end

    local colorEquals = colorEquals_smart

    local function colorEquals_raw(color1, color2)
        return color1 == color2
    end

    ----------------

    local api
    local api_flush
    api = {
        --[[
        getBuffer = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,
        getCurrent = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getRealBuffer(x + (y * rwidth))
        end,
        ]]
        get = function (x, y)
            if not drawer or x < 0 or x >= width or y < 0 or y >= height then return 0 end
            return drawer.getNewBuffer(x + (y * rwidth))
        end,

        -- not implemented (implement it yourself if necessary)
        isAllow = function()
            return true
        end,
        getAudience = function()
            return 1
        end,

        setOptimizationLevel = function(value)
            checkArg(1, value, "number")
            value = round(value)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.optimizationLevel ~= value then
                optimizationValue = optimizationLevelToValue(value)
                if value == 0 then
                    colorEquals = colorEquals_raw
                else
                    colorEquals = colorEquals_smart
                end

                dataTunnel.optimizationLevel = value
                dataTunnel.dataUpdated = true
            end
        end,
        getOptimizationLevel = function()
            return dataTunnel.optimizationLevel
        end,


        -- stubs (outdated methods)
        optimize = function() end,
        setFrameCheck = function () end,
        getFrameCheck = function () return false end,
        setSkipAtLags = function() end,
        getSkipAtLags = function() return false end,


        -- main
        setFontScale = function(scaleX, scaleY)
            checkArg(1, scaleX, "number")
            checkArg(2, scaleY, "number")
            if scaleX < 0 then scaleX = 0 end
            if scaleY < 0 then scaleY = 0 end
            fontScaleX, fontScaleY = scaleX, scaleY
            updateFontSize()
        end,
        getFontScale = function()
            return fontScaleX, fontScaleY
        end,
        setTextSpacing = function(_spacing)
            if _spacing < 0 then _spacing = 0 end
            spacing = _spacing
            updateFontSize()
        end,
        setFontSize = function(_width, _height)
            api.setFontScale(_width / dFontX, _height / dFontY)
        end,
        getTextSpacing = function()
            return spacing
        end,
        calcTextBox = function(text) --it will return two numbers, this will be the size of the box that your text will occupy with this font and this scale
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local totalSize = 0
            if monoFont then
                totalSize = textLen * (fontX + spacing)
            else
                local localFontWidth = dFontX
                local localFont = dataTunnel.customFont or font.optimized
                if fontIndex > 0 and fontsOptimized[fontIndex] then
                    localFont = fontsOptimized[fontIndex]
                    localFontWidth = localFont.width
                end

                local char, chrdata
                for i = 1, textLen do
                    char = sep(text, i, i)
                    if char ~= " " and char ~= spaceCharCode then
                        chrdata = localFont[char] or localFont.error or defaultError
                        totalSize = totalSize + (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                    else
                        totalSize = totalSize + (localFont.spaceSize or localFontWidth) + spacing
                    end
                    canvasAPI.yield()
                end
            end

            return totalSize - spacing, fontY
        end,
        calcCharsSize = function(text) --calculates the length of each character in a string, taking into account its spacing from the next character, and returns a table with these values
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    table_insert(lens, (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing)
                else
                    table_insert(lens, (localFont.spaceSize or localFontWidth) + spacing)
                end
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        calcDecreasingTextSizes = function(text) --it works almost like calcCharsSize. however, each value contains all the previous ones. this is used in the graphic.textBox function, but probably not applicable to any other
            local px, py
            local len, sep
            if utf8support then
                len, sep = utf8_len, utf8_sub
            else
                len, sep = string_len, string_byte
            end

            local textLen = len(text)
            if textLen == 0 then
                return 0, 0
            end

            local lens = {}
            local otherVals = 0

            local localFontWidth = dFontX
            local localFont = dataTunnel.customFont or font.optimized
            if fontIndex > 0 and fontsOptimized[fontIndex] then
                localFont = fontsOptimized[fontIndex]
                localFontWidth = localFont.width
            end

            local char, chrdata
            for i = 1, textLen do
                char = sep(text, i, i)
                local val
                if char ~= " " and char ~= spaceCharCode then
                    chrdata = localFont[char] or localFont.error or defaultError
                    val = (chrdata[0] and math_ceil(chrdata[0] * fontScaleX) or 0) + spacing
                else
                    val = (localFont.spaceSize or localFontWidth) + spacing
                end
                otherVals = otherVals + val
                table_insert(lens, otherVals)
                canvasAPI.yield()
            end

            lens[#lens] = lens[#lens] - spacing
            return lens
        end,
        isMonospacedFont = function()
            return not not monoFont
        end,

        getWidth = function()
            return rwidth
        end,
        getHeight = function()
            return rheight
        end,
        getSize = function()
            return rwidth, rheight
        end,
        getResolution = function()
            return rwidth, rheight
        end,

        clear = function(color)
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end

            lastAction = nil

            clearStackForce()
            stackIndex = 4
            stack[1] = resetViewportCodeID
            stack[2] = 0
            stack[3] = formatColorToSmallNumber(color, blackSmallNumber)
            
            --[[
            for i = 3, stackIndex - 1 do
                stack[i] = nil
            end
            stackIndex = 3
            ]]
        end,
        drawPixel = function(x, y, color)
            x, y = round(x), round(y)
            if x < 0 or x >= width or y < 0 or y >= height then return end
            local index = x + (y * rwidth)
            color = formatColorToSmallNumber(color, whiteSmallNumber)
            if pixelsCache[index] ~= color then
                if lastAction and x == lastPixelX + 1 and y == lastPixelY and colorEquals(lastPixelColor, color) then
                    if lastAction == 1 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 12
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 1
                elseif lastAction and x == lastPixelX - 1 and y == lastPixelY and colorEquals(lastPixelColor, color) then
                    if lastAction == 2 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 13
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 2
                elseif lastAction and x == lastPixelX and y == lastPixelY + 1 and colorEquals(lastPixelColor, color) then
                    if lastAction == 3 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 14
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 3
                elseif lastAction and x == lastPixelX and y == lastPixelY - 1 and colorEquals(lastPixelColor, color) then
                    if lastAction == 4 then
                        local i = stackIndex - 1
                        stack[i] = stack[i] + 1
                    else
                        stack[stackIndex] = 15
                        stackIndex = stackIndex + 1
                        stack[stackIndex] = 1
                        stackIndex = stackIndex + 1
                    end

                    lastAction = 4
                else
                    lastPixelColor = color

                    stack[stackIndex] = 16
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = index
                    stackIndex = stackIndex + 1
                    stack[stackIndex] = color
                    stackIndex = stackIndex + 1

                    lastAction = 0
                end

                lastPixelX, lastPixelY = x, y
                pixelsCache[index] = color
                pixelsCacheExists = true
            end
        end,
        fillRect = function(x, y, sizeX, sizeY, color)
            if x <= 0 and y <= 0 and x + sizeX >= width and y + sizeY >= height then
                return api.clear(color or 0xffffff)
            end

            stack[stackIndex] = 2
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawEllipse = function(x, y, sizeX, sizeY, cornerRadius, color)
            stack[stackIndex] = 17
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(cornerRadius)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillEllipse = function(x, y, sizeX, sizeY, cornerRadius, color)
            stack[stackIndex] = 18
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(cornerRadius)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawRect = function(x, y, sizeX, sizeY, color, lineWidth)
            lineWidth = round(lineWidth or 1)
            if lineWidth < 1 then
                lineWidth = 1
            end

            stack[stackIndex] = 3
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeX)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(sizeY)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = lineWidth
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawText = function(x, y, text, color)
            if y > rmheight or y + mFontY < 0 or fontScaleX <= 0 or fontScaleY <= 0 then return end
            text = tostring(text)

            if monoFont then
                local maxTextLen = math_ceil((width - x) / sFontX)
                if maxTextLen <= 0 then return end
                local startTextFrom = math_max(1, math_floor(-x / sFontX) + 1)

                if utf8support then
                    if utf8.len(text) > maxTextLen or startTextFrom > 1 then
                        text = utf8.sub(text, startTextFrom, maxTextLen)
                    end
                else
                    if #text > maxTextLen or startTextFrom > 1 then
                        text = text:sub(startTextFrom, maxTextLen)
                    end
                end

                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x) + ((startTextFrom - 1) * sFontX)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            else
                if #text == 0 then return end
                stack[stackIndex] = 4
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = text
                stackIndex = stackIndex + 1
                stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleX
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontScaleY
                stackIndex = stackIndex + 1
                stack[stackIndex] = spacing
                stackIndex = stackIndex + 1
                stack[stackIndex] = fontIndex
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCenteredText = function(x, y, text, color, centerX, centerY)
            if centerX == nil then centerX = true end
            if centerY == nil then centerY = true end
            
            local sizeX, sizeY
            if centerX or centerY then
                sizeX, sizeY = api.calcTextBox(text)
            end

            if centerX then
                x = x - (sizeX / 2)
            end

            if centerY then
                y = y - (sizeY / 2)
            end

            api.drawText(x, y, text, color)
        end,
        drawLine = function(x, y, x2, y2, color, width, roundFlag)
            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            stack[stackIndex] = 5
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y2)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = width
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircle = function (x, y, r, color)
            stack[stackIndex] = 6
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillCircle = function (x, y, r, color)
            stack[stackIndex] = 7
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleEvenly = function (x, y, r, color)
            stack[stackIndex] = 8
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawCircleVeryEvenly = function (x, y, r, color, stroke)
            if not stroke or stroke < 1 then stroke = 1 end

            stack[stackIndex] = 9
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(x)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(y)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(r)
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1
            stack[stackIndex] = round(stroke)
            stackIndex = stackIndex + 1
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawPoly = function(color, ...)
            api.drawWidePoly(color, 1, false, ...)
        end,
        drawWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 10
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        fillPoly = function(color, ...)
            api.fillWidePoly(color, 1, false, ...)
        end,
        fillWidePoly = function(color, width, roundFlag, ...)
            stack[stackIndex] = 11
            stackIndex = stackIndex + 1
            stack[stackIndex] = formatColorToSmallNumber(color, whiteSmallNumber)
            stackIndex = stackIndex + 1

            width = round(width or 1)
            if width < 1 then
                width = 1
            end
            if roundFlag then
                width = -width
            end

            local points = {...}
            if #points == 0 or #points % 2 ~= 0 then
                error("an odd number of points are specified", 2)
            end
            stack[stackIndex] = #points
            stackIndex = stackIndex + 1

            stack[stackIndex] = width
            stackIndex = stackIndex + 1

            for _, v in ipairs(points) do
                stack[stackIndex] = round(v)
                stackIndex = stackIndex + 1
            end
            
            if pixelsCacheExists then
                pixelsCache = {}
                pixelsCacheExists = false
            end
        end,
        drawTriangle = function(x1, y1, x2, y2, x3, y3, color)
            api.drawPoly(color, x1, y1, x2, y2, x3, y3)
        end,
        fillTriangle = function(x1, y1, x2, y2, x3, y3, color)
            api.fillPoly(color, x1, y1, x2, y2, x3, y3)
        end,
        flush = function()
            lastAction = nil
            api.setViewport()

            if dataTunnel.display_flush and dataTunnel.display_stack == stack then
                return
            end

            local needFlush = forceFlag
            --print("--------------------------- FLUSH 1", needFlush, stack, stackChecksum(stack), stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel)))

            if not needFlush and stackIndex ~= oldStackIndex then
                --print("FLUSH 2", stackIndex, oldStackIndex)
                needFlush = true
            end

            if not needFlush and newDataFlag then
                local dataSum = stackChecksum(canvasAPI.minimizeDataTunnel(dataTunnel))
                if dataSum ~= oldDataSum then
                    --print("FLUSH 3")
                    needFlush = true
                    oldDataSum = dataSum
                end
            end

            if not needFlush and stack ~= oldStack then
                for i = 1, stackIndex - 1 do
                    if stack[i] ~= oldStack[i] then
                        needFlush = true
                        --print("FLUSH 4", oldStack)
                        break
                    end
                end
            end

            --[[
            if needFlush then
                oldStackSum = nil
            else
                local stachSum = stackChecksum(stack)
                if stachSum ~= oldStackSum then
                    --print("FLUSH 5")
                    needFlush = true
                    oldStackSum = stachSum
                end
            end
            ]]
            
            if needFlush then
                --print("FLUSH ACTION")
                oldStack = stack
                oldStackIndex = stackIndex

                dataTunnel.display_stack = stack
                dataTunnel.display_flush = clearStack
                
                if flushCallback then
                    flushCallback()
                end
            else
                clearStackForce()
            end

            forceFlag = false
            newDataFlag = false
        end,
        forceFlush = function()
            api_flush()
            dataTunnel.display_forceFlush = true
        end,

        -- settings
        setUtf8Support = function (state)
            if type(state) == "boolean" then
                if dataTunnel.utf8support ~= state then
                    dataTunnel.utf8support = state
                    dataTunnel.dataUpdated = true
                    newDataFlag = true
                    utf8support = state
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getUtf8Support = function () return dataTunnel.utf8support end,

        setRenderAtDistance = function (c)
            if type(c) == "boolean" then
                if dataTunnel.renderAtDistance ~= c then
                    dataTunnel.renderAtDistance = c
                    dataTunnel.dataUpdated = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getRenderAtDistance = function () return dataTunnel.renderAtDistance end,

        setRotation = function (rotation)
            if type(rotation) == "number" and rotation % 1 == 0 and rotation >= 0 and rotation <= 3 then
                if rotation ~= dataTunnel.rotation then
                    dataTunnel.rotation = rotation
                    dataTunnel.dataUpdated = true
                    newDataFlag = true

                    if pixelsCacheExists then
                        pixelsCache = {}
                        pixelsCacheExists = false
                    end

                    if rotation == 1 or rotation == 3 then
                        rwidth = height
                        rheight = width
                    else
                        rwidth = width
                        rheight = height
                    end
                    rmheight = rheight - 1
                    rmwidth = rwidth - 1
                end
            else
                error("integer must be in [0; 3]", 2)
            end
        end,
        getRotation = function () return dataTunnel.rotation end,

        setFont = function (customFont)
            checkArg(1, customFont, "table", "nil")
            currentSettedFont = customFont
            fontIndex = 0
            if dataTunnel.customFont then
                dataTunnel.dataUpdated = true
                dataTunnel.customFont = nil
            end
            if customFont then
                if not checkedFonts[customFont] then
                    checkFont(customFont)
                    checkedFonts[customFont] = true
                end
                dFontX, dFontY = customFont.width, customFont.height
                drFontX, drFontY = customFont.returnWidth or customFont.width, customFont.returnHeight or customFont.height
                fontIndex = customFontIndexesCache[customFont]
                if not fontIndex then
                    fontIndex = 0
                    for _, v in pairs(fonts) do
                        if v == customFont then
                            fontIndex = v.index
                        end
                    end
                    customFontIndexesCache[customFont] = fontIndex
                end
                if fontIndex == 0 then
                    dataTunnel.customFont = font.optimizeFont(customFont)
                    dataTunnel.dataUpdated = true
                end
                monoFont = customFont.mono or customFont.mono == nil
            else
                dFontX, dFontY = defaultFont.width, defaultFont.height
                drFontX, drFontY = defaultFont.width, defaultFont.height
                monoFont = true
            end
            updateFontSize()
            newDataFlag = true
        end,
        getFont = function()
            return currentSettedFont
        end,

        getFontWidth = function ()
            return rFontX
        end,
        getFontHeight = function ()
            return rFontY
        end,
        getFontSize = function()
            return rFontX, rFontY
        end,

        getRealFontWidth = function ()
            return drFontX
        end,
        getRealFontHeight = function ()
            return drFontY
        end,
        getRealFontSize = function()
            return drFontX, drFontY
        end,

        setSkipAtNotSight = function (state)
            checkArg(1, state, "boolean")
            if dataTunnel.skipAtNotSight ~= state then
                dataTunnel.skipAtNotSight = state
                dataTunnel.dataUpdated = true
            end
        end,
        getSkipAtNotSight = function () return dataTunnel.skipAtNotSight end,

        getViewport = function()
            return viewport_x, viewport_y, viewport_sx, viewport_sy
        end,
        setViewport = function(x, y, sizeX, sizeY)
            if x or y or sizeX or sizeY then
                viewport_x, viewport_y, viewport_sx, viewport_sy = x or 0, y or 0, sizeX or api.getWidth(), sizeY or api.getHeight()
                stack[stackIndex] = -1
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_x)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_y)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sx)
                stackIndex = stackIndex + 1
                stack[stackIndex] = round(viewport_sy)
                stackIndex = stackIndex + 1
            else
                viewport_x, viewport_y, viewport_sx, viewport_sy = nil, nil, nil, nil
                stack[stackIndex] = resetViewportCodeID
                stackIndex = stackIndex + 1
            end
        end,
        setInlineViewport = function(x, y, sizeX, sizeY)
            if viewport_x then
                local x2 = x + (sizeX - 1)
                local y2 = y + (sizeY - 1)
                local px2 = viewport_x + (viewport_sx - 1)
                local py2 = viewport_y + (viewport_sy - 1)
                if x < viewport_x then x = viewport_x elseif x > px2 then x = px2 end
                if y < viewport_y then y = viewport_y elseif y > py2 then y = py2 end
                if x2 < viewport_x then x2 = viewport_x elseif x2 > px2 then x2 = px2 end
                if y2 < viewport_y then y2 = viewport_y elseif y2 > py2 then y2 = py2 end
                api.setViewport(x, y, (x2 - x) + 1, (y2 - y) + 1)
            else
                api.setViewport(x, y, sizeX, sizeY)
            end
        end,

        setBrightness = function(value) --legacy
            checkArg(1, value, "number")
            --[[
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.brightness ~= value then
                dataTunnel.brightness = value
                dataTunnel.dataUpdated = true
            end
            ]]
        end,
        getBrightness = function() --legacy
            --return dataTunnel.brightness
            return 1
        end,

        setLight = function(value)
            checkArg(1, value, "number")
            value = math_floor(value + 0.5)
            if value < 0 then value = 0 end
            if value > 255 then value = 255 end
            if dataTunnel.light ~= value then
                dataTunnel.light = value
                dataTunnel.dataUpdated = true
            end
        end,
        getLight = function(value)
            return dataTunnel.light
        end,

        getDefaultResolution = function()
            return defaultResolutionX, defaultResolutionY
        end,

        getTouchs = function()
            for i = 1, MAX_CLICKS do
                local click = api.getClick()
                if not click then
                    break
                end
                local index = #currentTouchs + 1
                for lindex, lclick in reverse_ipairs(currentTouchs) do
                    if lclick.nickname == click.nickname and lclick.button == click.button then
                        index = lindex
                        break
                    end
                end
                if click.state == "released" then
                    table.remove(currentTouchs, index)
                else
                    currentTouchs[index] = click
                end
            end

            return currentTouchs
        end,

        getTouch = function()
            return api.getTouchs()[1]
        end,

        reset = function()
            currentTouchs = {}
            if api.setMaterial then api.setMaterial(api.getDefaultMaterial()) end
            if api.setFontScale then api.setFontScale(1, 1) end
            if api.setTextSpacing then api.setTextSpacing(1) end
            if api.setFont then api.setFont() end
            if api.setRotation then api.setRotation(0) end
            if api.setUtf8Support then api.setUtf8Support(false) end
            if api.setClicksAllowed then api.setClicksAllowed(false) end
            if api.setMaxClicks then api.setMaxClicks(MAX_CLICKS) end
            if api.clearClicks then api.clearClicks() end
            if api.setSkipAtNotSight then api.setSkipAtNotSight(false) end
            if api.setRenderAtDistance then api.setRenderAtDistance(false) end
            if api.setViewport then api.setViewport() end
            if api.setLight then api.setLight(DEFAULT_ALPHA_VALUE) end
            if api.setOptimizationLevel then api.setOptimizationLevel(16) end
            if api.setHoloOffset then api.setHoloOffset(0, 0, 0) end
            if api.setHoloRotation then api.setHoloRotation(0, 0, 0) end
            if api.setHoloScale then api.setHoloScale(1, 1) end
            if api.setResolution then api.setResolution(defaultResolutionX, defaultResolutionY) end
            dataTunnel.display_reset = true
        end
    }

    if materialList then
        defaultMaterial = defaultMaterial or (materialList[0] and 0 or 1)
        local currentMaterialID

        function api.setMaterial(materialId)
            checkArg(1, materialId, "number")
            currentMaterialID = materialId
            if not materialList[currentMaterialID] then
                currentMaterialID = defaultMaterial
            end
            local material = materialList[currentMaterialID]
            if material == true then
                error("this material is not supported on this display", 2)
            end
            if dataTunnel.material ~= material then
                dataTunnel.material = material
                dataTunnel.dataUpdated = true
            end
        end

        function api.getMaterial()
            return currentMaterialID
        end

        function api.getDefaultMaterial()
            return defaultMaterial
        end

        api.setMaterial(api.getDefaultMaterial())
    end

    dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z = 0, 0, 0
    dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z = 0, 0, 0
    dataTunnel.scale_x, dataTunnel.scale_y = 1, 1
    if allowHoloAPI then
        local maxOffset = 5
        local maxScale = 5
        if type(allowHoloAPI) == "table" then
            maxOffset = allowHoloAPI.maxOffset or maxOffset
            maxScale = allowHoloAPI.maxScale or maxScale
        end

        function api.setHoloOffset(x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")
            
            if x < -maxOffset then x = -maxOffset end
            if y < -maxOffset then y = -maxOffset end
            if z < -maxOffset then z = -maxOffset end
            if x > maxOffset then x = maxOffset end
            if y > maxOffset then y = maxOffset end
            if z > maxOffset then z = maxOffset end

            if x ~= dataTunnel.offset_x or y ~= dataTunnel.offset_y or z ~= dataTunnel.offset_z then
                dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z = x, y, z
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloOffset()
            return dataTunnel.offset_x, dataTunnel.offset_y, dataTunnel.offset_z
        end

        function api.setHoloRotation(x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")
            if x ~= dataTunnel.rotation_x or y ~= dataTunnel.rotation_y or z ~= dataTunnel.rotation_z then
                dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z = x, y, z
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloRotation()
            return dataTunnel.rotation_x, dataTunnel.rotation_y, dataTunnel.rotation_z
        end

        function api.setHoloScale(x, y)
            checkArg(1, x, "number")
            checkArg(2, y, "number")

            if x < 0 then x = 0 end
            if y < 0 then y = 0 end
            if x > maxScale then x = maxScale end
            if y > maxScale then y = maxScale end

            if x ~= dataTunnel.scale_x or y ~= dataTunnel.scale_y then
                dataTunnel.scale_x, dataTunnel.scale_y = x, y
                dataTunnel.dataUpdated = true
            end
        end

        function api.getHoloScale()
            return dataTunnel.scale_x, dataTunnel.scale_y
        end
    end

    dataTunnel.res_x, dataTunnel.res_y = defaultResolutionX, defaultResolutionY
    if allowSetResolution then
        if type(allowSetResolution) ~= "table" then
            allowSetResolution = {
                maxPixels = 4096 * 4096,
                maxWidth = 4096,
                maxHeight = 4096
            }
        end

        function api.setResolution(resX, resY)
            checkArg(1, resX, "number")
            checkArg(2, resY, "number")

            resX = math.floor(resX)
            resY = math.floor(resY)
            if resX < 1 then resX = 1 end
            if resY < 1 then resY = 1 end

            if allowSetResolution.maxWidth and resX > allowSetResolution.maxWidth then
                error("the width resolution has been exceeded. maximum: " .. allowSetResolution.maxWidth, 2)
            end

            if allowSetResolution.maxHeight and resX > allowSetResolution.maxHeight then
                error("the height resolution has been exceeded. maximum: " .. allowSetResolution.maxHeight, 2)
            end

            if allowSetResolution.maxPixels and (resX * resY) > allowSetResolution.maxPixels then
                error("the total maximum number of pixels has been exceeded. maximum: " .. allowSetResolution.maxPixels, 2)
            end
            
            if resX ~= dataTunnel.res_x or resY ~= dataTunnel.res_y then
                dataTunnel.res_x, dataTunnel.res_y = resX, resY
                dataTunnel.dataUpdated = true
                dataTunnel.resolutionChanged = true

                if pixelsCacheExists then
                    pixelsCache = {}
                    pixelsCacheExists = false
                end

                width, height = resX, resY
                if dataTunnel.rotation == 1 or dataTunnel.rotation == 3 then
                    rwidth = height
                    rheight = width
                else
                    rwidth = width
                    rheight = height
                end
                rmheight = rheight - 1
                rmwidth = rwidth - 1
            end
        end
    end

    api.update = api.flush
    api.getBuffer = api.get
    api.getCurrent = api.get
    api_flush = api.flush

    local internal = {
        rawPush = function(tbl)
            for i = 1, #tbl do
                stack[stackIndex] = tbl[i]
                stackIndex = stackIndex + 1
            end
        end,
        setForceFrame = setForceFrame
    }

    return api, internal
end

--adds a touch screen API (does not implement click processing)
function canvasAPI.addTouch(api, dataTunnel)
    dataTunnel = dataTunnel or {}
    dataTunnel.clicksAllowed = false
    dataTunnel.maxClicks = MAX_CLICKS
    dataTunnel.clickData = {}

    api.getClick = function ()
        return (table_remove(dataTunnel.clickData, 1))
    end

    api.setMaxClicks = function (c)
        if type(c) == "number" and c % 1 == 0 and c > 0 and c <= 16 then
            dataTunnel.maxClicks = c
        else
            error("integer must be in [1; 16]", 2)
        end
    end

    api.getMaxClicks = function ()
        return dataTunnel.maxClicks
    end

    api.clearClicks = function ()
        dataTunnel.clickData = {}
    end

    api.setClicksAllowed = function (c)
        if type(c) == "boolean" then
            if dataTunnel.clicksAllowed ~= c then
                dataTunnel.clicksAllowed = c
                dataTunnel.dataUpdated = true
            end
        else
            error("Type must be boolean", 2)
        end
    end

    api.getClicksAllowed = function ()
        return dataTunnel.clicksAllowed
    end

    return function (tbl)
        tbl.x = tbl[1] or tbl.x
        tbl.y = tbl[2] or tbl.y
        tbl.state = tbl[3] or tbl.state
        tbl.button = tbl[4] or tbl.button
        tbl.nickname = tbl[5] or tbl.nickname
        tbl[1] = tbl.x or tbl[1]
        tbl[2] = tbl.y or tbl[2]
        tbl[3] = tbl.state or tbl[3]
        tbl[4] = tbl.button or tbl[4]
        tbl[5] = tbl.nickname or tbl[5]
        if #dataTunnel.clickData < dataTunnel.maxClicks then
            table_insert(dataTunnel.clickData, tbl)
        end
    end
end

--leaves only those tunnel fields that are needed for transmission over the network
function canvasAPI.minimizeDataTunnel(dataTunnel)
    return {
        clicksAllowed = dataTunnel.clicksAllowed,
        rotation = dataTunnel.rotation,
        renderAtDistance = dataTunnel.renderAtDistance,
        skipAtNotSight = dataTunnel.skipAtNotSight,
        utf8support = dataTunnel.utf8support,
        customFont = dataTunnel.customFont,
        display_reset = dataTunnel.display_reset,
        optimizationLevel = dataTunnel.optimizationLevel,
        light = dataTunnel.light,
        material = dataTunnel.material,

        offset_x = dataTunnel.offset_x,
        offset_y = dataTunnel.offset_y,
        offset_z = dataTunnel.offset_z,

        rotation_x = dataTunnel.rotation_x,
        rotation_y = dataTunnel.rotation_y,
        rotation_z = dataTunnel.rotation_z,

        scale_x = dataTunnel.scale_x,
        scale_y = dataTunnel.scale_y,

        res_x = dataTunnel.res_x,
        res_y = dataTunnel.res_y
    }
end

-------- additional
canvasAPI.stackChecksum = stackChecksum
canvasAPI.formatColor = formatColor
canvasAPI.formatColorToNumber = formatColorToNumber
canvasAPI.formatColorToSmallNumber = formatColorToSmallNumber
canvasAPI.checkFont = checkFont
canvasAPI.simpleRemathRect = simpleRemathRect
canvasAPI.remathRect = remathRect
canvasAPI.hexToRGB = hexToRGB
canvasAPI.hexToRGB256 = hexToRGB256
canvasAPI.posCheck = posCheck
canvasAPI.mathDist = mathDist
canvasAPI.needPushStack = needPushStack
canvasAPI.font = font
canvasAPI.tableClone = tableClone
canvasAPI.canvasService = canvasService
canvasAPI.userCalls = userCalls
canvasAPI.dataSizes = dataSizes
canvasAPI.color_new_fromSmallNumber = color_new_fromSmallNumber
canvasAPI.getEffectName = getEffectName
canvasAPI.fonts = fonts
canvasAPI.utf8 = utf8

function canvasAPI.pushData(stack, ...)
    for i, v in ipairs({...}) do
        table.insert(stack, v)
    end
end

_G.canvasAPI = canvasAPI
end
function scmframework_12dffa7052225280f6cb6e640bb1d409() --$CONTENT_DATA/Scripts/canvasAPI/canvasService.lua
canvasService = class()

function canvasService:sv_n_canvasService_request(state, player)
    if not self._audienceData then
        self._audienceData = {}
        self._getAudienceCount = function()
            local count = 0
            local ctick = sm.game.getCurrentTick()
            for id, updateTick in pairs(self._audienceData) do
                if ctick - updateTick <= 80 then
                    count = count + 1
                end
            end
            return count
        end
    end
    if state then
        self._audienceData[player.id] = sm.game.getCurrentTick()
    else
        self._audienceData[player.id] = nil
    end
end

function canvasService:canvasService(state)
    if self.old_canvasService_state ~= state or sm.game.getCurrentTick() % 40 == 0 then
        self.network:sendToServer("sv_n_canvasService_request", state)
        self.old_canvasService_state = state
    end
end

--------------------------------------------------

function canvasService:sv_n_lagDetector_request(score)
    self._lagDetector = (self._lagDetector or 0) + score
    if not self._getLagDetector then
        self._getLagDetector = function()
            local result
            if self._getAudienceCount then
                result = self._lagDetector / math.max(self._getAudienceCount(), 1)
            else
                result = self._lagDetector
            end
            self._lagDetector = 0
            return result or 0
        end
    end
end

function canvasService:lagDetector(execTime, mul)
    local lagScore = execTime * mul
    self._clLagDetector = (self._clLagDetector or 0) + lagScore
    if self._clLagDetector >= 0.5 then
        self.network:sendToServer("sv_n_lagDetector_request", self._clLagDetector)
        self._clLagDetector = 0
    end
end
end
function scmframework_7b54ffe41834b85ace943902325ca1e6() --$CONTENT_DATA/Scripts/canvasAPI/fonts/converted_fonts.lua
if __SCMFRAMEWORK_NOFONTS then return end

dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/verdanaz_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/verdanaz_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/verdanaz_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/webdings_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/webdings_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/webdings_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/wingding_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/wingding_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/wingding_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/arial_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/arial_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/arial_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/arialbd_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/arialbd_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/arialbd_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/arialbi_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/arialbi_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/arialbi_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ariali_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ariali_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ariali_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ariblk_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ariblk_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ariblk_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/bahnschrift_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/bahnschrift_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/bahnschrift_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibri_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibri_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibri_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibrib_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibrib_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibrib_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibrii_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibrii_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibrii_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibril_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibril_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibril_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibrili_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibrili_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibrili_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibriz_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibriz_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/calibriz_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/cambriab_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/cambriab_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/cambriab_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/cambriai_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/cambriai_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/cambriai_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/cambriaz_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/cambriaz_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/cambriaz_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candara_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candara_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candara_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candarab_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candarab_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candarab_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candarai_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candarai_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candarai_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candaral_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candaral_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candaral_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candarali_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candarali_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candarali_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candaraz_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candaraz_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Candaraz_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/CascadiaCode_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/CascadiaCode_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/CascadiaCode_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/CascadiaMono_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/CascadiaMono_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/CascadiaMono_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/comic_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/comic_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/comic_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/comicbd_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/comicbd_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/comicbd_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/comici_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/comici_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/comici_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/comicz_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/comicz_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/comicz_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/consola_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/consola_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/consola_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/consolab_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/consolab_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/consolab_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/consolai_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/consolai_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/consolai_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/consolaz_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/consolaz_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/consolaz_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/constan_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/constan_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/constan_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/constanb_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/constanb_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/constanb_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/constani_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/constani_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/constani_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/constanz_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/constanz_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/constanz_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbel_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbel_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbel_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbelb_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbelb_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbelb_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbeli_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbeli_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbeli_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbell_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbell_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbell_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbelli_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbelli_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbelli_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbelz_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbelz_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/corbelz_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/cour_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/cour_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/cour_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/courbd_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/courbd_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/courbd_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/courbi_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/courbi_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/courbi_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/couri_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/couri_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/couri_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ebrima_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ebrima_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ebrima_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ebrimabd_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ebrimabd_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ebrimabd_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/framd_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/framd_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/framd_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/framdit_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/framdit_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/framdit_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Gabriola_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Gabriola_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Gabriola_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/gadugi_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/gadugi_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/gadugi_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/gadugib_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/gadugib_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/gadugib_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/georgia_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/georgia_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/georgia_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/georgiab_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/georgiab_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/georgiab_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/georgiai_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/georgiai_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/georgiai_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/georgiaz_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/georgiaz_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/georgiaz_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/GOST_A_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/GOST_A_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/GOST_A_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/GOST_AU_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/GOST_AU_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/GOST_AU_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/GOST_B_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/GOST_B_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/GOST_B_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/GOST_BU_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/GOST_BU_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/GOST_BU_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/himalaya_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/himalaya_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/himalaya_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/holomdl2_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/holomdl2_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/holomdl2_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_Bd_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_Bd_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_Bd_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_BdIt_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_BdIt_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_BdIt_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_It_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_It_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_It_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_Lt_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_Lt_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_Lt_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_LtIt_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_LtIt_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_LtIt_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_Rg_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_Rg_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/HPSimplified_Rg_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/impact_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/impact_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/impact_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Inkfree_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Inkfree_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Inkfree_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/javatext_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/javatext_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/javatext_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/l_10646_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/l_10646_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/l_10646_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/LeelaUIb_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/LeelaUIb_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/LeelaUIb_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/LeelawUI_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/LeelawUI_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/LeelawUI_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/LeelUIsl_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/LeelUIsl_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/LeelUIsl_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/lucon_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/lucon_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/lucon_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/malgun_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/malgun_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/malgun_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/malgunbd_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/malgunbd_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/malgunbd_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/malgunsl_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/malgunsl_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/malgunsl_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/micross_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/micross_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/micross_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/mmrtext_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/mmrtext_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/mmrtext_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/mmrtextb_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/mmrtextb_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/mmrtextb_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/monbaiti_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/monbaiti_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/monbaiti_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/msyi_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/msyi_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/msyi_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/mvboli_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/mvboli_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/mvboli_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Nirmala_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Nirmala_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/Nirmala_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/NirmalaB_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/NirmalaB_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/NirmalaB_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/NirmalaS_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/NirmalaS_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/NirmalaS_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ntailu_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ntailu_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ntailu_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ntailub_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ntailub_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/ntailub_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/pala_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/pala_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/pala_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/palab_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/palab_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/palab_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/palabi_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/palabi_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/palabi_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/palai_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/palai_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/palai_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/phagspa_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/phagspa_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/phagspa_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/phagspab_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/phagspab_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/phagspab_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segmdl2_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segmdl2_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segmdl2_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoepr_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoepr_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoepr_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeprb_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeprb_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeprb_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoesc_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoesc_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoesc_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoescb_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoescb_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoescb_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeui_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeui_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeui_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuib_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuib_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuib_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuii_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuii_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuii_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuil_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuil_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuil_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuisl_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuisl_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuisl_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuiz_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuiz_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/segoeuiz_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguibl_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguibl_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguibl_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguibli_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguibli_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguibli_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguiemj_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguiemj_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguiemj_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguihis_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguihis_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguihis_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguili_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguili_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguili_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguisb_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguisb_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguisb_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguisbi_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguisbi_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguisbi_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguisli_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguisli_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguisli_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguisym_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguisym_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/seguisym_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/simsunb_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/simsunb_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/simsunb_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/sylfaen_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/sylfaen_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/sylfaen_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/symbol_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/symbol_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/symbol_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/SYMBOL_A_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/SYMBOL_A_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/SYMBOL_A_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/SYMBOL_B_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/SYMBOL_B_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/SYMBOL_B_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/tahoma_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/tahoma_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/tahoma_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/tahomabd_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/tahomabd_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/tahomabd_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/taile_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/taile_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/taile_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/taileb_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/taileb_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/taileb_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/times_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/times_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/times_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/timesbd_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/timesbd_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/timesbd_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/timesbi_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/timesbi_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/timesbi_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/timesi_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/timesi_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/timesi_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/trebuc_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/trebuc_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/trebuc_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/trebucbd_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/trebucbd_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/trebucbd_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/trebucbi_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/trebucbi_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/trebucbi_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/trebucit_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/trebucit_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/trebucit_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/verdana_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/verdana_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/verdana_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/verdanab_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/verdanab_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/verdanab_72.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/verdanai_16.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/verdanai_32.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted/verdanai_72.lua")

end
function scmframework_ec50326bfe146defcae13e1c3446f911() --$CONTENT_DATA/Scripts/canvasAPI/fonts/generated/oc_16x8.lua
font.fonts.oc_16x8 = {
  mono = false,
  returnWidth = 8,
  returnHeight = 16,
  width = 8,
  height = 16,
  chars = {
    ["\0"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["\1"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111..11..1..11",
        "11....1..1.1..1.",
        "..11..1..1.11111",
        "1...1.1..1.1..1.",
        ".111...11..1..11",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\2"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111.111.1..1.1",
        "11.....1..1..1..",
        "..11...1...11..1",
        "1...1..1..1..1..",
        ".111...1..1..1.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\3"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1111.111.1..1.1",
        "11.....1..1..1..",
        ".1111..1...11..1",
        "11.....1..1..1..",
        ".1111..1..1..1.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\4"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1111..11.111111",
        "11....1..1..1...",
        ".1111.1..1..1..1",
        "11....1..1..1...",
        ".1111..11...1..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\5"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1111.1..1..11.1",
        "11....1..1.1..1.",
        ".1111.11.1.1..11",
        "11....1.11.1.11.",
        ".1111.1..1..1111",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\6"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..11...11.1..1.1",
        "11..1.1...1.1...",
        ".1111.1...11...1",
        "11..1.1...1.1...",
        ".1..1..11.1..1.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\7"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111..1111.1...1",
        "11..1.1....1....",
        ".111..1111.1...1",
        "11..1.1....1....",
        ".111..1111.11111",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\8"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "...1111...111..1",
        "1..1...1.1......",
        "...1111...11...1",
        "1..1...1....1...",
        "...1111..111...1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\9"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..1...1.11111..1",
        "1.1...1...1.....",
        "..11111...1....1",
        "1.1...1...1.....",
        "..1...1...1....1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\10"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..1.....11111..1",
        "1.1.....1.......",
        "..1.....11111..1",
        "1.1.....1.......",
        "..11111.1......1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\11"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..1...1.11111..1",
        "1.1...1...1.....",
        "..1...1...1....1",
        "1..1.1....1.....",
        "....1.....1....1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\12"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..11111.11111..1",
        "1.1.....1.......",
        "..11111.11111..1",
        "1.1.....1.......",
        "..1.....1......1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\13"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "...1111.1111...1",
        "1.1.....1...1...",
        "..1.....1111...1",
        "1.1.....1..1....",
        "...1111.1...1..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\14"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "...1111..111...1",
        "1.1.....1...1...",
        "...111..1...1..1",
        "1.....1.1...1...",
        "..1111...111...1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\15"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "...1111.11111..1",
        "1.1.......1.....",
        "...111....1....1",
        "1.....1...1.....",
        "..1111..11111..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\16"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111..1...111.1",
        "1.1..1.1...1....",
        "..1..1.1...111.1",
        "1.1..1.1...1....",
        "..111..111.111.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\17"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111...11...1..1",
        "11..1.1....11...",
        ".1..1.1.....1..1",
        "11..1.1.....1...",
        ".111...11..111.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\18"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111...11..11..1",
        "11..1.1......1..",
        ".1..1.1.....1..1",
        "11..1.1....1....",
        ".111...11..111.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\19"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111...11..11..1",
        "11..1.1......1..",
        ".1..1.1....11..1",
        "11..1.1......1..",
        ".111...11..11..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\20"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111...11....1.1",
        "11..1.1.....11..",
        ".1..1.1....1.1.1",
        "11..1.1....111..",
        ".111...11....1.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\21"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1..1..11..1..11",
        "111.1.1..1.1.1..",
        ".11.1.1..1.11..1",
        "11.11.1111.1.1..",
        ".1..1.1..1.1..11",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\22"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..11.1...1.1..11",
        "11....1.1..11.1.",
        "..11...1...1.111",
        "1...1..1...1..1.",
        ".111...1...1..11",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\23"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1111.111.111..1",
        "11.....1..1..1..",
        ".1111..1..111..1",
        "11.....1..1..1..",
        ".1111..1..111..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\24"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..11..11..1..1.1",
        "11...1..1.11.1..",
        ".1...1111.1.11.1",
        "11...1..1.1..1..",
        "..11.1..1.1..1.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\25"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..11111.1...1..1",
        "1.1.....11.11...",
        "..11111.1.1.1..1",
        "1.1.....1...1...",
        "..11111.1...1..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\26"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111.1..1.111.1",
        "11....1..1.1..1.",
        "..11..1..1.111.1",
        "1...1.1..1.1..1.",
        ".111...11..111.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\27"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1111..111..1111",
        "11....1....1....",
        ".1111..11..1...1",
        "11.......1.1....",
        ".1111.111...1111",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\28"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "...1111..111...1",
        "1..1....1.......",
        "...1111..11....1",
        "1..1.......1....",
        "...1....111....1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\29"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "....111..111...1",
        "1..1....1.......",
        "...1.11..11....1",
        "1..1..1....1....",
        "....111.111....1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\30"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "...111...111...1",
        "1..1..1.1.......",
        "...111...11....1",
        "1..1.1.....1....",
        "...1..1.111....1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    ["\31"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "...1..1..111...1",
        "1..1..1.1.......",
        "...1..1..11....1",
        "1..1..1....1....",
        "....11..111....1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [" "] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["!"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["\""] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["#"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        "1111111.",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        "1111111.",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        "........",
        "........",
        "........"
    },
    ["$"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...11...",
        "...11...",
        "..1111..",
        ".11..11.",
        ".11.....",
        "..11....",
        "...11...",
        "....11..",
        ".....11.",
        ".11..11.",
        "..1111..",
        "...11...",
        "...11...",
        "........",
        "........"
    },
    ["%"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".....11.",
        "11...11.",
        "11..11..",
        "11..11..",
        "...11...",
        "...11...",
        "..11....",
        "..11....",
        ".11..11.",
        ".11..11.",
        "11...11.",
        "11......",
        "........",
        "........"
    },
    ["&"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..111...",
        ".11.11..",
        ".11.11..",
        "..111...",
        "..11....",
        ".1111.1.",
        "11.1111.",
        "11..11..",
        "11..11..",
        "11..11..",
        ".111.11.",
        "........",
        "........",
        "........"
    },
    ["'"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...11...",
        "...11...",
        "...11...",
        "..11....",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["("] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "....11..",
        "...11...",
        "...11...",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "...11...",
        "...11...",
        "....11..",
        "........",
        "........"
    },
    [")"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "..11....",
        "...11...",
        "...11...",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "...11...",
        "...11...",
        "..11....",
        "........",
        "........"
    },
    ["*"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "11111111",
        "..1111..",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["+"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "...11...",
        "...11...",
        "...11...",
        ".111111.",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    [","] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..111...",
        "...11...",
        "...11...",
        "..11....",
        ".11.....",
        "........"
    },
    ["-"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".111111.",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["."] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["/"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "......11",
        "......11",
        ".....11.",
        ".....11.",
        "....11..",
        "....11..",
        "...11...",
        "...11...",
        "..11....",
        "..11....",
        ".11.....",
        ".11.....",
        "11......",
        "11......",
        "........",
        "........"
    },
    ["0"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..111...",
        ".11.11..",
        "11...11.",
        "11...11.",
        "11..111.",
        "11.1.11.",
        "111..11.",
        "11...11.",
        "11...11.",
        ".11.11..",
        "..111...",
        "........",
        "........",
        "........"
    },
    ["1"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "...11...",
        "..111...",
        ".1111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["2"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".....11.",
        ".....11.",
        "....11..",
        "...11...",
        "..11....",
        ".11.....",
        ".11.....",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["3"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".....11.",
        ".....11.",
        "...111..",
        ".....11.",
        ".....11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["4"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "....11..",
        "...111..",
        "..1111..",
        ".11.11..",
        "11..11..",
        "11..11..",
        "1111111.",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "........",
        "........",
        "........"
    },
    ["5"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111111.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".....11.",
        ".....11.",
        ".....11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["6"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "...111..",
        "..11....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["7"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111111.",
        ".....11.",
        ".....11.",
        ".....11.",
        "....11..",
        "....11..",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["8"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".111.11.",
        "..1111..",
        ".11.111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["9"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        ".....11.",
        ".....11.",
        ".....11.",
        "....11..",
        "..111...",
        "........",
        "........",
        "........"
    },
    [":"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........",
        "........",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    [";"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........",
        "........",
        "..111...",
        "...11...",
        "...11...",
        "..11....",
        ".11.....",
        "........"
    },
    ["<"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        ".....11.",
        "....11..",
        "...11...",
        "..11....",
        ".11.....",
        "..11....",
        "...11...",
        "....11..",
        ".....11.",
        "........",
        "........",
        "........",
        "........"
    },
    ["="] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        ".111111.",
        "........",
        "........",
        "........",
        ".111111.",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    [">"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        ".11.....",
        "..11....",
        "...11...",
        "....11..",
        ".....11.",
        "....11..",
        "...11...",
        "..11....",
        ".11.....",
        "........",
        "........",
        "........",
        "........"
    },
    ["?"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".....11.",
        "....11..",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["@"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11111..",
        "11...11.",
        "11...11.",
        "11...11.",
        "11.1111.",
        "11.1111.",
        "11.1111.",
        "11.111..",
        "11......",
        "11......",
        ".11111..",
        "........",
        "........",
        "........"
    },
    ["A"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["B"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11.11..",
        ".1111...",
        ".11.11..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11111..",
        "........",
        "........",
        "........"
    },
    ["C"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["D"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".1111...",
        ".11.11..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11.11..",
        ".1111...",
        "........",
        "........",
        "........"
    },
    ["E"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111111.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["F"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111111.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        "........",
        "........",
        "........"
    },
    ["G"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11.....",
        ".11.....",
        ".11.111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["H"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["I"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111111.",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["J"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".....11.",
        ".....11.",
        ".....11.",
        ".....11.",
        ".....11.",
        ".....11.",
        ".....11.",
        ".....11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["K"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11...11.",
        "11...11.",
        "11..11..",
        "11..11..",
        "11.11...",
        "1111....",
        "11.11...",
        "11..11..",
        "11..11..",
        "11...11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["L"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["M"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11...11.",
        "111.111.",
        "111.111.",
        "1111111.",
        "11.1.11.",
        "11.1.11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["N"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11...11.",
        "11...11.",
        "111..11.",
        "111..11.",
        "1111.11.",
        "1111111.",
        "11.1111.",
        "11..111.",
        "11..111.",
        "11...11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["O"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["P"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        "........",
        "........",
        "........"
    },
    ["Q"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "....11..",
        ".....11.",
        "........"
    },
    ["R"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11111..",
        ".11.11..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["S"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11.....",
        "..11....",
        "...11...",
        "....11..",
        ".....11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["T"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111111.",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["U"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["V"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "..1111..",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["W"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11.1.11.",
        "11.1.11.",
        "1111111.",
        "111.111.",
        "111.111.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["X"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11....11",
        "11....11",
        ".11..11.",
        "..1111..",
        "...11...",
        "...11...",
        "...11...",
        "..1111..",
        ".11..11.",
        "11....11",
        "11....11",
        "........",
        "........",
        "........"
    },
    ["Y"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11....11",
        "11....11",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["Z"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111111.",
        ".....11.",
        ".....11.",
        "....11..",
        "....11..",
        "...11...",
        "..11....",
        "..11....",
        ".11.....",
        ".11.....",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["["] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "..1111..",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..1111..",
        "........",
        "........"
    },
    ["\\"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11......",
        "11......",
        ".11.....",
        ".11.....",
        "..11....",
        "..11....",
        "...11...",
        "...11...",
        "....11..",
        "....11..",
        ".....11.",
        ".....11.",
        "......11",
        "......11",
        "........",
        "........"
    },
    ["]"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "..1111..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "..1111..",
        "........",
        "........"
    },
    ["^"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...1....",
        "..111...",
        ".11.11..",
        ".11.11..",
        "11...11.",
        "11...11.",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["_"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111"
    },
    ["`"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...11...",
        "...11...",
        "....11..",
        ".....11.",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["a"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        ".....11.",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["b"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11111..",
        "........",
        "........",
        "........"
    },
    ["c"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["d"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".....11.",
        ".....11.",
        ".....11.",
        ".....11.",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["e"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11.....",
        ".11.....",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["f"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "...1111.",
        "..11....",
        "..11....",
        "..11....",
        ".111111.",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "........",
        "........",
        "........"
    },
    ["g"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        ".....11.",
        ".....11.",
        ".11111.."
    },
    ["h"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["i"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "...11...",
        "...11...",
        "........",
        "........",
        ".1111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...1111.",
        "........",
        "........",
        "........"
    },
    ["j"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "....11..",
        "....11..",
        "........",
        "........",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        "....11..",
        ".1111..."
    },
    ["k"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11..11.",
        ".11..11.",
        ".11.11..",
        ".1111...",
        ".11.11..",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["l"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".1111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...1111.",
        "........",
        "........",
        "........"
    },
    ["m"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11..11..",
        "1111111.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["n"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["o"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["p"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11....."
    },
    ["q"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        ".....11.",
        ".....11.",
        ".....11."
    },
    ["r"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        "........",
        "........",
        "........"
    },
    ["s"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..11111.",
        ".11.....",
        ".11.....",
        "..1111..",
        ".....11.",
        ".....11.",
        ".11111..",
        "........",
        "........",
        "........"
    },
    ["t"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "..11....",
        "..11....",
        "..11....",
        ".111111.",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "...1111.",
        "........",
        "........",
        "........"
    },
    ["u"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["v"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["w"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11...11.",
        "11...11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        ".11111..",
        ".11.11..",
        "........",
        "........",
        "........"
    },
    ["x"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11...11.",
        "11...11.",
        ".11.11..",
        "..111...",
        ".11.11..",
        "11...11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["y"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        ".....11.",
        ".....11.",
        "..1111.."
    },
    ["z"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".111111.",
        ".....11.",
        "....11..",
        "...11...",
        "..11....",
        ".11.....",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["{"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "....111.",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "1111....",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "....111.",
        "........",
        "........"
    },
    ["|"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........"
    },
    ["}"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "111.....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "...1111.",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "111.....",
        "........",
        "........"
    },
    ["~"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        ".111..1.",
        "11.1.11.",
        "1..111..",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["\127"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111..1111.1...1",
        "11..1.1....1....",
        ".1..1.1111.1...1",
        "11..1.1....1....",
        ".111..1111.11111",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111...11..111.1",
        "11..1.1..1.1..1.",
        ".111..1111.1..11",
        "11....1..1.1..1.",
        ".1....1..1.111.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1..1..11..111.1",
        "11..1.1..1.1..1.",
        ".1111.1..1.111.1",
        "11..1.1..1.1....",
        ".1..1..11..1...1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111..111..1..11",
        "11..1.1..1.1..1.",
        ".111..111..11111",
        "11..1.1....1..1.",
        ".111..1....1..11",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1..1.111..1..11",
        "111.1.1..1.1..1.",
        ".1.11.111..11111",
        "11..1.1..1.1..1.",
        ".1..1.111..1..11",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111.1..1.111..1",
        "1.1..11.1.1..1..",
        "..1..1.11.1..1.1",
        "1.1..1..1.1..1..",
        ".111.1..1.111..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1..1.1111.1...1",
        "111.1.1....1....",
        ".1.11.1111.1...1",
        "11..1.1....1....",
        ".1..1.1111.11111",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111..111..11.1",
        "11....1....1..1.",
        "..11...11..11111",
        "1...1....1.1..1.",
        ".111..111..1..11",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1111..111..11.1",
        "11....1....1..1.",
        ".1111..11..11111",
        "11.......1.1..1.",
        ".1111.111..1..11",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1..1.111..111.1",
        "11..1..1..1.....",
        ".1111..1...11..1",
        "11..1..1.....1..",
        ".1..1..1..111..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..1..1.111.111.1",
        "1.1..1..1....1..",
        "..1111..1....1.1",
        "1.1..1..1....1..",
        "..1..1..1..11..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1...1.111..11.1",
        "11...1..1..1....",
        ".1...1..1...1..1",
        "1.1.1...1....1..",
        "...1....1..11..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111..1....111.1",
        "11..1.1....1..1.",
        ".111..1....1..11",
        "11....1....1..1.",
        ".1....1111.111.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111..1....1..11",
        "11..1.1....1..1.",
        ".111..1....1..11",
        "11....1....1..1.",
        ".1....1111..11.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "....111...1....1",
        "1...1..1..1.....",
        "....111...1....1",
        "1...1.1...1.....",
        "....1..1..1....1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111..111.111.1",
        "11....1.......1.",
        "..11...11...11.1",
        "1...1....1.1....",
        ".111..111..11111",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111..111.111.1",
        "11....1.......1.",
        "..11...11...11.1",
        "1...1....1....1.",
        ".111..111..111.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111...111..1111",
        "11..1.1....1....",
        ".1..1.1.....11.1",
        "11..1.1.......1.",
        ".111...111.111.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111..1..1...1.1",
        "11..1.1..1..11..",
        ".111..1..1...1.1",
        "11....1..1...1..",
        ".1.....11...1111",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".111..1..1.111.1",
        "11..1.1..1....1.",
        ".111..1..1..11.1",
        "11....1..1.1....",
        ".1.....11..11111",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111.111..111.1",
        "11.....1..1.....",
        "..11...1...11..1",
        "1...1..1.....1..",
        ".111...1..111..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111..111.1..11",
        "11....1....1..1.",
        ".1....1....11111",
        "11....1....1..1.",
        "..111..111.1..11",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..1...1.1...1..1",
        "1.11.11.1...1...",
        "..1.1.1.1.1.1..1",
        "1.1...1.11.11...",
        "..1...1.1...1..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111.111...11.1",
        "11....1..1.1..1.",
        "..11..111..11111",
        "1...1.1....1..1.",
        ".111..1....1..11",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1111.111...11.1",
        "11....1..1.1..1.",
        ".1111.111..11111",
        "11....1....1..1.",
        ".1111.1....1..11",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111..11...1111",
        "11....1..1.1....",
        "..11..1..1..11.1",
        "1...1.1..1....1.",
        ".111...11..111.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..11..111..11.11",
        "11...1....1...1.",
        "..1..1.11.1...11",
        "1..1.1..1.1...1.",
        ".11...111..11.11",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111..111.111.1",
        "11....1.....1...",
        "..11..1.....1..1",
        "1...1.1.....1...",
        ".111...111.111.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..111..111.111.1",
        "11....1.....1...",
        ".1.....11...1..1",
        "11.......1..1...",
        "..111.111..111.1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "....111.11111..1",
        "1..1......1.....",
        "....11....1....1",
        "1.....1...1.....",
        "...111....1....1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..11...111..1111",
        "11..1.1....1....",
        ".1..1..11..1...1",
        "11..1....1.1....",
        "..11..111...1111",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "...111..1...1..1",
        "1..1..1.11.11...",
        "...111..1.1.1..1",
        "1..1....1...1...",
        "...1....1...1..1",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [""] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.1.1.1.1.",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        "..11..111...1111",
        "11..1.1..1.1....",
        ".1111.111..1...1",
        "11..1.1....1....",
        ".1..1.1.....1111",
        "1...............",
        "...............1",
        "1...............",
        "...............1",
        "1...............",
        ".1.1.1.1.1.1.1.1"
    },
    [" "] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["¡"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...11...",
        "...11...",
        "........",
        "........",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["¢"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...11...",
        "...11...",
        "...11...",
        "..1111..",
        ".11..11.",
        ".11.....",
        ".11.....",
        ".11..11.",
        "..1111..",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["£"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..111...",
        ".11.11..",
        ".11.11..",
        ".11.....",
        ".11.....",
        "1111....",
        ".11.....",
        ".11.....",
        ".11..11.",
        ".11..11.",
        "111111..",
        "........",
        "........",
        "........"
    },
    ["¤"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11..11.",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        ".11..11.",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["¥"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11....11",
        "11....11",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "...11...",
        ".111111.",
        "...11...",
        ".111111.",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["¦"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........"
    },
    ["§"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "..1111..",
        ".11..11.",
        ".11.....",
        "..11....",
        "..111...",
        ".11.11..",
        ".11..11.",
        "..11.11.",
        "...111..",
        "....11..",
        ".....11.",
        ".11..11.",
        "..1111..",
        "........",
        "........"
    },
    ["¨"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["©"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".1....1.",
        "1......1",
        "1..111.1",
        "1.11...1",
        "1.11...1",
        "1.11...1",
        "1..111.1",
        "1......1",
        ".1....1.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["ª"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "..1111..",
        ".....11.",
        ".....11.",
        "..11111.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        ".111111.",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["«"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "..11..11",
        ".11..11.",
        "11..11..",
        ".11..11.",
        "..11..11",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["¬"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1111111.",
        ".....11.",
        ".....11.",
        ".....11.",
        ".....11.",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["­"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["®"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".1....1.",
        "1......1",
        "1.111..1",
        "1.1..1.1",
        "1.111..1",
        "1.1..1.1",
        "1.1..1.1",
        "1......1",
        ".1....1.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["¯"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".111111.",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["°"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["±"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "...11...",
        "...11...",
        "...11...",
        ".111111.",
        "...11...",
        "...11...",
        "...11...",
        "........",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["²"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "..111...",
        ".11.11..",
        "....11..",
        "...11...",
        "..11....",
        ".11.....",
        ".11111..",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["³"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "..111...",
        ".11.11..",
        "....11..",
        "..111...",
        "....11..",
        ".11.11..",
        "..111...",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["´"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        ".....1..",
        "....1...",
        "...1....",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["µ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11111..",
        ".11.....",
        ".11.....",
        "11......"
    },
    ["¶"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..11111.",
        ".1111.1.",
        ".1111.1.",
        ".1111.1.",
        ".1111.1.",
        "..111.1.",
        "...11.1.",
        "...11.1.",
        "...11.1.",
        "...11.1.",
        "...11.1.",
        "........",
        "........",
        "........"
    },
    ["·"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "...11...",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["¸"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "....11..",
        ".....11.",
        "...111.."
    },
    ["¹"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "..11....",
        ".111....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "..11....",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["º"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        ".111111.",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["»"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "11..11..",
        ".11..11.",
        "..11..11",
        ".11..11.",
        "11..11..",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["¼"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        ".1......",
        "11...11.",
        ".1...11.",
        ".1..11..",
        ".1..11..",
        "...11...",
        "...11...",
        "..11....",
        "..11....",
        ".11...1.",
        ".11..11.",
        "11..1.1.",
        "11..1111",
        "......1.",
        "........"
    },
    ["½"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        ".1......",
        "11...11.",
        ".1...11.",
        ".1..11..",
        ".1..11..",
        "...11...",
        "...11...",
        "..11....",
        "..11....",
        ".11.11..",
        ".11...1.",
        "11...1..",
        "11..1...",
        "....111.",
        "........"
    },
    ["¾"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "11......",
        "..1..11.",
        ".11..11.",
        "..1.11..",
        "11..11..",
        "...11...",
        "...11...",
        "..11....",
        "..11....",
        ".11...1.",
        ".11..11.",
        "11..1.1.",
        "11..1111",
        "......1.",
        "........"
    },
    ["¿"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...11...",
        "...11...",
        "........",
        "........",
        "...11...",
        "..11....",
        "..11....",
        ".11.....",
        ".11.....",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["À"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..11....",
        "...11...",
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["Á"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "....11..",
        "...11...",
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["Â"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        ".11..11.",
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["Ã"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".111.11.",
        "11.111..",
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["Ä"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11..11.",
        ".11..11.",
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["Å"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        ".11..11.",
        "..1111..",
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["Æ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..111111",
        ".11111..",
        "111111..",
        "11..11..",
        "11..11..",
        "1111111.",
        "11..11..",
        "11..11..",
        "11..11..",
        "11..11..",
        "11..1111",
        "........",
        "........",
        "........"
    },
    ["Ç"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "....11..",
        ".....11.",
        "...111.."
    },
    ["È"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..11....",
        "...11...",
        "........",
        ".111111.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["É"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "....11..",
        "...11...",
        "........",
        ".111111.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["Ê"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        ".11..11.",
        "........",
        ".111111.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["Ë"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11..11.",
        ".11..11.",
        "........",
        ".111111.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["Ì"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..11....",
        "...11...",
        "........",
        ".111111.",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["Í"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "....11..",
        "...11...",
        "........",
        ".111111.",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["Î"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        ".11..11.",
        "........",
        ".111111.",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["Ï"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11..11.",
        ".11..11.",
        "........",
        ".111111.",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["Ð"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".1111...",
        ".11.11..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "1111.11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11.11..",
        ".1111...",
        "........",
        "........",
        "........"
    },
    ["Ñ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".111.11.",
        "11.111..",
        "........",
        "11...11.",
        "11...11.",
        "111..11.",
        "1111.11.",
        "11.1111.",
        "11..111.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["Ò"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..11....",
        "...11...",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["Ó"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "....11..",
        "...11...",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["Ô"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        ".11..11.",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["Õ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".111.11.",
        "11.111..",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["Ö"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11..11.",
        ".11..11.",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["×"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "1.....1.",
        "11...11.",
        ".11.11..",
        "..111...",
        ".11.11..",
        "11...11.",
        "1.....1.",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["Ø"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..11111.",
        ".11..11.",
        ".11.111.",
        ".11.111.",
        ".11.111.",
        ".111111.",
        ".111.11.",
        ".111.11.",
        ".111.11.",
        ".11..11.",
        ".11111..",
        "........",
        "........",
        "........"
    },
    ["Ù"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..11....",
        "...11...",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["Ú"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "....11..",
        "...11...",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["Û"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        ".11..11.",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["Ü"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11..11.",
        ".11..11.",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["Ý"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "....11..",
        "...11...",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["Þ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11......",
        "11......",
        "111111..",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "111111..",
        "11......",
        "11......",
        "........",
        "........",
        "........"
    },
    ["ß"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".1111...",
        "11..11..",
        "11..11..",
        "11..11..",
        "11.11...",
        "11..11..",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11..11..",
        "........",
        "........",
        "........"
    },
    ["à"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..11....",
        "...11...",
        "........",
        "........",
        "..1111..",
        ".....11.",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["á"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "....11..",
        "...11...",
        "........",
        "........",
        "..1111..",
        ".....11.",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["â"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        "........",
        "........",
        "..1111..",
        ".....11.",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["ã"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111.11.",
        "11.111..",
        "........",
        "........",
        "..1111..",
        ".....11.",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["ä"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "..1111..",
        ".....11.",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["å"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        "..1111..",
        "........",
        "..1111..",
        ".....11.",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["æ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".111111.",
        "...11.11",
        "...11.11",
        ".1111111",
        "11.11...",
        "11.11...",
        ".111.111",
        "........",
        "........",
        "........"
    },
    ["ç"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11..11.",
        "..1111..",
        "....11..",
        ".....11.",
        "...111.."
    },
    ["è"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..11....",
        "...11...",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11.....",
        ".11.....",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["é"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "....11..",
        "...11...",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11.....",
        ".11.....",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["ê"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11.....",
        ".11.....",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["ë"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11.....",
        ".11.....",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["ì"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..11....",
        "...11...",
        "........",
        "........",
        "..111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["í"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "....11..",
        "...11...",
        "........",
        "........",
        "..111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["î"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        "........",
        "........",
        "..111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["ï"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "..111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["ð"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "..11.11.",
        "...111..",
        "...111..",
        "..11.11.",
        ".....11.",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["ñ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111.11.",
        "11.111..",
        "........",
        "........",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["ò"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..11....",
        "...11...",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["ó"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "....11..",
        "...11...",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["ô"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["õ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111.11.",
        "11.111..",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["ö"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["÷"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "...11...",
        "...11...",
        "........",
        ".111111.",
        "........",
        "...11...",
        "...11...",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["ø"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111.1",
        ".11..11.",
        ".11.111.",
        ".111111.",
        ".111.11.",
        ".11..11.",
        "1.1111..",
        "........",
        "........",
        "........"
    },
    ["ù"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..11....",
        "...11...",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["ú"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "....11..",
        "...11...",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["û"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["ü"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["ý"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "....11..",
        "...11...",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        ".....11.",
        ".....11.",
        "..1111.."
    },
    ["þ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11....."
    },
    ["ÿ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        ".....11.",
        ".....11.",
        "..1111.."
    },
    ["а"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        ".....11.",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "........",
        "........",
        "........"
    },
    ["б"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        ".....11.",
        "..1111..",
        ".11.....",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["в"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11111..",
        "........",
        "........",
        "........"
    },
    ["г"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".111111.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        "........",
        "........",
        "........"
    },
    ["д"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        "1111111.",
        "11...11.",
        "........",
        "........"
    },
    ["е"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11.....",
        ".11.....",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["ё"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11.....",
        ".11.....",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["ж"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1..1..1.",
        "11.1.11.",
        ".11111..",
        "..111...",
        ".11111..",
        "11.1.11.",
        "1..1..1.",
        "........",
        "........",
        "........"
    },
    ["з"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".....11.",
        "...111..",
        ".....11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["и"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11...11.",
        "11..111.",
        "11.1111.",
        "1111111.",
        "1111.11.",
        "111..11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["й"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "11...11.",
        ".11111..",
        "........",
        "11...11.",
        "11..111.",
        "11.1111.",
        "1111111.",
        "1111.11.",
        "111..11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["к"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11.11..",
        ".1111...",
        ".11.11..",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["л"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "111..11.",
        "........",
        "........",
        "........"
    },
    ["м"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11...11.",
        "111.111.",
        "1111111.",
        "1111111.",
        "11.1.11.",
        "11.1.11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["н"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["о"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["п"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["р"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11....."
    },
    ["с"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["т"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".111111.",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["у"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        ".....11.",
        ".....11.",
        "..1111.."
    },
    ["ф"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "...1....",
        "...1....",
        ".11111..",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        ".11111..",
        "...1....",
        "...1....",
        "........"
    },
    ["х"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11...11.",
        "11...11.",
        ".11.11..",
        "..111...",
        ".11.11..",
        "11...11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["ц"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11..11..",
        "11..11..",
        "11..11..",
        "11..11..",
        "11..11..",
        "11..11..",
        "1111111.",
        ".....11.",
        "........",
        "........"
    },
    ["ч"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        ".....11.",
        ".....11.",
        ".....11.",
        "........",
        "........",
        "........"
    },
    ["ш"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "1111111.",
        "........",
        "........",
        "........"
    },
    ["щ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "1111111.",
        ".....11.",
        "........",
        "........"
    },
    ["ь"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11111..",
        "........",
        "........",
        "........"
    },
    ["ы"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11...11.",
        "11...11.",
        "11...11.",
        "1111.11.",
        "11.1111.",
        "11.1111.",
        "1111.11.",
        "........",
        "........",
        "........"
    },
    ["ъ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "111.....",
        "111.....",
        ".11.....",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11111..",
        "........",
        "........",
        "........"
    },
    ["э"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".1111...",
        "11..11..",
        ".....11.",
        "...1111.",
        ".....11.",
        "11..11..",
        ".1111...",
        "........",
        "........",
        "........"
    },
    ["ю"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11..11..",
        "11.1.11.",
        "11.1.11.",
        "1111.11.",
        "11.1.11.",
        "11.1.11.",
        "11..11..",
        "........",
        "........",
        "........"
    },
    ["я"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..11111.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "...1111.",
        "..11.11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["А"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "...11...",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["Б"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111111.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11111..",
        "........",
        "........",
        "........"
    },
    ["В"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11.11..",
        ".1111...",
        ".11.11..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11111..",
        "........",
        "........",
        "........"
    },
    ["Г"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111111.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        "........",
        "........",
        "........"
    },
    ["Д"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "...1111.",
        "..11.11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "11111111",
        "11....11",
        "11....11",
        "........"
    },
    ["Е"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111111.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["Ё"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11..11.",
        ".11..11.",
        "........",
        ".111111.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".111111.",
        "........",
        "........",
        "........"
    },
    ["Ж"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        ".11111..",
        "..111...",
        ".11111..",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "........",
        "........",
        "........"
    },
    ["З"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".....11.",
        ".....11.",
        "...111..",
        ".....11.",
        ".....11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["И"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11...11.",
        "11...11.",
        "11..111.",
        "11..111.",
        "11.1111.",
        "1111111.",
        "1111.11.",
        "111..11.",
        "111..11.",
        "11...11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["Й"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11...11.",
        ".11111..",
        "........",
        "11...11.",
        "11...11.",
        "11..111.",
        "11..111.",
        "11.1111.",
        "1111.11.",
        "111..11.",
        "111..11.",
        "11...11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["К"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11...11.",
        "11...11.",
        "11..11..",
        "11..11..",
        "11.11...",
        "1111....",
        "11.11...",
        "11..11..",
        "11..11..",
        "11...11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["Л"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "...1111.",
        "..11.11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["М"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11...11.",
        "111.111.",
        "111.111.",
        "1111111.",
        "11.1.11.",
        "11.1.11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "........",
        "........",
        "........"
    },
    ["Н"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["О"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["П"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["Р"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11111..",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        "........",
        "........",
        "........"
    },
    ["С"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1111..",
        ".11..11.",
        ".11..11.",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["Т"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".111111.",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........"
    },
    ["У"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        ".111111.",
        ".....11.",
        ".....11.",
        "111111..",
        "........",
        "........",
        "........"
    },
    ["Ф"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "...1....",
        ".11111..",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        ".11111..",
        "...1....",
        "...1....",
        "........"
    },
    ["Х"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11....11",
        "11....11",
        ".11..11.",
        "..1111..",
        "...11...",
        "...11...",
        "...11...",
        "..1111..",
        ".11..11.",
        "11....11",
        "11....11",
        "........",
        "........",
        "........"
    },
    ["Ц"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11..11..",
        "11..11..",
        "11..11..",
        "11..11..",
        "11..11..",
        "11..11..",
        "11..11..",
        "11..11..",
        "11..11..",
        "11..11..",
        "1111111.",
        ".....11.",
        ".....11.",
        "........"
    },
    ["Ч"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        ".111111.",
        ".....11.",
        ".....11.",
        ".....11.",
        ".....11.",
        ".....11.",
        "........",
        "........",
        "........"
    },
    ["Ш"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "1111111.",
        "........",
        "........",
        "........"
    },
    ["Щ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11111111",
        "......11",
        "......11",
        "........"
    },
    ["Ь"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11.....",
        ".11111..",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11111..",
        "........",
        "........",
        "........"
    },
    ["Ы"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "11...11.",
        "1111.11.",
        "11.1111.",
        "11.1111.",
        "11.1111.",
        "11.1111.",
        "1111.11.",
        "........",
        "........",
        "........"
    },
    ["Ъ"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "1111....",
        "1111....",
        "1.11....",
        "..11....",
        "..11....",
        "..1111..",
        "..11.11.",
        "..11.11.",
        "..11.11.",
        "..11.11.",
        "..1111..",
        "........",
        "........",
        "........"
    },
    ["Э"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        ".1111...",
        "11..11..",
        ".....11.",
        ".....11.",
        ".....11.",
        "..11111.",
        ".....11.",
        ".....11.",
        ".....11.",
        "11..11..",
        ".1111...",
        "........",
        "........",
        "........"
    },
    ["Ю"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11..11..",
        "11.1111.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "1111.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1.11.",
        "11.1111.",
        "11..11..",
        "........",
        "........",
        "........"
    },
    ["Я"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..11111.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..11111.",
        "...1111.",
        "..11.11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "........",
        "........",
        "........"
    },
    ["…"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1..1..1.",
        "1..1..1.",
        "........",
        "........",
        "........"
    },
    ["⎯"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["💫"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "................",
        "..111...........",
        ".1...11.........",
        ".1.....11.......",
        "..11.....11.....",
        ".....11....11...",
        "..11.11.11...1..",
        "..11111111...1..",
        "....1111..111...",
        "...111111.......",
        "..111..111......",
        "..11....11......",
        "................",
        "................"
    },
    ["📌"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "................",
        "..........1.....",
        "..........11....",
        "..........111...",
        "......11.11111..",
        ".......1111.....",
        "........11......",
        ".......1.11.....",
        "......1...1.....",
        ".....1..........",
        "....1...........",
        "...1............",
        "................",
        "................"
    },
    ["📂"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "...111..........",
        "...1..11........",
        "...1....11......",
        ".111......11....",
        ".1..111....1....",
        ".1.....111.1....",
        "..1......1.1....",
        "..1......1.1....",
        "..111.....11....",
        ".....1111.11....",
        ".........111....",
        "................",
        "................",
        "................"
    },
    ["❌"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "...11.....11....",
        "..1111...1111...",
        "...1111.1111....",
        "....1111111.....",
        ".....11111......",
        ".....11111......",
        "....1111111.....",
        "...1111.1111....",
        "..1111...1111...",
        "..111.....111...",
        "...1.......1....",
        "................",
        "................",
        "................"
    },
    ["⛌"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "................",
        "................",
        "..1.......1.....",
        "...1.....1......",
        "....1...1.......",
        ".....1..........",
        "......1.........",
        ".......1........",
        "....1...1.......",
        "...1.....1......",
        "..1.......1.....",
        "................",
        "................",
        "................"
    },
    ["🗓"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        ".....1.1.1......",
        "...111111111....",
        "...1.1.1.1.1....",
        "...1.......1....",
        "...1...1...1....",
        "...1..11...1....",
        "...1...1...1....",
        "...1...1...1....",
        "...1...1...1....",
        "...1..111..1....",
        "...1.......1....",
        "...111111111....",
        "................",
        "................"
    },
    ["🖹"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "...11111111.....",
        "...1......11....",
        "...1.1111.111...",
        "...1........1...",
        "...1.111111.1...",
        "...1........1...",
        "...1.111111.1...",
        "...1........1...",
        "...1.1111...1...",
        "...1........1...",
        "...1........1...",
        "...1111111111...",
        "................",
        "................"
    },
    ["🗘"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "..11111...11....",
        "...1111...1111..",
        "....111.....11..",
        "..11111......11.",
        "..11..1......11.",
        ".11..........11.",
        ".11..........11.",
        ".11......1..11..",
        ".11......11111..",
        "..11.....1111...",
        "..1111...1111...",
        "....11...11111..",
        "................",
        "................"
    },
    ["⇲"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        ".......1",
        ".......1",
        ".1.....1",
        "..1....1",
        "...1.1.1",
        "....11.1",
        "...111.1",
        ".......1",
        ".1111111",
        "........",
        "........"
    },
    ["⇊"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "..1..1..",
        "..1..1..",
        "..1..1..",
        "..1..1..",
        "..1..1..",
        "..1..1..",
        "..1..1..",
        "..1..1..",
        "..1..1..",
        "1.1..1.1",
        ".111111.",
        "..1..1..",
        "........",
        "........"
    },
    ["💻"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "................",
        "................",
        "...1111111111...",
        "...1........1...",
        "...1........1...",
        "...1........1...",
        "...1........1...",
        "...1111111111...",
        "......1111......",
        "................",
        "...111111111.11.",
        "...111111111.11.",
        "................",
        "................"
    },
    ["🌍"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".....111111.....",
        "...11....1111...",
        "..1...1.111111..",
        ".1.....11111111.",
        ".1....1...11111.",
        "1....1111111.111",
        "11..1111111...11",
        "111.111111.....1",
        "11....1111.....1",
        "11.....11.1....1",
        "1......1......11",
        ".1............1.",
        ".1............1.",
        "..1....111..11..",
        "...1111111111...",
        ".....111111....."
    },
    ["📷"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "................",
        "................",
        "..11..1111..11..",
        ".11111....11111.",
        ".1...111111...1.",
        ".11111....11111.",
        ".1111..11..1111.",
        ".1111.1..1.1111.",
        ".1111.1..1.1111.",
        ".1111..11..1111.",
        ".1...1....1...1.",
        ".11111111111111.",
        "................",
        "................"
    },
    ["➕"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "......111.......",
        "......111.......",
        "......111.......",
        "......111.......",
        "..11111111111...",
        "..11111111111...",
        "..11111111111...",
        "......111.......",
        "......111.......",
        "......111.......",
        "......111.......",
        "................",
        "................",
        "................"
    },
    ["🗎"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "................",
        "...1111111......",
        "...1.....11.....",
        "...1.111.111....",
        "...1.......1....",
        "...1.11111.1....",
        "...1.......1....",
        "...1.11111.1....",
        "...1.......1....",
        "...1.11111.1....",
        "...1.......1....",
        "...111111111....",
        "................",
        "................"
    },
    ["👁"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "................",
        ".....11111......",
        "...11.....11....",
        "..1...111...1...",
        ".1...11111...1..",
        "1....11111....1.",
        ".1...11111...1..",
        "..1...111...1...",
        "...11.....11....",
        ".....11111......",
        "................",
        "................",
        "................",
        "................"
    },
    ["𝕩"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "111...1.",
        "1.1...1.",
        ".1.1.1..",
        "..1.1...",
        "...1.1..",
        "..1.1.1.",
        ".1...1.1",
        ".1...111",
        "........",
        "........"
    },
    ["✂"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "..111........11.",
        ".11111.....111..",
        ".11.11....111...",
        ".1111111.111....",
        "..111111111.....",
        "......1111......",
        "..111111111.....",
        ".1111111.111....",
        ".11.11....111...",
        ".11111.....111..",
        "..111........11.",
        "................",
        "................",
        "................"
    },
    ["⧉"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "..11111111......",
        "..1......1......",
        "..1......1......",
        "..1......1......",
        "..1...11111111..",
        "..1...1..1...1..",
        "..1...1..1...1..",
        "..11111111...1..",
        "......1......1..",
        "......1......1..",
        "......1......1..",
        "......11111111..",
        "................",
        "................"
    },
    ["📦"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "....11...11.....",
        "...1..1.1..1....",
        "...1..11..1.....",
        "....1111111111..",
        ".....11111..11..",
        "....1..11..1.1..",
        "...1..1..11..1..",
        "..11111111...1..",
        "..1......1...1..",
        "..1......1...1..",
        "..1......1..1...",
        "..1......1.1....",
        "..1......11.....",
        "..11111111......",
        "................"
    },
    ["🖊"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        "..........111...",
        ".........1...1..",
        "........1....1..",
        ".......1.....1..",
        "......1.....1...",
        ".....1.....1....",
        "....1.1...1.....",
        "...1...1.1......",
        "..11....1.......",
        "..1....1........",
        "..11.11.........",
        ".11111..........",
        ".11.............",
        "................"
    },
    ["⭐"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        ".......1........",
        ".......1........",
        "......1.1.......",
        "......1.1.......",
        ".11111...11111..",
        "..1.........1...",
        "...1.......1....",
        "....1.....1.....",
        ".....1...1......",
        "....1.....1.....",
        "...1...1...1....",
        "..1..11.11..1...",
        "..111.....111...",
        "................",
        "................"
    },
    ["🥰"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        ".11.11..........",
        ".1111111111.....",
        "..111.....11.11.",
        "...1......11111.",
        "..1........111..",
        "..1..11.11..1.1.",
        ".1...11.11....1.",
        ".1............1.",
        ".1............1.",
        "..1..1...1...1..",
        "..1...111..11.11",
        "...1.......11111",
        "....11....1.111.",
        ".....111111..1..",
        "................"
    },
    ["😭"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "......11111.....",
        "....11.....11...",
        "...1.........1..",
        "..1..1.....1..1.",
        "..1...1...1...11",
        ".1...1.....1...1",
        ".1.1.........1.1",
        ".1.1..11111..1.1",
        ".1...11.1.11...1",
        "..1.1.1.1.1.1.1.",
        "..1.111111111.1.",
        "...1.........1..",
        "....11.....11...",
        "......11111.....",
        "................"
    },
    ["😎"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "......11111.....",
        "....11.....11...",
        "...1.........1..",
        "..1...........1.",
        "..1111111111111.",
        ".1.11111.11111.1",
        ".1..111...111..1",
        ".1.............1",
        ".1.............1",
        "..1.1.......1.1.",
        "..1..1.....1..1.",
        "...1..11111..1..",
        "....11.....11...",
        "......11111.....",
        "................"
    },
    ["🥺"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "......11111.....",
        "....11.....11...",
        "...1.........1..",
        "..1..11...11..1.",
        "..1.1..1.1..1.1.",
        ".1..1..1.1..1..1",
        ".1...11...11...1",
        ".1.............1",
        ".1.............1",
        "..1....111....1.",
        "..1...1...1...1.",
        "...1.........1..",
        "....11.....11...",
        "......11111.....",
        "................"
    },
    ["🤔"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "......11111.....",
        "....11.....11...",
        "...1.........1..",
        "..1...........1.",
        "..1..111.111..1.",
        ".1....11..11...1",
        ".1.............1",
        ".1.............1",
        ".1...11........1",
        "..1....11.1.1.1.",
        "..1......1.1.1.1",
        "...1.....1.1.1.1",
        "....11...1.....1",
        "......111.11...1",
        "............1..1"
    },
    ["🤓"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "......11111.....",
        "....11.....11...",
        "...1.........1..",
        "..1.1111.1111.1.",
        "..111..111..111.",
        ".1..1111.1111..1",
        ".1.............1",
        ".1..1.......1..1",
        ".1...1111111...1",
        "..1...1.1.1...1.",
        "..1...11111...1.",
        "...1.........1..",
        "....11.....11...",
        "......11111.....",
        "................"
    },
    ["🛒"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "............111.",
        "............1...",
        "...1111111111...",
        "...1........1...",
        "...1........1...",
        "...1........1...",
        "...1........1...",
        "...1111111111...",
        "............1...",
        "............1...",
        "...1111111111...",
        "................",
        "....11....11....",
        "....11....11....",
        "................"
    },
    ["🛈"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "......1111......",
        "....11....11....",
        "...1........1...",
        "..1....11....1..",
        "..1....11....1..",
        ".1............1.",
        ".1....111.....1.",
        ".1.....11.....1.",
        ".1.....11.....1.",
        "..1....11....1..",
        "..1...1111...1..",
        "...1........1...",
        "....11....11....",
        "......1111......",
        "................"
    },
    ["─"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["━"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["│"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┃"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┄"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11.111.1",
        "11.111.1",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┅"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11.111.1",
        "11.111.1",
        "11.111.1",
        "11.111.1",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┆"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "........",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "...11..."
    },
    ["┇"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "........",
        "..1111..",
        "..1111..",
        "..1111..",
        "........",
        "..1111..",
        "..1111..",
        "..1111..",
        "........",
        "..1111..",
        "..1111..",
        "..1111..",
        "........",
        "..1111.."
    },
    ["┈"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1.1.1.1.",
        "1.1.1.1.",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┉"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1.1.1.1.",
        "1.1.1.1.",
        "1.1.1.1.",
        "1.1.1.1.",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┊"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "........",
        "........",
        "...11...",
        "...11...",
        "........",
        "........",
        "...11...",
        "...11...",
        "........",
        "........",
        "...11...",
        "...11...",
        "........",
        "........",
        "...11..."
    },
    ["┋"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "........",
        "........",
        "..1111..",
        "..1111..",
        "........",
        "........",
        "..1111..",
        "..1111..",
        "........",
        "........",
        "..1111..",
        "..1111..",
        "........",
        "........",
        "..1111.."
    },
    ["┌"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "...11111",
        "...11111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┍"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "...11111",
        "...11111",
        "...11111",
        "...11111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┎"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..111111",
        "..111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┏"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..111111",
        "..111111",
        "..111111",
        "..111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┐"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111...",
        "11111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┑"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┒"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "111111..",
        "111111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┓"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["└"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11111",
        "...11111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┕"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11111",
        "...11111",
        "...11111",
        "...11111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┖"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..111111",
        "..111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┗"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..111111",
        "..111111",
        "..111111",
        "..111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┘"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111...",
        "11111...",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┙"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┚"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "111111..",
        "111111..",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┛"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["├"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11111",
        "...11111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┝"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11111",
        "...11111",
        "...11111",
        "...11111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┞"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..111111",
        "...11111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┟"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11111",
        "...11111",
        "..111111",
        "..111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┠"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..111111",
        "..111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┡"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..111111",
        "..111111",
        "...11111",
        "...11111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┢"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11111",
        "..111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┣"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..111111",
        "..111111",
        "..111111",
        "..111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┤"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111...",
        "11111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┥"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┦"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "111111..",
        "11111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┧"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111...",
        "11111...",
        "111111..",
        "111111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┨"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "111111..",
        "111111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┩"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "111111..",
        "111111..",
        "11111...",
        "11111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┪"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111...",
        "111111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┫"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┬"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┭"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1111....",
        "11111111",
        "11111111",
        "11111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┮"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "....1111",
        "11111111",
        "11111111",
        "...11111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┯"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┰"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┱"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1111....",
        "11111111",
        "11111111",
        "111111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┲"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "....1111",
        "11111111",
        "11111111",
        "..111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┳"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["┴"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111111",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┵"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111...",
        "11111111",
        "11111111",
        "1111....",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┶"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11111",
        "11111111",
        "11111111",
        "....1111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┷"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┸"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "11111111",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┹"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "111111..",
        "11111111",
        "11111111",
        "1111....",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┺"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..111111",
        "11111111",
        "11111111",
        "....1111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┻"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["┼"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111111",
        "11111111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┽"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111...",
        "11111111",
        "11111111",
        "11111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┾"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11111",
        "11111111",
        "11111111",
        "...11111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["┿"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╀"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "11111111",
        "11111111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╁"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111111",
        "11111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["╂"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "11111111",
        "11111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["╃"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "111111..",
        "11111111",
        "11111111",
        "11111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╄"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..111111",
        "11111111",
        "11111111",
        "...11111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╅"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111...",
        "11111111",
        "11111111",
        "111111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["╆"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11111",
        "11111111",
        "11111111",
        "..111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["╇"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╈"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["╉"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "111111..",
        "11111111",
        "11111111",
        "111111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["╊"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..111111",
        "11111111",
        "11111111",
        "..111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["╋"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["╌"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1..11..1",
        "1..11..1",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╍"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1..11..1",
        "1..11..1",
        "1..11..1",
        "1..11..1",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╎"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "........",
        "........",
        "........",
        "........",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........",
        "........",
        "...11...",
        "...11..."
    },
    ["╏"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        "..1111.."
    },
    ["═"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "........",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["║"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╒"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "...11111",
        "...11...",
        "...11111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╓"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".1111111",
        ".1111111",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╔"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".1111111",
        ".11.....",
        ".11.1111",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╕"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111...",
        "...11...",
        "11111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╖"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "111111..",
        "111111..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╗"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "111111..",
        "....11..",
        "111.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╘"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11111",
        "...11...",
        "...11111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╙"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".1111111",
        ".1111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╚"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.1111",
        ".11.....",
        ".1111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╛"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111...",
        "...11...",
        "11111...",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╜"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        "111111..",
        "111111..",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╝"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        "111.11..",
        "....11..",
        "111111..",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╞"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11111",
        "...11...",
        "...11111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╟"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.1111",
        ".11.1111",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╠"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.1111",
        ".11.....",
        ".11.1111",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╡"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111...",
        "...11...",
        "11111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╢"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        "111.11..",
        "111.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╣"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        "111.11..",
        "....11..",
        "111.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╤"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "........",
        "11111111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╥"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╦"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "........",
        "111.1111",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╧"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111111",
        "........",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╨"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        "11111111",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╩"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        "111.1111",
        "........",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╪"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "11111111",
        "...11...",
        "11111111",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╫"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        "11111111",
        "11111111",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╬"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        "111.1111",
        "........",
        "111.1111",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11..",
        ".11.11.."
    },
    ["╭"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        ".....111",
        "....1111",
        "...111..",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╮"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "111.....",
        "1111....",
        "..111...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╯"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "..111...",
        "1111....",
        "111.....",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╰"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...111..",
        "....1111",
        ".....111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╱"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "......11",
        "......11",
        ".....11.",
        ".....11.",
        "....11..",
        "....11..",
        "...11...",
        "...11...",
        "..11....",
        "..11....",
        ".11.....",
        ".11.....",
        "11......",
        "11......",
        "1.......",
        "1......."
    },
    ["╲"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11......",
        "11......",
        ".11.....",
        ".11.....",
        "..11....",
        "..11....",
        "...11...",
        "...11...",
        "....11..",
        "....11..",
        ".....11.",
        ".....11.",
        "......11",
        "......11",
        ".......1",
        ".......1"
    },
    ["╳"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11....11",
        "11....11",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "..1111..",
        "...11...",
        "...11...",
        "..1111..",
        "..1111..",
        ".11..11.",
        ".11..11.",
        "11....11",
        "11....11",
        "1......1",
        "1......1"
    },
    ["╴"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1111....",
        "1111....",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╵"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╶"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "....1111",
        "....1111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╷"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["╸"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╹"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╺"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╻"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["╼"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "....1111",
        "11111111",
        "11111111",
        "....1111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╽"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111.."
    },
    ["╾"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1111....",
        "11111111",
        "11111111",
        "1111....",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["╿"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    ["▀"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["▁"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111"
    },
    ["▂"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        "11111111",
        "11111111"
    },
    ["▃"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111"
    },
    ["▄"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111"
    },
    ["▅"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111"
    },
    ["▆"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111"
    },
    ["▇"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111"
    },
    ["█"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111"
    },
    ["▉"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111.",
        "1111111."
    },
    ["▊"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111.."
    },
    ["▋"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "11111...",
        "11111..."
    },
    ["▌"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111...."
    },
    ["▍"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "111.....",
        "111.....",
        "111.....",
        "111.....",
        "111.....",
        "111.....",
        "111.....",
        "111.....",
        "111.....",
        "111.....",
        "111.....",
        "111.....",
        "111.....",
        "111.....",
        "111.....",
        "111....."
    },
    ["▎"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11......",
        "11......",
        "11......",
        "11......",
        "11......",
        "11......",
        "11......",
        "11......",
        "11......",
        "11......",
        "11......",
        "11......",
        "11......",
        "11......",
        "11......",
        "11......"
    },
    ["▏"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.......",
        "1.......",
        "1.......",
        "1.......",
        "1.......",
        "1.......",
        "1.......",
        "1.......",
        "1.......",
        "1.......",
        "1.......",
        "1.......",
        "1.......",
        "1.......",
        "1.......",
        "1......."
    },
    ["▐"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111"
    },
    ["░"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "..1...1.",
        "1...1...",
        "..1...1.",
        "1...1...",
        "..1...1.",
        "1...1...",
        "..1...1.",
        "1...1...",
        "..1...1.",
        "1...1...",
        "..1...1.",
        "1...1...",
        "..1...1.",
        "1...1...",
        "..1...1.",
        "1...1..."
    },
    ["▒"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.1.1.1.",
        ".1.1.1.1",
        "1.1.1.1.",
        ".1.1.1.1",
        "1.1.1.1.",
        ".1.1.1.1",
        "1.1.1.1.",
        ".1.1.1.1",
        "1.1.1.1.",
        ".1.1.1.1",
        "1.1.1.1.",
        ".1.1.1.1",
        "1.1.1.1.",
        ".1.1.1.1",
        "1.1.1.1.",
        ".1.1.1.1"
    },
    ["▓"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11.111.1",
        ".111.111",
        "11.111.1",
        ".111.111",
        "11.111.1",
        ".111.111",
        "11.111.1",
        ".111.111",
        "11.111.1",
        ".111.111",
        "11.111.1",
        ".111.111",
        "11.111.1",
        ".111.111",
        "11.111.1",
        ".111.111"
    },
    ["▔"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11111111",
        "11111111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["▕"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".......1",
        ".......1",
        ".......1",
        ".......1",
        ".......1",
        ".......1",
        ".......1",
        ".......1",
        ".......1",
        ".......1",
        ".......1",
        ".......1",
        ".......1",
        ".......1",
        ".......1",
        ".......1"
    },
    ["▖"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111...."
    },
    ["▗"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111"
    },
    ["▘"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["▙"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111"
    },
    ["▚"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111"
    },
    ["▛"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111...."
    },
    ["▜"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111"
    },
    ["▝"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["▞"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111....",
        "1111...."
    },
    ["▟"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "....1111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        "11111111"
    },
    ["◣"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.......",
        "1.......",
        "11......",
        "11......",
        "111.....",
        "111.....",
        "1111....",
        "1111....",
        "11111...",
        "11111...",
        "111111..",
        "111111..",
        "1111111.",
        "1111111.",
        "11111111",
        "11111111"
    },
    ["◢"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".......1",
        ".......1",
        ".......1",
        "......11",
        "......11",
        ".....111",
        ".....111",
        "....1111",
        "....1111",
        "...11111",
        "...11111",
        "..111111",
        "..111111",
        ".1111111",
        ".1111111",
        "11111111"
    },
    ["•"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..111...",
        ".11111..",
        ".11111..",
        ".11111..",
        "..111...",
        "........",
        "........",
        "........",
        "........"
    },
    ["⚫"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..111...",
        ".11111..",
        "1111111.",
        "1111111.",
        "1111111.",
        ".11111..",
        "..111...",
        "........"
    },
    ["∙"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "..111...",
        ".11111..",
        ".11111..",
        ".11111..",
        "..111...",
        "........",
        "........",
        "........",
        "........"
    },
    ["⬤"] = {
        width = 16,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "................",
        "................",
        ".......111......",
        ".....1111111....",
        "....111111111...",
        "...11111111111..",
        "...11111111111..",
        "..1111111111111.",
        "..1111111111111.",
        "..1111111111111.",
        "...11111111111..",
        "...11111111111..",
        "....111111111...",
        ".....1111111....",
        ".......111......",
        "................"
    },
    ["◖"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "......11",
        "....1111",
        "...11111",
        "...11111",
        "..111111",
        "..111111",
        "..111111",
        "..111111",
        "..111111",
        "..111111",
        "...11111",
        "...11111",
        "....1111",
        "......11",
        "........"
    },
    ["◗"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "11......",
        "1111....",
        "11111...",
        "11111...",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "111111..",
        "11111...",
        "11111...",
        "1111....",
        "11......",
        "........"
    },
    ["▲"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "...11...",
        "...11...",
        "..1111..",
        "..1111..",
        ".111111.",
        ".111111.",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    [" "] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["▼"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11111111",
        "11111111",
        "11111111",
        "11111111",
        ".111111.",
        ".111111.",
        ".111111.",
        ".111111.",
        "..1111..",
        "..1111..",
        "..1111..",
        "..1111..",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    [" "] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["▽"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11111111",
        "11111111",
        "11....11",
        "11....11",
        "11....11",
        "11....11",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        ".11..11.",
        "..1111..",
        "..1111..",
        "...11...",
        "...11...",
        "...11...",
        "...11..."
    },
    [" "] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["△"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "...11...",
        "...11...",
        "..1..1..",
        "..1..1..",
        ".1....1.",
        ".111111.",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    [" "] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........",
        "........"
    },
    ["◥"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11111111",
        "11111111",
        ".1111111",
        ".1111111",
        "..111111",
        "..111111",
        "...11111",
        "...11111",
        "....1111",
        "....1111",
        ".....111",
        ".....111",
        "......11",
        "......11",
        ".......1",
        ".......1"
    },
    ["◤"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "11111111",
        "11111111",
        "1111111.",
        "1111111.",
        "111111..",
        "111111..",
        "11111...",
        "11111...",
        "1111....",
        "1111....",
        "111.....",
        "111.....",
        "11......",
        "11......",
        "1.......",
        "1......."
    },
    ["◢"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        ".......1",
        ".......1",
        ".......1",
        "......11",
        "......11",
        ".....111",
        ".....111",
        "....1111",
        "....1111",
        "...11111",
        "...11111",
        "..111111",
        "..111111",
        ".1111111",
        ".1111111",
        "11111111"
    },
    ["◣"] = {
        width = 8,
        height = 16,
        offsetX = 0,
        offsetY = 0,
        "1.......",
        "1.......",
        "11......",
        "11......",
        "111.....",
        "111.....",
        "1111....",
        "1111....",
        "11111...",
        "11111...",
        "111111..",
        "111111..",
        "1111111.",
        "1111111.",
        "11111111",
        "11111111"
    },
  }
}

font.fonts.oc_16x8.index = font.fontIndex
font.fonts[font.fontIndex] = font.fonts.oc_16x8
font.fontIndex = font.fontIndex + 1

end
function scmframework_36cb3d140da7f4e67200d36784a4305c() --$CONTENT_DATA/Scripts/canvasAPI/fonts/generated_fonts.lua
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/generated/oc_16x8.lua")
end
function scmframework_bce62c41f043de1981fded716df6598a() --$CONTENT_DATA/Scripts/canvasAPI/fonts/load.lua
print("canvas: loading fonts...")

font = {}
font.fonts = {}
font.fontIndex = 1
font.fontsOptimized = {}

dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/manual_fonts.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/converted_fonts.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/generated_fonts.lua")

---------------------------------------------------

local pairs = pairs
local ipairs = ipairs
local table_insert = table.insert
local string_byte = string.byte

function font.optimizeFont(lfont)
    local optimized = {}
	optimized.returnWidth = lfont.returnWidth
	optimized.returnHeight = lfont.returnHeight
	if lfont.mono or lfont.mono == nil then
		optimized.width = lfont.width
		optimized.height = lfont.height
		optimized.mono = true

		local pixels
		local chr
		for k, v in pairs(lfont.chars) do
			pixels = {}

			for ix = lfont.width, 1, -1 do
				for iy = #v, 1, -1 do
					chr = v[iy]:sub(ix, ix)
					if chr == "1" then
						table_insert(pixels, ix-1)
						table_insert(pixels, iy-1)
					end
				end
			end

			optimized[k] = pixels
			if #k == 1 then
				optimized[string_byte(k)] = pixels
			end
		end
	else
		if not optimized.spaceSize then
			local getSizeChar = lfont.chars[" "] or lfont.chars["a"] or lfont.chars["A"] or lfont.chars["8"]
			if not getSizeChar then
				for i, v in ipairs(lfont.chars) do
					getSizeChar = v
					break
				end
			end
			if getSizeChar and getSizeChar[1] then
				optimized.spaceSize = #getSizeChar[1]
			end
			if not optimized.spaceSize or optimized.spaceSize == 0 then
				optimized.spaceSize = 5
			end
		end

		local upperFont = 0
		for k, v in pairs(lfont.chars) do
			if not v.processed then
				if not v.width then
					v.width = (v[1] and #v[1]) or 0
				end
				if not v.height then
					v.height = #v
				end
				v.origWidth = v.width
				v.origHeight = v.height
				v.lOffsetX = v.offsetX
				v.lOffsetY = -v.offsetY
				v.width = v.width + math.abs(v.offsetX)
				v.height = v.height + math.abs(v.offsetY)
				if v.lOffsetY > upperFont then
					upperFont = v.lOffsetY
				end
				v.processed = true
			end
		end

		if not optimized.width then
			optimized.width = 0
			for k, v in pairs(lfont.chars) do
				if v.width > optimized.width then
					optimized.width = v.width
				end
			end
		end

		if not optimized.height then
			optimized.height = 0
			for k, v in pairs(lfont.chars) do
				if v.height > optimized.height then
					optimized.height = v.height
				end
			end
		end

		for k, v in pairs(lfont.chars) do
			local pixels = {}
			pixels[0] = v.width

			local addWidth = 0
			local addHeight = (optimized.height - v.origHeight) - upperFont

			for iy, w in ipairs(v) do
				for ix = 1, #w do
					local chr = w:sub(ix, ix)
					if chr == "1" then
						table_insert(pixels, (ix - 1) + addWidth + v.lOffsetX)
						table_insert(pixels, (iy - 1) + addHeight + v.lOffsetY)
					end
				end
			end

			optimized[k] = pixels
			if #k == 1 then
				optimized[string_byte(k)] = pixels
			end
		end
	end
    return optimized
end

---------------------------------------------------

font.fontsOptimized = {}
for i, fdata in ipairs(font.fonts) do
    font.fontsOptimized[i] = font.optimizeFont(fdata)
end

font.default = font.fonts[1]
font.optimized = font.fontsOptimized[1]
end
function scmframework_4b5722faf75bdb8e20c702ad63d6fbc9() --$CONTENT_DATA/Scripts/canvasAPI/fonts/manual/lgc_3x3.lua
font.fonts.lgc_3x3 = {}
font.fonts.lgc_3x3.width = 3
font.fonts.lgc_3x3.height = 3

font.fonts.lgc_3x3.chars = {
	["A"] = {
		".1.",
		"111",
		"1.1"
	},
	["B"] = {
		"11.",
		"111",
		"11."
	},
	["C"] = {
		".11",
		"1..",
		".11"
	},
	["D"] = {
		"11.",
		"1.1",
		"11."
	},
	["E"] = {
		"111",
		"11.",
		"111"
	},
	["F"] = {
		"111",
		"11.",
		"1.."
	},
	["G"] = {
		".1.",
		"111",
		".11"
	},
	["H"] = {
		"1.1",
		"111",
		"1.1"
	},
	["I"] = {
		".1.",
		".1.",
		".1."
	},
	["J"] = {
		"111",
		".1.",
		"1.."
	},
	["K"] = {
		"1.1",
		"11.",
		"1.1"
	},
	["L"] = {
		"1..",
		"1..",
		"111"
	},
	["M"] = {
		"1.1",
		"111",
		"111"
	},
	["N"] = {
		"111",
		"1.1",
		"1.1"
	},
	["O"] = {
		".1.",
		"1.1",
		".1."
	},
	["P"] = {
		"11.",
		"11.",
		"1.."
	},
	["Q"] = {
		".1.",
		"1.1",
		".11"
	},
	["R"] = {
		"11.",
		"11.",
		"1.1"
	},
	["S"] = {
		".11",
		".1.",
		"11."
	},
	["T"] = {
		"111",
		".1.",
		".1."
	},
	["U"] = {
		"1.1",
		"1.1",
		".1."
	},
	["V"] = {
		"1.1",
		"111",
		".1."
	},
	["W"] = {
		"111",
		"111",
		"1.1"
	},
	["X"] = {
		"1.1",
		".1.",
		"1.1"
	},
	["Y"] = {
		"1.1",
		".1.",
		".1."
	},
	["Z"] = {
		"11.",
		".1.",
		".11"
	},

	------------------------
	["0"] = {
		".1.",
		"1.1",
		".1."
	},
	["1"] = {
		"11.",
		".1.",
		".1."
	},
	["2"] = {
		"11.",
		".1.",
		".11"
	},
	["3"] = {
		"11.",
		".11",
		"11."
	},
	["4"] = {
		"1.1",
		"111",
		"..1"
	},
	["5"] = {
		".11",
		"11.",
		"11."
	},
	["6"] = {
		"1..",
		"11.",
		"11."
	},
	["7"] = {
		"111",
		"..1",
		".1."
	},
	["8"] = {
		".1.",
		"...",
		".1."
	},
	["9"] = {
		".11",
		".11",
		"..1"
	},
	["."] = {
		"...",
		"...",
		"..1"
	},
	[","] = {
		"...",
		"..1",
		".1."
	},
	[":"] = {
		".1.",
		"...",
		".1."
	},
	[";"] = {
		".1.",
		"...",
		".1."
	},
	["!"] = {
		"1..",
		"1..",
		"1.."
	},
	["?"] = {
		"11.",
		"..1",
		"1.."
	},
	["'"] = {
		".1.",
		".1.",
		"..."
	},
	['"'] = {
		"1.1",
		"1.1",
		"..."
	},
	["("] = {
		".1.",
		"1..",
		".1."
	},
	[")"] = {
		".1.",
		"..1",
		".1."
	},
	["["] = {
		".11",
		"..1",
		".11"
	},
	["]"] = {
		"11.",
		"1..",
		"11."
	},
	["{"] = {
		".11",
		"11.",
		".11"
	},
	["}"] = {
		"11.",
		".11",
		"11."
	},
	["<"] = {
		".11",
		"1..",
		".11"
	},
	[">"] = {
		"11.",
		"..1",
		"11."
	},
	["/"] = {
		"..1",
		".1.",
		"1.."
	},
	["\\"] = {
		"1..",
		".1.",
		"..1"
	},
	["@"] = {
		"11.",
		"11.",
		"..1"
	},
	["#"] = {
		"1.1",
		"111",
		"1.1"
	},
	["$"] = {
		".11",
		".1.",
		"11."
	},
	["%"] = {
		"1..",
		"...",
		"..1"
	},
	["^"] = {
		".1.",
		"1.1",
		"..."
	},
	["&"] = {
		".1.",
		"1..",
		".11"
	},
	["*"] = {
		".1.",
		"111",
		"..."
	},
	["+"] = {
		".1.",
		"111",
		".1."
	},
	["-"] = {
		"...",
		"111",
		"..."
	},
	["_"] = {
		"...",
		"...",
		"111"
	},
	["="] = {
		"111",
		"...",
		"111"
	},
	["`"] = {
		"1..",
		".1.",
		"..."
	},
	["~"] = {
		"1.1",
		".1.",
		"..."
	},
	["№"] = {
		"..1",
		"11.",
		"11."
	}
}

for i = string.byte("A"), string.byte("Z") do
	local char = string.char(i)
	font.fonts.lgc_3x3.chars[char:lower()] = font.fonts.lgc_3x3.chars[char]
end

font.fonts.lgc_3x3.chars.error = {
	"111",
	"1.1",
	"111"
}

font.fonts.lgc_3x3.index = font.fontIndex
font.fonts[font.fontIndex] = font.fonts.lgc_3x3
font.fontIndex = font.fontIndex + 1
end
function scmframework_04ae1b186a2771cb850554c1e01aaa12() --$CONTENT_DATA/Scripts/canvasAPI/fonts/manual/lgc_5x4.lua
font.fonts.lgc_5x4 = {}
font.fonts.lgc_5x4.width = 4
font.fonts.lgc_5x4.height = 5

font.fonts.lgc_5x4.chars = {
	----------big english fonts
	["A"] = {
		".11.",
		"1..1",
		"1111",
		"1..1",
		"1..1"
	},
	["B"] = {
		"111.",
		"1..1",
		"111.",
		"1..1",
		"111."
	},
	["C"] = {
		".11.",
		"1..1",
		"1...",
		"1..1",
		".11."
	},
	["D"] = {
		"111.",
		"1..1",
		"1..1",
		"1..1",
		"111."
	},
	["E"] = {
		"1111",
		"1...",
		"111.",
		"1...",
		"1111"
	},
	["F"] = {
		"1111",
		"1...",
		"111.",
		"1...",
		"1..."
	},
	["G"] = {
		".111",
		"1...",
		"1.11",
		"1..1",
		".11."
	},
	["H"] = {
		"1..1",
		"1..1",
		"1111",
		"1..1",
		"1..1"
	},
	["I"] = {
		"1111",
		".11.",
		".11.",
		".11.",
		"1111"
	},
	["J"] = {
		"1111",
		".11.",
		".11.",
		".11.",
		"11.."
	},
	["K"] = {
		"1..1",
		"1..1",
		"111.",
		"1..1",
		"1..1"
	},
	["L"] = {
		"1...",
		"1...",
		"1...",
		"1...",
		"1111"
	},
	["M"] = {
		"1..1",
		"1111",
		"1..1",
		"1..1",
		"1..1"
	},
	["N"] = {
		"1..1",
		"11.1",
		"1.11",
		"1..1",
		"1..1"
	},
	["O"] = {
		".11.",
		"1..1",
		"1..1",
		"1..1",
		".11."
	},
	["P"] = {
		"111.",
		"1..1",
		"111.",
		"1...",
		"1..."
	},
	["Q"] = {
		".11.",
		"1..1",
		"1..1",
		"1..1",
		".111"
	},
	["R"] = {
		"111.",
		"1..1",
		"111.",
		"1..1",
		"1..1"
	},
	["S"] = {
		".111",
		"1...",
		".11.",
		"...1",
		"111."
	},
	["T"] = {
		"1111",
		".11.",
		".11.",
		".11.",
		".11."
	},
	["U"] = {
		"1..1",
		"1..1",
		"1..1",
		"1..1",
		".111"
	},
	["V"] = {
		"1..1",
		"1..1",
		"1..1",
		"1..1",
		".11."
	},
	["W"] = {
		"1..1",
		"1..1",
		"1..1",
		"1111",
		"1..1"
	},
	["X"] = {
		"1..1",
		"1..1",
		".11.",
		"1..1",
		"1..1"
	},
	["Y"] = {
		"1..1",
		"1..1",
		".111",
		"...1",
		".11."
	},
	["Z"] = {
		"1111",
		"...1",
		".11.",
		"1...",
		"1111"
	},

	----------small english fonts
	["a"] = {
		"....",
		".11.",
		"...1",
		"1111",
		".111"
	},
	["b"] = {
		"....",
		"1...",
		"111.",
		"1..1",
		"111."
	},
	["c"] = {
		"....",
		".111",
		"1...",
		"1...",
		".111"
	},
	["d"] = {
		"....",
		"...1",
		".111",
		"1..1",
		".111"
	},
	["e"] = {
		"....",
		"1111",
		"111.",
		"1...",
		"1111"
	},
	["f"] = {
		"....",
		"1111",
		"1...",
		"111.",
		"1..."
	},
	["g"] = {
		"....",
		".111",
		"1...",
		"1..1",
		".11."
	},
	["h"] = {
		"....",
		"1...",
		"1111",
		"1..1",
		"1..1"
	},
	["i"] = {
		"....",
		".11.",
		"....",
		".11.",
		".11."
	},
	["j"] = {
		"....",
		"..1.",
		"..1.",
		"..1.",
		"11.."
	},
	["k"] = {
		"....",
		"1...",
		"1..1",
		"111.",
		"1..1"
	},
	["l"] = {
		"....",
		"1...",
		"1...",
		"1...",
		"1111"
	},
	["m"] = {
		"....",
		"1..1",
		"1111",
		"1..1",
		"1..1"
	},
	["n"] = {
		"....",
		"111.",
		"1..1",
		"1..1",
		"1..1"
	},
	["o"] = {
		"....",
		".11.",
		"1..1",
		"1..1",
		".11."
	},
	["p"] = {
		"....",
		"111.",
		"1..1",
		"111.",
		"1..."
	},
	["q"] = {
		"....",
		".11.",
		"1..1",
		"1111",
		"...1"
	},
	["r"] = {
		"....",
		"11.1",
		"1.1.",
		"1...",
		"1..."
	},
	["s"] = {
		"....",
		"..11",
		".1..",
		"..1.",
		"11.."
	},
	["t"] = {
		"....",
		"1111",
		".11.",
		".11.",
		".11."
	},
	["u"] = {
		"....",
		"1..1",
		"1..1",
		"1..1",
		".111"
	},
	["v"] = {
		"....",
		"1..1",
		"1..1",
		"1..1",
		".11."
	},
	["w"] = {
		"....",
		"1..1",
		"1..1",
		"1111",
		"1..1"
	},
	["x"] = {
		"....",
		"1..1",
		".11.",
		".11.",
		"1..1"
	},
	["y"] = {
		"....",
		"1..1",
		".111",
		"...1",
		".11."
	},
	["z"] = {
		"....",
		"1111",
		"..1.",
		".1..",
		"1111"
	},





	----------big russian fonts
	["А"] = {
		".11.",
		"1..1",
		"1111",
		"1..1",
		"1..1"
	},
	["Б"] = {
		"1111",
		"1...",
		"111.",
		"1..1",
		"111."
	},
	["В"] = {
		"111.",
		"1..1",
		"111.",
		"1..1",
		"111."
	},
	["Г"] = {
		"1111",
		"1...",
		"1...",
		"1...",
		"1..."
	},
	["Д"] = {
		".11.",
		"1..1",
		"1..1",
		".11.",
		"1..1"
	},
	["Е"] = {
		"1111",
		"1...",
		"1111",
		"1...",
		"1111"
	},
	["Ё"] = {
		"11.1",
		"1...",
		"1111",
		"1...",
		"1111"
	},
	["Ж"] = {
		"1..1",
		".11.",
		"1111",
		".11.",
		"1..1"
	},
	["З"] = {
		"111.",
		"...1",
		".11.",
		"...1",
		"111."
	},
	["И"] = {
		"1..1",
		"1..1",
		"1.11",
		"11.1",
		"1..1"
	},
	["Й"] = {
		"1.11",
		"1..1",
		"1.11",
		"11.1",
		"1..1"
	},
	["К"] = {
		"1..1",
		"1.1.",
		"11..",
		"1.1.",
		"1..1"
	},
	["Л"] = {
		".111",
		"1..1",
		"1..1",
		"1..1",
		"1..1"
	},
	["М"] = {
		"1..1",
		"1111",
		"1..1",
		"1..1",
		"1..1"
	},
	["Н"] = {
		"1..1",
		"1..1",
		"1111",
		"1..1",
		"1..1"
	},
	["О"] = {
		".11.",
		"1..1",
		"1..1",
		"1..1",
		".11."
	},
	["П"] = {
		"1111",
		"1..1",
		"1..1",
		"1..1",
		"1..1"
	},
	["Р"] = {
		"111.",
		"1..1",
		"111.",
		"1...",
		"1..."
	},
	["С"] = {
		".111",
		"1...",
		"1...",
		"1...",
		".111"
	},
	["Т"] = {
		"1111",
		".11.",
		".11.",
		".11.",
		".11."
	},
	["У"] = {
		"1..1",
		"1..1",
		".1.1",
		"..1.",
		".1.."
	},
	["Ф"] = {
		"1111",
		"1..1",
		"1..1",
		"1111",
		".11."
	},
	["Х"] = {
		"1..1",
		"1..1",
		".11.",
		"1..1",
		"1..1"
	},
	["Ц"] = {
		"1.1.",
		"1.1.",
		"1.1.",
		"1111",
		"...1"
	},
	["Ч"] = {
		"1..1",
		"1..1",
		"1111",
		"...1",
		"...1"
	},
	["Ш"] = {
		"1.11",
		"1.11",
		"1.11",
		"1.11",
		"1111"
	},
	["Щ"] = {
		"1.11",
		"1.11",
		"1.11",
		"1111",
		"...1"
	},
	["Ь"] = {
		"1...",
		"1...",
		"111.",
		"1..1",
		"111."
	},
	["Ы"] = {
		"1..1",
		"1..1",
		"11.1",
		"11.1",
		"11.1"
	},
	["Ъ"] = {
		"11..",
		".1..",
		".111",
		".1.1",
		".111"
	},
	["Э"] = {
		"111.",
		"...1",
		"1111",
		"...1",
		"111."
	},
	["Ю"] = {
		"1.1.",
		"11.1",
		"11.1",
		"11.1",
		"1.1."
	},
	["Я"] = {
		".111",
		"1..1",
		"1111",
		".1.1",
		"1..1"
	},

	----------------small russian font
	["а"] = {
		"....",
		".11.",
		"...1",
		"1111",
		".111"
	},
	["б"] = {
		"....",
		".11.",
		"1...",
		"1111",
		"111."
	},
	["в"] = {
		"....",
		"11..",
		"111.",
		"111.",
		"11.."
	},
	["г"] = {
		"....",
		"1111",
		"1...",
		"1...",
		"1..."
	},
	["д"] = {
		"....",
		".11.",
		"1..1",
		".11.",
		"1..1"
	},
	["е"] = {
		"....",
		"1111",
		"111.",
		"1...",
		"1111"
	},
	["ё"] = {
		".11.",
		"1111",
		"111.",
		"1...",
		"1111"
	},
	["ж"] = {
		"....",
		"1..1",
		".1.1",
		"1.1.",
		"1..1"
	},
	["з"] = {
		"....",
		"1111",
		".11.",
		"...1",
		"111."
	},
	["и"] = {
		"....",
		"1..1",
		"1.11",
		"11.1",
		"1..1"
	},
	["й"] = {
		"..1.",
		"1..1",
		"1.11",
		"11.1",
		"1..1"
	},
	["к"] = {
		"....",
		"1..1",
		"1.1.",
		"11..",
		"1.1."
	},
	["л"] = {
		"....",
		".111",
		"1..1",
		"1..1",
		"1..1"
	},
	["м"] = {
		"....",
		"1111",
		"1.11",
		"1.11",
		"1.11"
	},
	["н"] = {
		"....",
		"1..1",
		"1111",
		"1111",
		"1..1"
	},
	["о"] = {
		"....",
		".11.",
		"1..1",
		"1..1",
		".11."
	},
	["п"] = {
		"....",
		"1111",
		"1..1",
		"1..1",
		"1..1"
	},
	["р"] = {
		"....",
		"111.",
		"1..1",
		"111.",
		"1..."
	},
	["с"] = {
		"....",
		".111",
		"1...",
		"1...",
		".111"
	},
	["т"] = {
		"....",
		"1111",
		".11.",
		".11.",
		".11."
	},
	["у"] = {
		"....",
		"1..1",
		".1.1",
		"..1.",
		".1.."
	},
	["ф"] = {
		"....",
		".11.",
		"1..1",
		"1111",
		".11."
	},
	["х"] = {
		"....",
		"1..1",
		".11.",
		".11.",
		"1..1"
	},
	["ц"] = {
		"....",
		"1.1.",
		"1.1.",
		"1111",
		"...1"
	},
	["ч"] = {
		"....",
		"1..1",
		"1111",
		"...1",
		"...1"
	},
	["ш"] = {
		"....",
		"1.11",
		"1.11",
		"1.11",
		"1111"
	},
	["щ"] = {
		"....",
		"1.11",
		"1.11",
		"1111",
		"...1"
	},
	["ь"] = {
		"....",
		"1...",
		"111.",
		"1..1",
		"111."
	},
	["ы"] = {
		"....",
		"1..1",
		"1..1",
		"11.1",
		"11.1"
	},
	["ъ"] = {
		"....",
		"11..",
		".11.",
		".1.1",
		".11."
	},
	["э"] = {
		"....",
		"111.",
		"1111",
		"...1",
		"111."
	},
	["ю"] = {
		"....",
		"1.1.",
		"11.1",
		"11.1",
		"1.1."
	},
	["я"] = {
		"....",
		".111",
		"1..1",
		".111",
		"1..1"
	},





	------------------------
	["0"] = {
		".11.",
		"1..1",
		"1..1",
		"1..1",
		".11."
	},
	["1"] = {
		".11.",
		"111.",
		".11.",
		".11.",
		"1111"
	},
	["2"] = {
		"111.",
		"...1",
		".11.",
		"1...",
		".111"
	},
	["3"] = {
		"111.",
		"...1",
		"111.",
		"...1",
		"111."
	},
	["4"] = {
		"1..1",
		"1..1",
		"1111",
		"...1",
		"...1"
	},
	["5"] = {
		"1111",
		"1...",
		"111.",
		"...1",
		"111."
	},
	["6"] = {
		".11.",
		"1...",
		"111.",
		"1..1",
		".11."
	},
	["7"] = {
		"1111",
		"...1",
		".11.",
		".11.",
		".11."
	},
	["8"] = {
		".11.",
		"1..1",
		".11.",
		"1..1",
		".11."
	},
	["9"] = {
		".11.",
		"1..1",
		".111",
		"...1",
		".11."
	},
	["."] = {
		"....",
		"....",
		"....",
		"....",
		"1..."
	},
	[","] = {
		"....",
		"....",
		"....",
		"11..",
		"1..."
	},
	[":"] = {
		"....",
		"1...",
		"....",
		"1...",
		"...."
	},
	[";"] = {
		"....",
		"1...",
		"....",
		"11..",
		"1..."
	},
	["!"] = {
		"1...",
		"1...",
		"1...",
		"....",
		"1..."
	},
	["?"] = {
		"1...",
		".1..",
		"1...",
		"....",
		"1..."
	},
	["'"] = {
		"..1.",
		"..1.",
		"....",
		"....",
		"...."
	},
	['"'] = {
		"1.1.",
		"1.1.",
		"....",
		"....",
		"...."
	},
	["("] = {
		"...1",
		"..1.",
		"..1.",
		"..1.",
		"...1"
	},
	[")"] = {
		"1...",
		".1..",
		".1..",
		".1..",
		"1..."
	},
	["["] = {
		"..11",
		"..1.",
		"..1.",
		"..1.",
		"..11"
	},
	["]"] = {
		"11..",
		".1..",
		".1..",
		".1..",
		"11.."
	},
	["{"] = {
		"...1",
		"..1.",
		".11.",
		"..1.",
		"...1"
	},
	["}"] = {
		"1...",
		".1..",
		".11.",
		".1..",
		"1..."
	},
	["<"] = {
		"...1",
		"..1.",
		".1..",
		"..1.",
		"...1"
	},
	[">"] = {
		"1...",
		".1..",
		"..1.",
		".1..",
		"1..."
	},
	["/"] = {
		"...1",
		"..1.",
		"..1.",
		".1..",
		"1..."
	},
	["\\"] = {
		"1...",
		".1..",
		".1..",
		"..1.",
		"...1"
	},
	["@"] = {
		".111",
		"11.1",
		"1.11",
		"1...",
		".111"
	},
	["#"] = {
		"1..1",
		"1111",
		"1..1",
		"1111",
		"1..1"
	},
	["$"] = {
		".111",
		"1.1.",
		".11.",
		".1.1",
		"111."
	},
	["%"] = {
		"1..1",
		"..1.",
		"..1.",
		".1..",
		"1..1"
	},
	["^"] = {
		".1..",
		"1.1.",
		"....",
		"....",
		"...."
	},
	["&"] = {
		".11.",
		"1..1",
		".1..",
		"1.11",
		".111"
	},
	["*"] = {
		"1..1",
		".11.",
		"1..1",
		"....",
		"...."
	},
	["+"] = {
		"....",
		".11.",
		"1111",
		".11.",
		"...."
	},
	["-"] = {
		"....",
		"....",
		"1111",
		"....",
		"...."
	},
	["_"] = {
		"....",
		"....",
		"....",
		"....",
		"1111"
	},
	["="] = {
		"....",
		"1111",
		"....",
		"1111",
		"...."
	},
	["`"] = {
		"1...",
		".1..",
		"....",
		"....",
		"...."
	},
	["~"] = {
		"....",
		"1.1.",
		".1.1",
		"....",
		"...."
	},
	["№"] = {
		"...1",
		"1...",
		"11.1",
		"1.11",
		"1..1"
	},
}

font.fonts.lgc_5x4.chars.error = {
	"1111",
	"1..1",
	"1..1",
	"1..1",
	"1111"
}

font.fonts.lgc_5x4.index = font.fontIndex
font.fonts[font.fontIndex] = font.fonts.lgc_5x4
font.fontIndex = font.fontIndex + 1
end
function scmframework_fb363b923c666de167e84b957d116cf5() --$CONTENT_DATA/Scripts/canvasAPI/fonts/manual/lgc_5x5.lua
font.fonts.lgc_5x5 = {}
font.fonts.lgc_5x5.width = 5
font.fonts.lgc_5x5.height = 5

font.fonts.lgc_5x5.chars = {
	["A"] = {
		".111.",
		"1...1",
		"11111",
		"1...1",
		"1...1"
	},
	["B"] = {
		"1111.",
		"1...1",
		"1111.",
		"1...1",
		"1111."
	},
	["C"] = {
		".111.",
		"1...1",
		"1....",
		"1...1",
		".111."
	},
	["D"] = {
		"1111.",
		"1...1",
		"1...1",
		"1...1",
		"1111."
	},
	["E"] = {
		"11111",
		"1....",
		"1111.",
		"1....",
		"11111"
	},
	["F"] = {
		"11111",
		"1....",
		"1111.",
		"1....",
		"1...."
	},
	["G"] = {
		".1111",
		"1....",
		"1..11",
		"1...1",
		".111."
	},
	["H"] = {
		"1...1",
		"1...1",
		"11111",
		"1...1",
		"1...1"
	},
	["I"] = {
		"11111",
		"..1..",
		"..1..",
		"..1..",
		"11111"
	},
	["J"] = {
		"11111",
		"..1..",
		"..1..",
		".11..",
		"11..."
	},
	["K"] = {
		"1...1",
		"1..1.",
		"111..",
		"1..1.",
		"1...1"
	},
	["L"] = {
		"1....",
		"1....",
		"1....",
		"1....",
		"11111"
	},
	["M"] = {
		"1...1",
		"11.11",
		"1.1.1",
		"1...1",
		"1...1"
	},
	["N"] = {
		"1...1",
		"11..1",
		"1.1.1",
		"1..11",
		"1...1"
	},
	["O"] = {
		".111.",
		"1...1",
		"1...1",
		"1...1",
		".111."
	},
	["P"] = {
		"1111.",
		"1...1",
		"1111.",
		"1....",
		"1...."
	},
	["Q"] = {
		".111.",
		"1...1",
		"1...1",
		"1..1.",
		".11.1"
	},
	["R"] = {
		"1111.",
		"1...1",
		"1111.",
		"1...1",
		"1...1"
	},
	["S"] = {
		".1111",
		"1....",
		".111.",
		"....1",
		"1111."
	},
	["T"] = {
		"11111",
		"..1..",
		"..1..",
		"..1..",
		"..1.."
	},
	["U"] = {
		"1...1",
		"1...1",
		"1...1",
		"1...1",
		".111."
	},
	["V"] = {
		"1...1",
		"1...1",
		"1...1",
		".1.1.",
		"..1.."
	},
	["W"] = {
		"1...1",
		"1...1",
		"1.1.1",
		"11.11",
		"1...1"
	},
	["X"] = {
		"1...1",
		".1.1.",
		"..1..",
		".1.1.",
		"1...1"
	},
	["Y"] = {
		"1...1",
		"1...1",
		".1.1.",
		"..1..",
		"..1.."
	},
	["Z"] = {
		"11111",
		"....1",
		".111.",
		"1....",
		"11111"
	},

	----------small english fonts
	["a"] = {
		".....",
		".111.",
		"...11",
		"11111",
		".1111"
	},
	["b"] = {
		".....",
		"1....",
		"1111.",
		"1...1",
		"1111."
	},
	["c"] = {
		".....",
		".1111",
		"1....",
		"1....",
		".1111"
	},
	["d"] = {
		".....",
		"....1",
		".1111",
		"1...1",
		".1111"
	},
	["e"] = {
		".....",
		"11111",
		"1111.",
		"1....",
		"11111"
	},
	["f"] = {
		".....",
		"11111",
		"1....",
		"1111.",
		"1...."
	},
	["g"] = {
		".....",
		".1111",
		"1....",
		"1...1",
		".111."
	},
	["h"] = {
		".....",
		"1....",
		"11111",
		"1...1",
		"1...1"
	},
	["i"] = {
		".....",
		"..1..",
		".....",
		"..1..",
		"..1.."
	},
	["j"] = {
		".....",
		"..1..",
		"..1..",
		"..1..",
		"11..."
	},
	["k"] = {
		".....",
		"1....",
		"1..1.",
		"111..",
		"1..1."
	},
	["l"] = {
		".....",
		"1....",
		"1....",
		"1....",
		"11111"
	},
	["m"] = {
		".....",
		"1...1",
		"11.11",
		"1.1.1",
		"1...1"
	},
	["n"] = {
		".....",
		"1111.",
		"1...1",
		"1...1",
		"1...1"
	},
	["o"] = {
		".....",
		".111.",
		"1...1",
		"1...1",
		".111."
	},
	["p"] = {
		".....",
		"1111.",
		"1...1",
		"1111.",
		"1...."
	},
	["q"] = {
		".....",
		".111.",
		"1...1",
		".1111",
		"....1"
	},
	["r"] = {
		".....",
		"11..1",
		"1.11.",
		"1....",
		"1...."
	},
	["s"] = {
		".....",
		"..111",
		".11..",
		"..11.",
		"111.."
	},
	["t"] = {
		".....",
		"11111",
		"..1..",
		"..1..",
		"..1.."
	},
	["u"] = {
		".....",
		"1...1",
		"1...1",
		"1...1",
		".111."
	},
	["v"] = {
		".....",
		"1...1",
		"1...1",
		".1.1.",
		"..1.."
	},
	["w"] = {
		".....",
		"1...1",
		"1.1.1",
		"11.11",
		"1...1"
	},
	["x"] = {
		".....",
		"1...1",
		".111.",
		".111.",
		"1...1"
	},
	["y"] = {
		".....",
		"1...1",
		".1111",
		"....1",
		".111."
	},
	["z"] = {
		".....",
		"11111",
		"...1.",
		"..1..",
		"11111"
	},





	----------big russian fonts
	["А"] = {
		".111.",
		"1...1",
		"11111",
		"1...1",
		"1...1"
	},
	["Б"] = {
		"11111",
		"1....",
		"1111.",
		"1...1",
		"1111."
	},
	["В"] = {
		"1111.",
		"1...1",
		"1111.",
		"1...1",
		"1111."
	},
	["Г"] = {
		"11111",
		"1....",
		"1....",
		"1....",
		"1...."
	},
	["Д"] = {
		".111.",
		"1...1",
		"1...1",
		".111.",
		"1...1"
	},
	["Е"] = {
		"11111",
		"1....",
		"11111",
		"1....",
		"11111"
	},
	["Ё"] = {
		"111.1",
		"1....",
		"11111",
		"1....",
		"11111"
	},
	["Ж"] = {
		"1...1",
		".111.",
		"11111",
		".111.",
		"1...1"
	},
	["З"] = {
		"1111.",
		"....1",
		".111.",
		"....1",
		"1111."
	},
	["И"] = {
		"1...1",
		"1..11",
		"1.1.1",
		"11..1",
		"1...1"
	},
	["Й"] = {
		"1..11",
		"1...1",
		"1.111",
		"11..1",
		"1...1"
	},
	["К"] = {
		"1...1",
		"1..1.",
		"111..",
		"1..1.",
		"1...1"
	},
	["Л"] = {
		"..111",
		".1..1",
		"1...1",
		"1...1",
		"1...1"
	},
	["М"] = {
		"1...1",
		"11.11",
		"1.1.1",
		"1...1",
		"1...1"
	},
	["Н"] = {
		"1...1",
		"1...1",
		"11111",
		"1...1",
		"1...1"
	},
	["О"] = {
		".111.",
		"1...1",
		"1...1",
		"1...1",
		".111."
	},
	["П"] = {
		"11111",
		"1...1",
		"1...1",
		"1...1",
		"1...1"
	},
	["Р"] = {
		"1111.",
		"1...1",
		"1111.",
		"1....",
		"1...."
	},
	["С"] = {
		".1111",
		"1....",
		"1....",
		"1....",
		".1111"
	},
	["Т"] = {
		"11111",
		"..1..",
		"..1..",
		"..1..",
		"..1.."
	},
	["У"] = {
		"1...1",
		".1..1",
		"..11.",
		"..1..",
		".1..."
	},
	["Ф"] = {
		".111.",
		"1.1.1",
		"1.1.1",
		".111.",
		"..1.."
	},
	["Х"] = {
		"1...1",
		".1.1.",
		"..1..",
		".1.1.",
		"1...1"
	},
	["Ц"] = {
		"1..1.",
		"1..1.",
		"1..1.",
		"11111",
		"....1"
	},
	["Ч"] = {
		"1...1",
		"1...1",
		"11111",
		"....1",
		"....1"
	},
	["Ш"] = {
		"1.1.1",
		"1.1.1",
		"1.1.1",
		"1.1.1",
		"11111"
	},
	["Щ"] = {
		"1.1.1",
		"1.1.1",
		"1.1.1",
		"11111",
		"....1"
	},
	["Ь"] = {
		"1....",
		"1....",
		"1111.",
		"1...1",
		"1111."
	},
	["Ы"] = {
		"1...1",
		"1...1",
		"11..1",
		"1.1.1",
		"11..1"
	},
	["Ъ"] = {
		"11...",
		".1...",
		".111.",
		".1..1",
		".111."
	},
	["Э"] = {
		"1111.",
		"....1",
		"11111",
		"....1",
		"1111."
	},
	["Ю"] = {
		"1..1.",
		"1.1.1",
		"111.1",
		"1.1.1",
		"1..1."
	},
	["Я"] = {
		".1111",
		"1...1",
		"11111",
		".1..1",
		"1...1"
	},

	----------------small russian font
	["а"] = {
		".....",
		".111.",
		"....1",
		"11111",
		".1111"
	},
	["б"] = {
		".....",
		".111.",
		"1....",
		"11111",
		".111."
	},
	["в"] = {
		".....",
		"111..",
		"11.1.",
		"1.11.",
		"111.."
	},
	["г"] = {
		".....",
		"11111",
		"1....",
		"1....",
		"1...."
	},
	["д"] = {
		".....",
		".111.",
		"1...1",
		".111.",
		"1...1"
	},
	["е"] = {
		".....",
		"11111",
		"1111.",
		"1....",
		"11111"
	},
	["ё"] = {
		".1.1.",
		"11111",
		"1111.",
		"1....",
		"11111"
	},
	["ж"] = {
		".....",
		"1...1",
		".11.1",
		"1..1.",
		"1...1"
	},
	["з"] = {
		".....",
		"11111",
		".111.",
		"....1",
		"1111."
	},
	["и"] = {
		".....",
		"1...1",
		"1.111",
		"111.1",
		"1...1"
	},
	["й"] = {
		"...1.",
		"1...1",
		"1.111",
		"111.1",
		"1...1"
	},
	["к"] = {
		".....",
		"1...1",
		"1..1.",
		"111..",
		"1..1."
	},
	["л"] = {
		".....",
		"..111",
		".1..1",
		"1...1",
		"1...1"
	},
	["м"] = {
		".....",
		"1...1",
		"11.11",
		"1.1.1",
		"1...1"
	},
	["н"] = {
		".....",
		"1...1",
		"1...1",
		"11111",
		"1...1"
	},
	["о"] = {
		".....",
		".111.",
		"1...1",
		"1...1",
		".111."
	},
	["п"] = {
		".....",
		"11111",
		"1...1",
		"1...1",
		"1...1"
	},
	["р"] = {
		".....",
		"1111.",
		"1...1",
		"1111.",
		"1...."
	},
	["с"] = {
		".....",
		".1111",
		"1....",
		"1....",
		".1111"
	},
	["т"] = {
		".....",
		"11111",
		"..1..",
		"..1..",
		"..1.."
	},
	["у"] = {
		".....",
		"1...1",
		".1..1",
		"..11.",
		".1..."
	},
	["ф"] = {
		".....",
		".111.",
		"1.1.1",
		".111.",
		"..1.."
	},
	["х"] = {
		".....",
		"1...1",
		".111.",
		".111.",
		"1...1"
	},
	["ц"] = {
		".....",
		"1..1.",
		"1..1.",
		"11111",
		"....1"
	},
	["ч"] = {
		".....",
		"1...1",
		"11111",
		"....1",
		"....1"
	},
	["ш"] = {
		".....",
		"1.1.1",
		"1.1.1",
		"1.1.1",
		"11111"
	},
	["щ"] = {
		".....",
		"1.1.1",
		"1.1.1",
		"11111",
		"....1"
	},
	["ь"] = {
		".....",
		"1....",
		"1111.",
		"1...1",
		"1111."
	},
	["ы"] = {
		".....",
		"1...1",
		"11..1",
		"1.1.1",
		"11..1"
	},
	["ъ"] = {
		".....",
		"111..",
		"..11.",
		"..1.1",
		"..11."
	},
	["э"] = {
		".....",
		"1111.",
		"11111",
		"....1",
		"1111."
	},
	["ю"] = {
		".....",
		"1..1.",
		"111.1",
		"111.1",
		"1..1."
	},
	["я"] = {
		".....",
		".1111",
		"1...1",
		".1111",
		"1...1"
	},





	------------------------
	["0"] = {
		".111.",
		"1...1",
		"1...1",
		"1...1",
		".111."
	},
	["1"] = {
		"..1..",
		"111..",
		"..1..",
		"..1..",
		"11111"
	},
	["2"] = {
		"1111.",
		"....1",
		".111.",
		"1....",
		".1111"
	},
	["3"] = {
		"1111.",
		"....1",
		"1111.",
		"....1",
		"1111."
	},
	["4"] = {
		"1...1",
		"1...1",
		"11111",
		"....1",
		"....1"
	},
	["5"] = {
		"11111",
		"1....",
		"1111.",
		"....1",
		"1111."
	},
	["6"] = {
		".111.",
		"1....",
		"1111.",
		"1...1",
		".111."
	},
	["7"] = {
		"11111",
		"....1",
		"...1.",
		"..1..",
		"..1.."
	},
	["8"] = {
		".111.",
		"1...1",
		".111.",
		"1...1",
		".111."
	},
	["9"] = {
		".111.",
		"1...1",
		".1111",
		"....1",
		".111."
	},
	["."] = {
		".....",
		".....",
		".....",
		".....",
		"1...."
	},
	[","] = {
		".....",
		".....",
		".....",
		"11...",
		"1...."
	},
	[":"] = {
		".....",
		"1....",
		".....",
		"1....",
		"....."
	},
	[";"] = {
		".....",
		"1....",
		".....",
		"11...",
		"1...."
	},
	["!"] = {
		"1....",
		"1....",
		"1....",
		".....",
		"1...."
	},
	["?"] = {
		"1....",
		".1...",
		"1....",
		".....",
		"1...."
	},
	["'"] = {
		"..1..",
		"..1..",
		".....",
		".....",
		"....."
	},
	['"'] = {
		".1.1.",
		".1.1.",
		".....",
		".....",
		"....."
	},
	["("] = {
		"....1",
		"...1.",
		"...1.",
		"...1.",
		"....1"
	},
	[")"] = {
		"1....",
		".1...",
		".1...",
		".1...",
		"1...."
	},
	["["] = {
		"...11",
		"...1.",
		"...1.",
		"...1.",
		"...11"
	},
	["]"] = {
		"11...",
		".1...",
		".1...",
		".1...",
		"11..."
	},
	["{"] = {
		"....1",
		"...1.",
		"..11.",
		"...1.",
		"....1"
	},
	["}"] = {
		"1....",
		".1...",
		".11..",
		".1...",
		"1...."
	},
	["<"] = {
		"....1",
		"...1.",
		"..1..",
		"...1.",
		"....1"
	},
	[">"] = {
		"1....",
		".1...",
		"..1..",
		".1...",
		"1...."
	},
	["/"] = {
		"....1",
		"...1.",
		"..1..",
		".1...",
		"1...."
	},
	["\\"] = {
		"1....",
		".1...",
		"..1..",
		"...1.",
		"....1"
	},
	["@"] = {
		".1111",
		"11..1",
		"1.111",
		"1....",
		".1111"
	},
	["#"] = {
		"1.1.1",
		"11111",
		"1.1.1",
		"11111",
		"1.1.1"
	},
	["$"] = {
		".1111",
		"1..1.",
		".111.",
		".1..1",
		"1111."
	},
	["%"] = {
		"1...1",
		"...1.",
		"..1..",
		".1...",
		"1...1"
	},
	["^"] = {
		"..1..",
		".1.1.",
		".....",
		".....",
		"....."
	},
	["&"] = {
		".111.",
		"1...1",
		".11..",
		"1..11",
		".1111"
	},
	["*"] = {
		".1.1.",
		"..1..",
		".1.1.",
		".....",
		"....."
	},
	["+"] = {
		"..1..",
		"..1..",
		"11111",
		"..1..",
		"..1.."
	},
	["-"] = {
		".....",
		".....",
		"11111",
		".....",
		"....."
	},
	["_"] = {
		".....",
		".....",
		".....",
		".....",
		"11111"
	},
	["="] = {
		".....",
		"11111",
		".....",
		"11111",
		"....."
	},
	["`"] = {
		"1....",
		".1...",
		".....",
		".....",
		"....."
	},
	["~"] = {
		".....",
		"1..1.",
		".11.1",
		".....",
		"....."
	},
	["№"] = {
		"....1",
		"11...",
		"1.1.1",
		"1..11",
		"1...1"
	},
}

font.fonts.lgc_5x5.chars.error = {
	"11111",
	"1...1",
	"1...1",
	"1...1",
	"11111"
}

font.fonts.lgc_5x5.index = font.fontIndex
font.fonts[font.fontIndex] = font.fonts.lgc_5x5
font.fontIndex = font.fontIndex + 1
end
function scmframework_ef0361f4b6004ce40c4b1b7508b8d34e() --$CONTENT_DATA/Scripts/canvasAPI/fonts/manual_fonts.lua
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/manual/lgc_5x4.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/manual/lgc_5x5.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/fonts/manual/lgc_3x3.lua")
end
function scmframework_f6eb570ddd061da42b4136e5997d7298() --$CONTENT_DATA/Scripts/canvasAPI/luajit.lua
local function benchmart()
    local a = 0
    local upv = 3

    local function ab(i)
        return i + upv
    end

    for i = 1, 10 do
        local clk = os.clock()
        for i = 1, 10000000 do
            a = a + i + upv
        end
        print("a", os.clock() - clk)

        local clk = os.clock()
        for i = 1, 10000000 do
            a = a + ab(i)
        end
        print("f", os.clock() - clk)
    end

    print(a)
end

print("> luajit benchmart")
benchmart()
if better and better.isAvailable() then
    better.fast()
    print("> luajit benchmart after better.fast")
    benchmart()
end
end
function scmframework_e5718b31c85372a492b2c60c718596f8() --$CONTENT_DATA/Scripts/canvasAPI/test/test1.lua
dofile("$CONTENT_DATA/Scripts/canvasAPI/canvas.lua")
test1 = class()

local function color(...)
    return canvasAPI.formatColorToSmallNumber(sm.color.new(...))
end

function test1:client_onCreate()
    self.canvas = canvasAPI.createCanvas(self.interactable, 64, 64)
    self.canvas.setRenderDistance(64)
    self.rotation = 0
end

function test1:client_onFixedUpdate()
	self.canvas.update()
	
    --------------------------------------- motion

    self.canvas.setOffset(sm.vec3.new(0, 2.5 + (math.sin(math.rad(sm.game.getCurrentTick())) / 8), 0))
    self.canvas.setCanvasRotation(sm.vec3.new(0, self.rotation, 0))
    self.rotation = self.rotation + 0.25
    if not self.canvas.isRendering() then return end

    --------------------------------------- random fill

    local stack = {}
    for i = 1, 64 do
		canvasAPI.pushData(stack, canvasAPI.draw.fill, math.random(0, self.canvas.sizeX - 1), math.random(0, self.canvas.sizeY - 1), math.random(0, 16), math.random(0, 16), color(math.random() / 3, math.random() / 3, 0))
    end

	canvasAPI.pushData(stack, canvasAPI.draw.rect, 0, 0, self.canvas.sizeX, self.canvas.sizeY, color(1, 1, 1), 1)
	canvasAPI.pushData(stack, canvasAPI.draw.set, 0, 0, color(0, 1, 0))
	canvasAPI.pushData(stack, canvasAPI.draw.set, self.canvas.sizeX - 1, 0, color(1, 0, 0))
	canvasAPI.pushData(stack, canvasAPI.draw.set, self.canvas.sizeX - 1, self.canvas.sizeY - 1, color(1, 1, 0))
	canvasAPI.pushData(stack, canvasAPI.draw.set, 0, self.canvas.sizeY - 1, color(0, 0, 1))
	canvasAPI.pushData(stack, canvasAPI.draw.set, 0, 1, color(0, 1, 1))
	canvasAPI.pushData(stack, canvasAPI.draw.set, 1, 0, color(0, 1, 1))

    --------------------------------------- pushing

    self.canvas.pushStack(stack)
    self.canvas.flush()
end

function test1:client_onDestroy()
    self.canvas.destroy()
end
end
function scmframework_5c6f1289c3a713c41ee827374df3cef8() --$CONTENT_DATA/Scripts/canvasAPI/test/test2.lua
dofile("$CONTENT_DATA/Scripts/canvasAPI/canvas.lua")
test2 = class()
test2.displaySize = 1
test2.displayPosition = sm.vec3.new(0, 0.25, 0.25)
test2.displayRotation = sm.vec3.new(-32, 0, 0)

function test2:client_onCreate()
    self.display = canvasAPI.createClientScriptableCanvas(self.interactable, 64, 64, -test2.displaySize / 64, test2.displayPosition, test2.displayRotation)
	self.display.setOptimizationLevel(16)
	--self.display.setFont(canvasAPI.fonts.lgc_5x5)

    self.width = self.display.getWidth()
    self.height = self.display.getHeight()
    self.perlinSize = (1 / self.width) * 5
end

function test2:client_onFixedUpdate()
	self.display.update()

    self.pos = (self.pos or 0) + 1
    if self.display.getAudience() > 0 then
        --self.display.clear()
        local pos = math.floor(self.pos)
        for ix = 0, self.width - 1 do
            for iy = 0, self.height - 1 do
                self.display.drawPixel(ix, iy, sm.color.new(sm.noise.perlinNoise2d((ix + pos) * self.perlinSize, iy * self.perlinSize, 0), 0, 0))
            end
        end
		self.display.drawText(1, 1, "HELLO, WORLD!")
        self.display.flush()
    end
end

function test2:client_onDestroy()
    self.display.destroy()
end
end
function scmframework_1d083fda9809f2c6d9c76c2e69543fea() --$CONTENT_DATA/Scripts/canvasAPI/utf8.lua
local bit		= bit
local error		= error
local ipairs	= ipairs
local string	= string
local table		= table
local unpack	= unpack
local table_concat = table.concat
local string_sub = string.sub
local string_byte = string.byte
local bit_bor = bit.bor
local bit_band = bit.band
local string_char = string.char
local bit_rshift = bit.rshift
local bit_lshift = bit.lshift
local table_insert = table.insert

--
-- Pattern that can be used with the string library to match a single UTF-8 byte-sequence.
-- This expects the string to contain valid UTF-8 data.
--
--charpattern = "[%z\x01-\x7F\xC2-\xF4][\x80-\xBF]*"

--
-- Transforms indexes of a string to be positive.
-- Negative indices will wrap around like the string library's functions.
--
local function strRelToAbs( str, ... )
	local args = { ... }

	for k, v in ipairs( args ) do
		v = v > 0 and v or #str + v + 1

		if v < 1 or v > #str then
			error( "bad index to string (out of range)", 3 )
		end

		args[ k ] = v
	end

	return unpack(args)
end

-- Decodes a single UTF-8 byte-sequence from a string, ensuring it is valid
-- Returns the index of the first and last character of the sequence
--
local function decode( str, startPos )

	startPos = strRelToAbs( str, startPos or 1 )

	local b1 = string_byte(str, startPos, startPos )

	-- Single-byte sequence
	if b1 < 0x80 then
		return startPos, startPos
	end

	-- Validate first byte of multi-byte sequence
	if b1 > 0xF4 or b1 < 0xC2 then
		return
	end

	-- Get 'supposed' amount of continuation bytes from primary byte
	local contByteCount =	b1 >= 0xF0 and 3 or
							b1 >= 0xE0 and 2 or
							b1 >= 0xC0 and 1

	local endPos = startPos + contByteCount

	-- Validate our continuation bytes
	for _, bX in ipairs { string_byte(str, startPos + 1, endPos ) } do
		if bit_band( bX, 0xC0 ) ~= 0x80 then
			return
		end
	end

	return startPos, endPos 

end

--
-- Takes zero or more integers and returns a string containing the UTF-8 representation of each
--
local function char( ... )

	local bufn = 1
	local buf = {}
	local b1, b2, b3, b4 = nil, nil, nil, nil

	for k, v in ipairs { ... } do
		if v < 0 or v > 0x10FFFF then
			error( "bad argument #" .. k .. " to char (out of range)", 2 )
		end

		b1, b2, b3, b4 = nil, nil, nil, nil

		if v < 0x80 then -- Single-byte sequence
			buf[bufn] = string_char( v )
			bufn = bufn + 1
		elseif v < 0x800 then -- Two-byte sequence
			b1 = bit_bor( 0xC0, bit_band( bit_rshift( v, 6 ), 0x1F ) )
			b2 = bit_bor( 0x80, bit_band( v, 0x3F ) )

			buf[bufn] = string_char( b1, b2 )
			bufn = bufn + 1
		elseif v < 0x10000 then -- Three-byte sequence

			b1 = bit_bor( 0xE0, bit_band( bit_rshift( v, 12 ), 0x0F ) )
			b2 = bit_bor( 0x80, bit_band( bit_rshift( v, 6 ), 0x3F ) )
			b3 = bit_bor( 0x80, bit_band( v, 0x3F ) )

			buf[bufn] = string_char( b1, b2, b3 )
			bufn = bufn + 1
		else -- Four-byte sequence

			b1 = bit_bor( 0xF0, bit_band( bit_rshift( v, 18 ), 0x07 ) )
			b2 = bit_bor( 0x80, bit_band( bit_rshift( v, 12 ), 0x3F ) )
			b3 = bit_bor( 0x80, bit_band( bit_rshift( v, 6 ), 0x3F ) )
			b4 = bit_bor( 0x80, bit_band( v, 0x3F ) )

			buf[bufn] = string_char( b1, b2, b3, b4 )
			bufn = bufn + 1
		end
	end

	return table_concat(buf, "")
end

--
-- Iterates over a UTF-8 string similarly to pairs
-- k = index of sequence, v = string value of sequence
--
local function codes( str )
	local i = 1
	local startPos, endPos
	return function()
		-- Have we hit the end of the iteration set?
		if i > #str then
			return
		end

		startPos, endPos = decode( str, i )

		if not startPos then
			error( "invalid UTF-8 code", 2 )
		end

		i = endPos + 1

		return startPos, string_sub(str, startPos, endPos)
	end
end

--
-- Returns an integer-representation of the UTF-8 sequence(s) in a string
-- startPos defaults to 1, endPos defaults to startPos
--
local function codepoint( str, startPos, endPos )

	startPos, endPos = strRelToAbs( str, startPos or 1, endPos or startPos or 1 )

	local ret = {}
	local seqStartPos, seqEndPos
	local len, b1, cp, bX

	repeat
		seqStartPos, seqEndPos = decode( str, startPos )

		if not seqStartPos then
			error( "invalid UTF-8 code", 2 )
		end

		-- Increment current string index
		startPos = seqEndPos + 1

		-- Amount of bytes making up our sequence
		len = seqEndPos - seqStartPos + 1

		if len == 1 then -- Single-byte codepoint

			table_insert( ret, string_byte(str, seqStartPos))

		else -- Multi-byte codepoint

			b1 = string_byte(str, seqStartPos )
			cp = 0

			for i = seqStartPos + 1, seqEndPos do

				bX = string_byte(str, i )

				cp = bit_bor( bit_lshift( cp, 6 ), bit_band( bX, 0x3F ) )
				b1 = bit_lshift( b1, 1 )

			end

			cp = bit_bor( cp, bit_lshift( bit_band( b1, 0x7F ), ( len - 1 ) * 5 ) )

			table_insert( ret, cp )

		end
	until seqEndPos >= endPos

	return unpack( ret )

end

--
-- Returns the length of a UTF-8 string. false, index is returned if an invalid sequence is hit
-- startPos defaults to 1, endPos defaults to -1
--
local function len( str, startPos, endPos )
    if #str == 0 then return 0 end
	startPos, endPos = strRelToAbs( str, startPos or 1, endPos or -1 )

	local len, seqStartPos, seqEndPos = 0
	repeat
		seqStartPos, seqEndPos = decode( str, startPos )

		-- Hit an invalid sequence?
		if not seqStartPos then
			return false, startPos
		end

		-- Increment current string pointer
		startPos = seqEndPos + 1

		-- Increment length
		len = len + 1
	until seqEndPos >= endPos

	return len
end

--
-- Returns the byte-index of the n'th UTF-8-character after the given byte-index (nil if none)
-- startPos defaults to 1 when n is positive and -1 when n is negative
-- If 0 is zero, this function instead returns the byte-index of the UTF-8-character startPos lies within.
--
local function offset( str, n, startPos )

	startPos = strRelToAbs( str, startPos or ( n >= 0 and 1 ) or #str )

	-- Find the beginning of the sequence over startPos
	if n == 0 then
		local seqStartPos, seqEndPos
		for i = startPos, 1, -1 do
			seqStartPos, seqEndPos = decode( str, i )

			if seqStartPos then
				return seqStartPos
			end
		end
		return
	end

	if not decode( str, startPos ) then
		error( "initial position is not beginning of a valid sequence", 2 )
	end

	local itStart, itEnd, itStep = nil, nil, nil

	if n > 0 then -- Find the beginning of the n'th sequence forwards
		itStart = startPos
		itEnd = #str
		itStep = 1
	else -- Find the beginning of the n'th sequence backwards
		n = -n
		itStart = startPos
		itEnd = 1
		itStep = -1
	end

	local seqStartPos
	for i = itStart, itEnd, itStep do
		seqStartPos = decode( str, i )

		if seqStartPos then
			n = n - 1

			if n == 0 then
				return seqStartPos
			end
		end
	end
end

--
-- Forces a string to contain only valid UTF-8 data.
-- Invalid sequences are replaced with U+FFFD.
--
local function force( str )
	local bufn = 1
	local buf = {}

	local curPos, endPos = 1, #str

	local seqStartPos, seqEndPos
	repeat
		seqStartPos, seqEndPos = decode( str, curPos )

		if seqStartPos then
			buf[bufn] = string_sub(str, seqStartPos, seqEndPos )
			bufn = bufn + 1

			curPos = seqEndPos + 1
		else
			buf[bufn] = char( 0xFFFD )
			bufn = bufn + 1
			
			curPos = curPos + 1
		end
	until curPos > endPos

	return table_concat( buf, "" )
end






-----------------------------------------------

utf8 = {}
utf8.force = force
utf8.offset = offset
utf8.len = len
utf8.codepoint = codepoint
utf8.codes = codes
utf8.char = char

function utf8.sub(text, i, j)
	local charsn = 1
    local chars = {}
    for _, code in codes(text) do
        chars[charsn] = code
		charsn = charsn + 1
    end

    return table_concat({unpack(chars, i, j)})
end

function utf8.code(str, i)
	local charsn = 1
	for _, code in codes(str) do
		if charsn == i then
			return code
		end
		charsn = charsn + 1
    end
end
end
function scmframework_167caeea799e72edb9da8c84637b5148() --$CONTENT_DATA/Scripts/chaff.lua
chaff = class()
chaff.maxParentCount = 1
chaff.maxChildCount = 0
chaff.connectionInput = sm.interactable.connectionType.composite + sm.interactable.connectionType.logic
chaff.connectionOutput = sm.interactable.connectionType.none
chaff.colorNormal = sm.color.new(0x7F7F7Fff)
chaff.colorHighlight = sm.color.new(0xFFFFFFff)
chaff.componentType = "chaff" --absences can cause problems
chaff.maxCharges = 5 * (40 / 4)

function chaff:server_onCreate()
    self:sv_reload()

    self.interactable.publicData = {
        sc_component = {
            type = chaff.componentType,
            api = {
                isAvailable = function()
                    return self:sv_isAvailable()
                end,
                push = function()
                    return self:sv_push()
                end,
                shot = function()
                    return self:sv_shot()
                end,
                maxCharges = function()
                    return chaff.maxCharges
                end,
                getCharges = function()
                    return self.charges
                end
            }
        }
    }
end

function chaff:server_onFixedUpdate()
    local onLift = self.shape.body:isOnLift()
    if onLift and not self.onLift then
        self:sv_reload()
    end
    self.onLift = onLift

    if not scomputers.realIsComputerConnected(self.interactable) then
        local parent = self.interactable:getSingleParent()
        if parent and parent:isActive() then
            self:sv_push()
        end
    end

    if self.pushTimer then
        if self.pushTimer % 4 == 0 then
            if not self:sv_shot() then
                self.pushTimer = nil
            end
        end
        if self.pushTimer then
            self.pushTimer = self.pushTimer + 1
        end
    end

    if self.shotFlag then
        local body = self:sv_getBodyForChraff()
        if body then
            scomputers.addChaffObject(self.shape.worldPosition, body.id, body.mass)
        else
            scomputers.addChaffObject(self.shape.worldPosition, math.random(1, 99999), (math.random() * (15000 - 50)) + 50)
        end
        self.network:sendToClients("cl_n_addChaffObject", self.shape.worldPosition)
        
        self.shotFlag = nil
    end
end

function chaff:sv_getBodyForChraff()
    local ctick = sm.game.getCurrentTick()
    if self.bodyCounter_updateTime and ctick - self.bodyCounter_updateTime > 160 then
        self.bodyCounter = 0
    end
    self.bodyCounter = (self.bodyCounter or 0) + 1
    self.bodyCounter_updateTime = ctick
    return self.shape.body:getCreationBodies()[self.bodyCounter] --after it exceeds the number of bodies in the creation, there will be nil, which will lead to the generation of new random bodies
end

function chaff:sv_isAvailable()
    return self.isAvailable and self.charges > 0
end

function chaff:sv_reload()
    self.isAvailable = true
    self.charges = chaff.maxCharges
end

function chaff:sv_push()
    if not self.isAvailable then
        return false
    end
    self.pushTimer = 0
    self.isAvailable = false
    return true
end

function chaff:sv_shot()
    if self.charges <= 0 then
        return false
    end
    self.charges = self.charges - 1
    self.shotFlag = true
    return true
end

function chaff:cl_n_addChaffObject(position)
    scomputers.addChaffObject(position)
end
end
function scmframework_dd62d679ca9366cd1fa2c776f164718b() --$CONTENT_DATA/Scripts/chaff_task.lua
sc.background.chaff = sc.background.chaff or {}

local uuid = sm.uuid.new("24986ff2-3735-42d5-b3ba-f8c60c3b70bb")
local color = sm.color.new(1, 0, 0)
local checkFromHeight = 1000
local addSizeSpeed = 5 / 40

local function doChaffObjects(chaff_objects, clientSide)
    for i = #chaff_objects, 1, -1 do
        local chaffObject = chaff_objects[i]
        
        if sm.physics.raycast(sm.vec3.new(0, 0, checkFromHeight), chaffObject.position + sm.vec3.new(0, 0, sc.chaff_visible_size + 4), nil, sm.physics.filter.terrainSurface) then
            table.remove(chaff_objects, i)

            if chaffObject.effect then
                chaffObject.effect:destroy()
            end
        elseif clientSide then
            if not chaffObject.effect then
                chaffObject.radius = 0.1

                chaffObject.rotation = sm.vec3.new(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)))
                chaffObject.rotationSpeed = sm.vec3.new(
                    math.rad(math.random(-360, 360)) / 40,
                    math.rad(math.random(-360, 360)) / 40,
                    math.rad(math.random(-360, 360)) / 40
                )
                
                chaffObject.effect = sm.effect.createEffect("ShapeRenderable")
                chaffObject.effect:setParameter("uuid", uuid)
                chaffObject.effect:setParameter("color", color)
                chaffObject.effect:setPosition(chaffObject.position)
                chaffObject.effect:start()
            end
            
            chaffObject.effect:setPosition(chaffObject.position)
            chaffObject.effect:setRotation(sm.quat.fromEuler(chaffObject.rotation))
            chaffObject.effect:setScale(sm.vec3.new(chaffObject.radius, chaffObject.radius, chaffObject.radius))

            chaffObject.rotation = chaffObject.rotation + chaffObject.rotationSpeed
            chaffObject.radius = chaffObject.radius + addSizeSpeed
            if chaffObject.radius > sc.chaff_visible_size then
                chaffObject.radius = sc.chaff_visible_size
            end
        end

        chaffObject.position = chaffObject.position + chaffObject.move
    end
end

function sc.background.chaff:server()
    doChaffObjects(sc.sv_chaff_objects)
end

function sc.background.chaff:client()
    doChaffObjects(sc.cl_chaff_objects, true)
end
end
function scmframework_e0de4a6d12c9d689fa5cc8f5cd7b8c8b() --$CONTENT_DATA/Scripts/CompositeReader.lua
dofile "$CONTENT_DATA/Scripts/Config.lua"

CompositeReader = class(nil)

CompositeReader.maxParentCount = 1
CompositeReader.maxChildCount = -1
CompositeReader.connectionInput = sm.interactable.connectionType.composite
CompositeReader.connectionOutput = sm.interactable.connectionType.logic + sm.interactable.connectionType.power
CompositeReader.colorNormal = sm.color.new(0x940e0eff)
CompositeReader.colorHighlight = sm.color.new(0xd21414ff)

CompositeReader.UV_NON_ACTIVE = 2
CompositeReader.UV_ACTIVE_OFFSET = 6

--SERVER --
function CompositeReader.server_onCreate(self)
	local data = self.storage:load()
	if data ~= nil then
		self.register = data.register
	else
		self.register = ""
	end
    sc.readersRefs[self.interactable:getId()] = self
end

function CompositeReader:server_onDestroy()
    sc.readersRefs[self.interactable:getId()] = nil
end

function CompositeReader.server_onFixedUpdate(self, dt)
	self:sv_update()
end

function CompositeReader:sv_update()
	local parent = self.interactable:getSingleParent()
	if parent ~= nil then
		local data = sc.computersDatas[parent:getId()].public
		if data ~= nil then
			local value = data.registers[self.register]
			if value ~= nil then
				if value == true then
					value = 1
				elseif value == false then
					value = 0
				end
				self.interactable:setActive(value ~= 0)
				self.interactable:setPower(value)
			else
				self.interactable:setActive(false)
				self.interactable:setPower(0)
			end
		else
			self.interactable:setActive(false)
			self.interactable:setPower(0)
		end
	else
		self.interactable:setActive(false)
		self.interactable:setPower(0)
	end
end

function CompositeReader.server_updateRegister(self, reg)
	if #reg > 64 then return end
	self.storage:save({
		register = reg
	})
	self.register = reg
	self.network:sendToClients("client_updateRegister", self.register)
end

function CompositeReader.server_onRequiredRegister(self, data, client)
	self.network:sendToClient(client, "client_updateRegister", self.register)
end

-- CLIENT --

function CompositeReader.client_onFixedUpdate(self, dt)
	if self.interactable:isActive() then
		self.interactable:setUvFrameIndex(CompositeReader.UV_NON_ACTIVE + CompositeReader.UV_ACTIVE_OFFSET)
	else
		self.interactable:setUvFrameIndex(CompositeReader.UV_NON_ACTIVE)
	end
end

function CompositeReader.client_onCreate(self)
	self.network:sendToServer("server_onRequiredRegister")
	self.last_reg = ""
	self.saved_reg = ""
end

function CompositeReader.client_onInteract(self, char, state)
	if state then
		if self.gui == nil then
			self:client_createGUI()
		end
		self.last_reg = self.saved_reg
		self.gui:setText("RegisterName", formatBeforeGui(self.saved_reg))
		self.gui:open()
	end
end

function CompositeReader.client_updateRegister(self, reg)
	if self.gui == nil then
		self:client_createGUI()
	end
	self.saved_reg = reg
	self.last_reg = reg
end

function CompositeReader.client_createGUI(self)
	self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/CompositeReader.layout", false)
	self.gui:setTextChangedCallback("RegisterName", "client_onRegisterNameChanged")
	self.gui:setButtonCallback("Save", "client_onSaveRegister")
end

function CompositeReader.client_onRegisterNameChanged(self, widget, data)
	self.last_reg = formatAfterGui(data)
end

function CompositeReader.client_onSaveRegister(self)
	self.saved_reg = self.last_reg
	self.network:sendToServer("server_updateRegister", self.saved_reg)
	self.gui:close()
end

function CompositeReader.client_onDestroy(self)
	if self.gui ~= nil then
		self.gui:destroy()
	end
end
end
function scmframework_3833a261421e6ea1bc27750870df29e8() --$CONTENT_DATA/Scripts/CompositeWriter.lua
dofile "$CONTENT_DATA/Scripts/Config.lua"

CompositeWriter = class(nil)

CompositeWriter.maxParentCount = 1
CompositeWriter.maxChildCount = -1
CompositeWriter.connectionInput = sm.interactable.connectionType.logic + sm.interactable.connectionType.power
CompositeWriter.connectionOutput = sm.interactable.connectionType.composite
CompositeWriter.colorNormal = sm.color.new(0x160f94ff)
CompositeWriter.colorHighlight = sm.color.new(0x271beaff)

CompositeWriter.UV_NON_ACTIVE = 1
CompositeWriter.UV_ACTIVE_OFFSET = 6


--SERVER --
function CompositeWriter.server_onCreate(self)
	local data = self.storage:load()
	if data ~= nil then
		self.register = data.register
	else
		self.register = ""
	end
	sc.writersRefs[self.interactable:getId()] = self
end

function CompositeWriter.server_onDestroy(self)
	sc.writersRefs[self.interactable:getId()] = nil
end

-- invoked by computer
function CompositeWriter.server_updateComputerRegisterValue(self)
	local parent = self.interactable:getSingleParent()

	for k, child in pairs(self.interactable:getChildren()) do
		local data = sc.computersDatas[child:getId()]
		if data and data.public and self.register ~= "" then
			local regs = data.public.registers
			if parent then
				regs[self.register] = parent:getPower()
			else
				regs[self.register] = 0
			end
		end
	end
end

function CompositeWriter.server_onFixedUpdate(self, dt)
	self:server_updateComputerRegisterValue()
end

function CompositeWriter.server_updateRegister(self, reg)
	if #reg > 64 then return end
	self.storage:save({
		register = reg
	})
	self.register = reg
	self.network:sendToClients("client_updateRegister", self.register)
end

function CompositeWriter.server_onRequiredRegister(self, data, client)
	self.network:sendToClient(client, "client_updateRegister", self.register)
end

-- CLIENT --

function CompositeWriter.client_onFixedUpdate(self, dt)
	if self.interactable:getSingleParent() and self.interactable:getSingleParent():isActive() then
		self.interactable:setUvFrameIndex(CompositeWriter.UV_NON_ACTIVE + CompositeWriter.UV_ACTIVE_OFFSET)
	else
		self.interactable:setUvFrameIndex(CompositeWriter.UV_NON_ACTIVE)
	end
end

function CompositeWriter.client_onCreate(self)
	self.network:sendToServer("server_onRequiredRegister")
	self.last_reg = ""
	self.saved_reg = ""
end

function CompositeWriter.client_onInteract(self, char, state)
	if state then
		if self.gui == nil then
			self:client_createGUI()
		end
		self.last_reg = self.saved_reg
		self.gui:setText("RegisterName", formatBeforeGui(self.saved_reg))
		self.gui:open()
	end
end

function CompositeWriter.client_updateRegister(self, reg)
	if self.gui == nil then
		self:client_createGUI()
	end
	self.saved_reg = reg
	self.last_reg = reg
end

function CompositeWriter.client_createGUI(self)
	self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/CompositeWriter.layout", false)
	self.gui:setTextChangedCallback("RegisterName", "client_onRegisterNameChanged")
	self.gui:setButtonCallback("Save", "client_onSaveRegister")
end

function CompositeWriter.client_onRegisterNameChanged(self, widget, data)
	self.last_reg = formatAfterGui(data)
end

function CompositeWriter.client_onSaveRegister(self)
	self.saved_reg = self.last_reg
	self.network:sendToServer("server_updateRegister", self.saved_reg)
	self.gui:close()
end

function CompositeWriter.client_onDestroy(self)
	if self.gui ~= nil then
		self.gui:destroy()
	end
end
end
function scmframework_f96595358a600a527c5fbabaf47403f9() --$CONTENT_DATA/Scripts/Config.lua
if __scConfigLoaded then return end
__scConfigLoaded = true

dofile("$SURVIVAL_DATA/Scripts/game/survival_constants.lua")
dofile("$SURVIVAL_DATA/Scripts/game/survival_items.lua")
dofile("examples.lua")

---- libs
dofile("base64.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/utf8.lua")
dofile("json.lua")
dofile("md5.lua")
dofile("sha256.lua")

---- main
dofile "$CONTENT_DATA/Scripts/methods.lua"
dofile "$CONTENT_DATA/Scripts/FileSystem.lua"
dofile "$CONTENT_DATA/Scripts/fsmanager.lua"
dofile "$CONTENT_DATA/Scripts/env.lua"
dofile "$CONTENT_DATA/Scripts/load_code.lua"
dofile "$CONTENT_DATA/Scripts/vnetwork.lua"
dofile "$CONTENT_DATA/Scripts/localStorage.lua"

---- lua-in-lua
dofile "$CONTENT_DATA/Scripts/remade-lua-in-lua/lua/scanner.lua"
dofile "$CONTENT_DATA/Scripts/remade-lua-in-lua/lua/parser.lua"
dofile "$CONTENT_DATA/Scripts/remade-lua-in-lua/lua/interpreter.lua"
dofile "$CONTENT_DATA/Scripts/remade-lua-in-lua/lua/fixer.lua"
ll_Interpreter.MAX_ITERATIONS = math.huge

---- scrapVM
dofile("remade-scrapVM/scrapvm.lua")

---- FiOne_lua
dofile("$CONTENT_DATA/Scripts/FiOne_lua/lib.lua")

---- encryptVM
dofile("$CONTENT_DATA/Scripts/encryptVM/encryptVM.lua")

-------------------------------------------------------

local pairs = pairs
local ipairs = ipairs
local type = type

local sm_color_new = sm.color.new
local sm_vec3_new = sm.vec3.new
local sm_quat_new = sm.quat.new

local pcall = pcall
local unpack = unpack
local error = error
local sm_game_getCurrentTick = sm.game.getCurrentTick
local composite = sm.interactable.connectionType.composite

-------------------------------------------------------


sm.interactable.connectionType.composite = (4096 * 8)
sm.interactable.connectionType.networking = (8192 * 8)
sm.interactable.connectionType.networkCamera = 2 ^ 24
sm.interactable.connectionType.loopConnection = 2 ^ 25

local sc = {
	wasdInfo = {},
	
    gpstags = {},
    antennasApis = {},

    readersRefs = {},
    writersRefs = {},
    antennasRefs = {},

    computersDatas = {},
    displaysDatas = {},
    motorsDatas = {},
    radarsDatas = {},
    networkPortsDatas = {},
    hardDiskDrivesDatas = {},
    camerasDatas = {},
    camerasRefs = {},
    holoDatas = {},
    synthesizerDatas = {},
    keyboardDatas = {},

    allComputers = {},
    allComputersIds = {},

    sv_chaff_objects = {},
    cl_chaff_objects = {},

    chaff_visible_size = 1,
    chaff_real_size = 32
}
_G.sc = sc

sc.architectures = {}
sc.envhooks = {}
sc.cl_envhooks = {}

if dlm and dlm.debug and dlm.debug.traceback then
    sc.traceback = dlm.debug.traceback
elseif better and better.debug and better.debug.traceback then
    sc.traceback = better.debug.traceback
end

function sc.mt_hook(mt)
    local empty_class = class(mt)
    empty_class.__index = mt.__index
    return empty_class()
end

sc.version = "5.4a"
sc.actualBetterAPI = 45
sc.actualCoroutineBetterAPI = 45
sc.computersCount = 0

sc.deltaTime = 0
sc.maxcodelen = 32 * 1024
sc.clockLagMul = 150
sc.radarDetectedBodies = {}

sc.display = {}
sc.networking = {}

sc.disableFilesystemMenu = false
sc.useOriginalSettings = false
sc.enableByDefault = false
sc.noCommands = false
sc.componentsBackend = sc.mt_hook({__mode = "v"}) --sc.componentsBackend[table] = self


function sc.shutdown()
end

local function yield(computer)
    if computer and computer.env then
        computer.env[computer.yieldName](computer.yieldArg)
    elseif sc.lastComputer and sc.lastComputer.env then
        sc.lastComputer.env[sc.lastComputer.yieldName](sc.lastComputer.yieldArg)
    end
end

--[[
local count = 0
local function smartYield(computer)
    if count >= 256 then
        yield(computer)
        count = 0
    else
        count = count + 1
    end
end
]]

function sc.yield(computer) --для библиотек
    --[[
    if computer then
        local ok, err = pcall(computer.env[computer.yieldName], computer.yieldArg)
        if not ok then
            error(err or "unknown", 3)
        end
    elseif sc.lastComputer and sc.lastComputer.env then
        local ok, err = pcall(sc.lastComputer.env[sc.lastComputer.yieldName], sc.lastComputer.yieldArg)
        if not ok then
            error(err or "unknown", 3)
        end
    end
    ]]

    yield(computer)
end


function sc.smartYield(computer) --для библиотек
    yield(computer)
end

function sc.resetLagCounter(computer)
    if computer then
        computer:sv_init_yield()
    elseif sc.lastComputer then
        sc.lastComputer:sv_init_yield()
    end
end

function sc.getSkippedTicks()
    local skippedTicks = 0
    if sc.lastComputer and sc.lastComputer.env then
        local ok, result = pcall(sc.lastComputer.env.getSkippedTicks)
        if ok and type(skippedTicks) == "number" then
            skippedTicks = result
        end
    end
    return math.floor(skippedTicks)
end

function sc.lib_require(name)
    if sc.lastComputer and sc.lastComputer.env then
        return sc.lastComputer.env.require(name)
    end
end

function sc.atan2(y, x)
    return math.atan(y/x) + ((x < 0 and y < 0) and -math.pi or (y < 0 and math.pi or 0))
end

function sc.addStuff(t, parent)
    for k, v in pairs(parent) do
        t[k] = v
    end

    return t
end

function sc.setmetatable(t, meta) -- analog of native setmetatable
    for k, v in pairs(meta) do
        t[k] = v
    end

    t.__metatable = meta
    return t
end

function sc.getmetatable(t)
    return t.__metatable
end

function sc.networking.packetCopyPath(packet)
    packet = sc_copy(packet)
    packet.transmitterPath = sc_copy(packet.transmitterPath)

    return packet
end

function sc.advDeepcopy(t)
    local cache = {}

    local function clone(v, ctype)
        if ctype == "Color" then
            return sm_color_new(v.r, v.g, v.b, v.a)
        elseif ctype == "Vec3" then
            return sm_vec3_new(v.x, v.y, v.z)
        elseif ctype == "Quat" then
            return sm_quat_new(v.x, v.y, v.z, v.w)
        else
            return v
        end
    end

    local function recurse(tbl, newTable)
        for k, v in pairs(tbl) do
            sc.yield()

            local ctype = type(v)
            if ctype == "table" then
                if cache[v] then
                    newTable[k] = cache[v]
                else
                    if v == tbl then
                        newTable[k] = newTable
                    else
                        cache[v] = {}
                        newTable[k] = recurse(v, cache[v])
                    end
                end
            else
                newTable[k] = clone(v, ctype)
            end
        end

        return newTable
    end

    if type(t) == "table" then
        cache[t] = {}
        return recurse(t, cache[t])
    end
    return clone(t, type(t))
end

local type = type
local sm_color_new = sm.color.new
local function sc_deepcopy(v)
    local tname = type(v)
    if tname == "table" then
        local r = {}

        for k, v in pairs(v) do
            r[sc_deepcopy(k)] = sc_deepcopy(v)
        end

        return r
    elseif tname == "Color" then
        return sm_color_new(v.r, v.g, v.b, v.a)
    else
        return v
    end
end
sc.deepcopy = sc_deepcopy

function sc.copy(v)
    sc.yield()
    if type(v) == "table" then
        local r = {}
        for k, v in pairs(v) do
            sc.yield()
            r[k] = v
        end

        return r
    else
        return v
    end
end

sc_copy = sc.copy

function sc.needSaveData()
    local v = sc.restrictions.saving
    if v == 0 then v = 1 end
    return sm.game.getCurrentTick() % v == 0
end

function sc.needScreenSend()
    local ctick = sm.game.getCurrentTick()
    if sc.restrictions.screenRate < 1 then
        return ctick % 2 == 0
    end
    return ctick % sc.restrictions.screenRate == 0
end

function sc.getApi(name)
    if __SCMFRAMEWORK_NO_GETAPI then
        return
    end

    if _G[name] then
        return _G[name]
    elseif sm[name] then
        return sm[name]
    elseif better and better[name] then
        return better[name]
    elseif dlm and dlm[name] then
        return dlm[name]
    end
end

function sc.coroutineFixed()
    local c = sc.getApi("coroutine")
    return better and better.version >= sc.actualCoroutineBetterAPI and c and c.fixed 
end

function sc.coroutineCheck()
    local c = sc.getApi("coroutine")
    if c and not sc.coroutineFixed() and c.running() then
        error("this method cannot be called from a coroutine", 3)
    end
end

function sc.selfCoroutineCheck(self)
    local c = sc.getApi("coroutine")
    if c then
        local th = c.running()
        if th and th ~= self.th then
            error("this method cannot be called from a coroutine", 3)
        end
    end
end

function sc.creativeCheck(self, isCreative)
    if isCreative and sc.restrictions and not sc.restrictions.acreative then
        self.shape:destroyShape()
    end
end

----------------------   STORAGE    ----------------------

sc.treesPainted = sm.storage.load("sc_treesPainted") or {}

---------------------- RESTRICTIONS ----------------------

function sc.getDefaultVM()
    if better then
        return "betterAPI"
    elseif FiOne_lua then
        return "FiOne_lua"
    elseif dlm then
        return "dlm"
    elseif _HENV then    
        return "hsandbox"
    elseif a then
        return "fullLuaEnv"
    elseif sm.advancedExecuter then --in development
        return "advancedExecuter"
    else
        return "luaInLua"
    end
end

local restrictionsVersion = 5

sc.defaultRestrictions = { --DEFAULT
    restrictionsVersion = restrictionsVersion,
    acreative = true,
    adrop = true,
    disCompCheck = false,
    scriptMode = "safe",
    adminOnly = true,
    vm = sc.getDefaultVM(),
    allowChat = true,
    allowDist = true,
    optSpeed = false,
    rays = 0,
    rend = 15,
    cpu = (1 / 40) * 4, --max 4 ticks
    saving = 10,
    maxDisplays = 4096,
    ibridge = true,
    disableCallLimit = false,
    lagDetector = 1,
    screenRate = -1,
    hostrender = true,
    resourceConsumption = true,
    disableSplash = false
}

sc.survivalRestrictions = { --SURVIVAL
    restrictionsVersion = restrictionsVersion,
    acreative = false,
    adrop = true,
    disCompCheck = false,
    scriptMode = "safe",
    adminOnly = true,
    vm = sc.getDefaultVM(),
    allowChat = true,
    allowDist = false,
    optSpeed = false,
    rays = 0,
    rend = 15,
    cpu = (1 / 40) * 4, --max 4 ticks
    saving = 40,
    maxDisplays = 4096,
    ibridge = true,
    disableCallLimit = false,
    lagDetector = 1,
    screenRate = -1,
    hostrender = true,
    resourceConsumption = true,
    disableSplash = false
}

sc.unrestrictedRestrictions = { --UNRESTRICTED
    restrictionsVersion = restrictionsVersion,
    acreative = true,
    adrop = false,
    disCompCheck = true,
    scriptMode = "safe",
    adminOnly = true,
    vm = sc.getDefaultVM(),
    allowChat = true,
    allowDist = true,
    optSpeed = false,
    rays = 0,
    rend = 15,
    cpu = (1 / 40) * 40, --max 40 ticks
    saving = 10,
    maxDisplays = 4096,
    ibridge = true,
    disableCallLimit = false,
    lagDetector = 0,
    screenRate = 1,
    hostrender = true,
    resourceConsumption = false,
    disableSplash = false
}

sc.forServerRestrictions = { --FOR SERVERS
    restrictionsVersion = restrictionsVersion,
    acreative = false,
    adrop = true,
    disCompCheck = false,
    scriptMode = "safe",
    adminOnly = true,
    vm = sc.getDefaultVM(),
    allowChat = false,
    allowDist = false,
    optSpeed = 5,
    rays = 32,
    rend = 5,
    cpu = (1 / 40) * 2, --two ticks
    saving = 80,
    maxDisplays = 64,
    ibridge = false,
    disableCallLimit = false,
    lagDetector = 2,
    screenRate = 4,
    hostrender = false,
    resourceConsumption = true,
    disableSplash = false
}

sc.originalRestrictions = { --ScriptableComputer
    restrictionsVersion = restrictionsVersion,
    acreative = true,
    adrop = false,
    disCompCheck = true,
    scriptMode = "safe",
    adminOnly = true,
    vm = sc.getDefaultVM(),
    allowChat = true,
    allowDist = true,
    optSpeed = false,
    rays = 0,
    rend = 15,
    cpu = (1 / 40) * 20, --max 4 ticks
    saving = 10,
    maxDisplays = 128,
    ibridge = true,
    disableCallLimit = true,
    lagDetector = 0,
    screenRate = 1,
    hostrender = true,
    resourceConsumption = true,
    disableSplash = false
}

sc.restrictions = nil
sc.restrictionsKey = "ScriptableComputer-Restrictions"

function sc.isSplashEnabled()
    local data = sm.storage.load(sc.restrictionsKey)
    if data then
        return not data.disableSplash
    end
    return true
end

function sc.createRestrictions()
    sc.restrictions = sc.deepcopy(sc.defaultRestrictions)
    sc.restrictions.acreative = not sm.game.getLimitedInventory()
end

function sc.saveRestrictions()
    sc.restrictions.restrictionsVersion = restrictionsVersion
    sm.storage.save(sc.restrictionsKey, sc.restrictions)
    sc.restrictionsUpdated = true
end

function sc.setRestrictions(restrictions)
    sc.restrictions = sc.advDeepcopy(restrictions)
    for key, value in pairs(sc.defaultRestrictions) do
        if sc.restrictions[key] == nil then
            sc.restrictions[key] = value
        end
    end
    if sc.restrictions.acreative == nil then
        sc.restrictions.acreative = not sm.game.getLimitedInventory()
    end
end

function sc.loadRestrictions()
    local data = sm.storage.load(sc.restrictionsKey)
    if data then
        sc.restrictions = data
        local restrictions = sc.defaultRestrictions
        if sc.useOriginalSettings then
            restrictions = sc.originalRestrictions
        elseif sm.game.getLimitedInventory() then
            restrictions = sc.survivalRestrictions
        end

        for key, value in pairs(restrictions) do
            if sc.restrictions[key] == nil and key ~= "restrictionsVersion" then
                sc.restrictions[key] = value
            end
        end
        if not sc.restrictions.restrictionsVersion then
            sc.restrictions.restrictionsVersion = 0
        end

        sc.restrictions.vm = sc.getDefaultVM()
        if sc.restrictions.restrictionsVersion < 3 then
            sc.restrictions.allowChat = true
            sc.restrictions.allowDist = true
            sc.restrictions.maxDisplays = 4096
        end
        if sc.restrictions.restrictionsVersion < 5 then
            sc.restrictions.screenRate = -1
            sc.restrictions.allowChat = true
        end
    else
        sc.createRestrictions()
        sc.saveRestrictions()
    end
end


function sc.addLagScore(score)
    if sc.lastComputer and not sc.lastComputer.cdata.unsafe and type(sc.restrictions.lagDetector) == "number" then
        sc.lastComputer.lagScore = sc.lastComputer.lagScore + (score * sc.restrictions.lagDetector)
    end
end

function sc.init()
    if sc._INIT then return end
    sc.loadRestrictions()
    vnetwork.init()
    sc._INIT = true
end

function sc.xEngineClear()
    if sc.xEngineClear_flag then return end
    xEngine_clear()
    sc.xEngineClear_flag = true
end

---------------------- RESTRICTIONS END ----------------------

local type = type
local sm_color_new = sm.color.new
local tostring = tostring
local math_max = math.max
local math_min = math.min
local math_floor = math.floor
local string_format = string.format

function numberToColorpart(number)
    number = math_max(math_min(number, 1), 0)
    number = math_floor((number * 255) + 0.5)
    local hex = string_format("%x", number)
    if #hex < 2 then
        hex = "0" .. hex
    end
    return hex
end

--[[
local numberToColorpart = numberToColorpart
function sc.formatColor(data, isBlack, customAlpha)
    local customAlphaHex = "ff"
    if customAlpha then
        customAlphaHex = numberToColorpart(customAlpha)
    end

    if type(data) == "Color" then
        if customAlpha then
            return sm_color_new(tostring(data):sub(1, 6) .. customAlphaHex)
        else
            return data
        end
    elseif type(data) == "string" then
        return sm_color_new(data or (isBlack and ("000000" .. customAlphaHex) or ("ffffff"  .. customAlphaHex)))
    end
    return sm_color_new(isBlack and ("000000" .. customAlphaHex) or ("ffffff" .. customAlphaHex))
end

local formatColor = sc.formatColor
function sc.formatColorStr(data, isBlack, customAlpha)
    return tostring(formatColor(data, isBlack, customAlpha))
end
]]






local bit = bit or bit32
local band = bit.band
local rshift = bit.rshift
local function hexToRGB(color)
    return band(rshift(color, 16), 0xFF) / 255, band(rshift(color, 8), 0xFF) / 255, band(color, 0xFF) / 255
end

local black = "000000ff"
local white = "ffffffff"

local blackColor = sm_color_new(0, 0, 0)
local whiteColor = sm_color_new(1, 1, 1)

local type = type
function sc.formatColor(data, default, advancedDefault)
    local t = type(data)
    if t == "Color" then
        return data
    elseif t == "string" then
        return sm_color_new(data)
    elseif t == "number" then
        return sm_color_new(hexToRGB(data))
    end

    if advancedDefault then
        return default
    else
        return default and blackColor or whiteColor
    end
end

local formatColor, tostring = sc.formatColor, tostring
function sc.formatColorStr(data, default, advancedDefault)
    return tostring(formatColor(data, default, advancedDefault))
end

local table_insert = table.insert
function sc.display.optimizeFont(chars, width, height)
    local optimized = {}

    for k, v in pairs(chars) do
        local pixels = {}

        for iy, w in ipairs(v) do
            for ix = 1, width do
                local z = w:sub(ix, ix)
                if z == "1" then
                    table_insert(pixels, { ix-1, iy-1 })
                end
            end
        end

        optimized[k] = pixels
        if #k == 1 then
            optimized[k:byte()] = pixels
        end
    end

    return optimized
end

local sm_exists = sm.exists
function sc.checkComponent(self) --this method no longer needs to be called
    --[[
    if not sm_exists(self.shape or self.tool) then
        error("the " .. (self.componentType or "unknown") .. " component has been removed", 0)
    end
    ]]
end

do
    local currentEffect = 1
    local effectsNames = {
        "ShapeRenderable",
    }

    for i = 2, 114 do
        table.insert(effectsNames, "ShapeRenderable" .. tostring(i))
    end

    function sc.getEffectName()
        local name = effectsNames[currentEffect]
        currentEffect = currentEffect + 1
        if currentEffect > #effectsNames then
            currentEffect = 1
        end
        return name
    end
end

do
    local currentEffect = 1
    local effectsNames = {
        "A",
        "B",
        "C",
        "D",
    }

    function sc.getSoundEffectName(realname)
        local name = effectsNames[currentEffect]
        currentEffect = currentEffect + 1
        if currentEffect > #effectsNames then
            currentEffect = 1
        end
        return realname .. name
    end
end

local sc_coroutineCheck = sc.coroutineCheck
local sc_advDeepcopy = sc.advDeepcopy

local getChildren = sm.interactable.getChildren
local getParents = sm.interactable.getParents

function sc.getComponents(self, name, settings, publicDataChecker)
    sc_coroutineCheck()

    settings = settings or {}

    local components = {}
    if settings.vcomponents then
        for lname, tbl in pairs(settings.vcomponents) do
            if lname == name then
                for i, data in ipairs(tbl) do
                    data.type = lname
                    data[1] = function() end
                    table_insert(components, data)
                end
            end
        end
    end

    local lInteractable = self.interactable
    if not lInteractable then return components end

    ----------------

    local connectType = composite
    local findMethod
    local componentDatas

    if name == "keyboard" then
        findMethod = lInteractable.getParents
        componentDatas = sc.keyboardDatas
    elseif name == "synthesizer" then
        findMethod = lInteractable.getChildren
        componentDatas = sc.synthesizerDatas
    elseif name == "holoprojector" then
        findMethod = lInteractable.getChildren
        componentDatas = sc.holoDatas
    elseif name == "camera" then
        findMethod = lInteractable.getParents
        componentDatas = sc.camerasDatas
    elseif name == "disk" then
        findMethod = lInteractable.getChildren
        componentDatas = sc.hardDiskDrivesDatas
    elseif name == "port" then
        findMethod = lInteractable.getChildren
        componentDatas = sc.networkPortsDatas
    elseif name == "radar" then
        findMethod = lInteractable.getChildren
        componentDatas = sc.radarsDatas
    elseif name == "motor" then
        findMethod = lInteractable.getChildren
        componentDatas = sc.motorsDatas
    elseif name == "display" then
        findMethod = lInteractable.getChildren
        componentDatas = sc.displaysDatas
    elseif name == "antenna" then
        findMethod = lInteractable.getChildren
        componentDatas = sc.antennasApis
    end

    local function addComponents(interactable, api, componentInfo)
        local componentSelf = sc.componentsBackend[api]

        if self.componentCache[interactable.id] then
            table_insert(components, self.componentCache[interactable.id])
            return
        end

        local newapi = {}
        local checkTick
        local forceCheck = true
        
        for key, value in pairs(api) do
            local api_type = api.type
            --print("func state", key, type(value) == "function" and (not componentInfo or not componentInfo.directList or not componentInfo.directList[key]), type(value) == "function", not componentInfo , not componentInfo.directList , not componentInfo.directList[key])
            if type(value) == "function" and (not componentInfo or not componentInfo.directList or not componentInfo.directList[key]) then
                newapi[key] = function (...)
                    sc_coroutineCheck()

                    local ctick = sm_game_getCurrentTick()
                    if checkTick ~= ctick then
                        checkTick = ctick

                        if not sm_exists(interactable) then
                            error("the \"" .. (api_type or "unknown") .. "\" component has been removed", 2)
                        end

                        if (ctick % 20 == 0 or forceCheck) and not sc.restrictions.disCompCheck then
                            forceCheck = false

                            local find
                            for _, children in ipairs(getChildren(lInteractable)) do
                                if children == interactable then
                                    find = true
                                    break
                                end
                            end
                            if not find then
                                for _, parent in ipairs(getParents(lInteractable)) do
                                    if parent == interactable then
                                        find = true
                                        break
                                    end
                                end
                            end
                            if not find then
                                error("the \"" .. (api_type or "unknown") .. "\" component has been disconnected", 2)
                            end
                        end
                    end

                    if not api[key] then
                        error("the \"" .. (api_type or "unknown") .. "\" component was turned off", 2)
                    end

                    local result = {pcall(api[key], ...)} --кастомные(пользовательские) компоненты на основе компа могут динамически изменять свой API. по этому api[key] а не value
                    if result[1] then
                        return unpack(result, 2)
                    else
                        error(result[2], 2)
                    end
                end
            else
                newapi[key] = sc_advDeepcopy(value)
            end

            sc.componentsBackend[newapi] = componentSelf
        end

        local function ferr()
            forceCheck = true
            checkTick = nil
            error("there is no access to the component", 3)
        end

        newapi[1] = function ()
            sc_coroutineCheck()

            ---------------- exists check
            if not sm_exists(interactable) then
                ferr()
            end

            ---------------- connect check
            if not sc.restrictions.disCompCheck then
                local find
                for _, children in ipairs(getChildren(lInteractable)) do
                    if children == interactable then
                        find = true
                        break
                    end
                end
                if not find then
                    for _, parent in ipairs(getParents(lInteractable)) do
                        if parent == interactable then
                            find = true
                            break
                        end
                    end
                end
                if not find then
                    ferr()
                end
            end

            ---------------- enable check
            if api[-1] then
                ferr()
            end
        end

        self.componentCache[interactable.id] = newapi
        table_insert(components, newapi)
    end

    local function reg(interactable)
        local data = interactable.publicData
        if data and
        data.sc_component and
        data.sc_component.api and data.sc_component.type == name then
            if not publicDataChecker or publicDataChecker(interactable.publicData) then
                data.sc_component.api.type = name
                addComponents(interactable, data.sc_component.api, data.sc_component)
            end
        end
    end
    for k, v in pairs(getChildren(lInteractable, connectType)) do
        pcall(reg, v)
    end
    for k, v in pairs(getParents(lInteractable, connectType)) do
        pcall(reg, v)
    end

    if findMethod then
        for k, v in pairs(findMethod(lInteractable, connectType)) do
            if not publicDataChecker or publicDataChecker(v.publicData) then
                local data = componentDatas[v.id]
                if data then
                    data.type = name
                    addComponents(v, data)
                end
            end
        end
    end
    return components
end

-------------------------------------------------------

--[[
sc.internal_libs = {}
sc.internal_libs_folders = {}

function sc.reg_internal_lib(name, tbl)
    sc.internal_libs[name] = tbl
end

function sc.reg_lib_folder(path)
    table.insert(sc.internal_libs_folders, path)
end
]]

sc.internal_libs_folders = {}

function sc.reg_lib_folder(path)
    table.insert(sc.internal_libs_folders, path)
end

-------------------------------------------------------

sc.moduuid = sm.json.open("$CONTENT_DATA/description.json").localId --you need to read the file for scmframework to work with betterAPI
sc.origModPrefix = "$CONTENT_3aeb81c2-71b9-45a1-9479-1f48f1e8ff21"
sc.modPrefix = "$CONTENT_" .. sc.moduuid
sc.reg_lib_folder(sc.modPrefix .. "/Scripts/internal_libs")

function sc.changePrefixesInList(list)
    if sc.modPrefix == sc.origModPrefix then return end
    print("changing prefixes in list...", list, sc.origModPrefix, sc.modPrefix)
    for key, item in pairs(list) do
        if item:sub(1, #sc.origModPrefix) == sc.origModPrefix then
            list[key] = sc.modPrefix .. item:sub(#sc.origModPrefix + 1, #item)
        end
    end
    print("changed prefixes in list!", list)
end

-------------------------------------------------------

if not __SCMFRAMEWORK then
    sm.sc = sc --для интеграций
    sm.sc_g = _G
else
    _G.computersAllow = true
    _G.updateToolSettings = true
end

if dlm and dlm.setupContentPath then
    print("SComputers dlm.setupContentPath: ", pcall(dlm.setupContentPath, "SComputers [Fork]", sm.uuid.new(sc.moduuid), 2949350596))
end

if better then
    print("SComputers better.autoRegistration: ", pcall(better.autoRegistration, "SComputers [Fork]"))
end

function sc.customVersion(char)
    sc.version = sc.version:sub(1, #sc.version - 1) .. char
end

-------------------------------------------------------

--dofile("$CONTENT_DATA/Scripts/font.lua")
--dofile("$CONTENT_DATA/Scripts/basegraphic.lua")
dofile("$CONTENT_DATA/Scripts/warnings.lua")
dofile("$CONTENT_DATA/Scripts/canvasAPI/canvas.lua")
dofile("$CONTENT_DATA/Scripts/Displays/AnyDisplay.lua")
dofile("$CONTENT_DATA/Scripts/internal_libs/xEngine.lua")
--dofile("$CONTENT_DATA/Scripts/externAddonAPI.lua")
dofile("$CONTENT_DATA/Scripts/ai.lua")

dofile("$CONTENT_DATA/Scripts/scomputersAPI.lua")

-------------------------------------------------------

print("SComputers Configuration has been loaded. version " .. tostring(sc.version))
end
function scmframework_526ba469794a9225c66194dc4860fe59() --$CONTENT_DATA/Scripts/defaultLibs.lua
defaultLibs = {
    math = {
        abs = math.abs,
        acos = math.acos,
        asin = math.asin,
        atan = math.atan,
        atan2 = math.atan2,
        ceil = math.ceil,
        cos = math.cos,
        cosh = math.cosh,
        deg = math.deg,
        exp = math.exp,
        floor = math.floor,
        fmod = math.fmod,
        frexp = math.frexp,
        huge = math.huge,
        ldexp = math.ldexp,
        log = math.log,
        log10 = math.log10,
        max = math.max,
        min = math.min,
        modf = math.modf,
        pi = math.pi,
        pow = math.pow,
        rad = math.rad,
        random = math.random,
        sin = math.sin,
        sinh = math.sinh,
        sqrt = math.sqrt,
        tan = math.tan,
        tanh = math.tanh,
        round = function(number)
            if number >= 0 then
                return math.floor(number + 0.5)
            else
                return math.ceil(number - 0.5)
            end
        end
    },
    string = {
        byte = string.byte,
        char = string.char,
        dump = string.dump,
        find = string.find,
        format = string.format,
        gmatch = string.gmatch,
        gsub = string.gsub,
        len = string.len,
        lower = string.lower,
        match = string.match,
        rep = string.rep,
        reverse = string.reverse,
        sub = string.sub,
        upper = string.upper
    },
    table = {
        concat = table.concat,
        insert = table.insert,
        maxn = table.maxn,
        remove = table.remove,
        sort = table.sort
    }
}

end
function scmframework_5149b854c510e6111671e9af38becd33() --$CONTENT_DATA/Scripts/Displays/AnyDisplay.lua
--dofile("$CONTENT_DATA/Scripts/Displays/old/AnyDisplay.lua")
--do return end

dofile("$CONTENT_DATA/Scripts/Config.lua")
AnyDisplay = class(canvasAPI.canvasService)
AnyDisplay.maxParentCount = 1
AnyDisplay.maxChildCount = 0
AnyDisplay.connectionInput = sm.interactable.connectionType.composite
AnyDisplay.colorNormal = sm.color.new(0xbbbb1aff)
AnyDisplay.colorHighlight = sm.color.new(0xecec1fff)
AnyDisplay.componentType = "display"
AnyDisplay.stretchable_core_uuid = sm.uuid.new("ab36aa06-ea7d-4309-acd1-ed772e8c61fc")
AnyDisplay.stretchable_part_uuid = sm.uuid.new("c4704ff3-dd5a-4840-bfd6-0551497ccc32")

local PIXEL_SCALE = 0.0072
local RENDER_DISTANCE = 15
local DEBUG_WORLDMODE = false
local defaultTrySend = 7000
local sc = sc

--is it allowed to distort the geometry when auto is enabled to avoid pixels that pop out of the screen
local allowDistortGeometry = false
--local _debug_overwriteScale = 729

--------------------------------------- SERVER

local stackChecksum = canvasAPI.stackChecksum
local needPushStack = canvasAPI.needPushStack

local function sendStack(self, method, stack, force, forceForce)
    if #sm.player.getAllPlayers() > 1 then
        stack.flush = true
        stack.force = force
        stack.forceForce = forceForce
        if not pcall(self.network.sendToClients, self.network, method, stack) then
            stack.flush = nil

            local mul = 0.8
            local index = 1
            local stackSize = #stack
            local count = math.min(stackSize, self.tryPacket or defaultTrySend)
            local cycles = 0
            local lastIndex
            local datapack
            local dataPackI
            while true do
                lastIndex = index + (count - 1)
                datapack = {}
                dataPackI = 1
                for i = index, math.min(lastIndex, stackSize) do
                    datapack[dataPackI] = stack[i]
                    dataPackI = dataPackI + 1
                end
                datapack.force = force

                index = index + count
                if lastIndex >= #stack then
                    datapack.flush = true
                    if pcall(self.network.sendToClients, self.network, method, datapack) then
                        self.tryPacket = count
                        break
                    else
                        datapack.flush = nil
                        index = index - count
                        count = math.floor(count * mul)
                    end
                elseif not pcall(self.network.sendToClients, self.network, method, datapack) then
                    index = index - count
                    count = math.floor(count * mul)
                end

                cycles = cycles + 1
                if cycles > 100 then
                    print("try send: ", pcall(self.network.sendToClients, self.network, method, stack))
                    error("cycles to many 100")
                    break
                end
            end
        end
    else
        stack.force = force
        self["sendedData_" .. method] = stack
        self.network:sendToClients(method)
    end
end

function AnyDisplay:isAllow()
    if not sc.restrictions then return true end
    return self.width * self.height <= (sc.restrictions.maxDisplays * sc.restrictions.maxDisplays) --attempt to index field 'restrictions' (a nil value) on clients
end

local directList

function AnyDisplay:server_onCreate()
    self.lastLagScore = 0
	self.dataTunnel = {}
	self.width = self.data.x
	self.height = self.data.y
    self.mulSize = self.width * self.height
	local allowHoloAPI = self.data.allowOffsets
	if allowHoloAPI and (self.data.unrestrictedOffsets or DEBUG_WORLDMODE) then
		allowHoloAPI = {
			maxOffset = math.huge,
			maxScale = math.huge
		}
	end

	local allowSetResolution
	if self.data.dynamicResolution then
		allowSetResolution = true
	else
		local maxSide = math.max(self.width, self.height)
		allowSetResolution = {
			maxPixels = self.width * self.height,
			maxWidth = maxSide,
			maxHeight = maxSide
		}
	end

	self.api, self.internalApi = canvasAPI.createScriptableApi(self.width, self.height, self.dataTunnel, function ()
        self.lastComputer = sc.lastComputer
    end, {
        getRealBuffer = function(...)
            if not self.canvas then return end
            return self.canvas.getRealBuffer(...)
        end,
        getNewBuffer = function(...)
            if not self.canvas then return end
            return self.canvas.getNewBuffer(...)
        end
    }, (self.data.glass or self.data.unlockGlass) and canvasAPI.materialList or canvasAPI.materialListWithoutGlass, self.data.glass and 0 or 1, allowHoloAPI, allowSetResolution)
	
	self.api.noCameraEncode = true
    self._flush = self.api.flush
    self._forceFlush = self.api.forceFlush

    function self.api.flush()
        self.flushCallFlag = true
    end
    self.api.update = self.api.flush

    function self.api.forceFlush()
        self.flushCallFlag = true
        self.flushCallForce = true
    end

	self.touchscreen = canvasAPI.addTouch(self.api, self.dataTunnel)

	self.api.isAllow = function()
		return self:isAllow()
	end

    self.api.getAudience = function()
        if self._getAudienceCount then
            return self._getAudienceCount()
        end
        return 0
    end

    if not directList then
        directList = {}
        for name, obj in pairs(self.api) do
            if type(obj) == "function" and name ~= "flush" and name ~= "forceFlush" then
                directList[name] = true
            end
        end
    end

	self.interactable.publicData = {
		sc_component = {
			type = AnyDisplay.componentType,
			api = self.api,
            directList = directList
		}
	}

    sc.componentsBackend[self.api] = self
end

local rates = {1, 2, 4, 6, 8, 10}
local bigSize2 = 256 * 256
local bigSize1 = 128 * 128
function AnyDisplay:server_onFixedUpdate()
    local computerConnected = scomputers.isComputerConnected(self.interactable)
    if not computerConnected and self.sv_oldComputerConnected then
        self.internalApi.setForceFrame()
    end
    self.sv_oldComputerConnected = computerConnected
    
    if self.flushCallFlag then
        if self.flushCallForce then
            self._forceFlush()
        else
            self._flush()
        end
        self.flushCallFlag = nil
        self.flushCallForce = nil
    end

    local lagScore
    if self._getLagDetector then
        lagScore = self._getLagDetector()
    end

	local ctick = sm.game.getCurrentTick()
    if sc.restrictions.screenRate < 0 then
        if lagScore then
            local mathRateIndex = 1
            if lagScore > 8 then
                mathRateIndex = 5
            elseif lagScore > 6 then
                mathRateIndex = 4
            elseif lagScore > 4 then
                mathRateIndex = 3
            elseif lagScore > 2 then
                mathRateIndex = 2
            end
            if sc.restrictions.screenRate == -2 then
                mathRateIndex = mathRateIndex + 1
            end
            local newRate = rates[mathRateIndex] or 1
            if self.mulSize >= bigSize2 then
                if newRate < 4 then
                    newRate = 4
                end
            elseif self.mulSize >= bigSize1 then
                if newRate < 2 then
                    newRate = 2
                end
            end
            if self.allowDownRate or not self.mathRate or newRate > self.mathRate then
                self.allowDownRate = nil
                self.mathRate = newRate
            end
        elseif not self.mathRate then
            self.mathRate = 1
        end
        if ctick % self.mathRate == 0 then
            self.oldMathRate = self.mathRate
            self.allow_send = true
        elseif self.mathRate ~= self.oldMathRate then
            self.oldMathRate = self.mathRate
            self.allow_send = true
        end
    elseif ctick % sc.restrictions.screenRate == 0 then
        self.mathRate = nil
		self.allow_send = true
	end

    if ctick % (40 * 4) == 0 then
        self.tryPacket = nil
    end

    if ctick % 40 == 0 then
        self.allowDownRate = true
    end

    if self.lastComputer and self.lastComputer.lagScore and lagScore and type(sc.restrictions.lagDetector) == "number" then
        self.lastComputer.lagScore = self.lastComputer.lagScore + (lagScore * sc.restrictions.lagDetector)
    end

    self.dataTunnel.scriptableApi_update()

	if self:isAllow() then
		if self.allow_send then
			if self.dataTunnel.dataUpdated then
				if self.dataTunnel.resolutionChanged then
					self:sv_canvasRequest()
					self.dataTunnel.resolutionChanged = nil
				end

				self.network:sendToClients("cl_dataTunnel", canvasAPI.minimizeDataTunnel(self.dataTunnel))
				self.allow_send = nil
                self.dataTunnel.dataUpdated = nil
                self.dataTunnel.display_reset = nil
			end
	
			if self.dataTunnel.display_flush then
                sendStack(self, "cl_pushStack", self.dataTunnel.display_stack, self.dataTunnel.display_forceFlush, self.dataTunnel.display_forceForceFlush)
				
				self.dataTunnel.display_flush()
				self.dataTunnel.display_stack = nil
				self.dataTunnel.display_flush = nil
                self.dataTunnel.display_forceFlush = nil
                self.dataTunnel.display_forceForceFlush = nil
				self.allow_send = nil
			end
		end
	elseif self.dataTunnel.display_flush then
        self.dataTunnel.display_flush()
        self.dataTunnel.display_stack = nil
        self.dataTunnel.display_flush = nil
        self.dataTunnel.display_forceFlush = nil
        self.dataTunnel.display_forceForceFlush = nil
	end
end

function AnyDisplay:sv_dataRequest()
    self.tryPacket = nil
    self.dataTunnel.dataUpdated = true
    self.dataTunnel.display_forceFlush = true
    self.dataTunnel.display_forceForceFlush = true
end

function AnyDisplay:sv_recvPress(data)
	self.touchscreen(data)
end

function AnyDisplay:sv_canvasRequest(_, caller)
	self.width = self.api.getWidth()
	self.height = self.api.getHeight()
	self.mulSize = self.width * self.height

	local data = {
		width = self.width,
		height = self.height
	}

	if caller then
		self.network:sendToClient(caller, "cl_canvasResponse", data)
	else
		self.network:sendToClients("cl_canvasResponse", data)
	end
end

--------------------------------------- CLIENT

function AnyDisplay:client_onCreate()
	local material = canvasAPI.material.classic
	local rotate
	local ypos = 0
	local zpos = 0.12
	if self.data then
		if self.data.glass then
			material = canvasAPI.material.glass
		end

		if self.data.zpos then
			zpos = self.data.zpos
		end

		if self.data.offset then
			ypos = -(self.data.offset / 4)
		end

		if self.data.rotate then
			rotate = true
			ypos = -ypos
		end
	end

    if self.data.flat then
        zpos = -0.1025
    elseif self.data.ultra_flat then
        zpos = -0.124
    end

	self.width = self.data.x
	self.height = self.data.y
	self.defaultWidth = self.width
	self.defaultHeight = self.height
    local rot
	if self.data.altRotateMode then
		rot = sm.vec3.new(0, -90, -90)
	else
		rot = sm.vec3.new(0, -90, (not rotate) and 180 or 0)
	end
    local pos = sm.vec3.new(0, ypos, zpos)
    if self.data.addRot then
        rot = rot + self.data.addRot
    end
    if self.data.addPos then
        pos = pos + self.data.addPos
    end
	--self.canvas = (canvasAPI.createBetterCanvas or canvasAPI.createCanvas)(self.interactable, self.width, self.height, self.pixelScale, pos, sm.quat.fromEuler(rot), material)
    if self.data.autoV then
        local boundingBox = self.shape:getBoundingBox()
        local boxSizeX = self.data.fakeZ or boundingBox.z * 4
        local boxSizeY = self.data.fakeY or boundingBox.y * 4
        local borderSizeX = 0.2
        local borderSizeY = 0.2
        if boxSizeX <= 3 and not (boxSizeX == 3 and boxSizeY == 2) then
            borderSizeX = 0.1
            borderSizeY = 0.1
        end
        if self.data.ultra_flat then
            borderSizeX = 0
            borderSizeY = 0
        end

        local pixelScaleX = (boxSizeX - borderSizeX) / self.width / 4
        local pixelScaleY = (boxSizeY - borderSizeY) / self.height / 4

        if allowDistortGeometry then
            self.pixelScale = sm.vec3.new(pixelScaleX, pixelScaleY, 0.00025)
        else
            local pixelScaleXY = math.max(pixelScaleX, pixelScaleY)
            self.pixelScale = sm.vec3.new(pixelScaleXY, pixelScaleXY, 0.00025)
        end

        self.pixelScaleX = self.pixelScale.x / PIXEL_SCALE
        self.pixelScaleY = self.pixelScale.y / PIXEL_SCALE
    elseif self.data.sizeX then
        local pixelScaleX = self.data.sizeX / self.width
        local pixelScaleY = self.data.sizeY / self.height

        self.pixelScale = sm.vec3.new(pixelScaleX, pixelScaleY, 0.00025)
        self.pixelScaleX = self.pixelScale.x / PIXEL_SCALE
        self.pixelScaleY = self.pixelScale.y / PIXEL_SCALE
    else
        self.pixelScale = _debug_overwriteScale or self.data.v
        if self.data.div then
            self.pixelScale = self.pixelScale / self.width
        end
        self.pixelScaleX = self.pixelScale
        self.pixelScaleY = self.pixelScale
    end

	local canvasAttachObject
	if self.data.worldMode or DEBUG_WORLDMODE then
		canvasAttachObject = nil
	else
		canvasAttachObject = self.interactable
	end
    self.canvas = canvasAPI.createCanvas(canvasAttachObject, self.width, self.height, self.pixelScale, pos, rot, material, nil, self.data.altFromEuler, self.data.unrestrictedOffsets)
	self.network:sendToServer("sv_dataRequest")

	self.c_dataTunnel = {}
	self.dragging = {interact=false, tinker=false, interactLastPos={x=-1, y=-1}, tinkerLastPos={x=-1, y=-1}}

	self.network:sendToServer("sv_canvasRequest")
end

function AnyDisplay:client_onDestroy()
	self.canvas.destroy()
end

function AnyDisplay:cl_canvasResponse(data)
	if sm.isHost then return end
	self.width, self.height = data.width, data.height
end

local function defaultDisplayTouchDetect(self, detect, localPoint)
	local pixelScaleX = self.defaultWidth / self.width
	local pixelScaleY = self.defaultHeight / self.height
    if self.data.altTouchMode then
        if localPoint and localPoint.x > 0 then
            local pointX = math.floor(self.width / 2 - localPoint.z / (PIXEL_SCALE * self.pixelScaleX * pixelScaleX))
            local pointY = math.floor(self.height / 2 + localPoint.y / (PIXEL_SCALE * self.pixelScaleY * pixelScaleY))
        
            return detect(pointX, pointY)
        end
    else
        if localPoint and localPoint.x < 0 then
            local localPoint = sm.vec3.new(0, localPoint.y, localPoint.z)
    
            local pointX = math.floor(self.width / 2 - localPoint.z / (PIXEL_SCALE * self.pixelScaleX * pixelScaleX))
            local pointY = math.floor(self.height / 2 + localPoint.y / (PIXEL_SCALE * self.pixelScaleY * pixelScaleY))
        
            return detect(pointX, pointY)
        end
    end

    return false
end

function AnyDisplay:cl_onClick(type, action, localPoint) -- type - 1:interact|2:tinker (e.g 1 or 2), action - pressed, released, drag
    if self.data and self.data.noTouch then
        return
    end

    local function detect(pointX, pointY)
        pointX = math.floor(pointX + 0.5)
        pointY = math.floor(pointY + 0.5)

        if pointX >= 0 and pointX < self.width and pointY >= 0 and pointY < self.height then
            if action == "drag" then
                local t = type == 1 and self.dragging.interactLastPos or self.dragging.tinkerLastPos

                if t.x ~= -1 then
                    if t.x == pointX and t.y == pointY then 
                        return
                    else
                        t.x = pointX
                        t.y = pointY
                    end
                else
                    t.x = pointX
                    t.y = pointY
                    return
                end
            end

            local reverseX, reverseY, changeXY
            if self.c_dataTunnel.rotation == 1 then
                changeXY = true
                reverseX = true
            elseif self.c_dataTunnel.rotation == 2 then
                reverseX = true
                reverseY = true
            elseif self.c_dataTunnel.rotation == 3 then
                changeXY = true
                reverseY = true
            end
            if reverseX then
                pointX = self.width - pointX - 1
            end
            if reverseY then
                pointY = self.height - pointY - 1
            end
            if changeXY then
                pointX, pointY = pointY, pointX
            end

            --print("touch", pointX, pointY)
            self.lastPointX, self.lastPointY = pointX, pointY
            self.network:sendToServer("sv_recvPress", {pointX, pointY, action, type, sm.localPlayer.getPlayer().name})
        end
    end

    local localReg = self.altReg or function (ldetect, localPoint)
        defaultDisplayTouchDetect(self, ldetect, localPoint)
    end
    
    local function release(player)
        if self.lastPointX then
            self.network:sendToServer("sv_recvPress", {self.lastPointX or -1, self.lastPointY or -1, "released", type, player.name})
            self.lastPointX, self.lastPointY = nil, nil
            self.dragging.interact = false
            self.dragging.tinker = false
        end
    end

    if localPoint then
        localReg(detect, localPoint)
    elseif self.shape then
        local player = sm.localPlayer.getPlayer()
        local succ, res = sm.localPlayer.getRaycast((sc.restrictions and sc.restrictions.rend) or RENDER_DISTANCE)
        local shape = res:getShape()
        if succ and shape and (shape.id == self.shape.id or shape.uuid == AnyDisplay.stretchable_core_uuid or shape.uuid == AnyDisplay.stretchable_part_uuid) then
            local shape = self.shape
            local localPoint = shape:transformPoint(res.pointWorld)
            if self:cl_touchCheck(nil, nil, nil, succ, res) then
                localReg(detect, localPoint, res)
            else
                release(player)
            end
        else
            release(player)
        end
    elseif self.tablet_posX and self.tablet_posY then
        detect(self.tablet_posX, self.tablet_posY)
    end
end

function AnyDisplay:cl_touchCheck(type, action, localPoint, _succ, _res)
    if self.data and self.data.noTouch then
        return false
    end

    if self.altReg then
        return true
    end

    local function detect(pointX, pointY)
        pointX = math.floor(pointX + 0.5)
        pointY = math.floor(pointY + 0.5)

        if pointX >= 0 and pointX < self.width and pointY >= 0 and pointY < self.height then
            return true
        end
        return false
    end

    local function localReg(ldetect, localPoint)
        return defaultDisplayTouchDetect(self, ldetect, localPoint)
    end
    
    if localPoint then
        return localReg(detect, localPoint)
    elseif self.shape then
        local succ, res
        if _succ then
            succ, res = _succ, _res
        else
            succ, res = sm.localPlayer.getRaycast((sc.restrictions and sc.restrictions.rend) or RENDER_DISTANCE)
        end
        local shape = res:getShape()
        if succ and shape and shape.id == self.shape.id then
            local shape = self.shape
            local localPoint = shape:transformPoint(res.pointWorld)
            return localReg(detect, localPoint, res)
        end
    elseif self.tablet_posX and self.tablet_posY then
        return true
    end

    return false
end

function AnyDisplay:client_onFixedUpdate()
    if not self.canvas then
        return
    end

    local computerConnected = scomputers.isComputerConnected(self.interactable)
    if not computerConnected and self.oldComputerConnected then
        self.canvas.pushStack({canvasAPI.draw.clear, 0})
        self.canvas.flush()
    end
    self.oldComputerConnected = computerConnected
    
    self.disableState = not self:isAllow()
    if sm.isHost and not sc.restrictions.hostrender then
        self.disableState = true
    end
	self.canvas.disable(self.disableState)
	if self.data.alwaysRenderAtDistance or DEBUG_WORLDMODE then
		self.canvas.setRenderDistance(math.huge)
	else
		if sc.restrictions then
			if self.c_dataTunnel.renderAtDistance and sc.restrictions.allowDist then
				self.canvas.setRenderDistance(128)
			else
				self.canvas.setRenderDistance((sc.restrictions and sc.restrictions.rend) or RENDER_DISTANCE)
			end
		else
			self.canvas.setRenderDistance(RENDER_DISTANCE)
		end
	end
	self.canvas.update()
    self:canvasService(self.canvas.isRendering())

	if self.dragging.interact then
		self:cl_onClick(1, "drag")
	elseif self.dragging.tinker then
		self:cl_onClick(2, "drag")
	end

	if self.character then
        if self.tablet_left ~= self.old_tablet_left then
            self:client_onInteract(nil, not not self.tablet_left)
        end
    
        if self.tablet_right ~= self.old_tablet_right then
            self:client_onTinker(nil, not not self.tablet_right)
        end

        self.old_tablet_left = self.tablet_left
        self.old_tablet_right = self.tablet_right
    else
        if _G.stylus_left ~= self.old_stylus_left then
            self:client_onInteract(nil, not not _G.stylus_left)
        end
    
        if _G.stylus_right ~= self.old_stylus_right then
            self:client_onTinker(nil, not not _G.stylus_right)
        end

        self.old_stylus_left = _G.stylus_left
        self.old_stylus_right = _G.stylus_right
    end
end

function AnyDisplay:client_onInteract(character, state)
    self.dragging.interact = state
    if state then
        local t = self.dragging.interactLastPos
        t.x = -1
        t.y = -1
    end
    self:cl_onClick(1, state and "pressed" or "released")
end

function AnyDisplay:client_onTinker(character, state)
    self.dragging.tinker = state
    if state then
        local t = self.dragging.tinkerLastPos
        t.x = -1
        t.y = -1
    end
    self:cl_onClick(2, state and "pressed" or "released")
end

function AnyDisplay:client_canInteract(character)
	if self.data and self.data.noTouch then
        return false
    end

	local can = (not not self.c_dataTunnel.clicksAllowed) and self:cl_touchCheck()
    if can then
        sm.gui.setInteractionText("", "<p textShadow='false' bg='gui_keybinds_bg_orange' spacing='9' color='#65430B'>" .. sm.gui.getKeyBinding("Use") .. "</p> Primary Touch", "")
        sm.gui.setInteractionText("", "<p textShadow='false' bg='gui_keybinds_bg_orange' spacing='9' color='#65430B'>" .. sm.gui.getKeyBinding("Tinker") .. "</p> Secondary Touch", "")
    end
    return can
end

function AnyDisplay:client_canTinker(character)
	if self.data and self.data.noTouch then
        return false
    end

    return (not not self.c_dataTunnel.clicksAllowed) and self:cl_touchCheck()
end

function AnyDisplay:cl_pushStack(stack)
    if self.disableState or not scomputers.isComputerConnected(self.interactable) then
        return
    end
    
    if self.sendedData_cl_pushStack then
        if self.sendedData_cl_pushStack.force or needPushStack(self.canvas, self.c_dataTunnel, sc.deltaTime) then
            local startTime = os.clock()
            self.canvas.pushStack(self.sendedData_cl_pushStack)
            self.canvas.flush(self.sendedData_cl_pushStack.forceForce)
            self.sendedData_cl_pushStack = nil
            self:lagDetector(os.clock() - startTime, sc.clockLagMul)
        end
        return
    elseif self.stack then
		for _, action in ipairs(stack) do
			table.insert(self.stack, action)
		end
	else
		self.stack = stack
	end

	if stack.flush and (stack.force or needPushStack(self.canvas, self.c_dataTunnel, sc.deltaTime)) then
        local startTime = os.clock()
		self.canvas.pushStack(self.stack)
		self.canvas.flush(stack.forceForce)
		self.stack = nil
        self:lagDetector(os.clock() - startTime, sc.clockLagMul)
	end
end

function AnyDisplay:cl_dataTunnel(data)
	self.c_dataTunnel = data
    if data.display_reset then
        self.canvas.drawerReset()
    end
    self.canvas.pushDataTunnelParams(data)
end
end
function scmframework_99466ff28d6e1f31ecce1c60151aafa7() --$CONTENT_DATA/Scripts/Displays/old/AnyDisplay.lua
--dofile "$CONTENT_DATA/Scripts/Displays/DisplayBase.lua"
--dofile "$CONTENT_DATA/Scripts/Displays/old/DisplayBase.lua"

AnyDisplay = class(nil)

AnyDisplay.maxParentCount = 1
AnyDisplay.maxChildCount = 0
AnyDisplay.connectionInput = sm.interactable.connectionType.composite
AnyDisplay.colorNormal = sm.color.new(0xbbbb1aff)
AnyDisplay.colorHighlight = sm.color.new(0xecec1fff)
AnyDisplay.componentType = "display"


-- SERVER --


function AnyDisplay.server_onCreate(self)
	self.display = self.display or sc.display.createDisplay(self, self.data.x, self.data.y, self.data.v)
	sc.display.server_init(self.display)
end

function AnyDisplay.server_onDestroy(self)
	sc.display.server_destroy(self.display)
end

function AnyDisplay.server_onFixedUpdate(self, dt)
	sc.display.server_update(self.display, dt)
end

function AnyDisplay.server_recvPress(self, p, caller)
	sc.display.server_recvPress(self.display, p, caller)
end

function AnyDisplay.server_onDataRequired(self, client)
	sc.display.server_onDataRequired(self.display, client)
end

-- CLIENT --

function AnyDisplay.client_onReceiveDrawStack(self, stack)
	sc.display.client_drawStack(self.display, stack)
end

function AnyDisplay.client_onCreate(self)
	self.display = self.display or sc.display.createDisplay(self, self.data.x, self.data.y, self.data.v)
	sc.display.client_init(self.display)
end

function AnyDisplay.client_onDestroy(self)
	sc.display.client_destroy(self.display)
end

function AnyDisplay.client_onFixedUpdate(self, dt)
	sc.display.client_update(self.display, dt)
end

function AnyDisplay.client_onInteract(self, character, state)
	sc.display.client_onInteract(self.display, character, state)
end

function AnyDisplay:client_onProjectile(position, airTime, velocity, projectileName, shooter, damage, customData, normal, uuid)
	sc.display.client_onClick(self.display, 1, "pressed", normal)
	sc.display.client_onClick(self.display, 1, "released", normal)
end

function AnyDisplay.client_canInteract(self, character)
	return sc.display.client_canInteract(self.display, character)
end

function AnyDisplay.client_canTinker(self, character)
	return sc.display.client_canTinker(self.display, character)
end

function AnyDisplay.client_onTinker(self, character, state)
	sc.display.client_onTinker(self.display, character, state)
end

function AnyDisplay.client_onDataResponse(self, data)
	sc.display.client_onDataResponse(self.display, data)
end
end
function scmframework_b3d6addb3830c6bcb33351b646e22a1b() --$CONTENT_DATA/Scripts/Displays/old/basegraphic.lua
local type = type
local _utf8_code = utf8.code
local _utf8_sub = utf8.sub
local _utf8_len = utf8.len
local string_sub = string.sub
local string_len = string.len
local math_floor = math.floor
local string_char = string.char
local string_byte = string.byte
local ipairs = ipairs
local pairs = pairs
local table_insert = table.insert

local math_max = math.max
local math_min = math.min

local font_chars = legacyFont.optimized
local font_width = legacyFont.width
local font_height = legacyFont.height



local function loadChar(font, c)
	local chars = font and font.chars or font_chars
	local pixels = chars[c]
	if not pixels and type(c) == "number" then
		pixels = chars[string_char(c)]
	end
	if pixels then return pixels end
	return chars.error or font_chars.error
end

local function drawChar(self, font, drawPixel, x, y, c, color)
	local pixels = loadChar(font, c)
	local v
	for i = 1, #pixels do
		v = pixels[i]
		drawPixel(self, x + v[1], y + v[2], color)
	end
end

function basegraphic_checkFont(font)
	if type(font) ~= "table" then
		error("the font should be a table", 3)
	end
	if type(font.chars) ~= "table" or type(font.width) ~= "number" or type(font.height) ~= "number" then
		error("font failed integrity check", 3)
	end
	if font.width > 32 then
		error("the font width should not exceed 32", 3)
	end
	if font.height > 32 then
		error("the font height should not exceed 32", 3)
	end
	for char, data in pairs(font.chars) do
		if type(char) ~= "string" or type(data) ~= "table" or #data ~= font.height then
			error("font failed integrity check", 3)
		end
		for _, line in ipairs(data) do
			if type(line) ~= "string" or #line ~= font.width then
				error("font failed integrity check", 3)
			end
		end
	end
end

function basegraphic_printText(font, utf8support, self, drawPixel, drawPixelForce, x, y, width, height, text, color)
    --x = math_floor(x)
	--y = math_floor(y)

    local font_width = font and font.width or font_width
	local font_height = font and font.height or font_height

    if not self.printData or font ~= self.printData_old_font or utf8support ~= self.printData_old_utf8support then
        self.printData = {textcache = {}, textcount = 0}
        self.printData_old_font = font
        self.printData_old_utf8support = utf8support
    end
    local printData = self.printData

    if printData.textcache[text] then
        local dat, px, py = printData.textcache[text]
        for i = 1, dat.n do
            px, py = x + dat[i][1], y + dat[i][2]
            if px >= (width + font_width) then
                return
            end
            if px >= 0 and py >= 0 and px < width and py < height then
                drawPixelForce(self, px, py, color)
            end
        end
        return
    end

	local sub, flen, byte
	if utf8support then
		sub = _utf8_sub
		flen = _utf8_len
		byte = _utf8_code
	else
		sub = string_sub
		flen = string_len
		byte = string_byte
	end

	local len = flen(text)

	if x < 0 then
		local ic = 1
		while x + font_width < 0 do
			x = x + font_width + 1
			ic = ic + 1
			if ic > len or x >= width then
				return
			end
		end
		drawChar(self, font, drawPixel, x, y, sub(text, ic, ic), color)
		x = x + font_width + 1
		text = sub(text, ic + 1, len)
		len = len - ic
	end

	--старый вариант
	--if y >= 0 and (y + font_height) < self.height then
    --вот допустим размер шрифта по вертикали 1, в таком случаи предельное значения(например 127) окажеться не в пределах, так как 127 + 1 это 128, а 128 не меньше 128
	
	local ex, c
	if y >= 0 and (y + font_height) <= height then
		for i = 1, len do
			c = byte(text, i)

			ex = x + font_width
			if ex < width then
				drawChar(self, font, drawPixelForce, x, y, c, color)
			else
				drawChar(self, font, drawPixel, x, y, c, color)
				break
			end
			x = ex + 1
		end
	else
		for i = 1, len do
			c = byte(text, i)

			ex = x + font_width
			drawChar(self, font, drawPixel, x, y, c, color)
			if ex >= width then
				break
			end
			x = ex + 1
		end
	end

    if printData.textcount >= 256 then
        for key in pairs(printData.textcache) do
            printData.textcache[key] = nil
            break
        end
        printData.textcount = printData.textcount - 1
    end

    ex = {}
    local tbli = 1
    for i = 1, flen(text) do
        c = loadChar(font, byte(text, i))
        for i2 = 1, #c do
            ex[tbli] = {c[i2][1] + ((i - 1) * (font_width + 1)), c[i2][2]}
            tbli = tbli + 1
        end
    end
    ex.n = #ex
    printData.textcache[text] = ex
    printData.textcount = printData.textcount + 1
end
local basegraphic_printText = basegraphic_printText

function basegraphic_drawLine(x, y, x1, y1, color, width, height, buffer1)
	--x = math_floor(x)
	--y = math_floor(y)
	--x1 = math_floor(x1)
	--y1 = math_floor(y1)

	local sign_x, sign_y

	local clip_xmin = 0
	local clip_xmax = width - 1

	local clip_ymin = 0
	local clip_ymax = height - 1

	if x == x1 then
		if x < clip_xmin or x > clip_xmax then return end

		if y <= y1 then
			if y1 < clip_ymin or y > clip_xmax then return end

			y = math_max(y, clip_ymin)
			y1 = math_min(y1, clip_ymax)

			for iy = y, y1 do
				buffer1[x + (iy * width)] = color
			end
		else
			if y < clip_ymin or y1 > clip_ymax then return end

			y1 = math_max(y1, clip_ymin)
			y = math_min(y, clip_ymax)

			for iy = y, y1, -1 do
				buffer1[x + (iy * width)] = color
			end
		end

		return
	end

	if y == y1 then
		if y < clip_ymin or y > clip_ymax then return end

		if x <= x1 then
			if x1 < clip_xmin or x > clip_xmax then return end

			x = math_max(x, clip_xmin)
			x1 = math_min(x1, clip_xmax)

			for ix = x, x1 do
				buffer1[ix + (y * width)] = color
			end
		else
			if x < clip_xmin or x1 > clip_xmax then return end

			x1 = math_max(x1, clip_xmin)
			x = math_min(x, clip_xmax)

			for ix = x, x1, -1 do
				buffer1[ix + (y * width)] = color
			end
		end

		return
	end

	if x < x1 then
		if x > clip_xmax or x1 < clip_xmin then return end
		sign_x = 1
	else
		if x1 > clip_xmax or x < clip_xmin then return end
		x = -x
		x1 = -x1
		clip_xmin, clip_xmax = -clip_xmax, -clip_xmin

		sign_x = -1
	end

	if y < y1 then
		if y > clip_ymax or y1 < clip_ymin then return end
		sign_y = 1
	else
		if y1 > clip_ymax or y < clip_ymin then return end
		y = -y
		y1 = -y1
		clip_ymin, clip_ymax = -clip_ymax, -clip_ymin

		sign_y = -1
	end

	local delta_x = x1 - x
	local delta_y = y1 - y

	local delta_x_step = 2 * delta_x
	local delta_y_step = 2 * delta_y

	local xpos = x
	local ypos = y

	if delta_x >= delta_y then
		local error = delta_y_step - delta_x
		local exit = false

		if y < clip_ymin then
			local temp = (2 * (clip_ymin - y) - 1) * delta_x
			local msd = math_floor(temp / delta_y_step)

			xpos = xpos + msd

			if xpos > clip_xmax then return end

			if xpos >= clip_xmin then
				local rem = temp - msd * delta_y_step

				ypos = clip_ymin
				error = error - rem - delta_x

				if rem > 0 then
					xpos = xpos + 1
					error = error + delta_y_step
				end

				exit = true
			end
		end

		if not exit and x < clip_xmin then
			local temp = delta_y_step * (clip_xmin - x)
			local msd = math_floor(temp / delta_x_step)

			ypos = ypos + msd
			local rem = temp % delta_x_step

			if ypos > clip_ymax or (ypos == clip_ymax and rem >= delta_x) then return end

			xpos = clip_xmin
			error = error + rem

			if rem >= delta_x then
				ypos = ypos + 1
				error = error - delta_x_step
			end
		end

		local xpos_end = x1

		if y1 > clip_ymax then
			local temp = delta_x_step * (clip_ymax - y) + delta_x
			local msd = math_floor(temp / delta_y_step)

			xpos_end = x + msd

			if (temp - msd * delta_y_step) == 0 then
				xpos_end = xpos_end - 1
			end
		end

		xpos_end = math_min(xpos_end, clip_xmax) + 1

		if sign_y == -1 then 
			ypos = -ypos 
		end
		if sign_x == -1 then -- TODO * sign
			xpos = -xpos
			xpos_end = -xpos_end
		end

		delta_x_step = delta_x_step - delta_y_step

		while xpos ~= xpos_end do
			buffer1[xpos + (ypos * width)] = color

			if error >= 0 then
				ypos = ypos + sign_y
				error = error - delta_x_step
			else
				error = error + delta_y_step
			end

			xpos = xpos + sign_x
		end
	else
		local error = delta_x_step - delta_y
		local exit = false

		if x < clip_xmin then
			local temp = (2 * (clip_xmin - x) - 1) * delta_y
			local msd = math_floor(temp / delta_x_step)
			ypos = ypos + msd

			if ypos > clip_ymax then return end

			if ypos >= clip_ymin then
				local rem = temp - msd * delta_x_step

				xpos = clip_xmin
				error = error - rem - delta_y

				if rem > 0 then
					ypos = ypos + 1
					error = error + delta_x_step
				end

				exit = true
			end
		end

		if not exit and y < clip_ymin then
			local temp = delta_x_step * (clip_ymin - y)
			local msd = math_floor(temp / delta_y_step)

			xpos = xpos + msd

			local rem = temp % delta_y_step

			if xpos > clip_xmax or (xpos == clip_xmax and rem >= delta_y) then return end

			ypos = clip_ymin
			error = error + rem

			if rem >= delta_y then
				xpos = xpos + 1
				error = error - delta_y_step
			end
		end

		local ypos_end = y1

		if x1 > clip_xmax then
			local temp = delta_y_step * (clip_xmax - x) + delta_y
			local msd = math_floor(temp / delta_x_step)

			ypos_end = y + msd

			if (temp - msd * delta_x_step) == 0 then
				ypos_end = ypos_end - 1
			end
		end

		ypos_end = math_min(ypos_end, clip_ymax) + 1

		if sign_x == -1 then -- TODO * sign
			xpos = -xpos
		end
		if sign_y == -1 then
			ypos = -ypos
			ypos_end = -ypos_end
		end

		delta_y_step = delta_y_step - delta_x_step

		while ypos ~= ypos_end do
			buffer1[xpos + (ypos * width)] = color

			if error >= 0 then
				xpos = xpos + sign_x
				error = error - delta_y_step
			else
				error = error + delta_x_step
			end

			ypos = ypos + sign_y
		end
	end
end
local basegraphic_drawLine = basegraphic_drawLine

local function pointIn(dx, dy, cr_sq)
	return dx*dx + dy*dy <= cr_sq
end

function quadInCircle(qx, qy, qs, cx, cy, cr)
	local lx = qx - cx
	local ly = qy - cy
	local cr_sq = cr*cr
	return pointIn(lx, ly, cr_sq) and pointIn(lx + qs, ly, cr_sq) and pointIn(lx, ly + qs, cr_sq) and pointIn(lx + qs, ly + qs, cr_sq)
end
local quadInCircle = quadInCircle

function basegraphic_doFont(self, val)
	if val[1] == -1 then
		self.customFont = nil
	elseif val[1] == -2 then
		self.customFont = {width = val[2], height = val[3], chars = {}}
	elseif val[1] == -3 then
		self.customFont.chars[val[2]] = val[3]
	end
end
local basegraphic_doFont = basegraphic_doFont

local blackCol = sm.color.new(0, 0, 0)
local minRectFillSize = 8
local buffer1, buffer2 --recreating variables overloads the garbage collector (and creates freezes)
local formatColor = sc.formatColor
local col, v
local posDX_x
local negDX_x
local posDX_y
local negDX_y
local posDY_y
local negDY_y
local posDY_x
local negDY_x
local x
local y
local r
local lx
local ly
local d
local nx, ny, px, py
local isEffect
local buffer1All
local buffer2All
local col
local i2
local i
local pself
function basegraphic_doubleBuffering(self, stack, width, height, utf8support, flush, optimize, rectFlush)
	buffer1 = self.buffer1

	if stack then
		local function draw(_, x, y, color)
			if x >= 0 and y >= 0 and x < width and y < height then
				buffer1[x + (y * width)] = color
			end
		end

		local function drawCircle_putpixel(cx, cy, x, y, color)
			posDX_x = cx + x
			negDX_x = cx - x
			posDX_y = cx + y
			negDX_y = cx - y
			posDY_y = cy + y
			negDY_y = cy - y
			posDY_x = cy + x
			negDY_x = cy - x
		
			draw(nil, posDX_x, posDY_y, color)
			draw(nil, negDX_x, posDY_y, color)
			draw(nil, posDX_x, negDY_y, color)
			draw(nil, negDX_x, negDY_y, color)
			draw(nil, posDX_y, posDY_x, color)
			draw(nil, negDX_y, posDY_x, color)
			draw(nil, posDX_y, negDY_x, color)
			draw(nil, negDX_y, negDY_x, color)
		end

		col, v = nil, nil
		for i = 1, #stack do
			v = stack[i]
			if v[1] >= 0 then
				col = formatColor(v[2], v[1] == 0)
			end

			if v[1] == 0 then
				buffer1 = {}
				self.buffer1 = buffer1
				self.buffer1All = col
			elseif v[1] == 1 then
				buffer1[v[3] + (v[4] * width)] = col
			elseif v[1] == 2 then
				--[[
				for ix = v[3], v[3] + (v[5] - 1) do
					for iy = v[4], v[4] + (v[6] - 1) do
						if ix == v[3] or iy == v[4] or ix == (v[3] + (v[5] - 1)) or iy == (v[4] + (v[6] - 1)) then
							buffer1[ix + (iy * width)] = col
						end
					end
				end
				]]
				x = v[3]
				y = v[4]
				lx = v[5]
				ly = v[6]
				px = x + (lx - 1)
				py = y + (ly - 1)
				for ix = x, px do
					buffer1[ix + (y * width)] = col
					buffer1[ix + (py * width)] = col
				end
				for iy = y + 1, py - 1 do
					buffer1[x + (iy * width)] = col
					buffer1[px + (iy * width)] = col
				end
			elseif v[1] == 3 then
				for ix = v[3], v[3] + (v[5] - 1) do
					for iy = v[4], v[4] + (v[6] - 1) do
						buffer1[ix + (iy * width)] = col
					end
				end
			elseif v[1] == 4 then
				x = v[3]
				y = v[4]
				r = v[5]
				lx = 0
				ly = r
				d = 3 - 2 * r

				drawCircle_putpixel(x, y, lx, ly, col)
				while ly >= lx do
					lx = lx + 1

					if d > 0 then
						ly = ly - 1
						d = d + 4 * (lx - ly) + 10
					else
						d = d + 4 * lx + 6
					end

					drawCircle_putpixel(x, y, lx, ly, col)
				end
			elseif v[1] == 5 then
				nx, ny = v[3], v[4]
				x = math_floor(v[3])
				y = math_floor(v[4])
				r = v[5]
				px, py = nil, nil
				for ix = math_max(-r, -x), math_min(r, (width - x) - 1) do
					px = x + ix
					for iy = math_max(-r, -y), math_min(r, (height - y) - 1) do
						py = y + iy
						if quadInCircle(px, py, 1, nx, ny, r) then
							buffer1[px + (py * width)] = col
						end
					end
				end
			elseif v[1] == 6 then
				basegraphic_drawLine(v[3], v[4], v[5], v[6], col, width, height, buffer1)
			elseif v[1] == 7 then
				basegraphic_printText(self.customFont, utf8support, self, draw, draw, v[3], v[4], width, height, v[5], col)
			else
				basegraphic_doFont(self, v)
			end
		end
	end

	if flush then
		pself = self.quadTree or self

		isEffect = false
		buffer1All = self.buffer1All or blackCol
		buffer2All = self.buffer2All
		buffer2 = self.buffer2
		col = nil
	
		if rectFlush then
			--print("rect start")
			i = 0
			i2 = 1
			while i < width * height do
				col = buffer1[i] or buffer1All
				if col ~= (buffer2[i] or buffer2All) then
					x = i % width
					y = math_floor(i / width)

					--lx = math_min(width - 1, x + maxRectFillSize)
					--ly = math_min(height - 1, y + maxRectFillSize)
					lx = width
					ly = height
					for ix = x + 1, lx do
						--if (buffer1[ix + (y * width)] or buffer1All) ~= col or (buffer2[ix + (y * width)] or buffer2All) == col or ix == lx then
						if (buffer1[ix + (y * width)] or buffer1All) ~= col or ix == lx then
							for iy = y + 1, ly do
								if (buffer1[ix + (iy * width)] or buffer1All) ~= col or (buffer2[ix + (iy * width)] or buffer2All) == col or iy == ly then
									--print((buffer1[ix + (iy * width)] or buffer1All) ~= col, ix >= width, iy >= height)
									nx = ix - x
									ny = iy - y
									if nx > 1 and ny > 1 and (nx >= minRectFillSize or ny >= minRectFillSize) then
										for ix2 = x, x + (nx - 1) do
											for iy2 = y, y + (ny - 1) do
												buffer2[ix2 + (iy2 * width)] = col
											end
										end

										--print(x, y, nx, ny, col)
										rectFlush(pself, x, y, nx, ny, col)
										--rectFlush(pself, x, y, nx, ny, sm.color.new(math.random(), math.random(), math.random()))

										isEffect = true
										if optimize and i2 % 64 == 0 then optimize(self) end
										i2 = i2 + 1
									end

									break
								end
							end
							break
						end
					end
				end
				i = i + 1
			end

			--print("rect stop")
		end

		i = 0
		i2 = 1
		while i < width * height do
			--::continue::
			col = buffer1[i] or buffer1All
			if col ~= (buffer2[i] or buffer2All) then
				--[[
				if rectFlush then
					local rectSize = 0
					local oldI = i
					while col == (buffer1[i + 1] or buffer1All) and i % width ~= 0 do
						i = i + 1
						rectSize = rectSize + 1
					end
					if rectSize > 0 then
						isEffect = true
						rectFlush(self, math_floor(oldI % width), math_floor(oldI / width), rectSize, 1, col)
						if optimize and i2 % 64 == 0 then optimize(self) end
						i2 = i2 + 1
						goto continue
					end
				end
				]]
				if not flush(pself, i % width, math_floor(i / width), col) then
					isEffect = true
					if optimize and i2 % 1024 == 0 then optimize(self) end
					i2 = i2 + 1
				end
				buffer2[i] = col
			end
			i = i + 1
		end
		return isEffect
	end
end

--[[
function basegraphic_bufferingBudget(self, width, height, profitableQuantity)
	buffer1, buffer2 = self.buffer1, self.buffer2
	i = 0
	i2 = 0
	while i < width * height do
		col = buffer1[i] or buffer1All
		if col ~= (buffer2[i] or buffer2All) then
			i2 = i2 + 1
			if i2 > profitableQuantity then
				return true
			end
		end
		i = i + 1
	end
end
]]
end
function scmframework_45f037fa0dc98a21f85c8a54bd364dbd() --$CONTENT_DATA/Scripts/Displays/old/DisplayBase.lua
--[[
    THIS CODE IS FULL OF CRAP
    I KNOW IT'S TERRIBLE, AND I'M REFINING IT
]]

-- debug / settings
debug_out = false
debug_printeffects = false
debug_disabletext = false
debug_disableoptimize = false
debug_raycast = false
debug_offset = false
debug_disableEffectsBuffer = false
debug_disableSimpleCheck = false
debug_disableForceNativeRender = false
--debug_disableUpdateColor = false
debug_noNativeRender = false
debug_disableRectBufferFill = true
mul_ray_fov = 2

--code
if __displayBaseLoaded then return end
__displayBaseLoaded = true

dofile "$CONTENT_DATA/Scripts/Config.lua"
dofile("$CONTENT_DATA/Scripts/Displays/old/legacyFont.lua")
dofile("$CONTENT_DATA/Scripts/Displays/old/basegraphic.lua")

local vnetwork = vnetwork
local sc = sc
local sm = sm
local probability = probability
local checkArg = checkArg

sc.display.drawType = {
    clear = 0,
    drawPixel = 1,
    drawRect = 2,
    fillRect = 3,
    drawCircle = 4,
    fillCircle = 5,
    drawLine = 6,
    drawText = 7,
    optimize = 8,
}

local tableChecksum = tableChecksum

local floor = math.floor
local function nRound(num)
    return floor(num + 0.5)
end

--local _utf8 = string
local splitByMaxSize = splitByMaxSize
local string = string
local _utf8 = utf8
local sc_display_drawType = sc.display.drawType
local constrain, mathDist = constrain, mathDist

sc.display.PIXEL_SCALE = 0.0072
sc.display.RENDER_DISTANCE = 15

local oopsUuid = sm.uuid.new("c3931873-eadc-4e46-a575-0a369ae01202")
local cursorUuid = sm.uuid.new("77e46b76-0b2e-4a00-86e4-d030b8d9b59d")

local RENDER_DISTANCE = sc.display.RENDER_DISTANCE

local sm_camera_getRotation = sm.camera.getRotation
local sm_camera_getFov = sm.camera.getFov

local sm_isHost = sm.isHost
local sm_effect_createEffect = sm.effect.createEffect
local sm_quat_fromEuler = sm.quat.fromEuler

local table_insert = table.insert
local table_remove = table.remove

local tostring = tostring
local tonumber = tonumber
local math_rad = math.rad
local math_random = math.random
local math_floor = math.floor
local math_abs = math.abs
local math_max = math.max
local math_min = math.min
local math_ceil = math.ceil
--local string_sub = string.sub
local string_byte = string.byte
--local table_pack = table.pack

local sm_exists = sm.exists
local pairs = pairs
local print = print
local type = type
local unpack = unpack
local getCurrentTick = sm.game.getCurrentTick
local sm_localPlayer = sm.localPlayer
local sm_localPlayer_getPlayer = sm_localPlayer.getPlayer
local os_clock = os.clock

local sm_vec3 = sm.vec3
local util_clamp = sm.util.clamp
local sm_vec3_new = sm.vec3.new
local sc_display_PIXEL_SCALE = sc.display.PIXEL_SCALE

local formatColor = sc.formatColor
--local formatColorStr = sc.formatColorStr

local emptyEffect = sm.effect.createEffect(sc.getEffectName())
local effect_setParameter = emptyEffect.setParameter
local effect_stop = emptyEffect.stop
local effect_destroy = emptyEffect.destroy
local effect_start = emptyEffect.start
local effect_isDone = emptyEffect.isDone
local effect_isPlaying = emptyEffect.isPlaying
local effect_setScale = emptyEffect.setScale
local effect_setOffsetPosition = emptyEffect.setOffsetPosition
local effect_setOffsetRotation = emptyEffect.setOffsetRotation
--effect_stop(emptyEffect)
effect_destroy(emptyEffect)

local function effect_destroyAndUnreg(root, effect)
    root.effectsData[effect.id] = nil
    effect_destroy(effect)
end

local sm_camera_getPosition = sm.camera.getPosition

local quad_visibleRot = sm_quat_fromEuler(sm_vec3.zero())
local quad_hideRot = sm_quat_fromEuler(sm_vec3_new(0, 180, 0))

local quad_displayOffset = sm_vec3_new(-0.125, 0, 0)
--local quad_offsetRotation = sm_quat_fromEuler(sm_vec3_new(0, 0, 0))

local sm_physics_multicast = sm.physics.multicast
local sm_physics_filter_dynamicBody = sm.physics.filter.dynamicBody
local sm_physics_filter_staticBody = sm.physics.filter.staticBody
local filter_body = sm_physics_filter_dynamicBody + sm_physics_filter_staticBody

local displayRaycastQuad = sm_quat_fromEuler(sm_vec3_new(90, 180, 0))
local function cl_displayRaycast(self, position, r)
    if _G.raycastCache and (getCurrentTick() - _G.raycastCache.time) < 20 then
        return _G.raycastCache.shapes
    end

    --[[
    local shapes = {}
    local maxoffset = math.pi / 3
    for x = -maxoffset, maxoffset, maxoffset / 10 do
        for y = -maxoffset, maxoffset, maxoffset / 10 do
            local offset = sm.vec3.new(
                0, --why does it work relative to the world and not relative to the player?
                0, --why does it work relative to the world and not relative to the player?
                y
            )
            

            local ok, result = sm.localPlayer.getRaycast(r, nil, sm.localPlayer.getDirection() + offset)
            
            if result.pointWorld then
                sm.debris.createDebris(
                    sm.uuid.new("d3db3f52-0a8d-4884-afd6-b4f2ac4365c2"),
                    result.pointWorld,
                    sm.quat.fromEuler(sm.vec3.new(0, 0, 0)),
                    sm.vec3.zero(),
                    sm.vec3.zero(),
                    sm.color.new(1, 0, 0),
                    1 / 40
                )
            end
            if ok and result and result.type == "body" then
                --sm.debugDraw.addSphere("11", result.pointWorld, 0.5, sm.color.new(1, 0, 0))
                shapes[result:getShape()] = result
            end
        end
    end
    ]]

    ----createRays
    local rotation = sm_camera_getRotation() * displayRaycastQuad

    local resolutionX, resolutionY = sc.restrictions.rays, sc.restrictions.rays
    local distance = r
    local fov = math_rad(sm_camera_getFov() * mul_ray_fov)
    local rays = {}
    local rays_idx = 1
    local u, v, direction
    for x = 1, resolutionX do
        for y = 1, resolutionY do
            u = ( x / resolutionX - 0.5 ) * fov
            v = ( y / resolutionY - 0.5 ) * fov

            direction = rotation * sm_vec3_new(-u, -v, 1)

            rays[rays_idx] = {
                type = "ray",
                startPoint = position,
                endPoint = position + direction * distance,
                mask = filter_body
            }
            rays_idx = rays_idx + 1
         end
    end

    ----raycasting
    local casts = sm_physics_multicast(rays)

    local shapes, shape = {}
    for _, data in pairs(casts) do
        if data[1] then
            shape = data[2]:getShape()
            if shape then
                shapes[shape] = data[2]
            end

            if debug_raycast then
                sm.debris.createDebris(
                    sm.uuid.new("d3db3f52-0a8d-4884-afd6-b4f2ac4365c2"),
                    data[2].pointWorld,
                    sm.quat.fromEuler(sm.vec3.new(0, 0, 0)),
                    sm.vec3.zero(),
                    sm.vec3.zero(),
                    sm.color.new(1, 0, 0),
                    1 / 40
                )
            end
        end
    end
    
    _G.raycastCache = {shapes = shapes, time = getCurrentTick()}
    return shapes
end

local function debug_print_force(...)
    print(...)
end

local function debug_print(...)
    if debug_out then
        print(...)
    end
end

local sc_display_shapesUuid = sm.uuid.new("708d4a47-7de7-49df-8ba3-e58083c2610e")
--local sc_display_shapesUuidGlass = sm.uuid.new("3d11dd1d-1296-414b-a2d9-101e876c022f")
local sc_display_shapesUuidGlass = sm.uuid.new("75708339-6420-41e4-88a0-fbc210826c14")

local sc_getEffectName = sc.getEffectName

local quadIntersectsCircle, quad_createNode, quad_createRoot, quad_updateEffectColor
local quad_createEffect, quad_effectHide, quad_effectShow, quad_destroy, quad_destroyEffect
local quad_destroyChildren, quad_optimize, quad_split
local quad_findChild
--local quad_treeMultiSetColor
local quad_treeSetColor
local quad_treeFillRect
local quad_treeFillCircle
--local quad_treeShow
--local quad_treeHide
local quad_rootRealShow
local quad_rootRealHide
local sc_display_client_clear
local sc_display_client_drawPixelForce
local sc_display_client_drawPixel
local sc_display_client_drawRect
local sc_display_client_fillRect
local sc_display_client_drawCircle
local sc_display_client_fillCircle
local sc_display_client_drawLine
local sc_display_client_optimize

local sm_color_new = sm.color.new
local black = sm_color_new("000000ff")
local white = sm_color_new("ffffffff")
local oopsColor = sm_color_new("ffff00ff")

local font_chars = legacyFont.optimized
local font_width = legacyFont.width
local font_height = legacyFont.height

--[[
local function pointInQuad(x, y, qx, qy, qs)
    return (x >= qx and x < qx + qs) and (y >= qy and y < qy + qs)
end

local function pointInCircle(x, y, cx, cy, cr)
    local dx = cx - x
    local dy = cy - y

    return dx*dx + dy*dy <= cr*cr
end
]]

local function quadInRect(qx, qy, qs, rx, ry, rw, rh)
    return (qx >= rx and qx + qs <= rx + rw) and (qy >= ry and qy + qs <= ry + rh)
end

local quadInCircle = quadInCircle

local function quadIntersectsRect(qx, qy, qs, rx, ry, rw, rh)
    return (qx < rx + rw and qx + qs > rx) and (qy < ry + rh and qy + qs > ry)
end

function quadIntersectsCircle(qx, qy, qs, cx, cy, cr)
    local clamp = util_clamp
    local closestX = clamp(cx, qx, qx + qs)
    local closestY = clamp(cy, qy, qy + qs)

    local dx = cx - closestX
    local dy = cy - closestY

    return dx*dx + dy*dy <= cr*cr
end

function quad_createNode(parent, x, y, sizeX, sizeY, color)
    local node =  {
        x = x,
        y = y,
        sizeX = sizeX,
        sizeY = sizeY,
        size = math_max(sizeX, sizeY),
        children = nil,
        parent = parent,
        effect = nil,
        color = color,
        root = parent.root,
        display = parent.root.display,
        --uroot = parent.root.display.quadTree
    }

    --[[
    print(color, parent.root.display.lastLastClearColor, color == parent.root.display.lastLastClearColor)
    if color == parent.root.display.lastLastClearColor then
        node.effect = quad_createEffect(node.root, x, y, sizeX, sizeY)
        --quad_updateEffectColor(node)
        effect_setParameter(node.effect, "color", sm.color.new(1, 0, 0))
        effect_setScale(node.effect, sm.vec3.new(0.01, 0.01, 0.01))
        return node
    end
    ]]

    if color ~= parent.root.display.lastLastClearColor or parent.root.display.scriptableObject.data.noDoubleEffect then
        node.effect = quad_createEffect(node.root, x, y, sizeX, sizeY)
        quad_updateEffectColor(node, true)
    end

    --if parent.root.display.isRendering then
    --    quad_treeShow(node)
    --end
    
    return node
end

function quad_createRoot(display, x, y, size, maxX, maxY)
    local node = {
        x = x,
        y = y,
        size = size,
        maxX = maxX,
        maxY = maxY,
        sizeX = maxX,
        sizeY = maxY,
        children = nil,
        parent = nil,
        effect = nil,
        color = nil,
        display = display,
        bufferedEffects = {},
        effectsData = {},
        bf_idx = 0,
        allEffects = {}
    }

    node.root = node
    if not display.scriptableObject.data.noDoubleEffect then
        node.back_effect = quad_createEffect(node, x, y, maxX, maxY, 0.0005, true)
    end

    --node.effect = quad_createEffect(node, x, y, maxX, maxY)

    --if display.isRendering then
    --    quad_treeShow(node)
    --end

    --node.uroot = node
    return node
end
--[[
local function raw_set_color(effect, color)
    --local colorChecksum = tableChecksum(color)
    --if effectsData[effect.id][1] ~= color then
        --print("COLORPUSH", effectsData[effect.id][1], color)
    effect_setParameter(effect, "color", color)
    --    effectsData[effect.id][1] = color
    --end
end
]]

local color
function quad_updateEffectColor(self, force)
    --if debug_disableUpdateColor then return end

    --if not self.effect or not sm_exists(self.effect) then return end
    color = self.color

    --if color ~= self.display.lastLastClearColor or force then
        --effect_setScale(effect, sm.vec3.new(0.02, 0.02, 0.02))

    if color ~= self.root.display.lastLastClearColor or self.root.display.scriptableObject.data.noDoubleEffect then
        if not self.effect then
            self.effect = quad_createEffect(self.root, self.x, self.y, self.sizeX, self.sizeY)
        end

        --raw_set_color(self.effect, color)
        return effect_setParameter(self.effect, "color", color)
    else
        if self.effect and sm_exists(self.effect) then
            --effect_destroy(self.effect)
            --self.root.allEffects[self.effect] = nil
            quad_destroyEffect(self)
        end
        self.effect = nil
    end
    --end

    --effect_setParameter(self.effect, "color", color)
end

function quad_destroy(self, removeAll)
    if self.children then
        quad_destroyChildren(self)
    end
    quad_destroyEffect(self)


    if removeAll then
        debug_print("removeAll")
        
        --effect_stop(self.back_effect)
        if self.back_effect then
            effect_destroyAndUnreg(self, self.back_effect)
        end
        for effect in pairs(self.allEffects) do
            if effect and sm_exists(effect) then
                --effect_stop(effect)
                effect_destroyAndUnreg(self, effect)
            end
        end
        self.allEffects = {}
        self.bufferedEffects = {}
        self.bf_idx = 1
    end
end

local function getWidth(self)
    if self.quadTree.rotation == 1 or self.quadTree.rotation == 3 then
        return self.height
    else
        return self.width
    end
end

local function getHeight(self)
    if self.quadTree.rotation == 1 or self.quadTree.rotation == 3 then
        return self.width
    else
        return self.height
    end
end

local quad_alt_hideRot = sm_quat_fromEuler(sm_vec3_new(0, 90, 0))
local quad_alt_visibleRot = sm_quat_fromEuler(sm_vec3_new(0, 180 + 90, 0))
local vec3_011 = sm_vec3_new(0, 1, 1)

function quad_createEffect(root, x, y, sizeX, sizeY, z, nonBuf, nativeScale, wide, uuid)
    --local attemptRemove

    --::attempt::

    local rmaxX = root.maxX
    local rmaxY = root.maxY
    local reverseX, reverseY, changeXY

    if root.rotation == 1 then
        changeXY = true
        reverseX = true
    elseif root.rotation == 2 then
        reverseX = true
        reverseY = true
    elseif root.rotation == 3 then
        changeXY = true
        reverseY = true
    end

    if changeXY then
        x, y = y, x
        --rmaxX, rmaxY = rmaxY, rmaxX
        --sizeX, sizeY = sizeY, sizeX
    end
    if reverseX then x = (rmaxX - x) - sizeX end
    if reverseY then y = (rmaxY - y) - sizeY end
    
    if x < 0 then x = 0 end
    if y < 0 then y = 0 end
    if x > rmaxX then x = rmaxX end
    if y > rmaxY then y = rmaxY end
    if x + sizeX > rmaxX then sizeX = sizeX - ((x + (sizeX)) - rmaxX) end
    if y + sizeY > rmaxY then sizeY = sizeY - ((y + (sizeY)) - rmaxY) end

    local effect
    local display = root.display

    if not nonBuf and root.bf_idx > 0 and not debug_disableEffectsBuffer then
        effect = table_remove(root.bufferedEffects)
        --if effect_isDone(effect) then
        --    effect_start(effect)
        --end
        root.bf_idx = root.bf_idx - 1
    else
        --if total_effects < (1050000) then
            --debug_print(effectsNames[currentEffect])

            effect = sm_effect_createEffect(sc_getEffectName(), display.scriptableObject.character or display.scriptableObject.interactable)
            --effect = {stop = function() end, start = function() end, destroy = function() end,
            --setScale = function() end, setOffsetPosition = function() end, setOffsetRotation = function() end,
            --setParameter = function() end, id = math.random(0, 99999), trash = string.rep(" ", 1024 * 8)}
            --print("create_id", effect.id)

            if display.scriptableObject and display.scriptableObject.data.glass then
                effect_setParameter(effect, "uuid", uuid or sc_display_shapesUuidGlass)
            else
                effect_setParameter(effect, "uuid", uuid or sc_display_shapesUuid)
            end
            
            --effect:start()

            if not nonBuf and display.newEffects then
                display.newEffects[effect] = true
            end
            if not nonBuf then
                root.allEffects[effect] = true
            end

            --[[
            if effect and sm_exists(effect) then
                if not nonBuf then
                    
                end
            else
                debug_print("EFFECTS OVERFLOW!!!!", total_effects)
            end
            ]]
        --else
            --[[
            if attemptRemove then
                return
            else
                local count = 0
                for effect in pairs(root.allEffects) do
                    if effect and sm_exists(effect) then
                        quad_effectHide(effect)
                        table_insert(bufferedEffects, effect)
                        
                        count = count + 1
                        if count >= 50 then
                            break
                        end

                        debug_print("super quad_destroyEffect")
                    end
                end
                    

                attemptRemove = true
                goto attempt
            end
            ]]
        --end
    end

    if not effect or not sm_exists(effect) then return effect end

    local scale = sc_display_PIXEL_SCALE * display.pixelScale
    local vx = scale * sizeX + 1e-4
    local vy = scale * sizeY + 1e-4

    wide = wide or 0
    if display.scriptableObject.data and display.scriptableObject.data.wide then
        wide = display.scriptableObject.data.wide
    end

    local vecScale = sm_vec3_new(wide, vy, vx)
    if nativeScale then
        effect_setScale(effect, sm_vec3_new(wide, sizeX, sizeY))
    else
        effect_setScale(effect, vecScale)
    end

    local offset = sm_vec3_new(0, y - display.height/2 + sizeY/2, display.width/2 - x - sizeX/2) * scale
    offset.x = z or (debug_offset and -1 or 0)

    local chr = display.scriptableObject.character
    if chr then
        local x, y, z = offset.x, offset.y, offset.z
        offset.z = x
        offset.x = z
        offset.y = -y
        offset = offset + vec3_011
    else
        local loff = quad_displayOffset
        if display.scriptableObject.data and display.scriptableObject.data.zpos then
            loff = sm_vec3_new(display.scriptableObject.data.zpos, 0, 0)
        end
        offset = loff + offset

        if display.scriptableObject.data and display.scriptableObject.data.offset then
            offset = offset + sm_vec3_new(0, display.scriptableObject.data.offset / 4, 0)
        end
    end

    effect_setOffsetPosition(effect, offset)

    local tbl = {nil, nil, display.scriptableObject.data or {}, sizeX, sizeY, offset}
    if chr then
        tbl[7] = quad_alt_hideRot
        tbl[8] = quad_alt_visibleRot
    else
        tbl[7] = quad_hideRot
        tbl[8] = quad_visibleRot
    end
    local datatbl = root.effectsData[effect.id]
    if datatbl then
        for k, v in pairs(tbl) do
            datatbl[k] = v
        end
    else
        root.effectsData[effect.id] = tbl
    end
    quad_effectShow(root, effect)
    
    return effect
end

function quad_destroyEffect(self)
    local effect = self.effect

    if effect and sm_exists(effect) then
        if debug_disableEffectsBuffer then
            effect_destroyAndUnreg(self.root, effect)
            self.root.allEffects[effect] = nil
        else
            quad_effectHide(self.root, effect)
            self.root.bf_idx = self.root.bf_idx + 1
            self.root.bufferedEffects[self.root.bf_idx] = effect
        end
    end

    self.effect = nil
end

local hideOffset = sm_vec3_new(10000000, 10000000, 10000000)

function quad_effectHide(root, effect)
    if effect and sm_exists(effect) then
        local data = root.effectsData[effect.id]
        if data[3] and data[3].noRotateEffects then
            return effect_setOffsetPosition(effect, hideOffset)
        else
            return effect_setOffsetRotation(effect, data[7])
        end
    end
end

function quad_effectShow(root, effect)
    if effect and sm_exists(effect) then
        local data = root.effectsData[effect.id]
        if data[3] and data[3].noRotateEffects then
            return effect_setOffsetPosition(effect, data[6])
        else
            return effect_setOffsetRotation(effect, data[8])
        end
    end
end

function quad_destroyChildren(self)
    local children = self.children

    quad_destroy(children[1])
    quad_destroy(children[2])
    quad_destroy(children[3])
    quad_destroy(children[4])

    self.children = nil
    self.effect = quad_createEffect(self.root, self.x, self.y, self.size, self.size)
end


function quad_optimize(self)
    if debug_disableoptimize then return end

    local children = self.children
    if children then
        --debug_print("children found!!!")

        quad_optimize(children[1])
        quad_optimize(children[2])
        quad_optimize(children[3])
        quad_optimize(children[4])

        local color = children[1].color
        
        -- check children the same color
        local same = true
        for i = 2, 4 do
            if children[i].color ~= color then
                --debug_print("color is not equals", tostring(children[i].color), tostring(color))
                same = false
                break
            end
        end

        --[[
        local same = false
        for i = 2, 4 do
            if children[i].color == color then
                --debug_print("color is not equals", tostring(children[i].color), tostring(color))
                same = true
                break
            end
        end
        ]]

        if color and same then
            --debug_print("quad_optimize successful")

            quad_destroyChildren(self)

            --[[
            quad_destroy(children[1])
            for i = 2, 4 do
                if children[i].color == color then quad_destroy(children[i]) end
            end

            self.children = nil
            self.effect = quad_createEffect(self.root, self.x, self.y, self.sizeX, self.sizeY)
            ]]



            self.color = color
            return quad_updateEffectColor(self)

            --if self.root.display.isRendering then
            --    quad_effectShow(self.effect)
            --end
        end
    end

    --return not not children
end

function quad_split(self)
    --assert(self.children == nil, "quad node already has children")
    --assert(self.size > 1, "cant split size 1")

    --quad_effectHide(self.effect)
    quad_destroyEffect(self)

    local hsize = self.size / 2
    local x = self.x
    local y = self.y
    local color = self.color

    self.children = {
        quad_createNode(self, x, y, hsize, hsize, color),
        quad_createNode(self, x + hsize, y, hsize, hsize, color),
        quad_createNode(self, x, y + hsize, hsize, hsize, color),
        quad_createNode(self, x + hsize, y + hsize, hsize, hsize, color)
    }

    self.color = nil
end

function quad_findChild(self, tx, ty, size)
    if self.size ~= size then
        if not self.children then quad_split(self) end

        local hsize = self.size / 2

        local i = math_floor((tx - self.x) / hsize) + 2 * math_floor((ty - self.y) / hsize)
        --assert(self.children[i + 1] ~= nil, "children[i+1] is nil, i:"..i.." x:"..tx.." y:"..ty)
        return quad_findChild(self.children[i + 1], tx, ty, size)
    else
        return self
    end
end

--[[
function quad_treeMultiSetColor(self, coords, color)
    local coord0 = table_remove(coords, 1)

    if coord0 then
        local x0, y0 = unpack(coord0)
        local child
        local function updateChild(x, y)
            child = quad_findChild(self, x, y, 4)
        end

        updateChild(x0, y0)
        quad_treeSetColor(child, x0, y0, color)

        for k, v in pairs(coords) do
            local x, y = unpack(v)
            if pointInQuad(x, y, child.x, child.y, child.size) then
                quad_treeSetColor(child, x, y, color)
            else
                updateChild(x, y)
                quad_treeSetColor(child, x, y, color)
            end
        end
    end
end
]]


function quad_treeSetColor(self, tx, ty, color)
    if self and self.color ~= color then
        if self.size ~= 1 then
            if not self.children then quad_split(self) end

            local Q_hsize = 2 / self.size
            return quad_treeSetColor(self.children[math_floor((tx - self.x) * Q_hsize) + 2 * math_floor((ty - self.y) * Q_hsize) + 1], tx, ty, color)
        else
            if self.color ~= color then
                self.color = color
                return quad_updateEffectColor(self)
            end
        end
    else
        return true
    end
end

function quad_treeFillRect(self, x, y, w, h, color)
    local sx = self.x
    local sy = self.y
    local ssize = self.size

    if quadIntersectsRect(sx, sy, ssize, x, y, w, h) then
        if quadInRect(sx, sy, ssize, x, y, w, h) then
            if self.children then
                quad_destroyChildren(self)
            end

            if self.color ~= color then
                self.color = color
                quad_updateEffectColor(self)
            end
            --if self.root.display.isRendering then
            --    quad_effectShow(self.effect)
            --end
        else
            if not self.children then quad_split(self) end

            local children = self.children
            return quad_treeFillRect(children[1], x, y, w, h, color) or quad_treeFillRect(children[2], x, y, w, h, color) or quad_treeFillRect(children[3], x, y, w, h, color) or quad_treeFillRect(children[4], x, y, w, h, color)
        end
    end
end

function quad_treeFillCircle(self, x, y, r, color)
    local sx = self.x
    local sy = self.y
    local ssize = self.size

    if quadIntersectsCircle(sx, sy, ssize, x, y, r) then
        if quadInCircle(sx, sy, ssize, x, y, r) then
            if self.children then
                quad_destroyChildren(self)
            end

            if self.color ~= color then
                self.color = color
                quad_updateEffectColor(self)
                return true --если получилось шось отрисовать
            end

            --if self.root.display.isRendering then
            --    quad_effectShow(self.effect)
            --end
        else
            if ssize ~= 1 then
                if not self.children then quad_split(self) end

                local children = self.children

                local drawed = false
                if quad_treeFillCircle(children[1], x, y, r, color) then drawed = true end
                if quad_treeFillCircle(children[2], x, y, r, color) then drawed = true end
                if quad_treeFillCircle(children[3], x, y, r, color) then drawed = true end
                if quad_treeFillCircle(children[4], x, y, r, color) then drawed = true end
                return drawed
            end
        end
    end
end

--[[
function quad_treeShow(self)
    if self.children then
        local children = self.children

        quad_treeShow(children[1])
        quad_treeShow(children[2])
        quad_treeShow(children[3])
        quad_treeShow(children[4])
    else
        quad_effectShow(self.effect)
    end
end

function quad_treeHide(self)
    if self.children then
        local children = self.children

        quad_treeHide(children[1])
        quad_treeHide(children[2])
        quad_treeHide(children[3])
        quad_treeHide(children[4])
    else
        quad_effectHide(self.effect)
    end
end
]]

function quad_rootRealShow(self, noRecurse)
    --[[
    if self.children then
        local children = self.children

        quad_rootRealShow(children[1])
        quad_rootRealShow(children[2])
        quad_rootRealShow(children[3])
        quad_rootRealShow(children[4])
    end
    if self.effect and sm_exists(self.effect) and effect_isDone(self.effect) then
        effect_start(self.effect)
    end

    if self.bufferedEffects and noRecurse then
        if effect_isDone(self.back_effect) then
            effect_start(self.back_effect)
        end

        for k, v in pairs(self.bufferedEffects) do
            if sm_exists(v) and effect_isDone(v) then
                effect_start(v)
            end
        end
    end
    ]]

    if self.splashEffect and sm_exists(self.splashEffect) and effect_isDone(self.splashEffect) then
        effect_start(self.splashEffect)
    end
    if self.back_effect and effect_isDone(self.back_effect) then
        effect_start(self.back_effect)
    end
    for effect in pairs(self.allEffects) do
        if sm_exists(effect) and effect_isDone(effect) then
            effect_start(effect)
        end
    end
end

function quad_rootRealHide(self, noRecurse)
    --[[
    if self.children then
        local children = self.children

        quad_rootRealHide(children[1])
        quad_rootRealHide(children[2])
        quad_rootRealHide(children[3])
        quad_rootRealHide(children[4])
    end
    if self.effect and sm_exists(self.effect) then
        effect_stop(self.effect)
    end

    if self.bufferedEffects and noRecurse then
        effect_stop(self.back_effect)

        for k, v in pairs(self.bufferedEffects) do
            if sm_exists(v) then
                effect_stop(v)
            end
        end
    end
    ]]

    if self.splashEffect and sm_exists(self.splashEffect) then
        effect_stop(self.splashEffect)
    end
    if self.back_effect then
        effect_stop(self.back_effect)
    end
    for effect in pairs(self.allEffects) do
        if sm_exists(effect) then
            effect_stop(effect)
        end
    end
end

------------------------------------------------------------

local function hideNewEffects(self)
    if self.newEffects then
        for eff in pairs(self.newEffects) do
            effect_stop(eff)
            --quad_effectHide(eff)
        end
    end
end

local function showNewEffects(self)
    if self.newEffects then
        for eff in pairs(self.newEffects) do
            if effect_isDone(eff) then
                effect_start(eff)
            end
            --quad_effectShow(eff)
        end
    end
end

local function applyNew(self)
    if self.isRendering then
        if self.quadTree.splashEffect and effect_isDone(self.quadTree.splashEffect) then
            effect_start(self.quadTree.splashEffect)
        end
        if self.quadTree.back_effect and effect_isDone(self.quadTree.back_effect) then
            effect_start(self.quadTree.back_effect)
        end
        return showNewEffects(self)
    else
        --[[
        if self.quadTree.splashEffect then
            effect_stop(self.quadTree.splashEffect)
        end
        if self.quadTree.back_effect then
            effect_stop(self.quadTree.back_effect)
        end
        hideNewEffects(self)
        ]]
        return quad_rootRealHide(self.quadTree)
    end
end

------------------------------------------------------------

local function random_hide_show(self, probabilityNum, allow)
    --[[
    local sendallow = (allow or 0) + 1
    if self.children then
        local children = self.children

        random_hide_show(children[1], probabilityNum, sendallow)
        random_hide_show(children[2], probabilityNum, sendallow)
        random_hide_show(children[3], probabilityNum, sendallow)
        random_hide_show(children[4], probabilityNum, sendallow)
    end
    if self.effect and allow and allow >= 2 then
        if probability(probabilityNum) then
            self.effect:stop()
        else
            self.effect:start()
        end
    end
    ]]

    debug_print("random_hide_show")

    local edata
    for effect in pairs(self.quadTree.allEffects) do
        if sm_exists(effect) then
            if probabilityNum > 0 and probability(probabilityNum) then
                edata = self.quadTree.effectsData[effect.id]
                --если писклесь хотябы по одной оси меньше или равно 2
                --это позволит рендерить изображения в сильно упрошенном виде
                if edata[4] <= 2 or edata[5] <= 2 then
                    effect_stop(effect)
                end
            elseif effect_isDone(effect) then
                effect_start(effect)
            end
        end
    end
end

local forceRotate = false

local function reset(self)
    self.maxClicks = 16
    self.rotation = 0
    self.settedRotation = 0
    self.skipAtNotSight = false
    self.utf8support = false
    self.renderAtDistance = false
    self.skipAtLags = true
    self.clicksAllowed = false
    self.clickData = {}

    self.needSendData = true

    if self.scriptableObject.data and self.scriptableObject.data.rotate then
        forceRotate = true
        self.api.setRotation(0)
        forceRotate = false
    end
end

function sc.display.createDisplay(scriptableObject, width, height, pixelScale)
    local display = {
        renderingStack = {},
        rnd_idx = 1,
        width = width,
        height = height,
        pixelScale = pixelScale,
        scriptableObject = scriptableObject,
        needUpdate = false,
        serverCache = {},

        -- client
        localLag = 0,
        rnd = math_random(0, 40 * 5),
        quadTree = nil,
        dragging = {interact=false, tinker=false, interactLastPos={x=-1, y=-1}, tinkerLastPos={x=-1, y=-1}},

        buffer1 = {},
        buffer2 = {}
    }

    display.force_update = true --первая отрисовка всегда форсированая
    display.allow_update = true
    display.audience = {}

    return display
end

function sc.display.server_init(self)
    self.old_this_display_blocked = false

    if self.scriptableObject.interactable then
        sc.displaysDatas[self.scriptableObject.interactable.id] = sc.display.server_createData(self)
    end

    reset(self)
end

local function isAllow(self)
    return self.width * self.height <= (sc.restrictions.maxDisplays * sc.restrictions.maxDisplays)
end

function sc.display.server_update(self)
    local audienceSize = 0
    for id, timer in pairs(self.audience) do
        audienceSize = audienceSize + 1
        if timer <= 0 then
            self.audience[id] = nil
        else
            self.audience[id] = timer - 1
        end
    end

    local rate = sc.restrictions.screenRate
    if audienceSize == 0 then
        rate = 16
    end

    local ctick = sm.game.getCurrentTick()
    if ctick % rate == 0 then self.allow_update = true end
    if ctick % (40 * 4) == 0 then
        self.forceNative_update = true

		self.serverCache = {}
        self.serverCacheAll = nil

        self.force_update = true
        self.allow_update = true
        self.stackChecksum = nil

        debug_print("force setted")
    end


    if self.needUpdate and self.this_display_blocked then
        self.rnd_idx = 1
        self.renderingStack = {}
        self.needUpdate = false
    end

    self.this_display_blocked = not isAllow(self)
    if self.this_display_blocked ~= self.old_this_display_blocked then
        self.api.reset()
        self.api.clear()
        self.api.forceFlush()
        if self.this_display_blocked then
            self.renderingStack.oops = true
        end
        self.old_this_display_blocked = self.this_display_blocked
    end

    if self.needSendData then
        --debug_print("self.needSendData")
        self.scriptableObject.network:sendToClients("client_onDataResponse", sc.display.server_createNetworkData(self))
        self.needSendData = false
    end



    if self.needUpdate and self.allow_update then
        if self.rnd_idx > 1 then
            local stackChecksumVal
            local function stackChecksum()
                if not stackChecksumVal then
                    stackChecksumVal = tableChecksum(self.renderingStack)
                end
                return stackChecksumVal
            end

            if self.force_update or
            not self.stackChecksum or
            self.stackChecksumLen ~= self.rnd_idx or
            self.stackChecksum ~= stackChecksum() then
                local cancel
                if self.lastComputer and self.lastComputer.cdata and not self.lastComputer.cdata.unsafe and type(sc.restrictions.lagDetector) == "number" then
                    local oldLagScore = self.lastComputer.lagScore
                    self.lastComputer.lagScore = self.lastComputer.lagScore + (self.rnd_idx * 0.0005 * sc.restrictions.lagDetector)
                    debug_print("lag score delta", self.lastComputer.lagScore - oldLagScore)

                    if self.lastComputer.lagScore > 120 then
                        debug_print_force("lagScore > 120!!")
                        cancel = true
                    end
                end

                if not cancel then
                    self.renderingStack.forceNative = self.forceNative_update
                    self.renderingStack.force = self.force_update
                    self.renderingStack.endPack = true
                    --[[
                    local dist = RENDER_DISTANCE
                    if self.renderAtDistance or self.player then
                        dist = nil
                    end
                    ]]
                    --local dist = nil --sending to all players

                    local whitelist
                    if self.player then
                        whitelist = {[self.player.id] = true}
                    end
                    local maxDist
                    if self.skipAtNotSight and not self.force_update then
                        maxDist = sc.restrictions.rend
                    end

                    if not pcall(vnetwork.sendToClients, self.scriptableObject, "client_onReceiveDrawStack", self.renderingStack, maxDist, whitelist) then
                        self.renderingStack.endPack = false
                        
                        local index = 1
                        local count = 1024
                        local cycles = 0

                        local datapack
                        while true do
                            --datapack = {unpack(self.renderingStack, index, index + (count - 1))}
                            datapack = {unpack(self.renderingStack, index, index + (count - 1))}

                            index = index + count
                            if datapack[#datapack] == self.renderingStack[#self.renderingStack] then
                                datapack.endPack = true
                                if pcall(vnetwork.sendToClients, self.scriptableObject, "client_onReceiveDrawStack", datapack, maxDist, whitelist) then
                                    break
                                else
                                    index = index - count
                                    count = nRound(count / 2)
                                end
                            elseif not pcall(vnetwork.sendToClients, self.scriptableObject, "client_onReceiveDrawStack", datapack, maxDist, whitelist) then
                                index = index - count
                                count = nRound(count / 2)
                            end

                            cycles = cycles + 1
                            if cycles > 100 then
                                debug_print_force("cycles to many 100", pcall(vnetwork.sendToClients, self.scriptableObject, "client_onReceiveDrawStack", self.renderingStack, maxDist, whitelist))
                                error("cycles to many 100")
                                break
                            end
                        end
                        debug_print("self.needUpdate-sending end")
                    end
                end

                self.stackChecksum = stackChecksum()
                self.stackChecksumLen = self.rnd_idx
                
                self.force_update = false
                self.allow_update = false
                self.forceNative_update = false

                debug_print("RENDER SENDED!!!")
            end
        end

        self.needUpdate = false
        self.rnd_idx = 1
        self.renderingStack = {}
    end
end

function sc.display.client_init(self)
    --local size = math_max(self.width, self.height)
    --local root = quad_createRoot(self, 0, 0, size, self.width, self.height)
    --self.quadTree = root

    self.scriptableObject.network:sendToServer("server_onDataRequired", sm_localPlayer_getPlayer())

    self.newEffects = {}
    sc_display_client_clear(self, black, true)
    applyNew(self)
    self.newEffects = nil
end


function sc.display.server_destroy(self)
    if self.scriptableObject.interactable then
        sc.displaysDatas[self.scriptableObject.interactable.id] = nil
    end
end

function sc.display.client_destroy(self)
    local quadTree = self.quadTree

    if self.splashEffect and sm_exists(self.splashEffect) then
        effect_destroyAndUnreg(quadTree, self.splashEffect)
    end
    quad_destroy(quadTree, true)
end

function sc.display.server_createData(self)
    local width = self.width
    local height = self.height

    local rwidth = width
    local rheight = height

    local function checkPos(x, y)
        x = nRound(x)
        y = nRound(y)
        if x ~= x or x < 0 or x >= rwidth then return end -- x ~= x is NAN check
        if y ~= y or y < 0 or y >= rheight then return end -- y ~= y is NAN check
        return x, y
    end

    local function checkRectPos(x, y)
        if x < 0 then x = 0 end
        if y < 0 then y = 0 end
        if x >= rwidth then x = rwidth - 1 end
        if y >= rheight then y = rheight - 1 end
        return x, y
    end

    local function checkRect(x, y, w, h)
        local xneg, yneg = w < 0, h < 0
		w = math_floor(math_abs(w))
        h = math_floor(math_abs(h))
        if x + w > rwidth then
            w = w - ((x + w) - rwidth)
        end
        if y + h > rheight then
            h = h - ((y + h) - rheight)
        end
		if xneg then x = x - w end
		if yneg then y = y - h end
        return x, y, w, h
    end

    local temp
    local data = {
        isAllow = function ()
            return isAllow(self)
        end,
        getAudience = function()
            local num = 0
            for k, v in pairs(self.audience) do
                num = num + 1
            end
            return num
        end,
        reset = function ()
            reset(self)
            self.api.setFont()
        end,
        getWidth = function ()
            return rwidth
        end,
        getHeight = function ()
            return rheight
        end,
        clear = function (color)
            self.renderingStack = {{
                0,
                color or "000000ff"
            }}
            self.rnd_idx = 2

            self.serverCache = {}
            self.serverCacheAll = color
        end,
        drawPixel = function (x, y, color)
            x, y = checkPos(x, y)
            if x then
                temp = x + (y * rwidth)
                if (self.serverCache[temp] or self.serverCacheAll) ~= color then
                    self.renderingStack[self.rnd_idx] = {
                        1,
                        color or "ffffffff",
                        x,
                        y
                    }
                    self.rnd_idx = self.rnd_idx + 1
                    self.serverCache[temp] = color
                end
            end
        end,
        drawRect = function (x, y, w, h, c)
            x, y = checkRectPos(x, y)
            x, y, w, h = checkRect(x, y, w, h)

            self.renderingStack[self.rnd_idx] = {
                2,
                c or "ffffffff",
                nRound(x),
                nRound(y),
                nRound(w),
                nRound(h)
            }
            self.rnd_idx = self.rnd_idx + 1
            
            self.serverCache = {}
            self.serverCacheAll = nil
        end,
        fillRect = function (x, y, w, h, c)
            x, y = checkRectPos(x, y)
            x, y, w, h = checkRect(x, y, w, h)

            self.renderingStack[self.rnd_idx] = {
                3,
                c or "ffffffff",
                nRound(x),
                nRound(y),
                nRound(w),
                nRound(h)
            }
            self.rnd_idx = self.rnd_idx + 1
            
            self.serverCache = {}
            self.serverCacheAll = nil
        end,
        drawCircle = function (x, y, r, c)
            if r > 1024 then
                r = 1024
            end

            self.renderingStack[self.rnd_idx] = {
                4,
                c or "ffffffff",
                nRound(x),
                nRound(y),
                nRound(r)
            }
            self.rnd_idx = self.rnd_idx + 1
            
            self.serverCache = {}
            self.serverCacheAll = nil
        end,
        fillCircle = function (x, y, r, c)
            if r > 1024 then
                r = 1024
            end

            self.renderingStack[self.rnd_idx] = {
                5,
                c or "ffffffff",
                nRound(x) + 0.5, -- +0.5 because center of pixel
                nRound(y) + 0.5, -- +0.5 because center of pixel
                nRound(r)
            }
            self.rnd_idx = self.rnd_idx + 1
            
            self.serverCache = {}
            self.serverCacheAll = nil
        end,
        drawLine = function (x, y, x1, y1, c)
            self.renderingStack[self.rnd_idx] = {
                6,
                c or "ffffffff",
                nRound(x),
                nRound(y),
                nRound(x1),
                nRound(y1)
            }
            self.rnd_idx = self.rnd_idx + 1
            
            self.serverCache = {}
            self.serverCacheAll = nil
        end,
        drawText = function (x, y, text, c)
            if not debug_disabletext then
                self.renderingStack[self.rnd_idx] = {
                    7,
                    c or "ffffffff",
                    nRound(x),
                    nRound(y),
                    tostring(text)
                }
                self.rnd_idx = self.rnd_idx + 1
                
                self.serverCache = {}
                self.serverCacheAll = nil
            end
        end,


        optimize = function ()
            --ручная оптимизация отключена из за того что большенство использует ее неправильно, что вызовет понижения производительности. данная функция сейчас работает полностью автоматически
            --потом может быть что-то придумаю
            --[[
            self.renderingStack[self.rnd_idx] = {
                8
            }
            self.rnd_idx = self.rnd_idx + 1
            ]]
        end,
        update = function () --для совместимости с SCI
            self.lastComputer = sc.lastComputer
            self.needUpdate = true
        end,
        flush = function ()
            self.lastComputer = sc.lastComputer
            self.needUpdate = true
        end,
        forceFlush = function()
            self.lastComputer = sc.lastComputer
            self.force_update = true
            self.needUpdate = true
        end,
        
        getClick = function ()
            local res = table_remove(self.clickData, 1)
            return res
        end,
        setMaxClicks = function (c)
            if type(c) == "number" and c % 1 == 0 and c > 0 and c <= 16 then
                self.maxClicks = c
            else
                error("integer must be in [1; 16]", 2)
            end
        end,
        getMaxClicks = function ()
            return self.maxClicks
        end,
        clearClicks = function ()
            self.clickData = {}
        end,

        setFont = function (font)
            checkArg(1, font, "table", "nil")

            if font then
                basegraphic_checkFont(font)
                self.sv_customFont = {
                    width = font.width,
                    height = font.height,
                    chars = legacyFont.optimizeFont(font.chars, font.width, font.height)
                }

                self.renderingStack[self.rnd_idx] = {
                    -2,
                    font.width,
                    font.height
                }
                self.rnd_idx = self.rnd_idx + 1

                for k, v in pairs(self.sv_customFont.chars) do
                    self.renderingStack[self.rnd_idx] = {
                        -3,
                        k,
                        v
                    }
                    self.rnd_idx = self.rnd_idx + 1
                end
            else
                self.renderingStack[self.rnd_idx] = {-1}
                self.rnd_idx = self.rnd_idx + 1
                self.sv_customFont = nil
            end
        end,

        getFontWidth = function ()
            return (self.sv_customFont and self.sv_customFont.width) or font_width
        end,

        getFontHeight = function ()
            return (self.sv_customFont and self.sv_customFont.height) or font_height
        end,

        setClicksAllowed = function (c)
            if type(c) == "boolean" then
                if self.clicksAllowed ~= c then
                    self.clicksAllowed = c
                    self.needSendData = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getClicksAllowed = function () return self.clicksAllowed end,

        setRenderAtDistance = function (c)
            if type(c) == "boolean" then
                if self.renderAtDistance ~= c then
                    self.renderAtDistance = c
                    self.needSendData = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getRenderAtDistance = function () return self.renderAtDistance end,

        setSkipAtLags = function (state)
            if type(state) == "boolean" then
                if self.skipAtLags ~= state then
                    self.skipAtLags = state
                    self.needSendData = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getSkipAtLags = function () return self.skipAtLags end,

        setRotation = function (rotation)
            if type(rotation) == "number" and rotation % 1 == 0 and rotation >= 0 and rotation <= 3 then
                if self.rotation ~= rotation or forceRotate then
                    self.rotation = rotation
                    self.settedRotation = rotation
                    self.needSendData = true

                    if self.scriptableObject.data and self.scriptableObject.data.rotate then
                        self.rotation = (self.rotation + self.scriptableObject.data.rotate) % 4
                    end

                    if self.rotation == 1 or self.rotation == 3 then
                        rwidth = height
                        rheight = width
                    else
                        rwidth = width
                        rheight = height
                    end

                    if not forceRotate then
                        self.api.clear()
                    end
                end
            else
                error("integer must be in [0; 3]", 2)
            end
        end,
        getRotation = function () return self.settedRotation end,

        setFrameCheck = function (framecheck) end, --legacy (stub)
        getFrameCheck = function () return true end, --legacy (stub)


        setSkipAtNotSight = function (skipAtNotSight)
            if type(skipAtNotSight) == "boolean" then
                if self.skipAtNotSight ~= skipAtNotSight then
                    self.skipAtNotSight = skipAtNotSight
                    self.needSendData = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getSkipAtNotSight = function () return self.skipAtNotSight end,

        setUtf8Support = function (state)
            if type(state) == "boolean" then
                if self.utf8support ~= state then
                    self.utf8support = state
                    self.needSendData = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getUtf8Support = function () return self.utf8support end
    }

    self.api = data
    return data
end

function sc.display.server_createNetworkData(self)
    return {
        renderAtDistance = self.renderAtDistance,
        clicksAllowed = self.clicksAllowed,
        skipAtLags = self.skipAtLags,
        rotation = self.rotation,
        skipAtNotSight = self.skipAtNotSight,
        utf8support = self.utf8support
    }
end

function sc.display.server_onDataRequired(self, client)
    --self.buffer2 = {}
    --self.buffer2All = nil

    self.scriptableObject.network:sendToClient(client, "client_onDataResponse", sc.display.server_createNetworkData(self))
    self.serverCache = {}

    self.allow_update = true
    self.force_update = true
    self.forceNative_update = true
end

function sc.display.server_recvPress(self, p, caller)
    if type(p) == "number" then
        if self.lastComputer and (not self.lastComputer.cdata or not self.lastComputer.cdata.unsafe) and type(sc.restrictions.lagDetector) == "number" then
			local num = 0
            for k, v in pairs(self.audience) do
                num = num + 1
            end
			if num == 0 then
				num = 1
			end
            
            local add = (p / num) * sc.restrictions.lagDetector
            self.lastComputer.lagScore = self.lastComputer.lagScore + add
            debug_print("get lag score", add)
        end
    elseif p == "reg" then --user reg
        self.audience[caller.id] = 40
    else
        local d = self.clickData
        if #d <= self.maxClicks then
            table_insert(d, p)
        end
    end
end



















function sc_display_client_clear(self, color, removeAll)
    if not removeAll and color == self.lastLastClearColor2 and not self.scriptableObject.data.noDoubleEffect then
        return true
    end
    self.lastLastClearColor = color
    self.lastLastClearColor2 = color

    local quadTree = self.quadTree
    if removeAll then
        local rotation

        if quadTree then
            rotation = quadTree.rotation
            quad_destroy(quadTree, true)
        end

        local size = math_max(self.width, self.height)
        local root = quad_createRoot(self, 0, 0, size, self.width, self.height)
        if quadTree then
            root.splashEffect = quadTree.splashEffect
        end

        if rotation then
            root.rotation = rotation
        end
        self.quadTree = root
        quadTree = root
    end

    -------------------------

    if quadTree.children then
        quad_destroyChildren(quadTree)
    end

    if quadTree.color ~= color then
        quadTree.color = color
        quad_updateEffectColor(quadTree)
    end

    --if self.isRendering then
    --    quad_effectShow(quadTree.effect)
    --end

    if self.quadTree.back_effect then
        --raw_set_color(self.quadTree.back_effect, color)
        effect_setParameter(self.quadTree.back_effect, "color", color)
    end

    self.buffer1 = {}
    self.buffer2 = {}
    self.buffer1All = nil
    self.buffer2All = color
end






local width, height
function sc_display_client_drawPixelForce(self, x, y, color)
    width = getWidth(self)
    if (self.buffer2[x + (y * width)] or self.buffer2All) == color and not debug_disableSimpleCheck then
        return true --если нехрена не поменялось
    end

    quad_treeSetColor(self.quadTree, x, y, color)
    self.buffer2[x + (y * width)] = color
end

function sc_display_client_drawPixel(self, x, y, color)
    --x = math_floor(x)
    --y = math_floor(y)

    if x >= 0 and x < getWidth(self) and y >= 0 and y < getHeight(self) then
        return sc_display_client_drawPixelForce(self, x, y, color)
    else
        return true
    end
end

function sc_display_client_drawRect(self, x, y, w, h, color)
    width = getWidth(self)
    height = getHeight(self)

    if x >= width then return true end
    if y >= height then return true end
    local lx = math_floor(x >= 0 and x or 0)
    local ly = math_floor(y >= 0 and y or 0)
    
    local lw = w - (lx - x)
    local lh = h - (ly - y)

    local rw = width - lx
    local rh = height - ly

    lw = math_floor(lw < rw and lw or rw)
    lh = math_floor(lh < rh and lh or rh)

    local isEffect = false

    for i = lx,lx+lw-1 do
        if not sc_display_client_drawPixelForce(self, i, ly, color) then
            isEffect = true
        end
    end

    local ex = lx+lw-1
    for iy = ly+1, ly+lh-2 do
        if not sc_display_client_drawPixelForce(self, lx, iy, color) then
            isEffect = true
        end
        if not sc_display_client_drawPixelForce(self, ex, iy, color) then
            isEffect = true
        end
    end

    local ey = ly + lh - 1
    for i = lx,lx+lw-1 do
        if not sc_display_client_drawPixelForce(self, i, ey, color) then
            isEffect = true
        end
    end

    return not isEffect
end

function sc_display_client_fillRect(self, x, y, w, h, color)
    self.buffer2 = {}
    self.buffer2All = nil
    --quad_treeFillRect(self.quadTree, math_floor(x), math_floor(y), math_floor(w), math_floor(h), color)
    return quad_treeFillRect(self.quadTree, x, y, w, h, color)

    --[[
    local realAction = false
    local mw, mh = getWidth(self), getHeight(self)
    for cx = x, x + (w - 1) do
        for cy = y, y + (h - 1) do
            if cx >= 0 and cy >= 0 and cx < mw and cy < mh then
                if self.buffer2[x + (y * mw)] or self.buffer2All ~= color then
                    self.buffer2[cx + (cy * mw)] = color
                    realAction = true
                end
            end
        end
    end
    if realAction then
        quad_treeFillRect(self.quadTree, math_floor(x), math_floor(y), math_floor(w), math_floor(h), color)
    else
        return true
    end
    ]]
end

--[[
function sc_display_client_rawFillRect(self, x, y, w, h, color)
    self.buffer2 = {}
    self.buffer2All = nil
    quad_treeFillRect(self.quadTree, math_floor(x), math_floor(y), math_floor(w), math_floor(h), color)
end
]]

sc.display.client_fillRect = sc_display_client_fillRect

local function drawCircle_putpixel(self, cx, cy, x, y, color)
    local posDX_x = cx + x
    local negDX_x = cx - x
    local posDX_y = cx + y
    local negDX_y = cx - y
    local posDY_y = cy + y
    local negDY_y = cy - y
    local posDY_x = cy + x
    local negDY_x = cy - x

    local isEffect = false
    if not sc_display_client_drawPixel(self, posDX_x, posDY_y, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, negDX_x, posDY_y, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, posDX_x, negDY_y, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, negDX_x, negDY_y, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, posDX_y, posDY_x, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, negDX_y, posDY_x, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, posDX_y, negDY_x, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, negDX_y, negDY_x, color) then isEffect = true end
    return not isEffect
end

function sc_display_client_drawCircle(self, x, y, r, color)
    --x = math_floor(x)
    --y = math_floor(y)
    --r = math_floor(r)

    local lx = 0
    local ly = r
    local d = 3 - 2 * r

    local isEffect = false
    if not drawCircle_putpixel(self, x, y, lx, ly, color) then isEffect = true end
    while ly >= lx do
        lx = lx + 1

        if d > 0 then
            ly = ly - 1
            d = d + 4 * (lx - ly) + 10
        else
            d = d + 4 * lx + 6
        end

        if not drawCircle_putpixel(self, x, y, lx, ly, color) then isEffect = true end
    end
    return not isEffect
end

function sc_display_client_fillCircle(self, x, y, r, color)
    if quad_treeFillCircle(self.quadTree, x, y, r, color) then
        self.buffer2 = {}
        self.buffer2All = nil
    else
        return true
    end

    --[[
    r = math_abs(r)
    local mw, mh = getWidth(self), getHeight(self)
    local cx, cy = math_min(r, 1024), math_min(r, 1024)
    local px, py
    for ix = -cx, cx do
        px = x + ix
        if px >= 0 and px < mw then
            for iy = -cy, cy do
                py = y + iy
                if py >= mh then
                    break
                elseif ix*ix + iy*iy <= r*r and py >= 0 then
                    sc_display_client_drawPixel(self, px, py, color)
                    self.buffer2[px + (py * mw)] = color
                end
            end
            if px == true then --dubble break
                break
            end
        end
    end
    ]]
end

--[[
local function sc_display_client_drawLineForce(self, x, y, x1, y1, color)
    x = math_floor(x)
    y = math_floor(y)
    x1 = math_floor(x1)
    y1 = math_floor(y1)

    local dx = math_abs(x1 - x)
    local sx = x < x1 and 1 or -1
    local dy = -math_abs(y1 - y)
    local sy = y < y1 and 1 or -1
    
    local isEffect = false
    local error = dx + dy
    local e2
    while true do
        if not sc_display_client_drawPixelForce(self, x, y, color) then isEffect = true end

        if x == x1 and y == y1 then break end
        e2 = error * 2
        if e2 >= dy then
            if x == x1 then break end
            error = error + dy
            x = x + sx
        end
        if e2 <= dx then
            if y == y1 then break end
            error = error + dx
            y = y + sy
        end
    end
    return not isEffect
end
]]

-- y = y0 + round( (x-x0) * dy / dx )
function sc_display_client_drawLine(self, x, y, x1, y1, color)
    local width = getWidth(self)
    local height = getHeight(self)
    
    --x = math_floor(x)
    --y = math_floor(y)
    --x1 = math_floor(x1)
    --y1 = math_floor(y1)

    local sign_x, sign_y

    local clip_xmin = 0
    local clip_xmax = width - 1

    local clip_ymin = 0
    local clip_ymax = height - 1

    local isEffect = false

    if x == x1 then
        if x < clip_xmin or x > clip_xmax then return not isEffect end

        if y <= y1 then
            if y1 < clip_ymin or y > clip_xmax then return not isEffect end

            y = math_max(y, clip_ymin)
            y1 = math_min(y1, clip_ymax)

            for iy = y, y1 do
                if not sc_display_client_drawPixelForce(self, x, iy, color) then isEffect = true end
            end
        else
            if y < clip_ymin or y1 > clip_ymax then return not isEffect end

            y1 = math_max(y1, clip_ymin)
            y = math_min(y, clip_ymax)

            for iy = y, y1, -1 do
                if not sc_display_client_drawPixelForce(self, x, iy, color) then isEffect = true end
            end
        end

        return not isEffect
    end

    if y == y1 then
        if y < clip_ymin or y > clip_ymax then return not isEffect end

        if x <= x1 then
            if x1 < clip_xmin or x > clip_xmax then return not isEffect end

            x = math_max(x, clip_xmin)
            x1 = math_min(x1, clip_xmax)

            for ix = x, x1 do
                if not sc_display_client_drawPixelForce(self, ix, y, color) then isEffect = true end
            end
        else
            if x < clip_xmin or x1 > clip_xmax then return not isEffect end

            x1 = math_max(x1, clip_xmin)
            x = math_min(x, clip_xmax)

            for ix = x, x1, -1 do
                if not sc_display_client_drawPixelForce(self, ix, y, color) then isEffect = true end
            end
        end

        return not isEffect
    end

    if x < x1 then
        if x > clip_xmax or x1 < clip_xmin then return not isEffect end
        sign_x = 1
    else
        if x1 > clip_xmax or x < clip_xmin then return not isEffect end
        x = -x
        x1 = -x1
        clip_xmin, clip_xmax = -clip_xmax, -clip_xmin

        sign_x = -1
    end

    if y < y1 then
        if y > clip_ymax or y1 < clip_ymin then return not isEffect end
        sign_y = 1
    else
        if y1 > clip_ymax or y < clip_ymin then return not isEffect end
        y = -y
        y1 = -y1
        clip_ymin, clip_ymax = -clip_ymax, -clip_ymin

        sign_y = -1
    end

    local delta_x = x1 - x
    local delta_y = y1 - y

    local delta_x_step = 2 * delta_x
    local delta_y_step = 2 * delta_y

    local xpos = x
    local ypos = y

    if delta_x >= delta_y then
        local error = delta_y_step - delta_x
        local exit = false

        if y < clip_ymin then
            local temp = (2 * (clip_ymin - y) - 1) * delta_x
            local msd = math_floor(temp / delta_y_step)

            xpos = xpos + msd

            if xpos > clip_xmax then return not isEffect end

            if xpos >= clip_xmin then
                local rem = temp - msd * delta_y_step

                ypos = clip_ymin
                error = error - rem - delta_x

                if rem > 0 then
                    xpos = xpos + 1
                    error = error + delta_y_step
                end

                exit = true
            end
        end

        if not exit and x < clip_xmin then
            local temp = delta_y_step * (clip_xmin - x)
            local msd = math_floor(temp / delta_x_step)

            ypos = ypos + msd
            local rem = temp % delta_x_step

            if ypos > clip_ymax or (ypos == clip_ymax and rem >= delta_x) then return not isEffect end

            xpos = clip_xmin
            error = error + rem

            if rem >= delta_x then
                ypos = ypos + 1
                error = error - delta_x_step
            end
        end

        local xpos_end = x1

        if y1 > clip_ymax then
            local temp = delta_x_step * (clip_ymax - y) + delta_x
            local msd = math_floor(temp / delta_y_step)

            xpos_end = x + msd

            if (temp - msd * delta_y_step) == 0 then
                xpos_end = xpos_end - 1
            end
        end

        xpos_end = math_min(xpos_end, clip_xmax) + 1

        if sign_y == -1 then 
            ypos = -ypos 
        end
        if sign_x == -1 then -- TODO * sign
            xpos = -xpos
            xpos_end = -xpos_end
        end

        delta_x_step = delta_x_step - delta_y_step

        while xpos ~= xpos_end do
            if not sc_display_client_drawPixelForce(self, xpos, ypos, color) then isEffect = true end

            if error >= 0 then
                ypos = ypos + sign_y
                error = error - delta_x_step
            else
                error = error + delta_y_step
            end

            xpos = xpos + sign_x
        end
    else
        local error = delta_x_step - delta_y
        local exit = false

        if x < clip_xmin then
            local temp = (2 * (clip_xmin - x) - 1) * delta_y
            local msd = math_floor(temp / delta_x_step)
            ypos = ypos + msd

            if ypos > clip_ymax then return not isEffect end

            if ypos >= clip_ymin then
                local rem = temp - msd * delta_x_step

                xpos = clip_xmin
                error = error - rem - delta_y

                if rem > 0 then
                    ypos = ypos + 1
                    error = error + delta_x_step
                end

                exit = true
            end
        end

        if not exit and y < clip_ymin then
            local temp = delta_x_step * (clip_ymin - y)
            local msd = math_floor(temp / delta_y_step)

            xpos = xpos + msd

            local rem = temp % delta_y_step

            if xpos > clip_xmax or (xpos == clip_xmax and rem >= delta_y) then return not isEffect end

            ypos = clip_ymin
            error = error + rem

            if rem >= delta_y then
                xpos = xpos + 1
                error = error - delta_y_step
            end
        end

        local ypos_end = y1

        if x1 > clip_xmax then
            local temp = delta_y_step * (clip_xmax - x) + delta_y
            local msd = math_floor(temp / delta_x_step)

            ypos_end = y + msd

            if (temp - msd * delta_x_step) == 0 then
                ypos_end = ypos_end - 1
            end
        end

        ypos_end = math_min(ypos_end, clip_ymax) + 1

        if sign_x == -1 then -- TODO * sign
            xpos = -xpos
        end
        if sign_y == -1 then
            ypos = -ypos
            ypos_end = -ypos_end
        end

        delta_y_step = delta_y_step - delta_x_step

        while ypos ~= ypos_end do
            if not sc_display_client_drawPixelForce(self, xpos, ypos, color) then isEffect = true end

            if error >= 0 then
                xpos = xpos + sign_x
                error = error - delta_y_step
            else
                error = error + delta_x_step
            end

            ypos = ypos + sign_y
        end
    end
end


local string_char = string.char

--[[
local function loadChar(self, c)
    local chars = self.customFont and self.customFont.chars or font_chars
    local pixels = chars[c]
    if not pixels and type(c) == "number" then
        pixels = chars[string_char(c)]
    end
    if pixels then return pixels end
    return chars.error or font_chars.error
end

local function drawCharForce(self, x, y, c, color)
    local pixels = loadChar(self, c)
    local v
    for i = 1, #pixels do
        v = pixels[i]
        drawPixelForce(self, x + v[1], y + v[2], color)
    end
end


local function drawChar(self, x, y, c, color)
    local pixels = loadChar(self, c)
    local v
    for i = 1, #pixels do
        v = pixels[i]
        drawPixel(self, x + v[1], y + v[2], color)
    end
end
]]

local _utf8_code = _utf8.code
local _utf8_sub = _utf8.sub
local _utf8_len = _utf8.len
local string_sub = string.sub
local string_len = string.len
local basegraphic_printText = basegraphic_printText
local function sc_display_client_drawText(self, x, y, text, color)
    return basegraphic_printText(self.customFont, self.utf8support, self, sc_display_client_drawPixel, sc_display_client_drawPixelForce, x, y, getWidth(self), getHeight(self), text, color)
    --[[
    x = math_floor(x)
    y = math_floor(y)

    local sub, len, byte
    if self.utf8support then
        sub = _utf8_sub
        len = _utf8_len
        byte = _utf8_code
    else
        sub = string_sub
        len = string_len
        byte = string_byte
    end

    local len = len(text)
    local font_width = font_width
    local font_height = font_height
    local width = getWidth(self)

    if self.customFont then
        font_width = self.customFont.width
        font_height = self.customFont.height
    end

    if x < 0 then
        local ic = 1
        while x + font_width < 0 do
            x = x + font_width + 1
            ic = ic + 1
            if ic > len or x >= width then
                return
            end
        end
        drawChar(self, x, y, sub(text, ic, ic), color)
        x = x + font_width + 1
        text = sub(text, ic + 1, len)
        len = len - ic
    end

    --старый вариант
    --if y >= 0 and (y + font_height) < self.height then
    --вот допустим размер шрифта по вертикали 1, в таком случаи предельное значения(например 127) окажеться не в пределах, так как 127 + 1 это 128, а 128 не меньше 128
    
    local height = getHeight(self)
    local ex, c
    if y >= 0 and (y + font_height) <= height then
        for i = 1, len do
            c = byte(text, i)

            ex = x + font_width
            if ex < width then
                drawCharForce(self, x, y, c, color)
            else
                drawChar(self, x, y, c, color)
                break
            end
            x = ex + 1
        end
    else
        for i = 1, len do
            c = byte(text, i)

            ex = x + font_width
            drawChar(self, x, y, c, color)
            if ex >= width then
                break
            end
            x = ex + 1
        end
    end
    ]]
end

function sc_display_client_optimize(self)
    return quad_optimize(self.quadTree)
end

local math_sin = math.sin
local basegraphic_doubleBuffering = basegraphic_doubleBuffering

function sc.display.client_update(self, dt)
    --debug_print("total_effects", total_effects)
    --[[
    local allEffs = 0
    for key, value in pairs(self.quadTree.allEffects) do
        allEffs = allEffs + 1
    end
    debug_print("allEffs", allEffs)
    ]]

    --[[
	if self.forceNativeRender then
		self.forceNativeRender = self.forceNativeRender - (40 / (1 / dt))
	end
    ]]

    local ctick = getCurrentTick()

    if self.isRendering and self.bufferWait then
        debug_print("buffer flushing")

        self.newEffects = {}
        local isEffect = false
        if basegraphic_doubleBuffering(self, nil, getWidth(self), getHeight(self), self.utf8support, quad_treeSetColor, sc_display_client_optimize, (not debug_disableRectBufferFill) and quad_treeFillRect) then
            self.lastLastClearColor2 = nil
            isEffect = true
        end

        if isEffect then
            debug_print("buffer flushing - isEffect!!")
    
            self.lastClearColor = nil
            self.dispValue = nil

            self.clientDrawingTimer = ctick
            self.lastDrawTime = self.clientDrawingTimer
    
            applyNew(self)
        else
            debug_print("buffer flushing - no effect")
        end


        self.bufferWait = false
        self.newEffects = nil
    end
    
    local scriptableObject = self.scriptableObject
    local quadTree = self.quadTree
    local bufferedEffects = quadTree.bufferedEffects
    local allEffects = quadTree.allEffects

    if debug_printeffects then
        debug_print("total_effects", quadTree.bf_idx)
    end
    
    if not debug_disableEffectsBuffer then
        --если картинка давно не обновлялась
        --то минимальное каличество для удаления эфектов 5000
        --а если обновления идей сейчас то только если буферезированых минимум 10000
        local minToRemove = (not self.lastDrawTime or ctick - self.lastDrawTime >= 40) and 5000 or 10000
        if quadTree.bf_idx >= minToRemove then
            local effect
            for i = 1, 250 do
                if quadTree.bf_idx > 0 then
                    effect = table_remove(bufferedEffects)
                    quadTree.bf_idx = quadTree.bf_idx - 1
                    if effect and sm_exists(effect) then
                        --effect_stop(effect)
                        effect_destroyAndUnreg(quadTree, effect)
                        allEffects[effect] = nil
                    end
                else
                    break
                end
            end
        end

        --[[
        if quadTree.bf_idx >= minToRemove then
            local effect
            for i = 1, 250 do
                effect = table_remove(bufferedEffects, 1)
                if effect then
                    if sm_exists(effect) then
                        effect_stop(effect)
                    end
                    table_insert(bufferedEffects, effect)
                else
                    break
                end
            end
        end
        ]]
    end

    --debug_print("cursor works")
    if scriptableObject.character and self.clicksAllowed and self.tablet_posX and self.tablet_posY and not quadTree.splashEffect then
        if self.cursor then
            if sm_exists(self.cursor) then
                effect_setOffsetPosition(self.cursor, self.quadTree.effectsData[self.cursor.id][6] - sm_vec3_new((self.tablet_posX / self.width) * 0.95, (self.tablet_posY / self.height) * 0.95, 0))
                effect_setParameter(self.cursor, "color", sm_color_new(0.6, (0.5 + (math_sin(math_rad(ctick * 4)) / 2)) * 0.6, 0))
            else
                self.cursor = nil
            end
        else
            local old_rotation = quadTree.rotation
            quadTree.rotation = 0
            self.cursor = quad_createEffect(quadTree, 0, 0, 0.06, 0.06, -0.0005, true, true, 0.01)
            --self.cursor = quad_createEffect(quadTree, 0, 0, 1, 1, -0.0005, true, true)
            --self.cursor = sm_effect_createEffect(sc_getEffectName(), quadTree.display.scriptableObject.character)
            --effect_setParameter(self.cursor, "uuid", cursorUuid)
            effect_setParameter(self.cursor, "uuid", sc_display_shapesUuid)
            quadTree.rotation = old_rotation
            effect_start(self.cursor)
        end
    elseif self.cursor then
        --effect_stop(self.cursor)
        effect_destroyAndUnreg(quadTree, self.cursor)
        self.cursor = nil
    end

    --debug_print("dispValue works")
    if self.dispValue then
        self.dispValue = self.dispValue - 1
        if self.dispValue <= 0 then
            self.dispValue = nil
            
            debug_print("lastClearColor", self.lastClearColor)

            self.newEffects = {}
            sc_display_client_clear(self, self.lastClearColor, true)
            applyNew(self)
            self.newEffects = nil

            self.lastClearColor = nil
        end
    end

    if self.clientDrawingTimer and (
        self.optimize_flag or
        not self.oldOptimizeTime or
        ctick - self.oldOptimizeTime >= (40 * 5) or --автооптимизация каждые 5 секунд
        ctick - self.clientDrawingTimer >= 40 --если более секунды не было отрисовки - оптимизация
    ) then
        self.clientDrawingTimer = nil
        self.optimize_flag = nil
        self.oldOptimizeTime = ctick
        
        debug_print("effects optimization")

        self.newEffects = {}
        sc_display_client_optimize(self)
        applyNew(self)
        self.newEffects = nil
    end

    local localPlayer = sm_localPlayer_getPlayer().character
    if localPlayer and sc.restrictions then
        --[[
        local playerPos = localPlayer.worldPosition
        local selfPos
        if scriptableObject.shape then
            selfPos = scriptableObject.shape.worldPosition
        else
            selfPos = scriptableObject.character.worldPosition
        end
        ]]
        local playerPos = sm_camera_getPosition()
        local selfPos = scriptableObject.shape and scriptableObject.shape.worldPosition

        local nowIsRendering, dist = false
        if selfPos then
            dist = mathDist(selfPos, playerPos)
        end

        local r = sc.restrictions and sc.restrictions.rend
        if scriptableObject.character then
            if self.tablet_posX or self.renderAtDistance then --функция renderAtDistance на планшете паказывает экран когда планшет не в руке
                nowIsRendering = true
            end
        else
            local rendondist = sc.restrictions.allowDist and self.renderAtDistance
            if rendondist or dist < r then
                if rendondist then
                    nowIsRendering = true
                elseif self.last_raycast_time then
                    nowIsRendering = (ctick - self.last_raycast_time) < 10
                end

                if not nowIsRendering then
                    if not sc.restrictions or sc.restrictions.rays == 0 then
                        nowIsRendering = true
                    else
                        local detectedShapes = cl_displayRaycast(self, playerPos, r)
                        local localPoint, scale, pointX, pointY
                        for shape, result in pairs(detectedShapes) do
                            if shape.id == scriptableObject.shape.id then
                                localPoint = shape:transformPoint(result.pointWorld)
        
                                if localPoint and localPoint.x < 0 then
                                    localPoint = sm_vec3_new(0, localPoint.y, localPoint.z)
                                    scale = sc_display_PIXEL_SCALE * self.pixelScale
                    
                                    pointX = math_floor(self.width / 2 - localPoint.z / scale)
                                    pointY = math_floor(self.height / 2 + localPoint.y / scale)
                                
                                    if pointX >= 0 and pointX < self.width and pointY >= 0 and pointY < self.height then
                                        nowIsRendering = true
                                        self.last_raycast_time = ctick
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        --debug_print("isRendering works")
        local nowRender
        if self.isRendering ~= nowIsRendering then
            if nowIsRendering then
                nowRender = true
                quad_rootRealShow(quadTree, self)
            else
                quad_rootRealHide(quadTree, self)
            end
        end
        self.isRendering = nowIsRendering

        --debug_print("click works")
        if self.dragging.interact then
            sc.display.client_onClick(self, 1, "drag")
        elseif self.dragging.tinker then
            sc.display.client_onClick(self, 2, "drag")
        end

        --debug_print("random_hide_show works")
        if nowIsRendering and sc.restrictions and sc.restrictions.optSpeed and dist then
            local meters = math_floor(dist + 0.5)
            if meters ~= self.meters or nowRender or not self.old_opt then
                --if self.clientDrawingTimer then
                --    random_hide_show(self, 0)
                --end
                --debug_print("meters changed")
                
                local p = 0
                if meters > 2 then
                    p = ((meters * sc.restrictions.optSpeed) / self.pixelScale) * 4
                    p = constrain(p, 0, 100)
                    if p < 10 then
                        p = 0
                    --elseif p > 60 then
                    --    p = (p * 0.5) + 30
                    end
                    if p > 80 then
                        p = 80
                    end
                end

                if not self.old_p then self.old_p = p end
                --print("P", p, self.old_p, math.abs(p - self.old_p))
                if math_abs(p - self.old_p) > 5 or nowRender or not self.old_opt then
                    random_hide_show(self, p)
                    self.old_p = p
                end

                self.meters = meters
            end
        end

        if nowIsRendering then
            self.scriptableObject.network:sendToServer("server_recvPress", "reg")

            if self.old_opt and not sc.restrictions.optSpeed then
                random_hide_show(self, 0)
            end
        end
        self.old_opt = not not sc.restrictions.optSpeed
    end

    --debug_print("self.restrictions", self.restrictions, self.isRendering and self.restrictions and self.restrictions.opt)

    --[[
    if (getCurrentTick() + self.rnd) % (40 * 4) == 40 then
        debug_print("clear doValueHashCache")
        doValueHashCache = {}
    end
    ]]

    ------stylus
    --debug_print("stylus works")
    if scriptableObject.character then
        if self.tablet_left ~= self.old_tablet_left then
            sc.display.client_onInteract(self, nil, not not self.tablet_left)
        end
    
        if self.tablet_right ~= self.old_tablet_right then
            sc.display.client_onTinker(self, nil, not not self.tablet_right)
        end

        self.old_tablet_left = self.tablet_left
        self.old_tablet_right = self.tablet_right
    else
        if _G.stylus_left ~= self.old_stylus_left then
            sc.display.client_onInteract(self, nil, not not _G.stylus_left)
        end
    
        if _G.stylus_right ~= self.old_stylus_right then
            sc.display.client_onTinker(self, nil, not not _G.stylus_right)
        end

        self.old_stylus_left = _G.stylus_left
        self.old_stylus_right = _G.stylus_right
    end

    if ctick % 20 == 0 then
        if self.localLag > 0 then
            self.scriptableObject.network:sendToServer("server_recvPress", self.localLag)
            self.localLag = 0
        end
    end
end

function sc.display.client_onDataResponse(self, data)
    debug_print("client_onDataResponse", data)
    --[[
    local font_data = data.fontdata
    if font_data then
        if not sm_isHost then
            if font_data.remove then
                debug_print("custom font erase")
                self.customFont = nil
            else
                if font_data.width then
                    debug_print("custom font init")
                    self.customFont = {width = font_data.width, height = font_data.height, chars = {}}
                else
                    --debug_print("custom font add", font_data.name, tostring(font_data.data))
                    self.customFont.chars[font_data.name] = font_data.data
                end
            end
        end
        return
    end
    ]]

    self.quadTree.rotation = data.rotation
    if data.rotation ~= self.old_rotation then
        self.buffer1 = {}
        self.buffer2 = {}
        self.buffer1All = nil
        self.buffer2All = nil

        self.old_rotation = data.rotation
    end

    if sm_isHost then return end
    self.clicksAllowed = data.clicksAllowed
    self.renderAtDistance = data.renderAtDistance
    self.skipAtLags = data.skipAtLags
    self.skipAtNotSight = data.skipAtNotSight
    self.utf8support = data.utf8support
end


local drawActions = {
    [sc_display_drawType.clear] = function (self, t) return sc_display_client_clear(self, t[2]) end,
    [sc_display_drawType.drawPixel] = function (self, t) return sc_display_client_drawPixel(self, t[3], t[4], t[2]) end,
    [sc_display_drawType.drawRect] = function (self, t) return sc_display_client_drawRect(self, t[3], t[4], t[5], t[6], t[2]) end,
    [sc_display_drawType.fillRect] = function (self, t) return sc_display_client_fillRect(self, t[3], t[4], t[5], t[6], t[2]) end,
    [sc_display_drawType.drawCircle] = function (self, t) return sc_display_client_drawCircle(self, t[3], t[4], t[5], t[2]) end,
    [sc_display_drawType.fillCircle] = function (self, t) return sc_display_client_fillCircle(self, t[3], t[4], t[5], t[2]) end,
    [sc_display_drawType.drawLine] = function (self, t) return sc_display_client_drawLine(self, t[3], t[4], t[5], t[6], t[2]) end,
    [sc_display_drawType.drawText] = function (self, t) return sc_display_client_drawText(self, t[3], t[4], t[5], t[2]) end,
    [sc_display_drawType.optimize] = function (self) self.optimize_flag = true end,
}

local basegraphic_doFont = basegraphic_doFont

function sc.display.client_drawStack(self, sendstack)
    local startExecTimeStart = os_clock()

    sendstack = sendstack or self.scriptableObject.sendData
    if sendstack then
        if self.quadTree.splashEffect and sm_exists(self.quadTree.splashEffect) then
            effect_destroyAndUnreg(self.quadTree, self.quadTree.splashEffect)
            self.quadTree.splashEffect = nil
        end
        if sendstack.oops then
            local eff = quad_createEffect(self.quadTree, 0, 0, self.quadTree.sizeX, self.quadTree.sizeY, nil, true)
            --effect_setParameter(eff, "uuid", oopsUuid)
            --effect_setParameter(eff, "uuid", sc_display_shapesUuid)
            effect_setParameter(eff, "color", oopsColor)
            if self.scriptableObject.character then
                self.quadTree.effectsData[eff.id][8] = sm_quat_fromEuler(sm_vec3_new(180, 90, 0))
                quad_effectShow(self, eff)
            end
            self.quadTree.splashEffect = eff
            applyNew(self)    
        end

        if sendstack.endPack then
            if self.savestack then
                debug_print("slow stack copying (end)")
                local lstack = self.savestack
                local lidx = self.savestack_idx
                for i = 1, #sendstack do
                    lstack[lidx] = sendstack[i]
                    lidx = lidx + 1
                end
                self.savestack_idx = lidx
            else
                debug_print("fast stack copying (end)")
                self.savestack = sendstack
            end
        else
            debug_print("slow stack copying")
            if not self.savestack then self.savestack = {} self.savestack_idx = 1 end
            local lstack = self.savestack
            local lidx = self.savestack_idx
            for i = 1, #sendstack do
                lstack[lidx] = sendstack[i]
                lidx = lidx + 1
            end
            self.savestack_idx = lidx
            return
        end
    end
    local stack = self.savestack
    self.savestack = nil
    self.savestack_idx = nil
    if not stack then
        return
    end

    debug_print("start render --------------------", self.isRendering, sendstack.force, self.skipAtLags, self.skipAtNotSight, self.forceNativeRender)

    if sendstack.force then
        self.buffer2 = {}
        self.buffer2All = nil
    else
        if self.skipAtNotSight and not self.isRendering then debug_print("skipAtNotSight skipped") return end --если skipAtNotSight true, то картинка не будет обновляться когда ты на нее не смотриш
        if self.skipAtLags and sc.restrictions and sc.deltaTime >= (1 / sc.restrictions.skipFps) then debug_print("skipAtLags skipped") return end
    end

    self.localLag = self.localLag + ((os_clock() - startExecTimeStart) * sc.clockLagMul)
    if self.localLag > 120 then
        debug_print_force("localLag > 120!!")
    end

    local ctick = getCurrentTick()
    local startExecTime = os_clock()

    local isEndClear = stack[#stack][1] == 0
    local clearColor
    if stack[1] and stack[1][1] == 0 then
        clearColor = formatColor(stack[1][2], true)
    end

    self.newEffects = {}
    local isEffect = false --если от всего стека был хоть какой-то смысл
    local width, height = getWidth(self), getHeight(self)
    --[[
    if sendstack.forceNative then
        self.allowForceNativeSet = true
    end
    ]]

    if isEndClear and #stack == 1 then
        debug_print("clear only render")

        if not sc_display_client_clear(self, clearColor) then
            isEffect = true
        end

        self.oldRenderType = true
        self.bufferWait = false
    elseif not debug_noNativeRender and self.isRendering and (clearColor and (clearColor ~= self.lastClearColor3) or sendstack.forceNative or self.forceNativeRender) then
        debug_print("native render")

        local startRnd = os_clock()
        local v
        for i = 1, #stack do
            v = stack[i]
            
            if v[1] >= 0 then
                v[2] = formatColor(v[2], v[1] == 0)
            end
    
            if v[1] ~= 0 and v[1] ~= 8 then
                self.lastLastClearColor2 = nil
            end
    
            --если хоть что-то не вернуло значения, значит эфект от стека был
            if drawActions[v[1]] then
                if not drawActions[v[1]](self, v) and v[1] ~= 8 then
                    isEffect = true
                end
            else
                basegraphic_doFont(self, v)
            end
        end
        self.lastNativeRenderTime = os_clock() - startRnd
        self.oldRenderType = true
        self.bufferWait = false

        if self.lastNativeRenderTime > 1/40 then
            debug_print("disable forceNativeRender")
            self.forceNativeRender = nil
        end
    else
        debug_print("buffer render")

        local startRnd = os_clock()
        if basegraphic_doubleBuffering(self, stack, width, height, self.utf8support, self.isRendering and quad_treeSetColor, sc_display_client_optimize, (not debug_disableRectBufferFill) and quad_treeFillRect) then
            self.lastLastClearColor2 = nil
            isEffect = true
        end
        --local rendTime = os_clock() - startRnd

        if not debug_disableForceNativeRender and not debug_noNativeRender then
            --[[
            if rendTime > 1/40 then
                if self.allowForceNativeSet then
                    debug_print("enable forceNativeRender (1)")

                    self.allowForceNativeSet = nil
                    self.forceNativeRender = true
                end
            end
            ]]
            if self.lastNativeRenderTime and not self.oldRenderType then
                local dt2 = self.lastNativeRenderTime * 2
                local rendTime = os_clock() - startRnd
                if dt2 < rendTime then
                    debug_print("enable forceNativeRender (2)")

                    --local add = constrain(math_ceil(rendTime / dt2) * 5, 10, 40)
                    --debug_print("force native render", self.lastNativeRenderTime, dt2, rendTime, add)
                    --self.forceNativeRender = add
                    self.forceNativeRender = true
                end
            end
        end

        self.oldRenderType = false
        if not self.isRendering then
            self.bufferWait = true
        end
    end

    if clearColor then
    	self.lastClearColor3 = clearColor
    end

    if isEffect then
        debug_print("isEffect!!")

        if isEndClear then
            self.lastClearColor = clearColor
            self.dispValue = 40 * 2
        else
            self.lastClearColor = nil
            self.dispValue = nil
        end
        
        self.clientDrawingTimer = ctick
        self.lastDrawTime = self.clientDrawingTimer

        applyNew(self)
    else
        debug_print("no effect")
    end
    self.newEffects = nil

    self.localLag = self.localLag + ((os_clock() - startExecTime) * sc.clockLagMul)
    if self.localLag > 120 then
        debug_print_force("localLag > 120!!")
    end
end


function sc.display.client_onClick(self, type, action, localPoint) -- type - 1:interact|2:tinker (e.g 1 or 2), action - pressed, released, drag
    if not self.clicksAllowed or (self.scriptableObject and self.scriptableObject.data and self.scriptableObject.data.noTouch) then
        return
    end

    local function detect(pointX, pointY)
        pointX = math_floor(pointX + 0.5)
        pointY = math_floor(pointY + 0.5)

        if pointX >= 0 and pointX < self.width and pointY >= 0 and pointY < self.height then
            if action == "drag" then
                local t = type == 1 and self.dragging.interactLastPos or self.dragging.tinkerLastPos

                if t.x ~= -1 then
                    if t.x == pointX and t.y == pointY then 
                        return
                    else
                        t.x = pointX
                        t.y = pointY
                    end
                else
                    t.x = pointX
                    t.y = pointY
                    return
                end
            end

            local reverseX, reverseY, changeXY
            if self.quadTree.rotation == 1 then
                changeXY = true
                reverseX = true
            elseif self.quadTree.rotation == 2 then
                reverseX = true
                reverseY = true
            elseif self.quadTree.rotation == 3 then
                changeXY = true
                reverseY = true
            end
            if reverseX then
                pointX = self.width - pointX - 1
            end
            if reverseY then
                pointY = self.height - pointY - 1
            end
            if changeXY then
                pointX, pointY = pointY, pointX
            end

            debug_print("touch", pointX, pointY)

            self.scriptableObject.network:sendToServer("server_recvPress", { pointX, pointY, action, type })
        end
    end

    local function reg(localPoint)
        if localPoint and localPoint.x < 0 then
            local localPoint = sm_vec3_new(0, localPoint.y, localPoint.z)
            local scale = sc_display_PIXEL_SCALE * self.pixelScale

            local pointX = math_floor(self.width / 2 - localPoint.z / scale)
            local pointY = math_floor(self.height / 2 + localPoint.y / scale)
        
            detect(pointX, pointY)
        end
    end
    
    if localPoint then
        reg(localPoint)
    elseif self.scriptableObject.shape then
        local succ, res = sm_localPlayer.getRaycast((sc.restrictions and sc.restrictions.rend) or RENDER_DISTANCE)
        if succ then
            local shape = self.scriptableObject.shape
            local localPoint = shape:transformPoint(res.pointWorld)
            reg(localPoint)
        end
    elseif self.tablet_posX and self.tablet_posY then
        detect(self.tablet_posX, self.tablet_posY)
    end
end

function sc.display.client_onInteract(self, character, state)
    self.dragging.interact = state
    if state then
        local t = self.dragging.interactLastPos
        t.x = -1
        t.y = -1
    end
    sc.display.client_onClick(self, 1, state and "pressed" or "released")
end

function sc.display.client_onTinker(self, character, state)
    self.dragging.tinker = state
    if state then
        local t = self.dragging.tinkerLastPos
        t.x = -1
        t.y = -1
    end
    sc.display.client_onClick(self, 2, state and "pressed" or "released")
end

function sc.display.client_canInteract(self, character)
    if self.scriptableObject and self.scriptableObject.data and self.scriptableObject.data.noTouch then
        return false
    end

    return self.clicksAllowed
end

function sc.display.client_canTinker(self, character)
    if self.scriptableObject and self.scriptableObject.data and self.scriptableObject.data.noTouch then
        return false
    end

    return self.clicksAllowed
end
end
function scmframework_84a1f83b589eb1a76c55ae3c0fe76f02() --$CONTENT_DATA/Scripts/Displays/old/legacyFont.lua
legacyFont = {}
legacyFont.width = 4
legacyFont.height = 5

legacyFont.chars = {
	----------internal chars
	["\5"] = {
		"11..",
		"111.",
		"1111",
		"111.",
		"11.."
	},
	["\6"] = {
		"1111",
		"1111",
		"1111",
		".11.",
		".11."
	},

	----------big english legacyFonts
	["A"] = {
		".11.",
		"1..1",
		"1111",
		"1..1",
		"1..1"
	},
	["B"] = {
		"111.",
		"1..1",
		"111.",
		"1..1",
		"111."
	},
	["C"] = {
		".11.",
		"1..1",
		"1...",
		"1..1",
		".11."
	},
	["D"] = {
		"111.",
		"1..1",
		"1..1",
		"1..1",
		"111."
	},
	["E"] = {
		"1111",
		"1...",
		"111.",
		"1...",
		"1111"
	},
	["F"] = {
		"1111",
		"1...",
		"111.",
		"1...",
		"1..."
	},
	["G"] = {
		".111",
		"1...",
		"1.11",
		"1..1",
		".11."
	},
	["H"] = {
		"1..1",
		"1..1",
		"1111",
		"1..1",
		"1..1"
	},
	["I"] = {
		"1111",
		".11.",
		".11.",
		".11.",
		"1111"
	},
	["J"] = {
		"1111",
		".11.",
		".11.",
		".11.",
		"11.."
	},
	["K"] = {
		"1..1",
		"1..1",
		"111.",
		"1..1",
		"1..1"
	},
	["L"] = {
		"1...",
		"1...",
		"1...",
		"1...",
		"1111"
	},
	["M"] = {
		"1..1",
		"1111",
		"1..1",
		"1..1",
		"1..1"
	},
	["N"] = {
		"1..1",
		"11.1",
		"1.11",
		"1..1",
		"1..1"
	},
	["O"] = {
		".11.",
		"1..1",
		"1..1",
		"1..1",
		".11."
	},
	["P"] = {
		"111.",
		"1..1",
		"111.",
		"1...",
		"1..."
	},
	["Q"] = {
		".11.",
		"1..1",
		"1..1",
		"1..1",
		".111"
	},
	["R"] = {
		"111.",
		"1..1",
		"111.",
		"1..1",
		"1..1"
	},
	["S"] = {
		".111",
		"1...",
		".11.",
		"...1",
		"111."
	},
	["T"] = {
		"1111",
		".11.",
		".11.",
		".11.",
		".11."
	},
	["U"] = {
		"1..1",
		"1..1",
		"1..1",
		"1..1",
		".111"
	},
	["V"] = {
		"1..1",
		"1..1",
		"1..1",
		"1..1",
		".11."
	},
	["W"] = {
		"1..1",
		"1..1",
		"1..1",
		"1111",
		"1..1"
	},
	["X"] = {
		"1..1",
		"1..1",
		".11.",
		"1..1",
		"1..1"
	},
	["Y"] = {
		"1..1",
		"1..1",
		".111",
		"...1",
		".11."
	},
	["Z"] = {
		"1111",
		"...1",
		".11.",
		"1...",
		"1111"
	},

	----------small english legacyFonts
	["a"] = {
		"....",
		".11.",
		"...1",
		"1111",
		".111"
	},
	["b"] = {
		"....",
		"1...",
		"111.",
		"1..1",
		"111."
	},
	["c"] = {
		"....",
		".111",
		"1...",
		"1...",
		".111"
	},
	["d"] = {
		"...",
		"...1",
		".111",
		"1..1",
		".111"
	},
	["e"] = {
		"....",
		"1111",
		"111.",
		"1...",
		"1111"
	},
	["f"] = {
		"....",
		"1111",
		"1...",
		"111.",
		"1..."
	},
	["g"] = {
		"....",
		".111",
		"1...",
		"1..1",
		".11."
	},
	["h"] = {
		"....",
		"1...",
		"1111",
		"1..1",
		"1..1"
	},
	["i"] = {
		"....",
		".11.",
		"....",
		".11.",
		".11."
	},
	["j"] = {
		"....",
		"..1.",
		"..1.",
		"..1.",
		"11.."
	},
	["k"] = {
		"....",
		"1...",
		"1..1",
		"111.",
		"1..1"
	},
	["l"] = {
		"....",
		"1...",
		"1...",
		"1...",
		"1111"
	},
	["m"] = {
		"....",
		"1..1",
		"1111",
		"1..1",
		"1..1"
	},
	["n"] = {
		"....",
		"111.",
		"1..1",
		"1..1",
		"1..1"
	},
	["o"] = {
		"....",
		".11.",
		"1..1",
		"1..1",
		".11."
	},
	["p"] = {
		"....",
		"111.",
		"1..1",
		"111.",
		"1..."
	},
	["q"] = {
		"....",
		".11.",
		"1..1",
		"1111",
		"...1"
	},
	["r"] = {
		"....",
		"11.1",
		"1.1.",
		"1...",
		"1..."
	},
	["s"] = {
		"....",
		"..11",
		".1..",
		"..1.",
		"11.."
	},
	["t"] = {
		"....",
		"1111",
		".11.",
		".11.",
		".11."
	},
	["u"] = {
		"....",
		"1..1",
		"1..1",
		"1..1",
		".111"
	},
	["v"] = {
		"....",
		"1..1",
		"1..1",
		"1..1",
		".11."
	},
	["w"] = {
		"....",
		"1..1",
		"1..1",
		"1111",
		"1..1"
	},
	["x"] = {
		"....",
		"1..1",
		".11.",
		".11.",
		"1..1"
	},
	["y"] = {
		"....",
		"1..1",
		".111",
		"...1",
		".11."
	},
	["z"] = {
		"....",
		"1111",
		"..1.",
		".1..",
		"1111"
	},





	----------big russian legacyFonts
	["А"] = {
		".11.",
		"1..1",
		"1111",
		"1..1",
		"1..1"
	},
	["Б"] = {
		"1111",
		"1...",
		"111.",
		"1..1",
		"111."
	},
	["В"] = {
		"111.",
		"1..1",
		"111.",
		"1..1",
		"111."
	},
	["Г"] = {
		"1111",
		"1...",
		"1...",
		"1...",
		"1..."
	},
	["Д"] = {
		".11.",
		"1..1",
		"1..1",
		".11.",
		"1..1"
	},
	["Е"] = {
		"1111",
		"1...",
		"1111",
		"1...",
		"1111"
	},
	["Ё"] = {
		"11.1",
		"1...",
		"1111",
		"1...",
		"1111"
	},
	["Ж"] = {
		"1..1",
		".11.",
		"1111",
		".11.",
		"1..1"
	},
	["З"] = {
		"111.",
		"...1",
		".11.",
		"...1",
		"111."
	},
	["И"] = {
		"1..1",
		"1..1",
		"1.11",
		"11.1",
		"1..1"
	},
	["Й"] = {
		"1.11",
		"1..1",
		"1.11",
		"11.1",
		"1..1"
	},
	["К"] = {
		"1..1",
		"1.1.",
		"11..",
		"1.1.",
		"1..1"
	},
	["Л"] = {
		".111",
		"1..1",
		"1..1",
		"1..1",
		"1..1"
	},
	["М"] = {
		"1..1",
		"1111",
		"1..1",
		"1..1",
		"1..1"
	},
	["Н"] = {
		"1..1",
		"1..1",
		"1111",
		"1..1",
		"1..1"
	},
	["О"] = {
		".11.",
		"1..1",
		"1..1",
		"1..1",
		".11."
	},
	["П"] = {
		"1111",
		"1..1",
		"1..1",
		"1..1",
		"1..1"
	},
	["Р"] = {
		"111.",
		"1..1",
		"111.",
		"1...",
		"1..."
	},
	["С"] = {
		".111",
		"1...",
		"1...",
		"1...",
		".111"
	},
	["Т"] = {
		"1111",
		".11.",
		".11.",
		".11.",
		".11."
	},
	["У"] = {
		"1..1",
		"1..1",
		".1.1",
		"..1.",
		".1.."
	},
	["Ф"] = {
		"1111",
		"1..1",
		"1..1",
		"1111",
		".11."
	},
	["Х"] = {
		"1..1",
		"1..1",
		".11.",
		"1..1",
		"1..1"
	},
	["Ц"] = {
		"1.1.",
		"1.1.",
		"1.1.",
		"1111",
		"...1"
	},
	["Ч"] = {
		"1..1",
		"1..1",
		"1111",
		"...1",
		"...1"
	},
	["Ш"] = {
		"1.11",
		"1.11",
		"1.11",
		"1.11",
		"1111"
	},
	["Щ"] = {
		"1.11",
		"1.11",
		"1.11",
		"1111",
		"...1"
	},
	["Ь"] = {
		"1...",
		"1...",
		"111.",
		"1..1",
		"111."
	},
	["Ы"] = {
		"1..1",
		"1..1",
		"11.1",
		"11.1",
		"11.1"
	},
	["Ъ"] = {
		"11..",
		".1..",
		".111",
		".1.1",
		".111"
	},
	["Э"] = {
		"111.",
		"...1",
		"1111",
		"...1",
		"111."
	},
	["Ю"] = {
		"1.1.",
		"11.1",
		"11.1",
		"11.1",
		"1.1."
	},
	["Я"] = {
		".111",
		"1..1",
		"1111",
		".1.1",
		"1..1"
	},

	----------------small russian legacyFont
	["а"] = {
		"....",
		".11.",
		"...1",
		"1111",
		".111"
	},
	["б"] = {
		"....",
		".11.",
		"1...",
		"1111",
		"111."
	},
	["в"] = {
		"....",
		"11..",
		"111.",
		"111.",
		"11.."
	},
	["г"] = {
		"....",
		"1111",
		"1...",
		"1...",
		"1..."
	},
	["д"] = {
		"....",
		".11.",
		"1..1",
		".11.",
		"1..1"
	},
	["е"] = {
		"....",
		"1111",
		"111.",
		"1...",
		"1111"
	},
	["ё"] = {
		".11.",
		"1111",
		"111.",
		"1...",
		"1111"
	},
	["ж"] = {
		"....",
		"1..1",
		".1.1",
		"1.1.",
		"1..1"
	},
	["з"] = {
		"....",
		"1111",
		".11.",
		"...1",
		"111."
	},
	["и"] = {
		"....",
		"1..1",
		"1.11",
		"11.1",
		"1..1"
	},
	["й"] = {
		"..1.",
		"1..1",
		"1.11",
		"11.1",
		"1..1"
	},
	["к"] = {
		"....",
		"1..1",
		"1.1.",
		"11..",
		"1.1."
	},
	["л"] = {
		"....",
		".111",
		"1..1",
		"1..1",
		"1..1"
	},
	["м"] = {
		"....",
		"1111",
		"1.11",
		"1.11",
		"1.11"
	},
	["н"] = {
		"....",
		"1..1",
		"1111",
		"1111",
		"1..1"
	},
	["о"] = {
		"....",
		".11.",
		"1..1",
		"1..1",
		".11."
	},
	["п"] = {
		"....",
		"1111",
		"1..1",
		"1..1",
		"1..1"
	},
	["р"] = {
		"....",
		"111.",
		"1..1",
		"111.",
		"1..."
	},
	["с"] = {
		"....",
		".111",
		"1...",
		"1...",
		".111"
	},
	["т"] = {
		"....",
		"1111",
		".11.",
		".11.",
		".11."
	},
	["у"] = {
		"....",
		"1..1",
		".1.1",
		"..1.",
		".1.."
	},
	["ф"] = {
		"....",
		".11.",
		"1..1",
		"1111",
		".11."
	},
	["х"] = {
		"....",
		"1..1",
		".11.",
		".11.",
		"1..1"
	},
	["ц"] = {
		"....",
		"1.1.",
		"1.1.",
		"1111",
		"...1"
	},
	["ч"] = {
		"....",
		"1..1",
		"1111",
		"...1",
		"...1"
	},
	["ш"] = {
		"....",
		"1.11",
		"1.11",
		"1.11",
		"1111"
	},
	["щ"] = {
		"....",
		"1.11",
		"1.11",
		"1111",
		"...1"
	},
	["ь"] = {
		"....",
		"1...",
		"111.",
		"1..1",
		"111."
	},
	["ы"] = {
		"....",
		"1..1",
		"1..1",
		"11.1",
		"11.1"
	},
	["ъ"] = {
		"....",
		"11..",
		".11.",
		".1.1",
		".11."
	},
	["э"] = {
		"....",
		"111.",
		"1111",
		"...1",
		"111."
	},
	["ю"] = {
		"....",
		"1.1.",
		"11.1",
		"11.1",
		"1.1."
	},
	["я"] = {
		"....",
		".111",
		"1..1",
		".111",
		"1..1"
	},





	------------------------
	["0"] = {
		".11.",
		"1..1",
		"1..1",
		"1..1",
		".11."
	},
	["1"] = {
		".11.",
		"111.",
		".11.",
		".11.",
		"1111"
	},
	["2"] = {
		"111.",
		"...1",
		".11.",
		"1...",
		".111"
	},
	["3"] = {
		"111.",
		"...1",
		"111.",
		"...1",
		"111."
	},
	["4"] = {
		"1..1",
		"1..1",
		"1111",
		"...1",
		"...1"
	},
	["5"] = {
		"1111",
		"1...",
		"111.",
		"...1",
		"111."
	},
	["6"] = {
		".11.",
		"1...",
		"111.",
		"1..1",
		".11."
	},
	["7"] = {
		"1111",
		"...1.",
		".11.",
		".11.",
		".11."
	},
	["8"] = {
		".11.",
		"1..1",
		".11.",
		"1..1",
		".11."
	},
	["9"] = {
		".11.",
		"1..1",
		".111",
		"...1",
		".11."
	},
	["."] = {
		"....",
		"....",
		"....",
		"....",
		"1..."
	},
	[","] = {
		"....",
		"....",
		"....",
		"11..",
		"1..."
	},
	[":"] = {
		"....",
		"1...",
		"....",
		"1...",
		"...."
	},
	[";"] = {
		"....",
		"1...",
		"....",
		"11..",
		"1..."
	},
	["!"] = {
		"1...",
		"1...",
		"1...",
		"....",
		"1..."
	},
	["?"] = {
		"1...",
		".1..",
		"1...",
		"....",
		"1..."
	},
	["'"] = {
		"..1.",
		"..1.",
		"....",
		"....",
		"...."
	},
	['"'] = {
		"1.1.",
		"1.1.",
		"....",
		"....",
		"...."
	},
	["("] = {
		"...1",
		"..1.",
		"..1.",
		"..1.",
		"...1"
	},
	[")"] = {
		"1...",
		".1..",
		".1..",
		".1..",
		"1..."
	},
	["["] = {
		"..11",
		"..1.",
		"..1.",
		"..1.",
		"..11"
	},
	["]"] = {
		"11..",
		".1..",
		".1..",
		".1..",
		"11.."
	},
	["{"] = {
		"...1",
		"..1.",
		".11.",
		"..1.",
		"...1"
	},
	["}"] = {
		"1...",
		".1..",
		".11.",
		".1..",
		"1..."
	},
	["<"] = {
		"...1",
		"..1.",
		".1..",
		"..1.",
		"...1"
	},
	[">"] = {
		"1...",
		".1..",
		"..1.",
		".1..",
		"1..."
	},
	["/"] = {
		"...1",
		"..1.",
		"..1.",
		".1..",
		"1..."
	},
	["\\"] = {
		"1...",
		".1..",
		".1..",
		"..1.",
		"...1"
	},
	["@"] = {
		".111",
		"11.1",
		"1.11",
		"1...",
		".111"
	},
	["#"] = {
		"1..1",
		"1111",
		"1..1",
		"1111",
		"1..1"
	},
	["$"] = {
		".111",
		"1.1.",
		".11.",
		".1.1",
		"111."
	},
	["%"] = {
		"1..1",
		"..1.",
		"..1.",
		".1..",
		"1..1"
	},
	["^"] = {
		".1..",
		"1.1.",
		"....",
		"....",
		"...."
	},
	["&"] = {
		".11.",
		"1..1",
		".1..",
		"1.11",
		".111"
	},
	["*"] = {
		"1..1",
		".11.",
		"1..1",
		"....",
		"...."
	},
	["+"] = {
		"....",
		".11.",
		"1111",
		".11.",
		"...."
	},
	["-"] = {
		"....",
		"....",
		"1111",
		"....",
		"...."
	},
	["_"] = {
		"....",
		"....",
		"....",
		"....",
		"1111"
	},
	[" "] = {
		"....",
		"....",
		"....",
		"....",
		"...."
	},
	["="] = {
		"....",
		"1111",
		"....",
		"1111",
		"...."
	},
	["`"] = {
		"1...",
		".1..",
		"....",
		"....",
		"...."
	},
	["~"] = {
		"....",
		"1.1.",
		".1.1",
		"....",
		"...."
	},
	["№"] = {
		"...1",
		"1...",
		"11.1",
		"1.11",
		"1..1"
	},
}

legacyFont.chars.error = {
	"1111",
	"1..1",
	"1..1",
	"1..1",
	"1111"
}

local pairs = pairs
local ipairs = ipairs
local table_insert = table.insert
local string_byte = string.byte
function legacyFont.optimizeFont(chars, width, height)
    local optimized = {}

    local pixels
    local chr
    for k, v in pairs(chars) do
        pixels = {}

        for iy, w in ipairs(v) do
            for ix = 1, width do
                chr = w:sub(ix, ix)
                if chr == "1" then
                    table_insert(pixels, {ix-1, iy-1})
                end
            end
        end

        optimized[k] = pixels
        if #k == 1 then
            optimized[string_byte(k)] = pixels
        end
    end

    return optimized
end

legacyFont.optimized = legacyFont.optimizeFont(legacyFont.chars, legacyFont.width, legacyFont.height)
end
function scmframework_a5d973b9e9be8a8c885fc57889521efe() --$CONTENT_DATA/Scripts/Displays/trash/DisplayBase_test1.lua
-- debug
debug_out = true
debug_printeffects = false
debug_disabletext = false
debug_disableoptimize = false
debug_raycast = false
debug_offset = true
debug_disableEffectsBuffer = false
debug_disableDBuff = false
debug_disableForceNativeRender = false
debug_disableUpdateColor = false

--settings
mul_ray_fov = 2

--code
if __displayBaseLoaded then return end
__displayBaseLoaded = true

dofile "$CONTENT_DATA/Scripts/Config.lua"

local vnetwork = vnetwork
local sc = sc
local sm = sm
local probability = probability
local checkArg = checkArg

sc.display.drawType = {
    clear = 0,
    drawPixel = 1,
    drawRect = 2,
    fillRect = 3,
    drawCircle = 4,
    fillCircle = 5,
    drawLine = 6,
    drawText = 7,
    optimize = 8,
}

local tableChecksum = tableChecksum

local floor = math.floor
local function nRound(num)
    return floor(num + 0.5)
end

--local _utf8 = string
local splitByMaxSize = splitByMaxSize
local string = string
local _utf8 = utf8
local sc_display_drawType = sc.display.drawType
local constrain, mathDist = constrain, mathDist

sc.display.PIXEL_SCALE = 0.0072
sc.display.RENDER_DISTANCE = 15
sc.display.SKIP_RENDER_DT = 1 / 30
sc.display.SKIP_RENDER_DT_ALL = 1 / 20
sc.display.deltaTime = 0

sc.display.quad = {}

local oopsUuid = sm.uuid.new("c3931873-eadc-4e46-a575-0a369ae01202")
local cursorUuid = sm.uuid.new("77e46b76-0b2e-4a00-86e4-d030b8d9b59d")

local RENDER_DISTANCE = sc.display.RENDER_DISTANCE

local sm_camera_getRotation = sm.camera.getRotation
local sm_camera_getFov = sm.camera.getFov

local sm_isHost = sm.isHost
local sm_effect_createEffect = sm.effect.createEffect
local sm_quat_fromEuler = sm.quat.fromEuler

local table_insert = table.insert
local table_remove = table.remove

local tostring = tostring
local tonumber = tonumber
local math_rad = math.rad
local math_random = math.random
local math_floor = math.floor
local math_abs = math.abs
local math_max = math.max
local math_min = math.min
local math_ceil = math.ceil
--local string_sub = string.sub
local string_byte = string.byte
--local table_pack = table.pack

local sm_exists = sm.exists
local ipairs = ipairs
local pairs = pairs
local print = print
local type = type
local unpack = unpack
local getCurrentTick = sm.game.getCurrentTick
local sm_localPlayer = sm.localPlayer
local sm_localPlayer_getPlayer = sm_localPlayer.getPlayer
local os_clock = os.clock

local sm_vec3 = sm.vec3
local util_clamp = sm.util.clamp
local sm_vec3_new = sm.vec3.new
local sc_display_PIXEL_SCALE = sc.display.PIXEL_SCALE

local formatColor = sc.formatColor
--local formatColorStr = sc.formatColorStr

local effectsData = {}

local emptyEffect = sm.effect.createEffect(sc.getEffectName())
local effect_setParameter = emptyEffect.setParameter
local effect_stop = emptyEffect.stop
local effect_destroy = emptyEffect.destroy
local effect_start = emptyEffect.start
local effect_isDone = emptyEffect.isDone
local effect_isPlaying = emptyEffect.isPlaying
local effect_setScale = emptyEffect.setScale
local effect_setOffsetPosition = emptyEffect.setOffsetPosition
local effect_setOffsetRotation = emptyEffect.setOffsetRotation
--effect_stop(emptyEffect)
effect_destroy(emptyEffect)

local function effect_destroyAndUnreg(effect)
    effectsData[effect.id] = nil
    effect_destroy(effect)
end

local sm_camera_getPosition = sm.camera.getPosition

local quad_visibleRot = sm_quat_fromEuler(sm_vec3.zero())
local quad_hideRot = sm_quat_fromEuler(sm_vec3_new(0, 180, 0))

local quad_displayOffset = sm_vec3_new(-0.125, 0, 0)
--local quad_offsetRotation = sm_quat_fromEuler(sm_vec3_new(0, 0, 0))

local sm_physics_multicast = sm.physics.multicast
local sm_physics_filter_dynamicBody = sm.physics.filter.dynamicBody
local sm_physics_filter_staticBody = sm.physics.filter.staticBody
local filter_body = sm_physics_filter_dynamicBody + sm_physics_filter_staticBody

local function cl_displayRaycast(self, position, r)
    if _G.raycastCache and (getCurrentTick() - _G.raycastCache.time) < 20 then
        return _G.raycastCache.shapes
    end

    --[[
    local shapes = {}
    local maxoffset = math.pi / 3
    for x = -maxoffset, maxoffset, maxoffset / 10 do
        for y = -maxoffset, maxoffset, maxoffset / 10 do
            local offset = sm.vec3.new(
                0, --why does it work relative to the world and not relative to the player?
                0, --why does it work relative to the world and not relative to the player?
                y
            )
            

            local ok, result = sm.localPlayer.getRaycast(r, nil, sm.localPlayer.getDirection() + offset)
            
            if result.pointWorld then
                sm.debris.createDebris(
                    sm.uuid.new("d3db3f52-0a8d-4884-afd6-b4f2ac4365c2"),
                    result.pointWorld,
                    sm.quat.fromEuler(sm.vec3.new(0, 0, 0)),
                    sm.vec3.zero(),
                    sm.vec3.zero(),
                    sm.color.new(1, 0, 0),
                    1 / 40
                )
            end
            if ok and result and result.type == "body" then
                --sm.debugDraw.addSphere("11", result.pointWorld, 0.5, sm.color.new(1, 0, 0))
                shapes[result:getShape()] = result
            end
        end
    end
    ]]

    ----createRays
    local rotation = sm_camera_getRotation() * sm_quat_fromEuler(sm_vec3_new(90, 180, 0))

    local resolutionX, resolutionY = sc.restrictions.rays, sc.restrictions.rays
    local distance = r
    local fov = math_rad(sm_camera_getFov() * mul_ray_fov)
    local rays = {}
    local rays_idx = 1
    local u, v, direction
    for x = 1, resolutionX do
        for y = 1, resolutionY do
            u = ( x / resolutionX - 0.5 ) * fov
            v = ( y / resolutionY - 0.5 ) * fov

            direction = rotation * sm_vec3_new(-u, -v, 1)

            rays[rays_idx] = {
                type = "ray",
                startPoint = position,
                endPoint = position + direction * distance,
                mask = filter_body
            }
            rays_idx = rays_idx + 1
         end
    end

    ----raycasting
    local casts = sm_physics_multicast(rays)

    local shapes, shape = {}
    for _, data in pairs(casts) do
        if data[1] then
            shape = data[2]:getShape()
            if shape then
                shapes[shape] = data[2]
            end

            if debug_raycast then
                sm.debris.createDebris(
                    sm.uuid.new("d3db3f52-0a8d-4884-afd6-b4f2ac4365c2"),
                    data[2].pointWorld,
                    sm.quat.fromEuler(sm.vec3.new(0, 0, 0)),
                    sm.vec3.zero(),
                    sm.vec3.zero(),
                    sm.color.new(1, 0, 0),
                    1 / 40
                )
            end
        end
    end
    
    _G.raycastCache = {shapes = shapes, time = getCurrentTick()}
    return shapes
end

local function debug_print_force(...)
    print(...)
end

local function debug_print(...)
    if debug_out then
        print(...)
    end
end

local sc_display_shapesUuid = sm.uuid.new("708d4a47-7de7-49df-8ba3-e58083c2610e")
--local sc_display_shapesUuidGlass = sm.uuid.new("3d11dd1d-1296-414b-a2d9-101e876c022f")
local sc_display_shapesUuidGlass = sm.uuid.new("75708339-6420-41e4-88a0-fbc210826c14")

local sc_getEffectName = sc.getEffectName

local quadIntersectsCircle, quad_createNode, quad_createRoot, quad_updateEffectColor
local quad_createEffect, quad_effectHide, quad_effectShow, quad_destroy, quad_destroyEffect
local quad_destroyChildren, quad_optimize, quad_split
local quad_findChild
--local quad_treeMultiSetColor
local quad_treeSetColor
local quad_treeFillRect
local quad_treeFillCircle
local quad_treeShow
local quad_treeHide
local quad_rootRealShow
local quad_rootRealHide
local sc_display_client_clear
local sc_display_client_drawPixelForce
local sc_display_client_drawPixel
local sc_display_client_drawRect
local sc_display_client_fillRect
local sc_display_client_drawCircle
local sc_display_client_fillCircle
local sc_display_client_drawLine
local sc_display_client_optimize

local sm_color_new = sm.color.new
local black = sm_color_new("000000ff")
local white = sm_color_new("ffffffff")
local oopsColor = sm_color_new("ffff00ff")

local font_chars = sc.display.font.optimized
local font_width = sc.display.font.width
local font_height = sc.display.font.height

local total_effects = 0

--[[
local function pointInQuad(x, y, qx, qy, qs)
    return (x >= qx and x < qx + qs) and (y >= qy and y < qy + qs)
end

local function pointInCircle(x, y, cx, cy, cr)
    local dx = cx - x
    local dy = cy - y

    return dx*dx + dy*dy <= cr*cr
end
]]

local function quadInRect(qx, qy, qs, rx, ry, rw, rh)
    return (qx >= rx and qx + qs <= rx + rw) and (qy >= ry and qy + qs <= ry + rh)
end

local quadInCircle = quadInCircle

local function quadIntersectsRect(qx, qy, qs, rx, ry, rw, rh)
    return (qx < rx + rw and qx + qs > rx) and (qy < ry + rh and qy + qs > ry)
end

function quadIntersectsCircle(qx, qy, qs, cx, cy, cr)
    local clamp = util_clamp
    local closestX = clamp(cx, qx, qx + qs)
    local closestY = clamp(cy, qy, qy + qs)

    local dx = cx - closestX
    local dy = cy - closestY

    return dx*dx + dy*dy <= cr*cr
end

function quad_createNode(parent, x, y, sizeX, sizeY, color)
    local node =  {
        x = x,
        y = y,
        sizeX = sizeX,
        sizeY = sizeY,
        size = math_max(sizeX, sizeY),
        children = nil,
        parent = parent,
        effect = nil,
        color = color,
        root = parent.root,
        display = parent.root.display,
        --uroot = parent.root.display.quadTree
    }

    --[[
    print(color, parent.root.display.lastLastClearColor, color == parent.root.display.lastLastClearColor)
    if color == parent.root.display.lastLastClearColor then
        node.effect = quad_createEffect(node.root, x, y, sizeX, sizeY)
        --quad_updateEffectColor(node)
        effect_setParameter(node.effect, "color", sm.color.new(1, 0, 0))
        effect_setScale(node.effect, sm.vec3.new(0.01, 0.01, 0.01))
        return node
    end
    ]]

    if color ~= parent.root.display.lastLastClearColor or parent.root.display.scriptableObject.data.noDoubleEffect then
        node.effect = quad_createEffect(node.root, x, y, sizeX, sizeY)
        quad_updateEffectColor(node, true)
    end

    --if parent.root.display.isRendering then
    --    quad_treeShow(node)
    --end
    
    return node
end

function quad_createRoot(display, x, y, size, maxX, maxY)
    local node = {
        x = x,
        y = y,
        size = size,
        maxX = maxX,
        maxY = maxY,
        sizeX = maxX,
        sizeY = maxY,
        children = nil,
        parent = nil,
        effect = nil,
        color = nil,
        display = display,
        bufferedEffects = {},
        bf_idx = 0,
        allEffects = {}
    }

    node.root = node
    if not display.scriptableObject.data.noDoubleEffect then
        node.back_effect = quad_createEffect(node, x, y, maxX, maxY, 0.0005, true)
    end

    --node.effect = quad_createEffect(node, x, y, maxX, maxY)

    --if display.isRendering then
    --    quad_treeShow(node)
    --end

    --node.uroot = node
    return node
end

local function raw_set_color(effect, color)
    --local colorChecksum = tableChecksum(color)
    --if effectsData[effect.id][1] ~= color then
        --print("COLORPUSH", effectsData[effect.id][1], color)
    effect_setParameter(effect, "color", color)
    effectsData[effect.id][1] = color
    --end
end

function quad_updateEffectColor(self, force)
    if debug_disableUpdateColor then return end

    --if not self.effect or not sm_exists(self.effect) then return end
    local color = self.color

    --if color ~= self.display.lastLastClearColor or force then
        --effect_setScale(effect, sm.vec3.new(0.02, 0.02, 0.02))

    if color ~= self.root.display.lastLastClearColor or self.root.display.scriptableObject.data.noDoubleEffect then
        if not self.effect then
            self.effect = quad_createEffect(self.root, self.x, self.y, self.sizeX, self.sizeY)
        end

        raw_set_color(self.effect, color)
    else
        if self.effect and sm_exists(self.effect) then
            --effect_destroy(self.effect)
            --self.root.allEffects[self.effect] = nil
            quad_destroyEffect(self)
        end
        self.effect = nil
    end
    --end

    --effect_setParameter(self.effect, "color", color)
end

function quad_destroy(self, removeAll)
    if self.children then
        quad_destroyChildren(self)
    end
    quad_destroyEffect(self)


    if removeAll then
        debug_print("removeAll")
        
        --effect_stop(self.back_effect)
        if self.back_effect then
            effect_destroyAndUnreg(self.back_effect)
        end
        total_effects = total_effects - 1
        for effect in pairs(self.allEffects) do
            if effect and sm_exists(effect) then
                total_effects = total_effects - 1
                --effect_stop(effect)
                effect_destroyAndUnreg(effect)
            end
        end
        self.allEffects = {}
        self.bufferedEffects = {}
        self.bf_idx = 0
    end
end

local function getWidth(self)
    if self.quadTree.rotation == 1 or self.quadTree.rotation == 3 then
        return self.height
    else
        return self.width
    end
end

local function getHeight(self)
    if self.quadTree.rotation == 1 or self.quadTree.rotation == 3 then
        return self.width
    else
        return self.height
    end
end

local quad_alt_hideRot = sm_quat_fromEuler(sm_vec3_new(0, 90, 0))
local quad_alt_visibleRot = sm_quat_fromEuler(sm_vec3_new(0, 180 + 90, 0))


function quad_createEffect(root, x, y, sizeX, sizeY, z, nonBuf, nativeScale, wide, uuid)
    --local attemptRemove

    --::attempt::

    local rmaxX = root.maxX
    local rmaxY = root.maxY
    local reverseX, reverseY, changeXY

    if root.rotation == 1 then
        changeXY = true
        reverseX = true
    elseif root.rotation == 2 then
        reverseX = true
        reverseY = true
    elseif root.rotation == 3 then
        changeXY = true
        reverseY = true
    end

    if changeXY then
        x, y = y, x
        --rmaxX, rmaxY = rmaxY, rmaxX
        --sizeX, sizeY = sizeY, sizeX
    end
    if reverseX then x = (rmaxX - x) - sizeX end
    if reverseY then y = (rmaxY - y) - sizeY end
    
    if x < 0 then x = 0 end
    if y < 0 then y = 0 end
    if x > rmaxX then x = rmaxX end
    if y > rmaxY then y = rmaxY end
    if x + sizeX > rmaxX then sizeX = sizeX - ((x + (sizeX)) - rmaxX) end
    if y + sizeY > rmaxY then sizeY = sizeY - ((y + (sizeY)) - rmaxY) end

    local effect
    local display = root.display

    if not nonBuf and root.bf_idx > 0 and not debug_disableEffectsBuffer then
        effect = table_remove(root.bufferedEffects)
        if sm_exists(effect) and effect_isDone(effect) then
            effect_start(effect)
        else
            effect = nil
        end
        root.bf_idx = root.bf_idx - 1
    end
    if not effect then
        --if total_effects < (1050000) then
            --debug_print(effectsNames[currentEffect])

            effect = sm_effect_createEffect(sc_getEffectName(), display.scriptableObject.character or display.scriptableObject.interactable)
            --effect = {stop = function() end, start = function() end, destroy = function() end,
            --setScale = function() end, setOffsetPosition = function() end, setOffsetRotation = function() end,
            --setParameter = function() end, id = math.random(0, 99999), trash = string.rep(" ", 1024 * 8)}
            --print("create_id", effect.id)

            if display.scriptableObject and display.scriptableObject.data.glass then
                effect_setParameter(effect, "uuid", uuid or sc_display_shapesUuidGlass)
            else
                effect_setParameter(effect, "uuid", uuid or sc_display_shapesUuid)
            end
            
            --effect:start()

            if not nonBuf and display.newEffects then
                display.newEffects[effect] = true
            end
            if not nonBuf then
                root.allEffects[effect] = true
            end

            total_effects = total_effects + 1

            --[[
            if effect and sm_exists(effect) then
                if not nonBuf then
                    
                end
            else
                debug_print("EFFECTS OVERFLOW!!!!", total_effects)
            end
            ]]
        --else
            --[[
            if attemptRemove then
                return
            else
                local count = 0
                for effect in pairs(root.allEffects) do
                    if effect and sm_exists(effect) then
                        quad_effectHide(effect)
                        table_insert(bufferedEffects, effect)
                        
                        count = count + 1
                        if count >= 50 then
                            break
                        end

                        debug_print("super quad_destroyEffect")
                    end
                end
                    

                attemptRemove = true
                goto attempt
            end
            ]]
        --end
    end

    if not effect or not sm_exists(effect) then return effect end

    local scale = sc_display_PIXEL_SCALE * display.pixelScale
    local vx = scale * sizeX + 1e-4
    local vy = scale * sizeY + 1e-4

    wide = wide or 0
    if display.scriptableObject.data and display.scriptableObject.data.wide then
        wide = display.scriptableObject.data.wide
    end

    local vecScale = sm_vec3_new(wide, vy, vx)
    if nativeScale then
        effect_setScale(effect, sm_vec3_new(wide, sizeX, sizeY))
    else
        effect_setScale(effect, vecScale)
    end

    local offset = sm_vec3_new(0, y - display.height/2 + sizeY/2, display.width/2 - x - sizeX/2) * scale
    offset.x = z or (debug_offset and -0.5 or 0)

    local chr = display.scriptableObject.character
    if chr then
        local x, y, z = offset.x, offset.y, offset.z
        offset.z = x
        offset.x = z
        offset.y = -y
        offset = offset + sm_vec3_new(0, 1, 1)
    else
        local loff = quad_displayOffset
        if display.scriptableObject.data and display.scriptableObject.data.zpos then
            loff = sm_vec3_new(display.scriptableObject.data.zpos, 0, 0)
        end
        offset = loff + offset

        if display.scriptableObject.data and display.scriptableObject.data.offset then
            offset = offset + sm_vec3_new(0, display.scriptableObject.data.offset / 4, 0)
        end
    end

    effect_setOffsetPosition(effect, offset)

    local tbl = {nil, nil, display.scriptableObject.data or {}, sizeX, sizeY, offset}
    if chr then
        tbl[7] = quad_alt_hideRot
        tbl[8] = quad_alt_visibleRot
    else
        tbl[7] = quad_hideRot
        tbl[8] = quad_visibleRot
    end
    local datatbl = effectsData[effect.id]
    if datatbl then
        for k, v in pairs(tbl) do
            datatbl[k] = v
        end
    else
        effectsData[effect.id] = tbl
    end
    quad_effectShow(effect)
    
    return effect
end

function quad_destroyEffect(self)
    local effect = self.effect

    if effect and sm_exists(effect) then
        if debug_disableEffectsBuffer then
            effect_destroyAndUnreg(effect)
            total_effects = total_effects - 1
            self.root.allEffects[effect] = nil
        else
            quad_effectHide(effect)
            self.root.bf_idx = self.root.bf_idx + 1
            self.root.bufferedEffects[self.root.bf_idx] = effect
        end
    end

    self.effect = nil
end

local hideOffset = sm_vec3_new(10000000, 10000000, 10000000)

function quad_effectHide(effect)
    if effect and sm_exists(effect) then
        local data = effectsData[effect.id]
        if data[3] and data[3].noRotateEffects then
            effect_setOffsetPosition(effect, hideOffset)
        else
            effect_setOffsetRotation(effect, data[7])
        end
        data[2] = false
    end
end

function quad_effectShow(effect)
    if effect and sm_exists(effect) then
        local data = effectsData[effect.id]
        if data[3] and data[3].noRotateEffects then
            effect_setOffsetPosition(effect, data[6])
        else
            effect_setOffsetRotation(effect, data[8])
        end
        data[2] = true
    end
end

function quad_destroyChildren(self)
    local children = self.children

    quad_destroy(children[1])
    quad_destroy(children[2])
    quad_destroy(children[3])
    quad_destroy(children[4])

    self.children = nil
    self.effect = quad_createEffect(self.root, self.x, self.y, self.size, self.size)
end


function quad_optimize(self)
    if debug_disableoptimize then return end

    local children = self.children
    if children then
        --debug_print("children found!!!")

        quad_optimize(children[1])
        quad_optimize(children[2])
        quad_optimize(children[3])
        quad_optimize(children[4])

        local color = children[1].color
        
        -- check children the same color
        local same = true
        for i = 2, 4 do
            if children[i].color ~= color then
                --debug_print("color is not equals", tostring(children[i].color), tostring(color))
                same = false
                break
            end
        end

        --[[
        local same = false
        for i = 2, 4 do
            if children[i].color == color then
                --debug_print("color is not equals", tostring(children[i].color), tostring(color))
                same = true
                break
            end
        end
        ]]

        if color and same then
            --debug_print("quad_optimize successful")

            quad_destroyChildren(self)

            --[[
            quad_destroy(children[1])
            for i = 2, 4 do
                if children[i].color == color then quad_destroy(children[i]) end
            end

            self.children = nil
            self.effect = quad_createEffect(self.root, self.x, self.y, self.sizeX, self.sizeY)
            ]]



            self.color = color
            quad_updateEffectColor(self)

            --if self.root.display.isRendering then
            --    quad_effectShow(self.effect)
            --end
        end
    end

    --return not not children
end

function quad_split(self)
    --assert(self.children == nil, "quad node already has children")
    --assert(self.size > 1, "cant split size 1")

    --quad_effectHide(self.effect)
    quad_destroyEffect(self)

    local hsize = self.size / 2
    local x = self.x
    local y = self.y
    local color = self.color

    self.children = {
        quad_createNode(self, x, y, hsize, hsize, color),
        quad_createNode(self, x + hsize, y, hsize, hsize, color),
        quad_createNode(self, x, y + hsize, hsize, hsize, color),
        quad_createNode(self, x + hsize, y + hsize, hsize, hsize, color)
    }

    self.color = nil
end

function quad_findChild(self, tx, ty, size)
    if self.size ~= size then
        if not self.children then quad_split(self) end

        local hsize = self.size / 2

        local i = math_floor((tx - self.x) / hsize) + 2 * math_floor((ty - self.y) / hsize)
        --assert(self.children[i + 1] ~= nil, "children[i+1] is nil, i:"..i.." x:"..tx.." y:"..ty)
        return quad_findChild(self.children[i + 1], tx, ty, size)
    else
        return self
    end
end

--[[
function quad_treeMultiSetColor(self, coords, color)
    local coord0 = table_remove(coords, 1)

    if coord0 then
        local x0, y0 = unpack(coord0)
        local child
        local function updateChild(x, y)
            child = quad_findChild(self, x, y, 4)
        end

        updateChild(x0, y0)
        quad_treeSetColor(child, x0, y0, color)

        for k, v in pairs(coords) do
            local x, y = unpack(v)
            if pointInQuad(x, y, child.x, child.y, child.size) then
                quad_treeSetColor(child, x, y, color)
            else
                updateChild(x, y)
                quad_treeSetColor(child, x, y, color)
            end
        end
    end
end
]]


function quad_treeSetColor(self, tx, ty, color)
    if self and self.color ~= color then
        if self.size ~= 1 then
            if not self.children then quad_split(self) end

            local Q_hsize = 2 / self.size
            return quad_treeSetColor(self.children[math_floor((tx - self.x) * Q_hsize) + 2 * math_floor((ty - self.y) * Q_hsize) + 1], tx, ty, color)
        else
            if self.color ~= color then
                self.color = color
                quad_updateEffectColor(self)
            end
        end
    else
        return true
    end
end

function quad_treeFillRect(self, x, y, w, h, color)
    local sx = self.x
    local sy = self.y
    local ssize = self.size

    if quadIntersectsRect(sx, sy, ssize, x, y, w, h) then

        if quadInRect(sx, sy, ssize, x, y, w, h) then
            if self.children then
                quad_destroyChildren(self)
            end

            if self.color ~= color then
                self.color = color
                quad_updateEffectColor(self)
            end
            --if self.root.display.isRendering then
            --    quad_effectShow(self.effect)
            --end
        else
            if not self.children then quad_split(self) end
            local children = self.children

            quad_treeFillRect(children[1], x, y, w, h, color)
            quad_treeFillRect(children[2], x, y, w, h, color)
            quad_treeFillRect(children[3], x, y, w, h, color)
            quad_treeFillRect(children[4], x, y, w, h, color)
        end
    end
end

function quad_treeFillCircle(self, x, y, r, color)
    local sx = self.x
    local sy = self.y
    local ssize = self.size

    if quadIntersectsCircle(sx, sy, ssize, x, y, r) then
        if quadInCircle(sx, sy, ssize, x, y, r) then
            if self.children then
                quad_destroyChildren(self)
            end

            if self.color ~= color then
                self.color = color
                quad_updateEffectColor(self)
                return true --если получилось шось отрисовать
            end

            --if self.root.display.isRendering then
            --    quad_effectShow(self.effect)
            --end
        else
            if ssize ~= 1 then
                if not self.children then quad_split(self) end

                local children = self.children

                local drawed = false
                if quad_treeFillCircle(children[1], x, y, r, color) then drawed = true end
                if quad_treeFillCircle(children[2], x, y, r, color) then drawed = true end
                if quad_treeFillCircle(children[3], x, y, r, color) then drawed = true end
                if quad_treeFillCircle(children[4], x, y, r, color) then drawed = true end
                return drawed
            end
        end
    end
end

function quad_treeShow(self)
    if self.children then
        local children = self.children

        quad_treeShow(children[1])
        quad_treeShow(children[2])
        quad_treeShow(children[3])
        quad_treeShow(children[4])
    else
        quad_effectShow(self.effect)
    end
end

function quad_treeHide(self)
    if self.children then
        local children = self.children

        quad_treeHide(children[1])
        quad_treeHide(children[2])
        quad_treeHide(children[3])
        quad_treeHide(children[4])
    else
        quad_effectHide(self.effect)
    end
end

function quad_rootRealShow(self, noRecurse)
    --[[
    if self.children then
        local children = self.children

        quad_rootRealShow(children[1])
        quad_rootRealShow(children[2])
        quad_rootRealShow(children[3])
        quad_rootRealShow(children[4])
    end
    if self.effect and sm_exists(self.effect) and effect_isDone(self.effect) then
        effect_start(self.effect)
    end

    if self.bufferedEffects and noRecurse then
        if effect_isDone(self.back_effect) then
            effect_start(self.back_effect)
        end

        for k, v in pairs(self.bufferedEffects) do
            if sm_exists(v) and effect_isDone(v) then
                effect_start(v)
            end
        end
    end
    ]]

    if self.splashEffect and sm_exists(self.splashEffect) and effect_isDone(self.splashEffect) then
        effect_start(self.splashEffect)
    end
    if self.back_effect and effect_isDone(self.back_effect) then
        effect_start(self.back_effect)
    end
    for effect in pairs(self.allEffects) do
        if sm_exists(effect) and effect_isDone(effect) then
            effect_start(effect)
        end
    end
end

function quad_rootRealHide(self, noRecurse)
    --[[
    if self.children then
        local children = self.children

        quad_rootRealHide(children[1])
        quad_rootRealHide(children[2])
        quad_rootRealHide(children[3])
        quad_rootRealHide(children[4])
    end
    if self.effect and sm_exists(self.effect) then
        effect_stop(self.effect)
    end

    if self.bufferedEffects and noRecurse then
        effect_stop(self.back_effect)

        for k, v in pairs(self.bufferedEffects) do
            if sm_exists(v) then
                effect_stop(v)
            end
        end
    end
    ]]

    if self.splashEffect and sm_exists(self.splashEffect) then
        effect_stop(self.splashEffect)
    end
    if self.back_effect then
        effect_stop(self.back_effect)
    end
    for effect in pairs(self.allEffects) do
        if sm_exists(effect) then
            effect_stop(effect)
        end
    end
end

------------------------------------------------------------

local function hideNewEffects(self)
    if self.newEffects then
        for eff in pairs(self.newEffects) do
            effect_stop(eff)
            --quad_effectHide(eff)
        end
    end
end

local function showNewEffects(self)
    if self.newEffects then
        for eff in pairs(self.newEffects) do
            if effect_isDone(eff) then
                effect_start(eff)
            end
            --quad_effectShow(eff)
        end
    end
end

local function applyNew(self)
    if self.isRendering then
        if self.quadTree.splashEffect and effect_isDone(self.quadTree.splashEffect) then
            effect_start(self.quadTree.splashEffect)
        end
        if self.quadTree.back_effect and effect_isDone(self.quadTree.back_effect) then
            effect_start(self.quadTree.back_effect)
        end
        showNewEffects(self)
    else
        --[[
        if self.quadTree.splashEffect then
            effect_stop(self.quadTree.splashEffect)
        end
        if self.quadTree.back_effect then
            effect_stop(self.quadTree.back_effect)
        end
        hideNewEffects(self)
        ]]
        quad_rootRealHide(self.quadTree)
    end
end

------------------------------------------------------------

local function random_hide_show(self, probabilityNum, allow)
    --[[
    local sendallow = (allow or 0) + 1
    if self.children then
        local children = self.children

        random_hide_show(children[1], probabilityNum, sendallow)
        random_hide_show(children[2], probabilityNum, sendallow)
        random_hide_show(children[3], probabilityNum, sendallow)
        random_hide_show(children[4], probabilityNum, sendallow)
    end
    if self.effect and allow and allow >= 2 then
        if probability(probabilityNum) then
            self.effect:stop()
        else
            self.effect:start()
        end
    end
    ]]

    debug_print("random_hide_show")

    local edata
    for effect in pairs(self.quadTree.allEffects) do
        if sm_exists(effect) then
            if probabilityNum > 0 and probability(probabilityNum) then
                edata = effectsData[effect.id]
                --если писклесь хотябы по одной оси меньше или равно 2
                --это позволит рендерить изображения в сильно упрошенном виде
                if edata[4] <= 2 or edata[5] <= 2 then
                    effect_stop(effect)
                end
            elseif effect_isDone(effect) then
                effect_start(effect)
            end
        end
    end
end

local forceRotate = false

local function reset(self)
    self.maxClicks = 16
    self.rotation = 0
    self.settedRotation = 0
    self.skipAtNotSight = false
    self.utf8support = false
    self.renderAtDistance = false
    self.skipAtLags = true
    self.clicksAllowed = false
    self.clickData = {}

    self.needSendData = true

    if self.scriptableObject.data and self.scriptableObject.data.rotate then
        forceRotate = true
        self.api.setRotation(0)
        forceRotate = false
    end
end

function sc.display.createDisplay(scriptableObject, width, height, pixelScale)
    local display = {
        renderingStack = {},
        rnd_idx = 1,
        width = width,
        height = height,
        pixelScale = pixelScale,
        scriptableObject = scriptableObject,
        needUpdate = false,
        serverCache = {},

        -- client
        localLag = 0,
        rnd = math_random(0, 40 * 5),
        dbuffPixels = {},
        quadTree = nil,
        dragging = {interact=false, tinker=false, interactLastPos={x=-1, y=-1}, tinkerLastPos={x=-1, y=-1}},

        buffer1 = {},
        buffer2 = {}
    }

    display.force_update = true --первая отрисовка всегда форсированая
    display.allow_update = true
    display.audience = {}

    return display
end

function sc.display.server_init(self)
    self.old_this_display_blocked = false

    if self.scriptableObject.interactable then
        sc.displaysDatas[self.scriptableObject.interactable.id] = sc.display.server_createData(self)
    end

    reset(self)
end

local function sendFont(self, client)
    local function send(name, arg)
        if client then
            self.scriptableObject.network:sendToClient(client, name, arg)
        else
            self.scriptableObject.network:sendToClients(name, arg)
        end
    end

    if self.customFont then
        send("client_onDataResponse", {fontdata = {width = self.customFont.width, height = self.customFont.height}})
        for name, data in pairs(self.customFont.chars) do
            send("client_onDataResponse", {fontdata = {name = name, data = data}})
        end
    else
        send("client_onDataResponse", {fontdata = {remove = true}})
    end
end

local function isAllow(self)
    return self.width * self.height <= (sc.restrictions.maxDisplays * sc.restrictions.maxDisplays)
end

function sc.display.server_update(self)
    local audienceSize = 0
    for id, timer in pairs(self.audience) do
        audienceSize = audienceSize + 1
        if timer <= 0 then
            self.audience[id] = nil
        else
            self.audience[id] = timer - 1
        end
    end

    local rate = sc.restrictions.screenRate
    if audienceSize == 0 then
        rate = 16
    end

    local ctick = sm.game.getCurrentTick()
    if ctick % rate == 0 then self.allow_update = true end
    if ctick % (40 * 5) == 0 then
		self.forceNative_update = true
		self.serverCache = {}
        self.serverCacheAll = nil
	end
    if ctick % (40 * 2) == 0 then
        self.force_update = true
        self.allow_update = true
        self.stackChecksum = nil

        debug_print("force setted")
    end


    if self.needUpdate and self.this_display_blocked then
        self.rnd_idx = 1
        self.renderingStack = {}
        self.needUpdate = false
    end

    self.this_display_blocked = not isAllow(self)
    if self.this_display_blocked ~= self.old_this_display_blocked then
        self.api.reset()
        self.api.clear()
        self.api.forceFlush()
        if self.this_display_blocked then
            self.renderingStack.oops = true
        end
        self.old_this_display_blocked = self.this_display_blocked
    end

    if self.needSendData then
        --debug_print("self.needSendData")
        self.scriptableObject.network:sendToClients("client_onDataResponse", sc.display.server_createNetworkData(self))
        sendFont(self)

        self.needSendData = false
    end



    if self.needUpdate and self.allow_update then
        if self.rnd_idx > 1 then
            local stackChecksumVal
            local function stackChecksum()
                if not stackChecksumVal then
                    stackChecksumVal = tableChecksum(self.renderingStack)
                end
                return stackChecksumVal
            end

            if self.force_update or
            not self.stackChecksum or
            self.stackChecksumLen ~= self.rnd_idx or
            self.stackChecksum ~= stackChecksum() then
                local cancel
                if self.lastComputer and self.lastComputer.cdata and not self.lastComputer.cdata.unsafe and type(sc.restrictions.lagDetector) == "number" then
                    local oldLagScore = self.lastComputer.lagScore
                    self.lastComputer.lagScore = self.lastComputer.lagScore + (self.rnd_idx * 0.0005 * sc.restrictions.lagDetector)
                    debug_print("lag score delta", self.lastComputer.lagScore - oldLagScore)

                    if self.lastComputer.lagScore > 120 then
                        debug_print_force("lagScore > 120!!")
                        cancel = true
                    end
                end

                if not cancel then
                    self.renderingStack.force = self.force_update
                    self.renderingStack.forceNative = self.forceNative_update
                    self.renderingStack.endPack = true
                    --[[
                    local dist = RENDER_DISTANCE
                    if self.renderAtDistance or self.player then
                        dist = nil
                    end
                    ]]
                    --local dist = nil --sending to all players

                    local whitelist
                    if self.player then
                        whitelist = {[self.player.id] = true}
                    end
                    local maxDist
                    if self.skipAtNotSight and not self.force_update then
                        maxDist = sc.restrictions.rend
                    end

                    if not pcall(vnetwork.sendToClients, self.scriptableObject, "client_onReceiveDrawStack", self.renderingStack, maxDist, whitelist) then
                        self.renderingStack.endPack = false
                        
                        local index = 1
                        local count = 1024
                        local cycles = 0

                        local datapack
                        while true do
                            --datapack = {unpack(self.renderingStack, index, index + (count - 1))}
                            datapack = {unpack(self.renderingStack, index, index + (count - 1))}

                            index = index + count
                            if datapack[#datapack] == self.renderingStack[#self.renderingStack] then
                                datapack.endPack = true
                                if pcall(vnetwork.sendToClients, self.scriptableObject, "client_onReceiveDrawStack", datapack, maxDist, whitelist) then
                                    break
                                else
                                    index = index - count
                                    count = math_floor((count / 2) + 0.5)
                                end
                            elseif not pcall(vnetwork.sendToClients, self.scriptableObject, "client_onReceiveDrawStack", datapack, maxDist, whitelist) then
                                index = index - count
                                count = math_floor((count / 2) + 0.5)
                            end

                            cycles = cycles + 1
                            if cycles > 100 then
                                debug_print_force("cycles to many 100", pcall(vnetwork.sendToClients, self.scriptableObject, "client_onReceiveDrawStack", self.renderingStack, maxDist, whitelist))
                                error("cycles to many 100")
                                break
                            end
                        end
                        debug_print("self.needUpdate-sending end")
                    end
                end

                self.stackChecksum = stackChecksum()
                self.stackChecksumLen = self.rnd_idx
                
                self.force_update = false
                self.allow_update = false
                self.forceNative_update = false

                debug_print("RENDER SENDED!!!")
            end
        end

        self.needUpdate = false
        self.rnd_idx = 1
        self.renderingStack = {}
    end
end

function sc.display.client_init(self)
    --local size = math_max(self.width, self.height)
    --local root = quad_createRoot(self, 0, 0, size, self.width, self.height)
    --self.quadTree = root

    self.scriptableObject.network:sendToServer("server_onDataRequired", sm_localPlayer_getPlayer())

    self.newEffects = {}
    sc_display_client_clear(self, black, true)
    applyNew(self)
    self.newEffects = nil
end


function sc.display.server_destroy(self)
    if self.scriptableObject.interactable then
        sc.displaysDatas[self.scriptableObject.interactable.id] = nil
    end
end

function sc.display.client_destroy(self)
    local quadTree = self.quadTree

    if self.splashEffect and sm_exists(self.splashEffect) then
        effect_destroyAndUnreg(self.splashEffect)
    end
    quad_destroy(quadTree, true)
end

function sc.display.server_createData(self)
    local width = self.width
    local height = self.height

    local rwidth = width
    local rheight = height

    local function checkPos(x, y)
        x = nRound(x)
        y = nRound(y)
        if x ~= x or x < 0 or x >= rwidth then return end -- x ~= x is NAN check
        if y ~= y or y < 0 or y >= rheight then return end -- y ~= y is NAN check
        return x, y
    end

    local function checkRectPos(x, y)
        if x < 0 then x = 0 end
        if y < 0 then y = 0 end
        if x >= rwidth then x = rwidth - 1 end
        if y >= rheight then y = rheight - 1 end
        return x, y
    end

    local function checkRect(x, y, w, h)
        local xneg, yneg = w < 0, h < 0
		w = math_floor(math_abs(w))
        h = math_floor(math_abs(h))
        if x + w > rwidth then
            w = w - ((x + w) - rwidth)
        end
        if y + h > rheight then
            h = h - ((y + h) - rheight)
        end
		if xneg then x = x - w end
		if yneg then y = y - h end
        return x, y, w, h
    end

    local data = {
        isAllow = function ()
            return isAllow(self)
        end,
        getAudience = function()
            local num = 0
            for k, v in pairs(self.audience) do
                num = num + 1
            end
            return num
        end,
        reset = function ()
            reset(self)
            self.api.setFont()
        end,
        getWidth = function ()
            return rwidth
        end,
        getHeight = function ()
            return rheight
        end,
        clear = function (color)
            self.renderingStack = {{
                0,
                color or "000000ff"
            }}
            self.rnd_idx = 2

            self.serverCache = {}
            self.serverCacheAll = color
        end,
        drawPixel = function (x, y, color)
            x, y = checkPos(x, y)
            if x and (self.serverCache[x + (y * rwidth)] or self.serverCacheAll) ~= color then
                self.renderingStack[self.rnd_idx] = {
                    1,
                    color or "ffffffff",
                    x,
                    y
                }
                self.rnd_idx = self.rnd_idx + 1
                self.serverCache[x + (y * rwidth)] = color
            end
        end,
        drawRect = function (x, y, w, h, c)
            x, y = checkRectPos(x, y)
            x, y, w, h = checkRect(x, y, w, h)

            self.renderingStack[self.rnd_idx] = {
                2,
                c or "ffffffff",
                nRound(x),
                nRound(y),
                nRound(w),
                nRound(h)
            }
            self.rnd_idx = self.rnd_idx + 1
            
            self.serverCache = {}
            self.serverCacheAll = nil
        end,
        fillRect = function (x, y, w, h, c)
            x, y = checkRectPos(x, y)
            x, y, w, h = checkRect(x, y, w, h)

            self.renderingStack[self.rnd_idx] = {
                3,
                c or "ffffffff",
                nRound(x),
                nRound(y),
                nRound(w),
                nRound(h)
            }
            self.rnd_idx = self.rnd_idx + 1
            
            self.serverCache = {}
            self.serverCacheAll = nil
        end,
        drawCircle = function (x, y, r, c)
            if r > 1024 then
                r = 1024
            end

            self.renderingStack[self.rnd_idx] = {
                4,
                c or "ffffffff",
                nRound(x) + 0.5, -- +0.5 because center of pixel
                nRound(y) + 0.5, -- +0.5 because center of pixel
                nRound(r)
            }
            self.rnd_idx = self.rnd_idx + 1
            
            self.serverCache = {}
            self.serverCacheAll = nil
        end,
        fillCircle = function (x, y, r, c)
            if r > 1024 then
                r = 1024
            end

            self.renderingStack[self.rnd_idx] = {
                5,
                c or "ffffffff",
                nRound(x) + 0.5, -- +0.5 because center of pixel
                nRound(y) + 0.5, -- +0.5 because center of pixel
                nRound(r)
            }
            self.rnd_idx = self.rnd_idx + 1
            
            self.serverCache = {}
            self.serverCacheAll = nil
        end,
        drawLine = function (x, y, x1, y1, c)
            self.renderingStack[self.rnd_idx] = {
                6,
                c or "ffffffff",
                nRound(x),
                nRound(y),
                nRound(x1),
                nRound(y1)
            }
            self.rnd_idx = self.rnd_idx + 1
            
            self.serverCache = {}
            self.serverCacheAll = nil
        end,
        drawText = function (x, y, text, c)
            if not debug_disabletext then
                self.renderingStack[self.rnd_idx] = {
                    7,
                    c or "ffffffff",
                    nRound(x),
                    nRound(y),
                    tostring(text)
                }
                self.rnd_idx = self.rnd_idx + 1
                
                self.serverCache = {}
                self.serverCacheAll = nil
            end
        end,


        optimize = function ()
            --ручная оптимизация отключена из за того что большенство использует ее неправильно, что вызовет понижения производительности. данная функция сейчас работает полностью автоматически
            --потом может быть что-то придумаю
            --[[
            self.renderingStack[self.rnd_idx] = {
                8
            }
            self.rnd_idx = self.rnd_idx + 1
            ]]
        end,
        update = function () --для совместимости с SCI
            self.lastComputer = sc.lastComputer
            self.needUpdate = true
        end,
        flush = function ()
            self.lastComputer = sc.lastComputer
            self.needUpdate = true
        end,
        forceFlush = function()
            self.lastComputer = sc.lastComputer
            self.force_update = true
            self.needUpdate = true
        end,
        
        getClick = function ()
            local res = table_remove(self.clickData, 1)
            return res
        end,
        setMaxClicks = function (c)
            if type(c) == "number" and c % 1 == 0 and c > 0 and c <= 16 then
                self.maxClicks = c
            else
                error("integer must be in [1; 16]", 2)
            end
        end,
        getMaxClicks = function ()
            return self.maxClicks
        end,
        clearClicks = function ()
            self.clickData = {}
        end,

        setFont = function (font)
            checkArg(1, font, "table", "nil")
            if font then
                basegraphic_checkFont(font)
                self.customFont = {
                    width = font.width,
                    height = font.height,
                    chars = sc.display.optimizeFont(font.chars, font.width, font.height)
                }
            else
                self.customFont = nil
            end
            self.needSendData = true
            self.stackChecksum = nil
        end,

        getFontWidth = function ()
            return (self.customFont and self.customFont.width) or font_width
        end,

        getFontHeight = function ()
            return (self.customFont and self.customFont.height) or font_height
        end,

        setClicksAllowed = function (c)
            if type(c) == "boolean" then
                if self.clicksAllowed ~= c then
                    self.clicksAllowed = c
                    self.needSendData = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getClicksAllowed = function () return self.clicksAllowed end,

        setRenderAtDistance = function (c)
            if type(c) == "boolean" then
                if self.renderAtDistance ~= c then
                    self.renderAtDistance = c
                    self.needSendData = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getRenderAtDistance = function () return self.renderAtDistance end,

        setSkipAtLags = function (state)
            if type(state) == "boolean" then
                if self.skipAtLags ~= state then
                    self.skipAtLags = state
                    self.needSendData = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getSkipAtLags = function () return self.skipAtLags end,

        setRotation = function (rotation)
            if type(rotation) == "number" and rotation % 1 == 0 and rotation >= 0 and rotation <= 3 then
                if self.rotation ~= rotation or forceRotate then
                    self.rotation = rotation
                    self.settedRotation = rotation
                    self.needSendData = true

                    if self.scriptableObject.data and self.scriptableObject.data.rotate then
                        self.rotation = (self.rotation + self.scriptableObject.data.rotate) % 4
                    end

                    if self.rotation == 1 or self.rotation == 3 then
                        rwidth = height
                        rheight = width
                    else
                        rwidth = width
                        rheight = height
                    end
                end
            else
                error("integer must be in [0; 3]", 2)
            end
        end,
        getRotation = function () return self.settedRotation end,

        setFrameCheck = function (framecheck) end, --legacy (stub)
        getFrameCheck = function () return true end, --legacy (stub)


        setSkipAtNotSight = function (skipAtNotSight)
            if type(skipAtNotSight) == "boolean" then
                if self.skipAtNotSight ~= skipAtNotSight then
                    self.skipAtNotSight = skipAtNotSight
                    self.needSendData = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getSkipAtNotSight = function () return self.skipAtNotSight end,

        setUtf8Support = function (state)
            if type(state) == "boolean" then
                if self.utf8support ~= state then
                    self.utf8support = state
                    self.needSendData = true
                end
            else
                error("Type must be boolean", 2)
            end
        end,
        getUtf8Support = function () return self.utf8support end
    }

    self.api = data
    return data
end

function sc.display.server_createNetworkData(self)
    return {
        renderAtDistance = self.renderAtDistance,
        clicksAllowed = self.clicksAllowed,
        skipAtLags = self.skipAtLags,
        rotation = self.rotation,
        skipAtNotSight = self.skipAtNotSight,
        utf8support = self.utf8support
    }
end

function sc.display.server_onDataRequired(self, client)
    --self.dbuffPixels = {}
    --self.dbuffPixelsAll = nil

    self.scriptableObject.network:sendToClient(client, "client_onDataResponse", sc.display.server_createNetworkData(self))
    sendFont(self, client)
    self.serverCache = {}

    self.allow_update = true
    self.force_update = true
    self.forceNative_update = true
end

function sc.display.server_recvPress(self, p, caller)
    if type(p) == "number" then
        if self.lastComputer and (not self.lastComputer.cdata or not self.lastComputer.cdata.unsafe) and type(sc.restrictions.lagDetector) == "number" then
			local num = 0
            for k, v in pairs(self.audience) do
                num = num + 1
            end
			if num == 0 then
				num = 1
			end
            
            local add = (p / num) * sc.restrictions.lagDetector
            self.lastComputer.lagScore = self.lastComputer.lagScore + add
            debug_print("get lag score", add)
        end
    elseif p == "reg" then --user reg
        self.audience[caller.id] = 40
    else
        local d = self.clickData
        if #d <= self.maxClicks then
            table_insert(d, p)
        end
    end
end



















function sc_display_client_clear(self, color, removeAll)
    if not removeAll and color == self.lastLastClearColor2 and not self.scriptableObject.data.noDoubleEffect then
        return true
    end
    self.lastLastClearColor = color
    self.lastLastClearColor2 = color

    local quadTree = self.quadTree
    if removeAll then
        local rotation

        if quadTree then
            rotation = quadTree.rotation
            quad_destroy(quadTree, true)
        end

        local size = math_max(self.width, self.height)
        local root = quad_createRoot(self, 0, 0, size, self.width, self.height)
        if quadTree then
            root.splashEffect = quadTree.splashEffect
        end

        if rotation then
            root.rotation = rotation
        end
        self.quadTree = root
        quadTree = root

        --total_effects = 1 --в мире можно быть много дисплеев
    end

    -------------------------

    if quadTree.children then
        quad_destroyChildren(quadTree)
    end

    if quadTree.color ~= color then
        quadTree.color = color
        quad_updateEffectColor(quadTree)
    end

    --if self.isRendering then
    --    quad_effectShow(quadTree.effect)
    --end

    if self.quadTree.back_effect then
        raw_set_color(self.quadTree.back_effect, color)
    end

    self.dbuffPixels = {}
    self.dbuffPixelsAll = color

    self.buffer1 = {}
    self.buffer2 = {}
    self.buffer1All = nil
    self.buffer2All = nil
end

function sc_display_client_drawPixelForce(self, x, y, color)
    local width = getWidth(self)
    local currentColor = self.dbuffPixels[x + (y * width)] or self.dbuffPixelsAll

    if currentColor and currentColor == color and not debug_disableDBuff then
        return true --если нехрена не поменялось
    end

    quad_treeSetColor(self.quadTree, x, y, color)
    self.dbuffPixels[x + (y * width)] = color
end

function sc_display_client_drawPixel(self, x, y, color)
    x = math_floor(x)
    y = math_floor(y)

    if x >= 0 and x < getWidth(self) and y >= 0 and y < getHeight(self) then
        return sc_display_client_drawPixelForce(self, x, y, color)
    else
        return true
    end
end

function sc_display_client_drawRect(self, x, y, w, h, color)
    local width = getWidth(self)
    local height = getHeight(self)

    if x >= width then return true end
    if y >= height then return true end
    local lx = math_floor(x >= 0 and x or 0)
    local ly = math_floor(y >= 0 and y or 0)
    
    local lw = w - (lx - x)
    local lh = h - (ly - y)

    local rw = width - lx
    local rh = height - ly

    lw = math_floor(lw < rw and lw or rw)
    lh = math_floor(lh < rh and lh or rh)

    local isEffect = false

    for i = lx,lx+lw-1 do
        if not sc_display_client_drawPixelForce(self, i, ly, color) then
            isEffect = true
        end
    end

    local ex = lx+lw-1
    for iy = ly+1, ly+lh-2 do
        if not sc_display_client_drawPixelForce(self, lx, iy, color) then
            isEffect = true
        end
        if not sc_display_client_drawPixelForce(self, ex, iy, color) then
            isEffect = true
        end
    end

    local ey = ly + lh - 1
    for i = lx,lx+lw-1 do
        if not sc_display_client_drawPixelForce(self, i, ey, color) then
            isEffect = true
        end
    end

    return not isEffect
end

function sc_display_client_fillRect(self, x, y, w, h, color)
    self.dbuffPixels = {}
    self.dbuffPixelsAll = nil
    quad_treeFillRect(self.quadTree, math_floor(x), math_floor(y), math_floor(w), math_floor(h), color)

    --[[
    local realAction = false
    local mw, mh = getWidth(self), getHeight(self)
    for cx = x, x + (w - 1) do
        for cy = y, y + (h - 1) do
            if cx >= 0 and cy >= 0 and cx < mw and cy < mh then
                if self.dbuffPixels[x + (y * mw)] or self.dbuffPixelsAll ~= color then
                    self.dbuffPixels[cx + (cy * mw)] = color
                    realAction = true
                end
            end
        end
    end
    if realAction then
        quad_treeFillRect(self.quadTree, math_floor(x), math_floor(y), math_floor(w), math_floor(h), color)
    else
        return true
    end
    ]]
end

sc.display.client_fillRect = sc_display_client_fillRect

local function drawCircle_putpixel(self, cx, cy, x, y, color)
    local posDX_x = cx + x
    local negDX_x = cx - x
    local posDX_y = cx + y
    local negDX_y = cx - y

    local posDY_y = cy + y
    local negDY_y = cy - y
    local posDY_x = cy + x
    local negDY_x = cy - x

    local isEffect = false
    if not sc_display_client_drawPixel(self, posDX_x, posDY_y, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, negDX_x, posDY_y, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, posDX_x, negDY_y, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, negDX_x, negDY_y, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, posDX_y, posDY_x, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, negDX_y, posDY_x, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, posDX_y, negDY_x, color) then isEffect = true end
    if not sc_display_client_drawPixel(self, negDX_y, negDY_x, color) then isEffect = true end
    return not isEffect
end

function sc_display_client_drawCircle(self, x, y, r, color)
    x = math_floor(x)
    y = math_floor(y)
    r = math_floor(r)

    local lx = 0
    local ly = r
    local d = 3 - 2 * r

    local isEffect = false
    if not drawCircle_putpixel(self, x, y, lx, ly, color) then isEffect = true end
    while ly >= lx do
        lx = lx + 1

        if d > 0 then
            ly = ly - 1
            d = d + 4 * (lx - ly) + 10
        else
            d = d + 4 * lx + 6
        end

        if not drawCircle_putpixel(self, x, y, lx, ly, color) then isEffect = true end
    end
    return not isEffect
end

function sc_display_client_fillCircle(self, x, y, r, color)
    if quad_treeFillCircle(self.quadTree, x, y, r, color) then
        self.dbuffPixels = {}
        self.dbuffPixelsAll = nil
    else
        return true
    end

    --[[
    r = math_abs(r)
    local mw, mh = getWidth(self), getHeight(self)
    local cx, cy = math_min(r, 1024), math_min(r, 1024)
    local px, py
    for ix = -cx, cx do
        px = x + ix
        if px >= 0 and px < mw then
            for iy = -cy, cy do
                py = y + iy
                if py >= mh then
                    break
                elseif ix*ix + iy*iy <= r*r and py >= 0 then
                    sc_display_client_drawPixel(self, px, py, color)
                    self.dbuffPixels[px + (py * mw)] = color
                end
            end
            if px == true then --dubble break
                break
            end
        end
    end
    ]]
end

--[[
local function sc_display_client_drawLineForce(self, x, y, x1, y1, color)
    x = math_floor(x)
    y = math_floor(y)
    x1 = math_floor(x1)
    y1 = math_floor(y1)

    local dx = math_abs(x1 - x)
    local sx = x < x1 and 1 or -1
    local dy = -math_abs(y1 - y)
    local sy = y < y1 and 1 or -1
    
    local isEffect = false
    local error = dx + dy
    local e2
    while true do
        if not sc_display_client_drawPixelForce(self, x, y, color) then isEffect = true end

        if x == x1 and y == y1 then break end
        e2 = error * 2
        if e2 >= dy then
            if x == x1 then break end
            error = error + dy
            x = x + sx
        end
        if e2 <= dx then
            if y == y1 then break end
            error = error + dx
            y = y + sy
        end
    end
    return not isEffect
end
]]

-- y = y0 + round( (x-x0) * dy / dx )
function sc_display_client_drawLine(self, x, y, x1, y1, color)
    local width = getWidth(self)
    local height = getHeight(self)
    
    x = math_floor(x)
    y = math_floor(y)
    x1 = math_floor(x1)
    y1 = math_floor(y1)

    local sign_x, sign_y

    local clip_xmin = 0
    local clip_xmax = width - 1

    local clip_ymin = 0
    local clip_ymax = height - 1

    local isEffect = false

    if x == x1 then
        if x < clip_xmin or x > clip_xmax then return not isEffect end

        if y <= y1 then
            if y1 < clip_ymin or y > clip_xmax then return not isEffect end

            y = math_max(y, clip_ymin)
            y1 = math_min(y1, clip_ymax)

            for iy = y, y1 do
                if not sc_display_client_drawPixelForce(self, x, iy, color) then isEffect = true end
            end
        else
            if y < clip_ymin or y1 > clip_ymax then return not isEffect end

            y1 = math_max(y1, clip_ymin)
            y = math_min(y, clip_ymax)

            for iy = y, y1, -1 do
                if not sc_display_client_drawPixelForce(self, x, iy, color) then isEffect = true end
            end
        end

        return not isEffect
    end

    if y == y1 then
        if y < clip_ymin or y > clip_ymax then return not isEffect end

        if x <= x1 then
            if x1 < clip_xmin or x > clip_xmax then return not isEffect end

            x = math_max(x, clip_xmin)
            x1 = math_min(x1, clip_xmax)

            for ix = x, x1 do
                if not sc_display_client_drawPixelForce(self, ix, y, color) then isEffect = true end
            end
        else
            if x < clip_xmin or x1 > clip_xmax then return not isEffect end

            x1 = math_max(x1, clip_xmin)
            x = math_min(x, clip_xmax)

            for ix = x, x1, -1 do
                if not sc_display_client_drawPixelForce(self, ix, y, color) then isEffect = true end
            end
        end

        return not isEffect
    end

    if x < x1 then
        if x > clip_xmax or x1 < clip_xmin then return not isEffect end
        sign_x = 1
    else
        if x1 > clip_xmax or x < clip_xmin then return not isEffect end
        x = -x
        x1 = -x1
        clip_xmin, clip_xmax = -clip_xmax, -clip_xmin

        sign_x = -1
    end

    if y < y1 then
        if y > clip_ymax or y1 < clip_ymin then return not isEffect end
        sign_y = 1
    else
        if y1 > clip_ymax or y < clip_ymin then return not isEffect end
        y = -y
        y1 = -y1
        clip_ymin, clip_ymax = -clip_ymax, -clip_ymin

        sign_y = -1
    end

    local delta_x = x1 - x
    local delta_y = y1 - y

    local delta_x_step = 2 * delta_x
    local delta_y_step = 2 * delta_y

    local xpos = x
    local ypos = y

    if delta_x >= delta_y then
        local error = delta_y_step - delta_x
        local exit = false

        if y < clip_ymin then
            local temp = (2 * (clip_ymin - y) - 1) * delta_x
            local msd = math_floor(temp / delta_y_step)

            xpos = xpos + msd

            if xpos > clip_xmax then return not isEffect end

            if xpos >= clip_xmin then
                local rem = temp - msd * delta_y_step

                ypos = clip_ymin
                error = error - rem - delta_x

                if rem > 0 then
                    xpos = xpos + 1
                    error = error + delta_y_step
                end

                exit = true
            end
        end

        if not exit and x < clip_xmin then
            local temp = delta_y_step * (clip_xmin - x)
            local msd = math_floor(temp / delta_x_step)

            ypos = ypos + msd
            local rem = temp % delta_x_step

            if ypos > clip_ymax or (ypos == clip_ymax and rem >= delta_x) then return not isEffect end

            xpos = clip_xmin
            error = error + rem

            if rem >= delta_x then
                ypos = ypos + 1
                error = error - delta_x_step
            end
        end

        local xpos_end = x1

        if y1 > clip_ymax then
            local temp = delta_x_step * (clip_ymax - y) + delta_x
            local msd = math_floor(temp / delta_y_step)

            xpos_end = x + msd

            if (temp - msd * delta_y_step) == 0 then
                xpos_end = xpos_end - 1
            end
        end

        xpos_end = math_min(xpos_end, clip_xmax) + 1

        if sign_y == -1 then 
            ypos = -ypos 
        end
        if sign_x == -1 then -- TODO * sign
            xpos = -xpos
            xpos_end = -xpos_end
        end

        delta_x_step = delta_x_step - delta_y_step

        while xpos ~= xpos_end do
            if not sc_display_client_drawPixelForce(self, xpos, ypos, color) then isEffect = true end

            if error >= 0 then
                ypos = ypos + sign_y
                error = error - delta_x_step
            else
                error = error + delta_y_step
            end

            xpos = xpos + sign_x
        end
    else
        local error = delta_x_step - delta_y
        local exit = false

        if x < clip_xmin then
            local temp = (2 * (clip_xmin - x) - 1) * delta_y
            local msd = math_floor(temp / delta_x_step)
            ypos = ypos + msd

            if ypos > clip_ymax then return not isEffect end

            if ypos >= clip_ymin then
                local rem = temp - msd * delta_x_step

                xpos = clip_xmin
                error = error - rem - delta_y

                if rem > 0 then
                    ypos = ypos + 1
                    error = error + delta_x_step
                end

                exit = true
            end
        end

        if not exit and y < clip_ymin then
            local temp = delta_x_step * (clip_ymin - y)
            local msd = math_floor(temp / delta_y_step)

            xpos = xpos + msd

            local rem = temp % delta_y_step

            if xpos > clip_xmax or (xpos == clip_xmax and rem >= delta_y) then return not isEffect end

            ypos = clip_ymin
            error = error + rem

            if rem >= delta_y then
                xpos = xpos + 1
                error = error - delta_y_step
            end
        end

        local ypos_end = y1

        if x1 > clip_xmax then
            local temp = delta_y_step * (clip_xmax - x) + delta_y
            local msd = math_floor(temp / delta_x_step)

            ypos_end = y + msd

            if (temp - msd * delta_x_step) == 0 then
                ypos_end = ypos_end - 1
            end
        end

        ypos_end = math_min(ypos_end, clip_ymax) + 1

        if sign_x == -1 then -- TODO * sign
            xpos = -xpos
        end
        if sign_y == -1 then
            ypos = -ypos
            ypos_end = -ypos_end
        end

        delta_y_step = delta_y_step - delta_x_step

        while ypos ~= ypos_end do
            if not sc_display_client_drawPixelForce(self, xpos, ypos, color) then isEffect = true end

            if error >= 0 then
                xpos = xpos + sign_x
                error = error - delta_y_step
            else
                error = error + delta_x_step
            end

            ypos = ypos + sign_y
        end
    end
end


local string_char = string.char

--[[
local function loadChar(self, c)
    local chars = self.customFont and self.customFont.chars or font_chars
    local pixels = chars[c]
    if not pixels and type(c) == "number" then
        pixels = chars[string_char(c)]
    end
    if pixels then return pixels end
    return chars.error or font_chars.error
end

local function drawCharForce(self, x, y, c, color)
    local pixels = loadChar(self, c)
    local v
    for i = 1, #pixels do
        v = pixels[i]
        drawPixelForce(self, x + v[1], y + v[2], color)
    end
end


local function drawChar(self, x, y, c, color)
    local pixels = loadChar(self, c)
    local v
    for i = 1, #pixels do
        v = pixels[i]
        drawPixel(self, x + v[1], y + v[2], color)
    end
end
]]

local _utf8_code = _utf8.code
local _utf8_sub = _utf8.sub
local _utf8_len = _utf8.len
local string_sub = string.sub
local string_len = string.len
local basegraphic_printText = basegraphic_printText
local function sc_display_client_drawText(self, x, y, text, color)
    basegraphic_printText(self.customFont, self.utf8support, self, sc_display_client_drawPixel, sc_display_client_drawPixelForce, x, y, getWidth(self), getHeight(self), text, color)
    --[[
    x = math_floor(x)
    y = math_floor(y)

    local sub, len, byte
    if self.utf8support then
        sub = _utf8_sub
        len = _utf8_len
        byte = _utf8_code
    else
        sub = string_sub
        len = string_len
        byte = string_byte
    end

    local len = len(text)
    local font_width = font_width
    local font_height = font_height
    local width = getWidth(self)

    if self.customFont then
        font_width = self.customFont.width
        font_height = self.customFont.height
    end

    if x < 0 then
        local ic = 1
        while x + font_width < 0 do
            x = x + font_width + 1
            ic = ic + 1
            if ic > len or x >= width then
                return
            end
        end
        drawChar(self, x, y, sub(text, ic, ic), color)
        x = x + font_width + 1
        text = sub(text, ic + 1, len)
        len = len - ic
    end

    --старый вариант
    --if y >= 0 and (y + font_height) < self.height then
    --вот допустим размер шрифта по вертикали 1, в таком случаи предельное значения(например 127) окажеться не в пределах, так как 127 + 1 это 128, а 128 не меньше 128
    
    local height = getHeight(self)
    local ex, c
    if y >= 0 and (y + font_height) <= height then
        for i = 1, len do
            c = byte(text, i)

            ex = x + font_width
            if ex < width then
                drawCharForce(self, x, y, c, color)
            else
                drawChar(self, x, y, c, color)
                break
            end
            x = ex + 1
        end
    else
        for i = 1, len do
            c = byte(text, i)

            ex = x + font_width
            drawChar(self, x, y, c, color)
            if ex >= width then
                break
            end
            x = ex + 1
        end
    end
    ]]
end

function sc_display_client_optimize(self)
    if not self.scriptableObject.data.noDoubleEffect then
        local popularColors, oldVal, popularColor = {}, 0
        local edata = effectsData[self.quadTree.back_effect.id]
        local baseValue = 0
        for effect in pairs(self.quadTree.allEffects) do
            local data = effectsData[effect.id]
            if sm_exists(effect) and effect_isPlaying(effect) and data[2] then
                local colorHash = tableChecksum(data[1])
                if not popularColors[colorHash] then
                    popularColors[colorHash] = {data[1], 0}
                end
                local v = data[4] * data[5]
                baseValue = baseValue + v
                popularColors[colorHash][2] = popularColors[colorHash][2] + v
            end
        end
        popularColors[tableChecksum(edata[1])] = {edata[1], (edata[4] * edata[5]) - baseValue}
        for _, dat in pairs(popularColors) do
            if dat[2] > oldVal then
                popularColor = dat[1]
                oldVal = dat[2]
            end
        end

        debug_print("popularColor", popularColor)


        if popularColor and popularColor ~= self.lastLastClearColor then
            raw_set_color(self.quadTree.back_effect, popularColor)
            for effect in pairs(self.quadTree.allEffects) do
                local data = effectsData[effect.id]
                if sm_exists(effect) and effect_isPlaying(effect) and data[2] and data[1] == popularColor then
                    quad_effectHide(effect)
                    --self.quadTree.bf_idx = self.quadTree.bf_idx + 1
                    --self.quadTree.bufferedEffects[self.quadTree.bf_idx] = effect
                end
            end
        
            self.lastLastClearColor = popularColor
            if self.lastLastClearColor2 then
                self.lastLastClearColor2 = popularColor
            end

            debug_print("changed")
        end
    end
    quad_optimize(self.quadTree)
end

local math_sin = math.sin
local basegraphic_doubleBuffering = basegraphic_doubleBuffering

function sc.display.client_update(self, dt)
    --debug_print("total_effects", total_effects)
    --[[
    local allEffs = 0
    for key, value in pairs(self.quadTree.allEffects) do
        allEffs = allEffs + 1
    end
    debug_print("allEffs", allEffs)
    ]]

	if self.forceNativeRender then
		self.forceNativeRender = self.forceNativeRender - (40 / (1 / dt))
	end

    local ctick = getCurrentTick()

    if self.isRendering and self.bufferWait then
        debug_print("buffer flushing")

        self.newEffects = {}
        local isEffect = false
        if basegraphic_doubleBuffering(self, nil, getWidth(self), getHeight(self), self.customFont, self.utf8support, sc_display_client_drawPixelForce, sc_display_client_optimize) then
            self.lastLastClearColor2 = nil
            isEffect = true
        end

        if isEffect then
            debug_print("buffer flushing - isEffect!!")
    
            self.lastClearColor = nil
            self.dispValue = nil

            self.clientDrawingTimer = ctick
            self.lastDrawTime = self.clientDrawingTimer
    
            applyNew(self)
        else
            debug_print("buffer flushing - no effect")
        end


        self.bufferWait = false
        self.newEffects = nil
    end
    
    local scriptableObject = self.scriptableObject
    local quadTree = self.quadTree
    local bufferedEffects = quadTree.bufferedEffects
    local allEffects = quadTree.allEffects

    if debug_printeffects then
        debug_print("total_effects", total_effects, quadTree.bf_idx)
    end
    
    if not debug_disableEffectsBuffer then
        --если картинка давно не обновлялась
        --то минимальное каличество для удаления эфектов 5000
        --а если обновления идей сейчас то только если буферезированых минимум 10000
        local minToRemove = (not self.lastDrawTime or ctick - self.lastDrawTime >= 40) and 5000 or 10000
        if quadTree.bf_idx >= minToRemove then
            local effect
            for i = 1, 250 do
                if quadTree.bf_idx > 0 then
                    effect = table_remove(bufferedEffects)
                    quadTree.bf_idx = quadTree.bf_idx - 1
                    if effect and sm_exists(effect) then
                        --effect_stop(effect)
                        effect_destroyAndUnreg(effect)
                        total_effects = total_effects - 1

                        allEffects[effect] = nil
                    end
                else
                    break
                end
            end
        end

        --[[
        if quadTree.bf_idx >= minToRemove then
            local effect
            for i = 1, 250 do
                effect = table_remove(bufferedEffects, 1)
                if effect then
                    if sm_exists(effect) then
                        effect_stop(effect)
                    end
                    table_insert(bufferedEffects, effect)
                else
                    break
                end
            end
        end
        ]]
    end

    --debug_print("cursor works")
    if scriptableObject.character and self.clicksAllowed and self.tablet_posX and self.tablet_posY and not quadTree.splashEffect then
        if self.cursor then
            if sm_exists(self.cursor) then
                effect_setOffsetPosition(self.cursor, effectsData[self.cursor.id][6] - sm_vec3_new((self.tablet_posX / self.width) * 0.95, (self.tablet_posY / self.height) * 0.95, 0))
                effect_setParameter(self.cursor, "color", sm_color_new(0.6, (0.5 + (math_sin(math_rad(ctick * 4)) / 2)) * 0.6, 0))
            else
                self.cursor = nil
            end
        else
            local old_rotation = quadTree.rotation
            quadTree.rotation = 0
            self.cursor = quad_createEffect(quadTree, 0, 0, 0.06, 0.06, -0.0005, true, true, 0.01)
            --self.cursor = quad_createEffect(quadTree, 0, 0, 1, 1, -0.0005, true, true)
            --self.cursor = sm_effect_createEffect(sc_getEffectName(), quadTree.display.scriptableObject.character)
            --effect_setParameter(self.cursor, "uuid", cursorUuid)
            effect_setParameter(self.cursor, "uuid", sc_display_shapesUuid)
            quadTree.rotation = old_rotation
            effect_start(self.cursor)
        end
    elseif self.cursor then
        --effect_stop(self.cursor)
        effect_destroyAndUnreg(self.cursor)
        self.cursor = nil
        total_effects = total_effects - 1
    end

    --debug_print("dispValue works")
    if self.dispValue then
        self.dispValue = self.dispValue - 1
        if self.dispValue <= 0 then
            self.dispValue = nil
            
            debug_print("lastClearColor", self.lastClearColor)

            self.newEffects = {}
            sc_display_client_clear(self, self.lastClearColor, true)
            applyNew(self)
            self.newEffects = nil

            self.lastClearColor = nil
        end
    end

    if self.clientDrawingTimer and (
        self.optimize_flag or
        not self.oldOptimizeTime or
        ctick - self.oldOptimizeTime >= (40 * 5) or --автооптимизация каждые 5 секунд
        ctick - self.clientDrawingTimer >= 40 --если более секунды не было отрисовки - оптимизация
    ) then
        self.clientDrawingTimer = nil
        self.optimize_flag = nil
        self.oldOptimizeTime = ctick
        
        debug_print("effects optimization")

        self.newEffects = {}
        sc_display_client_optimize(self)
        applyNew(self)
        self.newEffects = nil
    end

    local localPlayer = sm_localPlayer_getPlayer().character
    if localPlayer and sc.restrictions then
        --[[
        local playerPos = localPlayer.worldPosition
        local selfPos
        if scriptableObject.shape then
            selfPos = scriptableObject.shape.worldPosition
        else
            selfPos = scriptableObject.character.worldPosition
        end
        ]]
        local playerPos = sm_camera_getPosition()
        local selfPos = scriptableObject.shape and scriptableObject.shape.worldPosition

        local nowIsRendering, dist = false
        if selfPos then
            dist = mathDist(selfPos, playerPos)
        end

        local r = sc.restrictions and sc.restrictions.rend
        if scriptableObject.character then
            if self.tablet_posX or self.renderAtDistance then --функция renderAtDistance на планшете паказывает экран когда планшет не в руке
                nowIsRendering = true
            end
        else
            local rendondist = sc.restrictions.allowDist and self.renderAtDistance
            if rendondist or dist < r then
                if rendondist then
                    nowIsRendering = true
                elseif self.last_raycast_time then
                    nowIsRendering = (ctick - self.last_raycast_time) < 10
                end

                if not nowIsRendering then
                    if not sc.restrictions or sc.restrictions.rays == 0 then
                        nowIsRendering = true
                    else
                        local detectedShapes = cl_displayRaycast(self, playerPos, r)
                        local localPoint, scale, pointX, pointY
                        for shape, result in pairs(detectedShapes) do
                            if shape.id == scriptableObject.shape.id then
                                localPoint = shape:transformPoint(result.pointWorld)
        
                                if localPoint and localPoint.x < 0 then
                                    localPoint = sm_vec3_new(0, localPoint.y, localPoint.z)
                                    scale = sc_display_PIXEL_SCALE * self.pixelScale
                    
                                    pointX = math_floor(self.width / 2 - localPoint.z / scale)
                                    pointY = math_floor(self.height / 2 + localPoint.y / scale)
                                
                                    if pointX >= 0 and pointX < self.width and pointY >= 0 and pointY < self.height then
                                        nowIsRendering = true
                                        self.last_raycast_time = ctick
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        --debug_print("isRendering works")
        local nowRender
        if self.isRendering ~= nowIsRendering then
            if nowIsRendering then
                nowRender = true
                quad_rootRealShow(quadTree, self)
            else
                quad_rootRealHide(quadTree, self)
            end
        end
        self.isRendering = nowIsRendering

        --debug_print("click works")
        if self.dragging.interact then
            sc.display.client_onClick(self, 1, "drag")
        elseif self.dragging.tinker then
            sc.display.client_onClick(self, 2, "drag")
        end

        --debug_print("random_hide_show works")
        if nowIsRendering and sc.restrictions and sc.restrictions.optSpeed and dist then
            local meters = math_floor(dist + 0.5)
            if meters ~= self.meters or nowRender or not self.old_opt then
                --if self.clientDrawingTimer then
                --    random_hide_show(self, 0)
                --end
                --debug_print("meters changed")
                
                local p = 0
                if meters > 2 then
                    p = ((meters * sc.restrictions.optSpeed) / self.pixelScale) * 4
                    p = constrain(p, 0, 100)
                    if p < 10 then
                        p = 0
                    --elseif p > 60 then
                    --    p = (p * 0.5) + 30
                    end
                    if p > 80 then
                        p = 80
                    end
                end

                if not self.old_p then self.old_p = p end
                --print("P", p, self.old_p, math.abs(p - self.old_p))
                if math_abs(p - self.old_p) > 5 or nowRender or not self.old_opt then
                    random_hide_show(self, p)
                    self.old_p = p
                end

                self.meters = meters
            end
        end

        if nowIsRendering then
            self.scriptableObject.network:sendToServer("server_recvPress", "reg")

            if self.old_opt and not sc.restrictions.optSpeed then
                random_hide_show(self, 0)
            end
        end
        self.old_opt = not not sc.restrictions.optSpeed
    end

    --debug_print("self.restrictions", self.restrictions, self.isRendering and self.restrictions and self.restrictions.opt)

    --[[
    if (getCurrentTick() + self.rnd) % (40 * 4) == 40 then
        debug_print("clear doValueHashCache")
        doValueHashCache = {}
    end
    ]]

    if self.clearLastClearColor3 then
        self.clearLastClearColor3 = self.clearLastClearColor3 - 1
        if self.clearLastClearColor3 <= 0 then
            self.old_backgroundChanged = false
            self.lastClearColor3 = nil
            self.clearLastClearColor3 = nil
        end
    end

    ------stylus
    --debug_print("stylus works")
    if scriptableObject.character then
        if self.tablet_left ~= self.old_tablet_left then
            sc.display.client_onInteract(self, nil, not not self.tablet_left)
        end
    
        if self.tablet_right ~= self.old_tablet_right then
            sc.display.client_onTinker(self, nil, not not self.tablet_right)
        end

        self.old_tablet_left = self.tablet_left
        self.old_tablet_right = self.tablet_right
    else
        if _G.stylus_left ~= self.old_stylus_left then
            sc.display.client_onInteract(self, nil, not not _G.stylus_left)
        end
    
        if _G.stylus_right ~= self.old_stylus_right then
            sc.display.client_onTinker(self, nil, not not _G.stylus_right)
        end

        self.old_stylus_left = _G.stylus_left
        self.old_stylus_right = _G.stylus_right
    end

    if ctick % 20 == 0 then
        if self.localLag > 0 then
            self.scriptableObject.network:sendToServer("server_recvPress", self.localLag)
            self.localLag = 0
        end
    end
end

function sc.display.client_onDataResponse(self, data)
    debug_print("client_onDataResponse", data)
    local font_data = data.fontdata
    if font_data then
        if not sm_isHost then
            if font_data.remove then
                debug_print("custom font erase")
                self.customFont = nil
            else
                if font_data.width then
                    debug_print("custom font init")
                    self.customFont = {width = font_data.width, height = font_data.height, chars = {}}
                else
                    --debug_print("custom font add", font_data.name, tostring(font_data.data))
                    self.customFont.chars[font_data.name] = font_data.data
                end
            end
        end
        return
    end

    self.quadTree.rotation = data.rotation
    if data.rotation ~= self.old_rotation then
        self.dbuffPixels = {}
        self.dbuffPixelsAll = nil

        self.buffer1 = {}
        self.buffer2 = {}
        self.buffer1All = nil
        self.buffer2All = nil

        self.old_rotation = data.rotation
    end

    if sm_isHost then return end
    self.clicksAllowed = data.clicksAllowed
    self.renderAtDistance = data.renderAtDistance
    self.skipAtLags = data.skipAtLags
    self.skipAtNotSight = data.skipAtNotSight
    self.utf8support = data.utf8support
end


local drawActions = {
    [sc_display_drawType.clear] = function (self, t) return sc_display_client_clear(self, t[2]) end,
    [sc_display_drawType.drawPixel] = function (self, t) return sc_display_client_drawPixel(self, t[3], t[4], t[2]) end,
    [sc_display_drawType.drawRect] = function (self, t) return sc_display_client_drawRect(self, t[3], t[4], t[5], t[6], t[2]) end,
    [sc_display_drawType.fillRect] = function (self, t) return sc_display_client_fillRect(self, t[3], t[4], t[5], t[6], t[2]) end,
    [sc_display_drawType.drawCircle] = function (self, t) return sc_display_client_drawCircle(self, t[3], t[4], t[5], t[2]) end,
    [sc_display_drawType.fillCircle] = function (self, t) return sc_display_client_fillCircle(self, t[3], t[4], t[5], t[2]) end,
    [sc_display_drawType.drawLine] = function (self, t) return sc_display_client_drawLine(self, t[3], t[4], t[5], t[6], t[2]) end,
    [sc_display_drawType.drawText] = function (self, t) return sc_display_client_drawText(self, t[3], t[4], t[5], t[2]) end,
    [sc_display_drawType.optimize] = function (self) self.optimize_flag = true end,
}

function sc.display.client_drawStack(self, sendstack)
    local startExecTimeStart = os_clock()

    sendstack = sendstack or self.scriptableObject.sendData
    if sendstack then
        if self.quadTree.splashEffect and sm_exists(self.quadTree.splashEffect) then
            effect_destroyAndUnreg(self.quadTree.splashEffect)
            self.quadTree.splashEffect = nil
        end
        if sendstack.oops then
            local eff = quad_createEffect(self.quadTree, 0, 0, self.quadTree.sizeX, self.quadTree.sizeY, nil, true)
            --effect_setParameter(eff, "uuid", oopsUuid)
            --effect_setParameter(eff, "uuid", sc_display_shapesUuid)
            effect_setParameter(eff, "color", oopsColor)
            if self.scriptableObject.character then
                effectsData[eff.id][8] = sm_quat_fromEuler(sm_vec3_new(180, 90, 0))
                quad_effectShow(eff)
            end
            self.quadTree.splashEffect = eff
            applyNew(self)    
        end

        if sendstack.endPack then
            if self.savestack then
                local lstack = self.savestack
                local lidx = self.savestack_idx
                for i = 1, #sendstack do
                    lstack[lidx] = sendstack[i]
                    lidx = lidx + 1
                end
                self.savestack_idx = lidx
            else
                self.savestack = sendstack
            end
        else
            if not self.savestack then self.savestack = {} self.savestack_idx = 1 end
            local lstack = self.savestack
            local lidx = self.savestack_idx
            for i = 1, #sendstack do
                lstack[lidx] = sendstack[i]
                lidx = lidx + 1
            end
            self.savestack_idx = lidx
            return
        end
    end
    local stack = self.savestack
    self.savestack = nil
    self.savestack_idx = nil
    if not stack then
        return
    end

    debug_print("start render --------------------", self.isRendering, sendstack.force, self.skipAtLags, self.skipAtNotSight, self.forceNativeRender)

    if sendstack.force then
        self.dbuffPixels = {}
        self.dbuffPixelsAll = nil
    else
        if self.skipAtNotSight and not self.isRendering then debug_print("skipAtNotSight skipped") return end --если skipAtNotSight true, то картинка не будет обновляться когда ты на нее не смотриш
        if self.skipAtLags and sc.restrictions and sc.deltaTime >= (1 / sc.restrictions.skipFps) then debug_print("skipAtLags skipped") return end
    end

    self.localLag = self.localLag + ((os_clock() - startExecTimeStart) * sc.clockLagMul)
    if self.localLag > 120 then
        debug_print_force("localLag > 120!!")
    end

    local ctick = getCurrentTick()

    local startExecTime = os_clock()

    local isEndClear = stack[#stack][1] == 0
    local clearColor
	for i, v in ipairs(stack) do
		if v[1] == 0 then
			clearColor = formatColor(v[2], true)
			break
		end
	end

    self.newEffects = {}
    local isEffect = false --если от всего стека был хоть какой-то смысл
    local backgroundChanged = clearColor and clearColor ~= self.lastClearColor3
    debug_print("background change detecter", clearColor, self.lastClearColor3, backgroundChanged, self.old_backgroundChanged)

    if isEndClear and #stack == 1 then
        debug_print("clear only render")

        local col = formatColor(stack[1][2], true)

        self.buffer1 = {}
        self.buffer2 = {}
        self.buffer2All = col
        self.buffer1All = col

        if not sc_display_client_clear(self, col) then
            isEffect = true
        end

        self.oldRenderType = true
        self.bufferWait = false
    elseif self.isRendering and ((backgroundChanged and not self.old_backgroundChanged) or sendstack.forceNative or (self.forceNativeRender and self.forceNativeRender > 0)) then
        debug_print("native render")

        self.buffer1 = {}
        self.buffer2 = {}
        self.buffer2All = nil
        self.buffer1All = nil

        local startRnd = os_clock()
        for _, v in ipairs(stack) do
            v[2] = formatColor(v[2], v[1] == 0)
    
            if v[1] ~= 0 and v[1] ~= 8 then
                self.lastLastClearColor2 = nil
            end
    
            --если хоть что-то не вернуло значения, значит эфект от стека был
            if not drawActions[v[1]](self, v) and v[1] ~= 8 then
                isEffect = true
            end
        end
        self.lastNativeRenderTime = os_clock() - startRnd
        self.oldRenderType = true
        self.bufferWait = false
    else
        debug_print("buffer render")

        local startRnd = os_clock()
        if basegraphic_doubleBuffering(self, stack, getWidth(self), getHeight(self), self.customFont, self.utf8support, self.isRendering and sc_display_client_drawPixelForce, sc_display_client_optimize) then
            self.lastLastClearColor2 = nil
            isEffect = true
        end

		if self.lastNativeRenderTime then
			local rendTime = os_clock() - startRnd
			local dt2 = self.lastNativeRenderTime * 2
			if not self.oldRenderType and dt2 < rendTime and not debug_disableForceNativeRender then
				local add = constrain(math.ceil(rendTime / dt2) * 5, 10, 40)
				debug_print("force native render", self.lastNativeRenderTime, dt2, rendTime, add)
				self.forceNativeRender = add
			end
		end

        self.oldRenderType = false
        if not self.isRendering then
            self.bufferWait = true
        end
    end

    self.old_backgroundChanged = backgroundChanged
    if clearColor then
    	self.lastClearColor3 = clearColor
    end
    self.clearLastClearColor3 = 5

    if isEffect then
        debug_print("isEffect!!")

        if isEndClear then
            self.lastClearColor = clearColor
            self.dispValue = 40 * 2
        else
            self.lastClearColor = nil
            self.dispValue = nil
        end
        
        self.clientDrawingTimer = ctick
        self.lastDrawTime = self.clientDrawingTimer

        applyNew(self)
    else
        debug_print("no effect")
    end
    self.newEffects = nil

    self.localLag = self.localLag + ((os_clock() - startExecTime) * sc.clockLagMul)
    if self.localLag > 120 then
        debug_print_force("localLag > 120!!")
    end
end


function sc.display.client_onClick(self, type, action, localPoint) -- type - 1:interact|2:tinker (e.g 1 or 2), action - pressed, released, drag
    if not self.clicksAllowed or (self.scriptableObject and self.scriptableObject.data and self.scriptableObject.data.noTouch) then
        return
    end

    local function detect(pointX, pointY)
        pointX = math_floor(pointX + 0.5)
        pointY = math_floor(pointY + 0.5)

        if pointX >= 0 and pointX < self.width and pointY >= 0 and pointY < self.height then
            if action == "drag" then
                local t = type == 1 and self.dragging.interactLastPos or self.dragging.tinkerLastPos

                if t.x ~= -1 then
                    if t.x == pointX and t.y == pointY then 
                        return
                    else
                        t.x = pointX
                        t.y = pointY
                    end
                else
                    t.x = pointX
                    t.y = pointY
                    return
                end
            end

            local reverseX, reverseY, changeXY
            if self.quadTree.rotation == 1 then
                changeXY = true
                reverseX = true
            elseif self.quadTree.rotation == 2 then
                reverseX = true
                reverseY = true
            elseif self.quadTree.rotation == 3 then
                changeXY = true
                reverseY = true
            end
            if reverseX then
                pointX = self.width - pointX - 1
            end
            if reverseY then
                pointY = self.height - pointY - 1
            end
            if changeXY then
                pointX, pointY = pointY, pointX
            end

            debug_print("touch", pointX, pointY)

            self.scriptableObject.network:sendToServer("server_recvPress", { pointX, pointY, action, type })
        end
    end

    local function reg(localPoint)
        if localPoint and localPoint.x < 0 then
            local localPoint = sm_vec3_new(0, localPoint.y, localPoint.z)
            local scale = sc_display_PIXEL_SCALE * self.pixelScale

            local pointX = math_floor(self.width / 2 - localPoint.z / scale)
            local pointY = math_floor(self.height / 2 + localPoint.y / scale)
        
            detect(pointX, pointY)
        end
    end
    
    if localPoint then
        reg(localPoint)
    elseif self.scriptableObject.shape then
        local succ, res = sm_localPlayer.getRaycast((sc.restrictions and sc.restrictions.rend) or RENDER_DISTANCE)
        if succ then
            local shape = self.scriptableObject.shape
            local localPoint = shape:transformPoint(res.pointWorld)
            reg(localPoint)
        end
    elseif self.tablet_posX and self.tablet_posY then
        detect(self.tablet_posX, self.tablet_posY)
    end
end

function sc.display.client_onInteract(self, character, state)
    self.dragging.interact = state
    if state then
        local t = self.dragging.interactLastPos
        t.x = -1
        t.y = -1
    end
    sc.display.client_onClick(self, 1, state and "pressed" or "released")
end

function sc.display.client_onTinker(self, character, state)
    self.dragging.tinker = state
    if state then
        local t = self.dragging.tinkerLastPos
        t.x = -1
        t.y = -1
    end
    sc.display.client_onClick(self, 2, state and "pressed" or "released")
end

function sc.display.client_canInteract(self, character)
    if self.scriptableObject and self.scriptableObject.data and self.scriptableObject.data.noTouch then
        return false
    end

    return self.clicksAllowed
end

function sc.display.client_canTinker(self, character)
    if self.scriptableObject and self.scriptableObject.data and self.scriptableObject.data.noTouch then
        return false
    end

    return self.clicksAllowed
end
end
function scmframework_21212becc0fd5fdafb0a5bb5a60d2c4a() --$CONTENT_DATA/Scripts/encryptVM/compile/LBI.lua
local lua_opcode_types = {
	"ABC",  "ABx", "ABC",  "ABC",
	"ABC",  "ABx", "ABC",  "ABx", 
	"ABC",  "ABC", "ABC",  "ABC",
	"ABC",  "ABC", "ABC",  "ABC",
	"ABC",  "ABC", "ABC",  "ABC",
	"ABC",  "ABC", "AsBx", "ABC",
	"ABC",  "ABC", "ABC",  "ABC",
	"ABC",  "ABC", "ABC",  "AsBx",
	"AsBx", "ABC", "ABC", "ABC",
	"ABx",  "ABC",
}

local lua_opcode_names = {
	"MOVE",     "LOADK",     "LOADBOOL", "LOADNIL",
	"GETUPVAL", "GETGLOBAL", "GETTABLE", "SETGLOBAL",
	"SETUPVAL", "SETTABLE",  "NEWTABLE", "SELF",
	"ADD",      "SUB",       "MUL",      "DIV",
	"MOD",      "POW",       "UNM",      "NOT",
	"LEN",      "CONCAT",    "JMP",      "EQ",
	"LT",       "LE",        "TEST",     "TESTSET",
	"CALL",     "TAILCALL",  "RETURN",   "FORLOOP",
	"FORPREP",  "TFORLOOP",  "SETLIST",  "CLOSE",
	"CLOSURE",  "VARARG"
};

local function get_bits(input, n, n2)
	if n2 then
		local total = 0
		local digitn = 0
		for i = n, n2 do
			total = total + 2^digitn*get_bits(input, i)
			digitn = digitn + 1
		end
		return total
	else
		local pn = 2^(n-1)
		return (input % (pn + pn) >= pn) and 1 or 0
	end
end

local function decode_bytecode(bytecode)
	local index = 1
	local big_endian = false
    local int_size;
    local size_t;

    -- Actual binary decoding functions. Dependant on the bytecode.
    local get_int, get_size_t;

	-- Binary decoding helper functions
	local floorTo = 5 --шоб убрать лютые касяци с числами
	local get_int8, get_int32, get_int64, get_float64, get_string;
	do
		function get_int8()
			local a = bytecode:byte(index, index);
			index = index + 1
			return round(a, floorTo)
		end
		function get_int32()
            local a, b, c, d = bytecode:byte(index, index + 3);
            index = index + 4;
            return round(d*16777216 + c*65536 + b*256 + a, floorTo)
        end
        function get_int64()
            local a = get_int32();
            local b = get_int32();
            return round(b*4294967296 + a, floorTo)
        end
		function get_float64()
			local a = get_int32()
			local b = get_int32()
			return round((-2*get_bits(b, 32)+1)*(2^(get_bits(b, 21, 31)-1023))*
			       ((get_bits(b, 1, 20)*(2^32) + a)/(2^52)+1), floorTo)
		end
		function get_string(len)
			local str;
            if len then
	            str = bytecode:sub(index, index + len - 1);
	            index = index + len;
            else
                len = get_size_t();
	            if len == 0 then return; end
	            str = bytecode:sub(index, index + len - 1);
	            index = index + len;
            end
            return str;
        end
	end

	local function decode_chunk()
		local chunk;
		local instructions = {};
		local constants    = {};
		local prototypes   = {};
		local debug = {
			lines = {};
		};

		chunk = {
			instructions = instructions;
			constants    = constants;
			prototypes   = prototypes;
			debug = debug;
		};

		local num;

		chunk.name       = get_string();-- Function name
		chunk.first_line = get_int();	-- First line
		chunk.last_line  = get_int();	-- Last  line

        if chunk.name then chunk.name = chunk.name:sub(1, -2); end
		
		chunk.upvalues  = get_int8();
		chunk.arguments = get_int8();
		chunk.varg      = get_int8();
		chunk.stack     = get_int8();

        -- TODO: realign lists to 1
		-- Decode instructions
		do
			num = get_int();
			for i = 1, num do
				local instruction = {
					-- opcode = opcode number;
					-- type   = [ABC, ABx, AsBx]
					-- A, B, C, Bx, or sBx depending on type
				};

				local data   = get_int32();
				local opcode = get_bits(data, 1, 6);
				local type   = lua_opcode_types[opcode + 1];

				instruction.opcode = opcode;
				instruction.type   = type;
				
				instruction.A = get_bits(data, 7, 14);
				if type == "ABC" then
					instruction.B = get_bits(data, 24, 32);
					instruction.C = get_bits(data, 15, 23);
				elseif type == "ABx" then
					instruction.Bx = get_bits(data, 15, 32);
				elseif type == "AsBx" then
					instruction.sBx = get_bits(data, 15, 32) - 131071;
				end

				instructions[i] = instruction;
			end
		end

		-- Decode constants
		do
			num = get_int();
			for i = 1, num do
				local constant = {
					-- type = constant type;
					-- data = constant data;
				};
				local type = get_int8();
				constant.type = type;

				if type == 1 then
					constant.data = (get_int8() ~= 0);
				elseif type == 3 then
					constant.data = get_float64();
				elseif type == 4 then
					constant.data = get_string():sub(1, -2);
				end

				constants[i-1] = constant;
			end
		end

		-- Decode Prototypes
		do
			num = get_int();
			for i = 1, num do
				prototypes[i-1] = decode_chunk();
			end
		end

		-- Decode debug info
        -- Not all of which is used yet.
		do
			-- line numbers
			local data = debug.lines
			num = get_int();
			for i = 1, num do
				data[i] = get_int32();
			end

			-- locals
			num = get_int();
			for i = 1, num do
				get_string():sub(1, -2);	-- local name
				get_int32();	-- local start PC
				get_int32();	-- local end   PC
			end

			-- upvalues
			num = get_int();
			for i = 1, num do
				get_string();	-- upvalue name
			end
		end

		return chunk;
	end

	-- Verify bytecode header
	do
		assert(get_string(4) == "\27Lua", "Lua bytecode expected.");
		assert(get_int8() == 0x51, "Only Lua 5.1 is supported.");
		get_int8(); 	-- Oficial bytecode
		big_endian = (get_int8() == 0);
        int_size = get_int8();
        size_t   = get_int8();

        if int_size == 4 then
            get_int = get_int32;
        elseif int_size == 8 then
            get_int = get_int64;
        else
	        -- TODO: refactor errors into table
            error("Unsupported bytecode target platform");
        end

        if size_t == 4 then
            get_size_t = get_int32;
        elseif size_t == 8 then
            get_size_t = get_int64;
        else
            error("Unsupported bytecode target platform");
        end

        assert(get_string(3) == "\4\8\0",
	           "Unsupported bytecode target platform");
	end

	return decode_chunk();
end

local function handle_return(...)
	local c = select("#", ...)
	local t = {...}
	return c, t
end

local function create_wrapper(cache, upvalues, environment)
	local instructions = cache.instructions;
	local constants    = cache.constants;
	local prototypes   = cache.prototypes;
	
	local stack, top
	local IP = 1;	-- instruction pointer
	local vararg, vararg_size 

	local opcode_funcs = {
		[0]  = function(instruction)	-- MOVE
			stack[instruction.A] = stack[instruction.B];
		end,
		[1]  = function(instruction)	-- LOADK
			stack[instruction.A] = constants[instruction.Bx].data;
		end,
		[2]  = function(instruction)	-- LOADBOOL
			stack[instruction.A] = instruction.B ~= 0
			if instruction.C ~= 0 then
				IP = IP + 1
			end
		end,
		[3]  = function(instruction)	-- LOADNIL
			local stack = stack
			for i = instruction.A, instruction.B do
				stack[i] = nil
			end
		end,
		[4] = function(instruction)		-- GETUPVAL
			stack[instruction.A] = upvalues[instruction.B]
		end,
		[5]  = function(instruction)	-- GETGLOBAL
			local key = constants[instruction.Bx].data;
			stack[instruction.A] = environment[key];
		end,
		[6]  = function(instruction)	-- GETTABLE
			local C = instruction.C
			local stack = stack
			C = C > 255 and constants[C-256].data or stack[C]
			stack[instruction.A] = stack[instruction.B][C];
		end,
		[7]  = function(instruction)	-- SETGLOBAL
			local key = constants[instruction.Bx].data;
			environment[key] = stack[instruction.A];
		end,
		[8] = function (instruction)	-- SETUPVAL
			upvalues[instruction.B] = stack[instruction.A]
		end,
		[9] = function (instruction)	-- SETTABLE
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A][B] = C
		end,
		[10] = function (instruction)	-- NEWTABLE
			stack[instruction.A] = {}
		end,
		[11] = function (instruction)	-- SELF
			local A = instruction.A
			local B = instruction.B
			local C = instruction.C
			local stack = stack
			
			B = stack[B]
			C = C > 255 and constants[C-256].data or stack[C]
			
			stack[A+1] = B
			stack[A]   = B[C]
		end,
		[12] = function(instruction)	-- ADD
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A] = B+C;
		end,
		[13] = function(instruction)	-- SUB
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A] = B - C;	
		end,
		[14] = function(instruction)	-- MUL
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A] = B * C;
		end,
		[15] = function(instruction)	--DIV
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A] = B / C;
		end,
		[16] = function(instruction) 	-- MOD
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A] = B % C;		
		end,
		[17] = function(instruction)	-- POW
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A] = B ^ C;		
		end,
		[18] = function(instruction)	-- UNM
			stack[instruction.A] = -stack[instruction.B]
		end,
		[19] = function(instruction)	-- NOT
			stack[instruction.A] = not stack[instruction.B]
		end,
		[20] = function(instruction)	-- LEN
			stack[instruction.A] = #stack[instruction.B]
		end,
		[21] = function(instruction)	-- CONCAT
			local B = instruction.B
			local result = stack[B]
			for i = B+1, instruction.C do
				result = result .. stack[i] 
			end
			stack[instruction.A] = result
		end,
		[22] = function(instruction)	-- JUMP
			IP = IP + instruction.sBx
		end,
		[23] = function(instruction)	-- EQ
			local A = instruction.A
			local B = instruction.B
			local C = instruction.C
			local stack, constants = stack, constants
			
			A = A ~= 0
			B = B > 255 and constants[B-256].data or stack[B]
			C = C > 255 and constants[C-256].data or stack[C]
			if (B == C) ~= A then
				IP = IP + 1
			end
		end,
		[24] = function(instruction)	-- LT
			local A = instruction.A
			local B = instruction.B
			local C = instruction.C
			local stack, constants = stack, constants
			
			A = A ~= 0
			B = B > 255 and constants[B-256].data or stack[B]
			C = C > 255 and constants[C-256].data or stack[C]
			if (B < C) ~= A then
				IP = IP + 1
			end		
		end,
		[25] = function(instruction)	-- LT
			local A = instruction.A
			local B = instruction.B
			local C = instruction.C
			local stack, constants = stack, constants
			
			A = A ~= 0
			B = B > 255 and constants[B-256].data or stack[B]
			C = C > 255 and constants[C-256].data or stack[C]
			if (B <= C) ~= A then
				IP = IP + 1
			end		
		end,
		[26] = function(instruction)	-- TEST
			if (not not stack[instruction.A]) == (instruction.C == 0) then
				IP = IP + 1
			end
		end,
		[27] = function(instruction)	-- TESTSET
			local stack = stack
			local B = stack[instruction.B]
			if (not not B) == (instruction.C == 0) then
				IP = IP + 1
			else
				stack[instruction.A] = B
			end
		end,
		[28] = function(instruction)	-- CALL
			local A = instruction.A;
			local B = instruction.B;
			local C = instruction.C;
			local stack = stack;
			local args, results;
			local limit, loop
			
			args = {};
			if B ~= 1 then
				if B ~= 0 then
					limit = A+B-1;
				else
					limit = top
				end
				
				loop = 0
				for i = A+1, limit do
					loop = loop + 1
					args[loop] = stack[i];
				end
				
				limit, results = handle_return(stack[A](unpack(args, 1, limit-A)))
			else
				limit, results = handle_return(stack[A]())
			end
			
			top = A - 1
		
			if C ~= 1 then
				if C ~= 0 then
					limit = A+C-2;
				else
					limit = limit+A
				end
				
				loop = 0;
				for i = A, limit do
					loop = loop + 1;
					stack[i] = results[loop];
				end
			end
		end,
		[29] = function (instruction)	-- TAILCALL
			local A = instruction.A;
			local B = instruction.B;
			local C = instruction.C;
			local stack = stack;
			local args, results;
			local top, limit, loop = top
			
			args = {};
			if B ~= 1 then
				if B ~= 0 then
					limit = A+B-1;
				else
					limit = top
				end
				
				loop = 0
				for i = A+1, limit do
					loop = loop + 1
					args[#args+1] = stack[i];
				end
				
				results = {stack[A](unpack(args, 1, limit-A))};
			else
				results = {stack[A]()};
			end
			
			return true, results
		end,
		[30] = function(instruction) -- RETURN
			--TODO: CLOSE
			local A = instruction.A;
			local B = instruction.B;
			local stack = stack;
			local limit;
			local loop, output;
						
			if B == 1 then
				return true;
			end
			if B == 0 then
				limit = top
			else
				limit = A + B - 2;
			end
			
			output = {};
			local loop = 0
			for i = A, limit do
				loop = loop + 1
				output[loop] = stack[i];
			end
			return true, output;
		end,
		[31] = function(instruction)	-- FORLOOP
			local A = instruction.A
			local stack = stack
			
			local step = stack[A+2]
			local index = stack[A] + step 
			stack[A] = index
			
			if step > 0 then
				if index <= stack[A+1] then
					IP = IP + instruction.sBx
					stack[A+3] = index
				end
			else
				if index >= stack[A+1] then
					IP = IP + instruction.sBx
					stack[A+3] = index
				end
			end
		end,
		[32] = function(instruction)	-- FORPREP
			local A = instruction.A
			local stack = stack
			
			stack[A] = stack[A] - stack[A+2]
			IP = IP + instruction.sBx 
		end,
		[33] = function(instruction)	-- TFORLOOP
			local A = instruction.A
			local B = instruction.B
			local C = instruction.C
			local stack = stack
			
			local offset = A+2
			local result = {stack[A](stack[A+1], stack[A+2])}
			for i = 1, C do
				stack[offset+i] = result[i]
			end
			
			if stack[A+3] ~= nil then
				stack[A+2] = stack[A+3]
			else
				IP = IP + 1
			end
		end,
		[34] = function(instruction)	-- SETLIST
			local A = instruction.A
			local B = instruction.B
			local C = instruction.C
			local stack = stack

			if C == 0 then
				error("NYI: extended SETLIST")
			else
				local offset = (C - 1) * 50
				local t = stack[A]
				
				if B == 0 then
					B = top
				end
				for i = 1, B do
					t[offset+i] = stack[A+i]	
				end				
			end
		end,
		[35] = function(instruction)	-- CLOSE
			--io.stderr:write("NYI: CLOSE")
			--io.stderr:flush()
		end,
		[36] = function(instruction)	-- CLOSURE
			local proto = prototypes[instruction.Bx]
			local instructions = instructions
			local stack = stack
			
			local indices = {}
			new_upvals = class(nil)
			new_upvals.__index = function(t, k)
				local upval = indices[k]
				return upval.segment[upval.offset]
			end
			new_upvals.__newindex = function(t, k, v)
				local upval = indices[k]
				upval.segment[upval.offset] = v
			end
			new_upvals = new_upvals()

			for i = 1, proto.upvalues do
				local movement = instructions[IP]
				if movement.opcode == 0 then -- MOVE
					indices[i-1] = {segment = stack, offset = movement.B}
				elseif instructions[IP].opcode == 4 then -- GETUPVAL
					indices[i-1] = {segment = upvalues, offset = movement.B}
				end
				IP = IP + 1
			end
			
			local _, func = create_wrapper(proto, new_upvals, environment)
			stack[instruction.A] = func
		end,
		[37] = function(instruction)	-- VARARG
			local A = instruction.A
			local B = instruction.B
			local stack, vararg = stack, vararg
			
			for i = A, A + (B > 0 and B - 1 or vararg_size) do
				stack[i] = vararg[i - A]
			end
		end,
	}
	
	local function loop()
		local instructions = instructions
		local instruction, a, b
		
		while true do
			instruction = instructions[IP];
			IP = IP + 1
			a, b = opcode_funcs[instruction.opcode](instruction);
			if a then
				return b;
			end
		end
	end

	local debugging = {
		get_stack = function()
			return stack;
		end;
		get_IP = function()
			return IP;
		end
	};

	local function func(...)
		local local_stack = {};
		local ghost_stack = {};

		top = -1
		stack = class(nil)
		stack.__index = ghost_stack
		stack.__newindex = function(t, k, v)
			if k > top and v then
				top = k
			end
			ghost_stack[k] = v
		end
		stack = stack()
		local_stack = stack
		
		local args = {...};	
		vararg = {}
		vararg_size = select("#", ...) - 1
		for i = 0, vararg_size do
			local_stack[i] = args[i+1];
			vararg[i] = args[i+1]
		end
		
		IP = 1;
		local a, b = pcall(loop)

		if a then
			if b then
				return unpack(b);
			end
			return;
		else
			--TODO error converting
			local name = cache.name;
			local line = cache.debug.lines[IP];
			local err  = b:gsub("(.-:)", "");
			local output = "";
			
			output = output .. (name and name .. ":" or "");
			output = output .. (line and line .. ":" or "");
			output = output .. b
			--[[
			output = ("%s (Instruction=%s)"):format(output, 
				lua_opcode_names[select(2,debug.getlocal(loop,1, 1)).opcode+1])
			--]]
			error(output, 0);
		end
	end

	return debugging, func;
end

_G.encryptVM_compile.lbi = {
	load_bytecode = function(bytecode,env)
		local cache = decode_bytecode(bytecode);
		local _, func = create_wrapper(cache, nil, env);
		return func;
	end;

	-- Utilities (Debug, Introspection, Testing, etc)
	utils = {
		decode_bytecode = decode_bytecode;
		create_wrapper = create_wrapper;
		debug_bytecode = function(bytecode)
			local cache = decode_bytecode(bytecode)
			return create_wrapper(cache);
		end;
	};
}
end
function scmframework_fc549321681b4026f71eb3ae79422d29() --$CONTENT_DATA/Scripts/encryptVM/compile/LuaK.lua
--[[--------------------------------------------------------------------

  lcode.lua
  Lua 5 code generator in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2007 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * one function manipulate a pointer argument with a simple data type
--   (can't be emulated by a table, ambiguous), now returns that value:
--   luaK:concat(fs, l1, l2)
-- * luaM_growvector uses the faux luaY:growvector, for limit checking
-- * some function parameters changed to boolean, additional code
--   translates boolean back to 1/0 for instruction fields
--
-- Not implemented:
-- * NOTE there is a failed assert in luaK:addk, a porting problem
--
-- Added:
-- * constant MAXSTACK from llimits.h
-- * luaK:ttisnumber(o) (from lobject.h)
-- * luaK:nvalue(o) (from lobject.h)
-- * luaK:setnilvalue(o) (from lobject.h)
-- * luaK:setnvalue(o, x) (from lobject.h)
-- * luaK:setbvalue(o, x) (from lobject.h)
-- * luaK:sethvalue(o, x) (from lobject.h), parameter L deleted
-- * luaK:setsvalue(o, x) (from lobject.h), parameter L deleted
-- * luaK:numadd, luaK:numsub, luaK:nummul, luaK:numdiv, luaK:nummod,
--   luaK:numpow, luaK:numunm, luaK:numisnan (from luaconf.h)
-- * copyexp(e1, e2) added in luaK:posfix to copy expdesc struct
--
-- Changed in 5.1.x:
-- * enum BinOpr has a new entry, OPR_MOD
-- * enum UnOpr has a new entry, OPR_LEN
-- * binopistest, unused in 5.0.x, has been deleted
-- * macro setmultret is new
-- * functions isnumeral, luaK_ret, boolK are new
-- * funcion nilK was named nil_constant in 5.0.x
-- * function interface changed: need_value, patchtestreg, concat
-- * TObject now a TValue
-- * functions luaK_setreturns, luaK_setoneret are new
-- * function luaK:setcallreturns deleted, to be replaced by:
--   luaK:setmultret, luaK:ret, luaK:setreturns, luaK:setoneret
-- * functions constfolding, codearith, codecomp are new
-- * luaK:codebinop has been deleted
-- * function luaK_setlist is new
-- * OPR_MULT renamed to OPR_MUL
----------------------------------------------------------------------]]

-- requires luaP, luaX, luaY
local luaK = {}
local luaP = _G.luavm.luaP
local luaX = _G.luavm.luaX

------------------------------------------------------------------------
-- constants used by code generator
------------------------------------------------------------------------
-- maximum stack for a Lua function
luaK.MAXSTACK = 250  -- (from llimits.h)

--[[--------------------------------------------------------------------
-- other functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- emulation of TValue macros (these are from lobject.h)
-- * TValue is a table since lcode passes references around
-- * tt member field removed, using Lua's type() instead
-- * for setsvalue, sethvalue, parameter L (deleted here) in lobject.h
--   is used in an assert for testing, see checkliveness(g,obj)
------------------------------------------------------------------------
function luaK:ttisnumber(o)
  if o then return type(o.value) == "number" else return false end
end
function luaK:nvalue(o) return o.value end
function luaK:setnilvalue(o) o.value = nil end
function luaK:setsvalue(o, x) o.value = x end
luaK.setnvalue = luaK.setsvalue
luaK.sethvalue = luaK.setsvalue
luaK.setbvalue = luaK.setsvalue

------------------------------------------------------------------------
-- The luai_num* macros define the primitive operations over numbers.
-- * this is not the entire set of primitive operations from luaconf.h
-- * used in luaK:constfolding()
------------------------------------------------------------------------
function luaK:numadd(a, b) return a + b end
function luaK:numsub(a, b) return a - b end
function luaK:nummul(a, b) return a * b end
function luaK:numdiv(a, b) return a / b end
function luaK:nummod(a, b) return a % b end
  -- ((a) - floor((a)/(b))*(b)) /* actual, for reference */
function luaK:numpow(a, b) return a ^ b end
function luaK:numunm(a) return -a end
function luaK:numisnan(a) return not a == a end
  -- a NaN cannot equal another NaN

--[[--------------------------------------------------------------------
-- code generator functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- Marks the end of a patch list. It is an invalid value both as an absolute
-- address, and as a list link (would link an element to itself).
------------------------------------------------------------------------
luaK.NO_JUMP = -1

------------------------------------------------------------------------
-- grep "ORDER OPR" if you change these enums
------------------------------------------------------------------------
luaK.BinOpr = {
  OPR_ADD = 0, OPR_SUB = 1, OPR_MUL = 2, OPR_DIV = 3, OPR_MOD = 4, OPR_POW = 5,
  OPR_CONCAT = 6,
  OPR_NE = 7, OPR_EQ = 8,
  OPR_LT = 9, OPR_LE = 10, OPR_GT = 11, OPR_GE = 12,
  OPR_AND = 13, OPR_OR = 14,
  OPR_NOBINOPR = 15,
}

-- * UnOpr is used by luaK:prefix's op argument, but not directly used
--   because the function receives the symbols as strings, e.g. "OPR_NOT"
luaK.UnOpr = {
  OPR_MINUS = 0, OPR_NOT = 1, OPR_LEN = 2, OPR_NOUNOPR = 3
}

------------------------------------------------------------------------
-- returns the instruction object for given e (expdesc), was a macro
------------------------------------------------------------------------
function luaK:getcode(fs, e)
  return fs.f.code[e.info]
end

------------------------------------------------------------------------
-- codes an instruction with a signed Bx (sBx) field, was a macro
-- * used in luaK:jump(), (lparser) luaY:forbody()
------------------------------------------------------------------------
function luaK:codeAsBx(fs, o, A, sBx)
  return self:codeABx(fs, o, A, sBx + luaP.MAXARG_sBx)
end

------------------------------------------------------------------------
-- set the expdesc e instruction for multiple returns, was a macro
------------------------------------------------------------------------
function luaK:setmultret(fs, e)
  self:setreturns(fs, e, luaY.LUA_MULTRET)
end

------------------------------------------------------------------------
-- there is a jump if patch lists are not identical, was a macro
-- * used in luaK:exp2reg(), luaK:exp2anyreg(), luaK:exp2val()
------------------------------------------------------------------------
function luaK:hasjumps(e)
  return e.t ~= e.f
end

------------------------------------------------------------------------
-- true if the expression is a constant number (for constant folding)
-- * used in constfolding(), infix()
------------------------------------------------------------------------
function luaK:isnumeral(e)
  return e.k == "VKNUM" and e.t == self.NO_JUMP and e.f == self.NO_JUMP
end

------------------------------------------------------------------------
-- codes loading of nil, optimization done if consecutive locations
-- * used in luaK:discharge2reg(), (lparser) luaY:adjust_assign()
------------------------------------------------------------------------
function luaK:_nil(fs, from, n)
  if fs.pc > fs.lasttarget then  -- no jumps to current position?
    if fs.pc == 0 then  -- function start?
      if from >= fs.nactvar then
        return  -- positions are already clean
      end
    else
      local previous = fs.f.code[fs.pc - 1]
      if luaP:GET_OPCODE(previous) == "OP_LOADNIL" then
        local pfrom = luaP:GETARG_A(previous)
        local pto = luaP:GETARG_B(previous)
        if pfrom <= from and from <= pto + 1 then  -- can connect both?
          if from + n - 1 > pto then
            luaP:SETARG_B(previous, from + n - 1)
          end
          return
        end
      end
    end
  end
  self:codeABC(fs, "OP_LOADNIL", from, from + n - 1, 0)  -- else no optimization
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:jump(fs)
  local jpc = fs.jpc  -- save list of jumps to here
  fs.jpc = self.NO_JUMP
  local j = self:codeAsBx(fs, "OP_JMP", 0, self.NO_JUMP)
  j = self:concat(fs, j, jpc)  -- keep them on hold
  return j
end

------------------------------------------------------------------------
-- codes a RETURN instruction
-- * used in luaY:close_func(), luaY:retstat()
------------------------------------------------------------------------
function luaK:ret(fs, first, nret)
  self:codeABC(fs, "OP_RETURN", first, nret + 1, 0)
end

------------------------------------------------------------------------
--
-- * used in luaK:jumponcond(), luaK:codecomp()
------------------------------------------------------------------------
function luaK:condjump(fs, op, A, B, C)
  self:codeABC(fs, op, A, B, C)
  return self:jump(fs)
end

------------------------------------------------------------------------
--
-- * used in luaK:patchlistaux(), luaK:concat()
------------------------------------------------------------------------
function luaK:fixjump(fs, pc, dest)
  local jmp = fs.f.code[pc]
  local offset = dest - (pc + 1)
  assert(dest ~= self.NO_JUMP)
  if math.abs(offset) > luaP.MAXARG_sBx then
    luaX:syntaxerror(fs.ls, "control structure too long")
  end
  luaP:SETARG_sBx(jmp, offset)
end

------------------------------------------------------------------------
-- returns current 'pc' and marks it as a jump target (to avoid wrong
-- optimizations with consecutive instructions not in the same basic block).
-- * used in multiple locations
-- * fs.lasttarget tested only by luaK:_nil() when optimizing OP_LOADNIL
------------------------------------------------------------------------
function luaK:getlabel(fs)
  fs.lasttarget = fs.pc
  return fs.pc
end

------------------------------------------------------------------------
--
-- * used in luaK:need_value(), luaK:removevalues(), luaK:patchlistaux(),
--   luaK:concat()
------------------------------------------------------------------------
function luaK:getjump(fs, pc)
  local offset = luaP:GETARG_sBx(fs.f.code[pc])
  if offset == self.NO_JUMP then  -- point to itself represents end of list
    return self.NO_JUMP  -- end of list
  else
    return (pc + 1) + offset  -- turn offset into absolute position
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:need_value(), luaK:patchtestreg(), luaK:invertjump()
------------------------------------------------------------------------
function luaK:getjumpcontrol(fs, pc)
  local pi = fs.f.code[pc]
  local ppi = fs.f.code[pc - 1]
  if pc >= 1 and luaP:testTMode(luaP:GET_OPCODE(ppi)) ~= 0 then
    return ppi
  else
    return pi
  end
end

------------------------------------------------------------------------
-- check whether list has any jump that do not produce a value
-- (or produce an inverted value)
-- * return value changed to boolean
-- * used only in luaK:exp2reg()
------------------------------------------------------------------------
function luaK:need_value(fs, list)
  while list ~= self.NO_JUMP do
    local i = self:getjumpcontrol(fs, list)
    if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then return true end
    list = self:getjump(fs, list)
  end
  return false  -- not found
end

------------------------------------------------------------------------
--
-- * used in luaK:removevalues(), luaK:patchlistaux()
------------------------------------------------------------------------
function luaK:patchtestreg(fs, node, reg)
  local i = self:getjumpcontrol(fs, node)
  if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
    return false  -- cannot patch other instructions
  end
  if reg ~= luaP.NO_REG and reg ~= luaP:GETARG_B(i) then
    luaP:SETARG_A(i, reg)
  else  -- no register to put value or register already has the value
    -- due to use of a table as i, i cannot be replaced by another table
    -- so the following is required; there is no change to ARG_C
    luaP:SET_OPCODE(i, "OP_TEST")
    local b = luaP:GETARG_B(i)
    luaP:SETARG_A(i, b)
    luaP:SETARG_B(i, 0)
    -- *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i)); /* C */
  end
  return true
end

------------------------------------------------------------------------
--
-- * used only in luaK:codenot()
------------------------------------------------------------------------
function luaK:removevalues(fs, list)
  while list ~= self.NO_JUMP do
    self:patchtestreg(fs, list, luaP.NO_REG)
    list = self:getjump(fs, list)
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:dischargejpc(), luaK:patchlist(), luaK:exp2reg()
------------------------------------------------------------------------
function luaK:patchlistaux(fs, list, vtarget, reg, dtarget)
  while list ~= self.NO_JUMP do
    local _next = self:getjump(fs, list)
    if self:patchtestreg(fs, list, reg) then
      self:fixjump(fs, list, vtarget)
    else
      self:fixjump(fs, list, dtarget)  -- jump to default target
    end
    list = _next
  end
end

------------------------------------------------------------------------
--
-- * used only in luaK:code()
------------------------------------------------------------------------
function luaK:dischargejpc(fs)
  self:patchlistaux(fs, fs.jpc, fs.pc, luaP.NO_REG, fs.pc)
  fs.jpc = self.NO_JUMP
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:whilestat(), luaY:repeatstat(), luaY:forbody()
------------------------------------------------------------------------
function luaK:patchlist(fs, list, target)
  if target == fs.pc then
    self:patchtohere(fs, list)
  else
    assert(target < fs.pc)
    self:patchlistaux(fs, list, target, luaP.NO_REG, target)
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:patchtohere(fs, list)
  self:getlabel(fs)
  fs.jpc = self:concat(fs, fs.jpc, list)
end

------------------------------------------------------------------------
-- * l1 was a pointer, now l1 is returned and callee assigns the value
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:concat(fs, l1, l2)
  if l2 == self.NO_JUMP then return l1
  elseif l1 == self.NO_JUMP then
    return l2
  else
    local list = l1
    local _next = self:getjump(fs, list)
    while _next ~= self.NO_JUMP do  -- find last element
      list = _next
      _next = self:getjump(fs, list)
    end
    self:fixjump(fs, list, l2)
  end
  return l1
end

------------------------------------------------------------------------
--
-- * used in luaK:reserveregs(), (lparser) luaY:forlist()
------------------------------------------------------------------------
function luaK:checkstack(fs, n)
  local newstack = fs.freereg + n
  if newstack > fs.f.maxstacksize then
    if newstack >= self.MAXSTACK then
      luaX:syntaxerror(fs.ls, "function or expression too complex")
    end
    fs.f.maxstacksize = newstack
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:reserveregs(fs, n)
  self:checkstack(fs, n)
  fs.freereg = fs.freereg + n
end

------------------------------------------------------------------------
--
-- * used in luaK:freeexp(), luaK:dischargevars()
------------------------------------------------------------------------
function luaK:freereg(fs, reg)
  if not luaP:ISK(reg) and reg >= fs.nactvar then
    fs.freereg = fs.freereg - 1
    assert(reg == fs.freereg)
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:freeexp(fs, e)
  if e.k == "VNONRELOC" then
    self:freereg(fs, e.info)
  end
end

------------------------------------------------------------------------
-- * TODO NOTE implementation is not 100% correct, since the assert fails
-- * luaH_set, setobj deleted; direct table access used instead
-- * used in luaK:stringK(), luaK:numberK(), luaK:boolK(), luaK:nilK()
------------------------------------------------------------------------
function luaK:addk(fs, k, v)
  local L = fs.L
  local idx = fs.h[k.value]
  --TValue *idx = luaH_set(L, fs->h, k); /* C */
  local f = fs.f
  if self:ttisnumber(idx) then
    --TODO this assert currently FAILS (last tested for 5.0.2)
    --assert(fs.f.k[self:nvalue(idx)] == v)
    --assert(luaO_rawequalObj(&fs->f->k[cast_int(nvalue(idx))], v)); /* C */
    return self:nvalue(idx)
  else -- constant not found; create a new entry
    idx = {}
    self:setnvalue(idx, fs.nk)
    fs.h[k.value] = idx
    -- setnvalue(idx, cast_num(fs->nk)); /* C */
    luaY:growvector(L, f.k, fs.nk, f.sizek, nil,
                    luaP.MAXARG_Bx, "constant table overflow")
    -- loop to initialize empty f.k positions not required
    f.k[fs.nk] = v
    -- setobj(L, &f->k[fs->nk], v); /* C */
    -- luaC_barrier(L, f, v); /* GC */
    local nk = fs.nk
    fs.nk = fs.nk + 1
    return nk
  end

end

------------------------------------------------------------------------
-- creates and sets a string object
-- * used in (lparser) luaY:codestring(), luaY:singlevar()
------------------------------------------------------------------------
function luaK:stringK(fs, s)
  local o = {}  -- TValue
  self:setsvalue(o, s)
  return self:addk(fs, o, o)
end

------------------------------------------------------------------------
-- creates and sets a number object
-- * used in luaK:prefix() for negative (or negation of) numbers
-- * used in (lparser) luaY:simpleexp(), luaY:fornum()
------------------------------------------------------------------------
function luaK:numberK(fs, r)
  local o = {}  -- TValue
  self:setnvalue(o, r)
  return self:addk(fs, o, o)
end

------------------------------------------------------------------------
-- creates and sets a boolean object
-- * used only in luaK:exp2RK()
------------------------------------------------------------------------
function luaK:boolK(fs, b)
  local o = {}  -- TValue
  self:setbvalue(o, b)
  return self:addk(fs, o, o)
end

------------------------------------------------------------------------
-- creates and sets a nil object
-- * used only in luaK:exp2RK()
------------------------------------------------------------------------
function luaK:nilK(fs)
  local k, v = {}, {}  -- TValue
  self:setnilvalue(v)
  -- cannot use nil as key; instead use table itself to represent nil
  self:sethvalue(k, fs.h)
  return self:addk(fs, k, v)
end

------------------------------------------------------------------------
--
-- * used in luaK:setmultret(), (lparser) luaY:adjust_assign()
------------------------------------------------------------------------
function luaK:setreturns(fs, e, nresults)
  if e.k == "VCALL" then  -- expression is an open function call?
    luaP:SETARG_C(self:getcode(fs, e), nresults + 1)
  elseif e.k == "VVARARG" then
    luaP:SETARG_B(self:getcode(fs, e), nresults + 1);
    luaP:SETARG_A(self:getcode(fs, e), fs.freereg);
    luaK:reserveregs(fs, 1)
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:dischargevars(), (lparser) luaY:assignment()
------------------------------------------------------------------------
function luaK:setoneret(fs, e)
  if e.k == "VCALL" then  -- expression is an open function call?
    e.k = "VNONRELOC"
    e.info = luaP:GETARG_A(self:getcode(fs, e))
  elseif e.k == "VVARARG" then
    luaP:SETARG_B(self:getcode(fs, e), 2)
    e.k = "VRELOCABLE"  -- can relocate its simple result
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:dischargevars(fs, e)
  local k = e.k
  if k == "VLOCAL" then
    e.k = "VNONRELOC"
  elseif k == "VUPVAL" then
    e.info = self:codeABC(fs, "OP_GETUPVAL", 0, e.info, 0)
    e.k = "VRELOCABLE"
  elseif k == "VGLOBAL" then
    e.info = self:codeABx(fs, "OP_GETGLOBAL", 0, e.info)
    e.k = "VRELOCABLE"
  elseif k == "VINDEXED" then
    self:freereg(fs, e.aux)
    self:freereg(fs, e.info)
    e.info = self:codeABC(fs, "OP_GETTABLE", 0, e.info, e.aux)
    e.k = "VRELOCABLE"
  elseif k == "VVARARG" or k == "VCALL" then
    self:setoneret(fs, e)
  else
    -- there is one value available (somewhere)
  end
end

------------------------------------------------------------------------
--
-- * used only in luaK:exp2reg()
------------------------------------------------------------------------
function luaK:code_label(fs, A, b, jump)
  self:getlabel(fs)  -- those instructions may be jump targets
  return self:codeABC(fs, "OP_LOADBOOL", A, b, jump)
end

------------------------------------------------------------------------
--
-- * used in luaK:discharge2anyreg(), luaK:exp2reg()
------------------------------------------------------------------------
function luaK:discharge2reg(fs, e, reg)
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VNIL" then
    self:_nil(fs, reg, 1)
  elseif k == "VFALSE" or k == "VTRUE" then
    self:codeABC(fs, "OP_LOADBOOL", reg, (e.k == "VTRUE") and 1 or 0, 0)
  elseif k == "VK" then
    self:codeABx(fs, "OP_LOADK", reg, e.info)
  elseif k == "VKNUM" then
    self:codeABx(fs, "OP_LOADK", reg, self:numberK(fs, e.nval))
  elseif k == "VRELOCABLE" then
    local pc = self:getcode(fs, e)
    luaP:SETARG_A(pc, reg)
  elseif k == "VNONRELOC" then
    if reg ~= e.info then
      self:codeABC(fs, "OP_MOVE", reg, e.info, 0)
    end
  else
    assert(e.k == "VVOID" or e.k == "VJMP")
    return  -- nothing to do...
  end
  e.info = reg
  e.k = "VNONRELOC"
end

------------------------------------------------------------------------
--
-- * used in luaK:jumponcond(), luaK:codenot()
------------------------------------------------------------------------
function luaK:discharge2anyreg(fs, e)
  if e.k ~= "VNONRELOC" then
    self:reserveregs(fs, 1)
    self:discharge2reg(fs, e, fs.freereg - 1)
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:exp2nextreg(), luaK:exp2anyreg(), luaK:storevar()
------------------------------------------------------------------------
function luaK:exp2reg(fs, e, reg)
  self:discharge2reg(fs, e, reg)
  if e.k == "VJMP" then
    e.t = self:concat(fs, e.t, e.info)  -- put this jump in 't' list
  end
  if self:hasjumps(e) then
    local final  -- position after whole expression
    local p_f = self.NO_JUMP  -- position of an eventual LOAD false
    local p_t = self.NO_JUMP  -- position of an eventual LOAD true
    if self:need_value(fs, e.t) or self:need_value(fs, e.f) then
      local fj = (e.k == "VJMP") and self.NO_JUMP or self:jump(fs)
      p_f = self:code_label(fs, reg, 0, 1)
      p_t = self:code_label(fs, reg, 1, 0)
      self:patchtohere(fs, fj)
    end
    final = self:getlabel(fs)
    self:patchlistaux(fs, e.f, final, reg, p_f)
    self:patchlistaux(fs, e.t, final, reg, p_t)
  end
  e.f, e.t = self.NO_JUMP, self.NO_JUMP
  e.info = reg
  e.k = "VNONRELOC"
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:exp2nextreg(fs, e)
  self:dischargevars(fs, e)
  self:freeexp(fs, e)
  self:reserveregs(fs, 1)
  self:exp2reg(fs, e, fs.freereg - 1)
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:exp2anyreg(fs, e)
  self:dischargevars(fs, e)
  if e.k == "VNONRELOC" then
    if not self:hasjumps(e) then  -- exp is already in a register
      return e.info
    end
    if e.info >= fs.nactvar then  -- reg. is not a local?
      self:exp2reg(fs, e, e.info)  -- put value on it
      return e.info
    end
  end
  self:exp2nextreg(fs, e)  -- default
  return e.info
end

------------------------------------------------------------------------
--
-- * used in luaK:exp2RK(), luaK:prefix(), luaK:posfix()
-- * used in (lparser) luaY:yindex()
------------------------------------------------------------------------
function luaK:exp2val(fs, e)
  if self:hasjumps(e) then
    self:exp2anyreg(fs, e)
  else
    self:dischargevars(fs, e)
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:exp2RK(fs, e)
  self:exp2val(fs, e)
  local k = e.k
  if k == "VKNUM" or k == "VTRUE" or k == "VFALSE" or k == "VNIL" then
    if fs.nk <= luaP.MAXINDEXRK then  -- constant fit in RK operand?
      -- converted from a 2-deep ternary operator expression
      if e.k == "VNIL" then
        e.info = self:nilK(fs)
      else
        e.info = (e.k == "VKNUM") and self:numberK(fs, e.nval)
                                  or self:boolK(fs, e.k == "VTRUE")
      end
      e.k = "VK"
      return luaP:RKASK(e.info)
    end
  elseif k == "VK" then
    if e.info <= luaP.MAXINDEXRK then  -- constant fit in argC?
      return luaP:RKASK(e.info)
    end
  else
    -- default
  end
  -- not a constant in the right range: put it in a register
  return self:exp2anyreg(fs, e)
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:assignment(), luaY:localfunc(), luaY:funcstat()
------------------------------------------------------------------------
function luaK:storevar(fs, var, ex)
  local k = var.k
  if k == "VLOCAL" then
    self:freeexp(fs, ex)
    self:exp2reg(fs, ex, var.info)
    return
  elseif k == "VUPVAL" then
    local e = self:exp2anyreg(fs, ex)
    self:codeABC(fs, "OP_SETUPVAL", e, var.info, 0)
  elseif k == "VGLOBAL" then
    local e = self:exp2anyreg(fs, ex)
    self:codeABx(fs, "OP_SETGLOBAL", e, var.info)
  elseif k == "VINDEXED" then
    local e = self:exp2RK(fs, ex)
    self:codeABC(fs, "OP_SETTABLE", var.info, var.aux, e)
  else
    assert(0)  -- invalid var kind to store
  end
  self:freeexp(fs, ex)
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:primaryexp()
------------------------------------------------------------------------
function luaK:_self(fs, e, key)
  self:exp2anyreg(fs, e)
  self:freeexp(fs, e)
  local func = fs.freereg
  self:reserveregs(fs, 2)
  self:codeABC(fs, "OP_SELF", func, e.info, self:exp2RK(fs, key))
  self:freeexp(fs, key)
  e.info = func
  e.k = "VNONRELOC"
end

------------------------------------------------------------------------
--
-- * used in luaK:goiftrue(), luaK:codenot()
------------------------------------------------------------------------
function luaK:invertjump(fs, e)
  local pc = self:getjumpcontrol(fs, e.info)
  assert(luaP:testTMode(luaP:GET_OPCODE(pc)) ~= 0 and
             luaP:GET_OPCODE(pc) ~= "OP_TESTSET" and
             luaP:GET_OPCODE(pc) ~= "OP_TEST")
  luaP:SETARG_A(pc, (luaP:GETARG_A(pc) == 0) and 1 or 0)
end

------------------------------------------------------------------------
--
-- * used in luaK:goiftrue(), luaK:goiffalse()
------------------------------------------------------------------------
function luaK:jumponcond(fs, e, cond)
  if e.k == "VRELOCABLE" then
    local ie = self:getcode(fs, e)
    if luaP:GET_OPCODE(ie) == "OP_NOT" then
      fs.pc = fs.pc - 1  -- remove previous OP_NOT
      return self:condjump(fs, "OP_TEST", luaP:GETARG_B(ie), 0, cond and 0 or 1)
    end
    -- else go through
  end
  self:discharge2anyreg(fs, e)
  self:freeexp(fs, e)
  return self:condjump(fs, "OP_TESTSET", luaP.NO_REG, e.info, cond and 1 or 0)
end

------------------------------------------------------------------------
--
-- * used in luaK:infix(), (lparser) luaY:cond()
------------------------------------------------------------------------
function luaK:goiftrue(fs, e)
  local pc  -- pc of last jump
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VK" or k == "VKNUM" or k == "VTRUE" then
    pc = self.NO_JUMP  -- always true; do nothing
  elseif k == "VFALSE" then
    pc = self:jump(fs)  -- always jump
  elseif k == "VJMP" then
    self:invertjump(fs, e)
    pc = e.info
  else
    pc = self:jumponcond(fs, e, false)
  end
  e.f = self:concat(fs, e.f, pc)  -- insert last jump in `f' list
  self:patchtohere(fs, e.t)
  e.t = self.NO_JUMP
end

------------------------------------------------------------------------
--
-- * used in luaK:infix()
------------------------------------------------------------------------
function luaK:goiffalse(fs, e)
  local pc  -- pc of last jump
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VNIL" or k == "VFALSE"then
    pc = self.NO_JUMP  -- always false; do nothing
  elseif k == "VTRUE" then
    pc = self:jump(fs)  -- always jump
  elseif k == "VJMP" then
    pc = e.info
  else
    pc = self:jumponcond(fs, e, true)
  end
  e.t = self:concat(fs, e.t, pc)  -- insert last jump in `t' list
  self:patchtohere(fs, e.f)
  e.f = self.NO_JUMP
end

------------------------------------------------------------------------
--
-- * used only in luaK:prefix()
------------------------------------------------------------------------
function luaK:codenot(fs, e)
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VNIL" or k == "VFALSE" then
    e.k = "VTRUE"
  elseif k == "VK" or k == "VKNUM" or k == "VTRUE" then
    e.k = "VFALSE"
  elseif k == "VJMP" then
    self:invertjump(fs, e)
  elseif k == "VRELOCABLE" or k == "VNONRELOC" then
    self:discharge2anyreg(fs, e)
    self:freeexp(fs, e)
    e.info = self:codeABC(fs, "OP_NOT", 0, e.info, 0)
    e.k = "VRELOCABLE"
  else
    assert(0)  -- cannot happen
  end
  -- interchange true and false lists
  e.f, e.t = e.t, e.f
  self:removevalues(fs, e.f)
  self:removevalues(fs, e.t)
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:field(), luaY:primaryexp()
------------------------------------------------------------------------
function luaK:indexed(fs, t, k)
  t.aux = self:exp2RK(fs, k)
  t.k = "VINDEXED"
end

------------------------------------------------------------------------
--
-- * used only in luaK:codearith()
------------------------------------------------------------------------
function luaK:constfolding(op, e1, e2)
  local r
  if not self:isnumeral(e1) or not self:isnumeral(e2) then return false end
  local v1 = e1.nval
  local v2 = e2.nval
  if op == "OP_ADD" then
    r = self:numadd(v1, v2)
  elseif op == "OP_SUB" then
    r = self:numsub(v1, v2)
  elseif op == "OP_MUL" then
    r = self:nummul(v1, v2)
  elseif op == "OP_DIV" then
    if v2 == 0 then return false end  -- do not attempt to divide by 0
    r = self:numdiv(v1, v2)
  elseif op == "OP_MOD" then
    if v2 == 0 then return false end  -- do not attempt to divide by 0
    r = self:nummod(v1, v2)
  elseif op == "OP_POW" then
    r = self:numpow(v1, v2)
  elseif op == "OP_UNM" then
    r = self:numunm(v1)
  elseif op == "OP_LEN" then
    return false  -- no constant folding for 'len'
  else
    assert(0)
    r = 0
  end
  if self:numisnan(r) then return false end  -- do not attempt to produce NaN
  e1.nval = r
  return true
end

------------------------------------------------------------------------
--
-- * used in luaK:prefix(), luaK:posfix()
------------------------------------------------------------------------
function luaK:codearith(fs, op, e1, e2)
  if self:constfolding(op, e1, e2) then
    return
  else
    local o2 = (op ~= "OP_UNM" and op ~= "OP_LEN") and self:exp2RK(fs, e2) or 0
    local o1 = self:exp2RK(fs, e1)
    if o1 > o2 then
      self:freeexp(fs, e1)
      self:freeexp(fs, e2)
    else
      self:freeexp(fs, e2)
      self:freeexp(fs, e1)
    end
    e1.info = self:codeABC(fs, op, 0, o1, o2)
    e1.k = "VRELOCABLE"
  end
end

------------------------------------------------------------------------
--
-- * used only in luaK:posfix()
------------------------------------------------------------------------
function luaK:codecomp(fs, op, cond, e1, e2)
  local o1 = self:exp2RK(fs, e1)
  local o2 = self:exp2RK(fs, e2)
  self:freeexp(fs, e2)
  self:freeexp(fs, e1)
  if cond == 0 and op ~= "OP_EQ" then
    -- exchange args to replace by `<' or `<='
    o1, o2 = o2, o1  -- o1 <==> o2
    cond = 1
  end
  e1.info = self:condjump(fs, op, cond, o1, o2)
  e1.k = "VJMP"
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:subexpr()
------------------------------------------------------------------------
function luaK:prefix(fs, op, e)
  local e2 = {}  -- expdesc
  e2.t, e2.f = self.NO_JUMP, self.NO_JUMP
  e2.k = "VKNUM"
  e2.nval = 0
  if op == "OPR_MINUS" then
    if not self:isnumeral(e) then
      self:exp2anyreg(fs, e)  -- cannot operate on non-numeric constants
    end
    self:codearith(fs, "OP_UNM", e, e2)
  elseif op == "OPR_NOT" then
    self:codenot(fs, e)
  elseif op == "OPR_LEN" then
    self:exp2anyreg(fs, e)  -- cannot operate on constants
    self:codearith(fs, "OP_LEN", e, e2)
  else
    assert(0)
  end
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:subexpr()
------------------------------------------------------------------------
function luaK:infix(fs, op, v)
  if op == "OPR_AND" then
    self:goiftrue(fs, v)
  elseif op == "OPR_OR" then
    self:goiffalse(fs, v)
  elseif op == "OPR_CONCAT" then
    self:exp2nextreg(fs, v)  -- operand must be on the 'stack'
  elseif op == "OPR_ADD" or op == "OPR_SUB" or
         op == "OPR_MUL" or op == "OPR_DIV" or
         op == "OPR_MOD" or op == "OPR_POW" then
    if not self:isnumeral(v) then self:exp2RK(fs, v) end
  else
    self:exp2RK(fs, v)
  end
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:subexpr()
------------------------------------------------------------------------
-- table lookups to simplify testing
luaK.arith_op = {
  OPR_ADD = "OP_ADD", OPR_SUB = "OP_SUB", OPR_MUL = "OP_MUL",
  OPR_DIV = "OP_DIV", OPR_MOD = "OP_MOD", OPR_POW = "OP_POW",
}
luaK.comp_op = {
  OPR_EQ = "OP_EQ", OPR_NE = "OP_EQ", OPR_LT = "OP_LT",
  OPR_LE = "OP_LE", OPR_GT = "OP_LT", OPR_GE = "OP_LE",
}
luaK.comp_cond = {
  OPR_EQ = 1, OPR_NE = 0, OPR_LT = 1,
  OPR_LE = 1, OPR_GT = 0, OPR_GE = 0,
}
function luaK:posfix(fs, op, e1, e2)
  -- needed because e1 = e2 doesn't copy values...
  -- * in 5.0.x, only k/info/aux/t/f copied, t for AND, f for OR
  --   but here, all elements are copied for completeness' sake
  local function copyexp(e1, e2)
    e1.k = e2.k
    e1.info = e2.info; e1.aux = e2.aux
    e1.nval = e2.nval
    e1.t = e2.t; e1.f = e2.f
  end
  if op == "OPR_AND" then
    assert(e1.t == self.NO_JUMP)  -- list must be closed
    self:dischargevars(fs, e2)
    e2.f = self:concat(fs, e2.f, e1.f)
    copyexp(e1, e2)
  elseif op == "OPR_OR" then
    assert(e1.f == self.NO_JUMP)  -- list must be closed
    self:dischargevars(fs, e2)
    e2.t = self:concat(fs, e2.t, e1.t)
    copyexp(e1, e2)
  elseif op == "OPR_CONCAT" then
    self:exp2val(fs, e2)
    if e2.k == "VRELOCABLE" and luaP:GET_OPCODE(self:getcode(fs, e2)) == "OP_CONCAT" then
      assert(e1.info == luaP:GETARG_B(self:getcode(fs, e2)) - 1)
      self:freeexp(fs, e1)
      luaP:SETARG_B(self:getcode(fs, e2), e1.info)
      e1.k = "VRELOCABLE"
      e1.info = e2.info
    else
      self:exp2nextreg(fs, e2)  -- operand must be on the 'stack'
      self:codearith(fs, "OP_CONCAT", e1, e2)
    end
  else
    -- the following uses a table lookup in place of conditionals
    local arith = self.arith_op[op]
    if arith then
      self:codearith(fs, arith, e1, e2)
    else
      local comp = self.comp_op[op]
      if comp then
        self:codecomp(fs, comp, self.comp_cond[op], e1, e2)
      else
        assert(0)
      end
    end--if arith
  end--if op
end

------------------------------------------------------------------------
-- adjusts debug information for last instruction written, in order to
-- change the line where item comes into existence
-- * used in (lparser) luaY:funcargs(), luaY:forbody(), luaY:funcstat()
------------------------------------------------------------------------
function luaK:fixline(fs, line)
  fs.f.lineinfo[fs.pc - 1] = line
end

------------------------------------------------------------------------
-- general function to write an instruction into the instruction buffer,
-- sets debug information too
-- * used in luaK:codeABC(), luaK:codeABx()
-- * called directly by (lparser) luaY:whilestat()
------------------------------------------------------------------------
function luaK:code(fs, i, line)
  local f = fs.f
  self:dischargejpc(fs)  -- 'pc' will change
  -- put new instruction in code array
  luaY:growvector(fs.L, f.code, fs.pc, f.sizecode, nil,
                  luaY.MAX_INT, "code size overflow")
  f.code[fs.pc] = i
  -- save corresponding line information
  luaY:growvector(fs.L, f.lineinfo, fs.pc, f.sizelineinfo, nil,
                  luaY.MAX_INT, "code size overflow")
  f.lineinfo[fs.pc] = line
  local pc = fs.pc
  fs.pc = fs.pc + 1
  return pc
end

------------------------------------------------------------------------
-- writes an instruction of type ABC
-- * calls luaK:code()
------------------------------------------------------------------------
function luaK:codeABC(fs, o, a, b, c)
  assert(luaP:getOpMode(o) == luaP.OpMode.iABC)
  assert(luaP:getBMode(o) ~= luaP.OpArgMask.OpArgN or b == 0)
  assert(luaP:getCMode(o) ~= luaP.OpArgMask.OpArgN or c == 0)
  return self:code(fs, luaP:CREATE_ABC(o, a, b, c), fs.ls.lastline)
end

------------------------------------------------------------------------
-- writes an instruction of type ABx
-- * calls luaK:code(), called by luaK:codeAsBx()
------------------------------------------------------------------------
function luaK:codeABx(fs, o, a, bc)
  assert(luaP:getOpMode(o) == luaP.OpMode.iABx or
             luaP:getOpMode(o) == luaP.OpMode.iAsBx)
  assert(luaP:getCMode(o) == luaP.OpArgMask.OpArgN)
  return self:code(fs, luaP:CREATE_ABx(o, a, bc), fs.ls.lastline)
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:closelistfield(), luaY:lastlistfield()
------------------------------------------------------------------------
function luaK:setlist(fs, base, nelems, tostore)
  local c = math.floor((nelems - 1)/luaP.LFIELDS_PER_FLUSH) + 1
  local b = (tostore == luaY.LUA_MULTRET) and 0 or tostore
  assert(tostore ~= 0)
  if c <= luaP.MAXARG_C then
    self:codeABC(fs, "OP_SETLIST", base, b, c)
  else
    self:codeABC(fs, "OP_SETLIST", base, b, 0)
    self:code(fs, luaP:CREATE_Inst(c), fs.ls.lastline)
  end
  fs.freereg = base + 1  -- free registers with list values
end

_G.encryptVM_compile.luaK = function(a) luaY = a return luaK end
end
function scmframework_d7494fcdc2f2ee5a6788b657074917bb() --$CONTENT_DATA/Scripts/encryptVM/compile/LuaP.lua
--[[--------------------------------------------------------------------

  lopcodes.lua
  Lua 5 virtual machine opcodes in Lua
  This file is part of Yueliang.

  Copyright (c) 2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * an Instruction is a table with OP, A, B, C, Bx elements; this
--   makes the code easy to follow and should allow instruction handling
--   to work with doubles and ints
-- * WARNING luaP:Instruction outputs instructions encoded in little-
--   endian form and field size and positions are hard-coded
--
-- Not implemented:
-- *
--
-- Added:
-- * luaP:CREATE_Inst(c): create an inst from a number (for OP_SETLIST)
-- * luaP:Instruction(i): convert field elements to a 4-char string
-- * luaP:DecodeInst(x): convert 4-char string into field elements
--
-- Changed in 5.1.x:
-- * POS_OP added, instruction field positions changed
-- * some symbol names may have changed, e.g. LUAI_BITSINT
-- * new operators for RK indices: BITRK, ISK(x), INDEXK(r), RKASK(x)
-- * OP_MOD, OP_LEN is new
-- * OP_TEST is now OP_TESTSET, OP_TEST is new
-- * OP_FORLOOP, OP_TFORLOOP adjusted, OP_FORPREP is new
-- * OP_TFORPREP deleted
-- * OP_SETLIST and OP_SETLISTO merged and extended
-- * OP_VARARG is new
-- * many changes to implementation of OpMode data
----------------------------------------------------------------------]]

local luaP = {}

--[[
===========================================================================
  We assume that instructions are unsigned numbers.
  All instructions have an opcode in the first 6 bits.
  Instructions can have the following fields:
        'A' : 8 bits
        'B' : 9 bits
        'C' : 9 bits
        'Bx' : 18 bits ('B' and 'C' together)
        'sBx' : signed Bx

  A signed argument is represented in excess K; that is, the number
  value is the unsigned value minus K. K is exactly the maximum value
  for that argument (so that -max is represented by 0, and +max is
  represented by 2*max), which is half the maximum for the corresponding
  unsigned argument.
===========================================================================
--]]

luaP.OpMode = { iABC = 0, iABx = 1, iAsBx = 2 }  -- basic instruction format

------------------------------------------------------------------------
-- size and position of opcode arguments.
-- * WARNING size and position is hard-coded elsewhere in this script
------------------------------------------------------------------------
luaP.SIZE_C  = 9
luaP.SIZE_B  = 9
luaP.SIZE_Bx = luaP.SIZE_C + luaP.SIZE_B
luaP.SIZE_A  = 8

luaP.SIZE_OP = 6

luaP.POS_OP = 0
luaP.POS_A  = luaP.POS_OP + luaP.SIZE_OP
luaP.POS_C  = luaP.POS_A + luaP.SIZE_A
luaP.POS_B  = luaP.POS_C + luaP.SIZE_C
luaP.POS_Bx = luaP.POS_C

------------------------------------------------------------------------
-- limits for opcode arguments.
-- we use (signed) int to manipulate most arguments,
-- so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
------------------------------------------------------------------------
-- removed "#if SIZE_Bx < BITS_INT-1" test, assume this script is
-- running on a Lua VM with double or int as LUA_NUMBER

luaP.MAXARG_Bx  = math.ldexp(1, luaP.SIZE_Bx) - 1
luaP.MAXARG_sBx = math.floor(luaP.MAXARG_Bx / 2)  -- 'sBx' is signed

luaP.MAXARG_A = math.ldexp(1, luaP.SIZE_A) - 1
luaP.MAXARG_B = math.ldexp(1, luaP.SIZE_B) - 1
luaP.MAXARG_C = math.ldexp(1, luaP.SIZE_C) - 1

-- creates a mask with 'n' 1 bits at position 'p'
-- MASK1(n,p) deleted, not required
-- creates a mask with 'n' 0 bits at position 'p'
-- MASK0(n,p) deleted, not required

--[[--------------------------------------------------------------------
  Visual representation for reference:

   31    |    |     |            0      bit position
    +-----+-----+-----+----------+
    |  B  |  C  |  A  |  Opcode  |      iABC format
    +-----+-----+-----+----------+
    -  9  -  9  -  8  -    6     -      field sizes
    +-----+-----+-----+----------+
    |   [s]Bx   |  A  |  Opcode  |      iABx | iAsBx format
    +-----+-----+-----+----------+

----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- the following macros help to manipulate instructions
-- * changed to a table object representation, very clean compared to
--   the [nightmare] alternatives of using a number or a string
-- * Bx is a separate element from B and C, since there is never a need
--   to split Bx in the parser or code generator
------------------------------------------------------------------------

-- these accept or return opcodes in the form of string names
function luaP:GET_OPCODE(i) return self.ROpCode[i.OP] end
function luaP:SET_OPCODE(i, o) i.OP = self.OpCode[o] end

function luaP:GETARG_A(i) return i.A end
function luaP:SETARG_A(i, u) i.A = u end

function luaP:GETARG_B(i) return i.B end
function luaP:SETARG_B(i, b) i.B = b end

function luaP:GETARG_C(i) return i.C end
function luaP:SETARG_C(i, b) i.C = b end

function luaP:GETARG_Bx(i) return i.Bx end
function luaP:SETARG_Bx(i, b) i.Bx = b end

function luaP:GETARG_sBx(i) return i.Bx - self.MAXARG_sBx end
function luaP:SETARG_sBx(i, b) i.Bx = b + self.MAXARG_sBx end

function luaP:CREATE_ABC(o,a,b,c)
  return {OP = self.OpCode[o], A = a, B = b, C = c}
end

function luaP:CREATE_ABx(o,a,bc)
  return {OP = self.OpCode[o], A = a, Bx = bc}
end

------------------------------------------------------------------------
-- create an instruction from a number (for OP_SETLIST)
------------------------------------------------------------------------
function luaP:CREATE_Inst(c)
  local o = c % 64
  c = (c - o) / 64
  local a = c % 256
  c = (c - a) / 256
  return self:CREATE_ABx(o, a, c)
end

------------------------------------------------------------------------
-- returns a 4-char string little-endian encoded form of an instruction
------------------------------------------------------------------------
function luaP:Instruction(i)
  if i.Bx then
    -- change to OP/A/B/C format
    i.C = i.Bx % 512
    i.B = (i.Bx - i.C) / 512
  end
  local I = i.A * 64 + i.OP
  local c0 = I % 256
  I = i.C * 64 + (I - c0) / 256  -- 6 bits of A left
  local c1 = I % 256
  I = i.B * 128 + (I - c1) / 256  -- 7 bits of C left
  local c2 = I % 256
  local c3 = (I - c2) / 256
  return string.char(c0, c1, c2, c3)
end

------------------------------------------------------------------------
-- decodes a 4-char little-endian string into an instruction struct
------------------------------------------------------------------------
function luaP:DecodeInst(x)
  local byte = string.byte
  local i = {}
  local I = byte(x, 1)
  local op = I % 64
  i.OP = op
  I = byte(x, 2) * 4 + (I - op) / 64  -- 2 bits of c0 left
  local a = I % 256
  i.A = a
  I = byte(x, 3) * 4 + (I - a) / 256  -- 2 bits of c1 left
  local c = I % 512
  i.C = c
  i.B = byte(x, 4) * 2 + (I - c) / 512 -- 1 bits of c2 left
  local opmode = self.OpMode[tonumber(string.sub(self.opmodes[op + 1], 7, 7))]
  if opmode ~= "iABC" then
    i.Bx = i.B * 512 + i.C
  end
  return i
end

------------------------------------------------------------------------
-- Macros to operate RK indices
-- * these use arithmetic instead of bit ops
------------------------------------------------------------------------

-- this bit 1 means constant (0 means register)
luaP.BITRK = math.ldexp(1, luaP.SIZE_B - 1)

-- test whether value is a constant
function luaP:ISK(x) return x >= self.BITRK end

-- gets the index of the constant
function luaP:INDEXK(x) return x - self.BITRK end

luaP.MAXINDEXRK = luaP.BITRK - 1

-- code a constant index as a RK value
function luaP:RKASK(x) return x + self.BITRK end

------------------------------------------------------------------------
-- invalid register that fits in 8 bits
------------------------------------------------------------------------
luaP.NO_REG = luaP.MAXARG_A

------------------------------------------------------------------------
-- R(x) - register
-- Kst(x) - constant (in constant table)
-- RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)
------------------------------------------------------------------------

------------------------------------------------------------------------
-- grep "ORDER OP" if you change these enums
------------------------------------------------------------------------

--[[--------------------------------------------------------------------
Lua virtual machine opcodes (enum OpCode):
------------------------------------------------------------------------
name          args    description
------------------------------------------------------------------------
OP_MOVE       A B     R(A) := R(B)
OP_LOADK      A Bx    R(A) := Kst(Bx)
OP_LOADBOOL   A B C   R(A) := (Bool)B; if (C) pc++
OP_LOADNIL    A B     R(A) := ... := R(B) := nil
OP_GETUPVAL   A B     R(A) := UpValue[B]
OP_GETGLOBAL  A Bx    R(A) := Gbl[Kst(Bx)]
OP_GETTABLE   A B C   R(A) := R(B)[RK(C)]
OP_SETGLOBAL  A Bx    Gbl[Kst(Bx)] := R(A)
OP_SETUPVAL   A B     UpValue[B] := R(A)
OP_SETTABLE   A B C   R(A)[RK(B)] := RK(C)
OP_NEWTABLE   A B C   R(A) := {} (size = B,C)
OP_SELF       A B C   R(A+1) := R(B); R(A) := R(B)[RK(C)]
OP_ADD        A B C   R(A) := RK(B) + RK(C)
OP_SUB        A B C   R(A) := RK(B) - RK(C)
OP_MUL        A B C   R(A) := RK(B) * RK(C)
OP_DIV        A B C   R(A) := RK(B) / RK(C)
OP_MOD        A B C   R(A) := RK(B) % RK(C)
OP_POW        A B C   R(A) := RK(B) ^ RK(C)
OP_UNM        A B     R(A) := -R(B)
OP_NOT        A B     R(A) := not R(B)
OP_LEN        A B     R(A) := length of R(B)
OP_CONCAT     A B C   R(A) := R(B).. ... ..R(C)
OP_JMP        sBx     pc+=sBx
OP_EQ         A B C   if ((RK(B) == RK(C)) ~= A) then pc++
OP_LT         A B C   if ((RK(B) <  RK(C)) ~= A) then pc++
OP_LE         A B C   if ((RK(B) <= RK(C)) ~= A) then pc++
OP_TEST       A C     if not (R(A) <=> C) then pc++
OP_TESTSET    A B C   if (R(B) <=> C) then R(A) := R(B) else pc++
OP_CALL       A B C   R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))
OP_TAILCALL   A B C   return R(A)(R(A+1), ... ,R(A+B-1))
OP_RETURN     A B     return R(A), ... ,R(A+B-2)  (see note)
OP_FORLOOP    A sBx   R(A)+=R(A+2);
                      if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }
OP_FORPREP    A sBx   R(A)-=R(A+2); pc+=sBx
OP_TFORLOOP   A C     R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));
                      if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++
OP_SETLIST    A B C   R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B
OP_CLOSE      A       close all variables in the stack up to (>=) R(A)
OP_CLOSURE    A Bx    R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))
OP_VARARG     A B     R(A), R(A+1), ..., R(A+B-1) = vararg
----------------------------------------------------------------------]]

luaP.opnames = {}  -- opcode names
luaP.OpCode = {}   -- lookup name -> number
luaP.ROpCode = {}  -- lookup number -> name

------------------------------------------------------------------------
-- ORDER OP
------------------------------------------------------------------------
local i = 0
for v in string.gmatch([[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]], "%S+") do
  local n = "OP_"..v
  luaP.opnames[i] = v
  luaP.OpCode[n] = i
  luaP.ROpCode[i] = n
  i = i + 1
end
luaP.NUM_OPCODES = i

--[[
===========================================================================
  Notes:
  (*) In OP_CALL, if (B == 0) then B = top. C is the number of returns - 1,
      and can be 0: OP_CALL then sets 'top' to last_result+1, so
      next open instruction (OP_CALL, OP_RETURN, OP_SETLIST) may use 'top'.
  (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
      set top (like in OP_CALL with C == 0).
  (*) In OP_RETURN, if (B == 0) then return up to 'top'
  (*) In OP_SETLIST, if (B == 0) then B = 'top';
      if (C == 0) then next 'instruction' is real C
  (*) For comparisons, A specifies what condition the test should accept
      (true or false).
  (*) All 'skips' (pc++) assume that next instruction is a jump
===========================================================================
--]]

--[[--------------------------------------------------------------------
  masks for instruction properties. The format is:
  bits 0-1: op mode
  bits 2-3: C arg mode
  bits 4-5: B arg mode
  bit 6: instruction set register A
  bit 7: operator is a test

  for OpArgMask:
  OpArgN - argument is not used
  OpArgU - argument is used
  OpArgR - argument is a register or a jump offset
  OpArgK - argument is a constant or register/constant
----------------------------------------------------------------------]]

-- was enum OpArgMask
luaP.OpArgMask = { OpArgN = 0, OpArgU = 1, OpArgR = 2, OpArgK = 3 }

------------------------------------------------------------------------
-- e.g. to compare with symbols, luaP:getOpMode(...) == luaP.OpCode.iABC
-- * accepts opcode parameter as strings, e.g. "OP_MOVE"
------------------------------------------------------------------------

function luaP:getOpMode(m)
  return self.opmodes[self.OpCode[m]] % 4
end

function luaP:getBMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 16) % 4
end

function luaP:getCMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 4) % 4
end

function luaP:testAMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 64) % 2
end

function luaP:testTMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 128)
end

-- luaP_opnames[] is set above, as the luaP.opnames table

-- number of list items to accumulate before a SETLIST instruction
luaP.LFIELDS_PER_FLUSH = 50

------------------------------------------------------------------------
-- build instruction properties array
-- * deliberately coded to look like the C equivalent
------------------------------------------------------------------------
local function opmode(t, a, b, c, m)
  local luaP = luaP
  return t * 128 + a * 64 +
         luaP.OpArgMask[b] * 16 + luaP.OpArgMask[c] * 4 + luaP.OpMode[m]
end

-- ORDER OP
luaP.opmodes = {
-- T A B C mode opcode
  opmode(0, 1, "OpArgK", "OpArgN", "iABx"),     -- OP_LOADK
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_LOADBOOL
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_LOADNIL
  opmode(0, 1, "OpArgU", "OpArgN", "iABC"),     -- OP_GETUPVAL
  opmode(0, 1, "OpArgK", "OpArgN", "iABx"),     -- OP_GETGLOBAL
  opmode(0, 1, "OpArgR", "OpArgK", "iABC"),     -- OP_GETTABLE
  opmode(0, 0, "OpArgK", "OpArgN", "iABx"),     -- OP_SETGLOBAL
  opmode(0, 0, "OpArgU", "OpArgN", "iABC"),     -- OP_SETUPVAL
  opmode(0, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_SETTABLE
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_NEWTABLE
  opmode(0, 1, "OpArgR", "OpArgK", "iABC"),     -- OP_SELF
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_ADD
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_SUB
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_MUL
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_DIV
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_MOD
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_POW
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_UNM
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_NOT
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_LEN
  opmode(0, 1, "OpArgR", "OpArgR", "iABC"),     -- OP_CONCAT
  opmode(0, 0, "OpArgR", "OpArgN", "iAsBx"),    -- OP_JMP
  opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_EQ
  opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_LT
  opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_LE
  opmode(1, 1, "OpArgR", "OpArgU", "iABC"),     -- OP_TEST
  opmode(1, 1, "OpArgR", "OpArgU", "iABC"),     -- OP_TESTSET
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_CALL
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_TAILCALL
  opmode(0, 0, "OpArgU", "OpArgN", "iABC"),     -- OP_RETURN
  opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),    -- OP_FORLOOP
  opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),    -- OP_FORPREP
  opmode(1, 0, "OpArgN", "OpArgU", "iABC"),     -- OP_TFORLOOP
  opmode(0, 0, "OpArgU", "OpArgU", "iABC"),     -- OP_SETLIST
  opmode(0, 0, "OpArgN", "OpArgN", "iABC"),     -- OP_CLOSE
  opmode(0, 1, "OpArgU", "OpArgN", "iABx"),     -- OP_CLOSURE
  opmode(0, 1, "OpArgU", "OpArgN", "iABC"),     -- OP_VARARG
}
-- an awkward way to set a zero-indexed table...
luaP.opmodes[0] =
  opmode(0, 1, "OpArgR", "OpArgN", "iABC")      -- OP_MOVE

_G.encryptVM_compile.luaP = luaP
end
function scmframework_13bcbb63d4898c2b60e6331048d4c8a2() --$CONTENT_DATA/Scripts/encryptVM/compile/LuaU.lua
--[[--------------------------------------------------------------------

  ldump.lua
  Save precompiled Lua chunks
  This file is part of Yueliang.

  Copyright (c) 2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * WARNING! byte order (little endian) and data type sizes for header
--   signature values hard-coded; see luaU:header
-- * chunk writer generators are included, see below
-- * one significant difference is that instructions are still in table
--   form (with OP/A/B/C/Bx fields) and luaP:Instruction() is needed to
--   convert them into 4-char strings
--
-- Not implemented:
-- * DumpVar, DumpMem has been removed
-- * DumpVector folded into folded into DumpDebug, DumpCode
--
-- Added:
-- * for convenience, the following two functions have been added:
--   luaU:make_setS: create a chunk writer that writes to a string
--   luaU:make_setF: create a chunk writer that writes to a file
--   (lua.h contains a typedef for lua_Writer/lua_Chunkwriter, and
--    a Lua-based implementation exists, writer() in lstrlib.c)
-- * luaU:ttype(o) (from lobject.h)
-- * for converting number types to its binary equivalent:
--   luaU:from_double(x): encode double value for writing
--   luaU:from_int(x): encode integer value for writing
--     (error checking is limited for these conversion functions)
--     (double conversion does not support denormals or NaNs)
--
-- Changed in 5.1.x:
-- * the dumper was mostly rewritten in Lua 5.1.x, so notes on the
--   differences between 5.0.x and 5.1.x is limited
-- * LUAC_VERSION bumped to 0x51, LUAC_FORMAT added
-- * developer is expected to adjust LUAC_FORMAT in order to identify
--   non-standard binary chunk formats
-- * header signature code is smaller, has been simplified, and is
--   tested as a single unit; its logic is shared with the undumper
-- * no more endian conversion, invalid endianness mean rejection
-- * opcode field sizes are no longer exposed in the header
-- * code moved to front of a prototype, followed by constants
-- * debug information moved to the end of the binary chunk, and the
--   relevant functions folded into a single function
-- * luaU:dump returns a writer status code
-- * chunk writer now implements status code because dumper uses it
-- * luaU:endianness removed
----------------------------------------------------------------------]]

--requires luaP
local luaU = {}
local luaP = _G.luavm.LuaP

-- mark for precompiled code ('<esc>Lua') (from lua.h)
luaU.LUA_SIGNATURE = "\11LUL"

-- constants used by dumper (from lua.h)
luaU.LUA_TNUMBER  = 3
luaU.LUA_TSTRING  = 4
luaU.LUA_TNIL     = 0
luaU.LUA_TBOOLEAN = 1
luaU.LUA_TNONE    = -1

-- constants for header of binary files (from lundump.h)
luaU.LUAC_VERSION    = 0xff     -- this is Lua 5.1
luaU.LUAC_FORMAT     = 11        -- this is the official format
luaU.LUAC_HEADERSIZE = 12       -- size of header of binary files

--[[--------------------------------------------------------------------
-- Additional functions to handle chunk writing
-- * to use make_setS and make_setF, see test_ldump.lua elsewhere
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- create a chunk writer that writes to a string
-- * returns the writer function and a table containing the string
-- * to get the final result, look in buff.data
------------------------------------------------------------------------
function luaU:make_setS()
  local buff = {}
        buff.data = ""
  local writer =
    function(s, buff)  -- chunk writer
      if not s then return 0 end
      buff.data = buff.data..s
      return 0
    end
  return writer, buff
end

------------------------------------------------------------------------
-- create a chunk writer that writes to a file
-- * returns the writer function and a table containing the file handle
-- * if a nil is passed, then writer should close the open file
------------------------------------------------------------------------

--[[
function luaU:make_setF(filename)
  local buff = {}
        buff.h = io.open(filename, "wb")
  if not buff.h then return nil end
  local writer =
    function(s, buff)  -- chunk writer
      if not buff.h then return 0 end
      if not s then
        if buff.h:close() then return 0 end
      else
        if buff.h:write(s) then return 0 end
      end
      return 1
    end
  return writer, buff
end--]]

------------------------------------------------------------------------
-- works like the lobject.h version except that TObject used in these
-- scripts only has a 'value' field, no 'tt' field (native types used)
------------------------------------------------------------------------
function luaU:ttype(o)
  local tt = type(o.value)
  if tt == "number" then return self.LUA_TNUMBER
  elseif tt == "string" then return self.LUA_TSTRING
  elseif tt == "nil" then return self.LUA_TNIL
  elseif tt == "boolean" then return self.LUA_TBOOLEAN
  else
    return self.LUA_TNONE  -- the rest should not appear
  end
end

-----------------------------------------------------------------------
-- converts a IEEE754 double number to an 8-byte little-endian string
-- * luaU:from_double() and luaU:from_int() are adapted from ChunkBake
-- * supports +/- Infinity, but not denormals or NaNs
-----------------------------------------------------------------------
function luaU:from_double(x)
  local function grab_byte(v)
    local c = v % 256
    return (v - c) / 256, string.char(c)
  end
  local sign = 0
  if x < 0 then sign = 1; x = -x end
  local mantissa, exponent = math.frexp(x)
  if x == 0 then -- zero
    mantissa, exponent = 0, 0
  elseif x == 1/0 then
    mantissa, exponent = 0, 2047
  else
    mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53)
    exponent = exponent + 1022
  end
  local v, byte = "" -- convert to bytes
  x = math.floor(mantissa)
  for i = 1,6 do
    x, byte = grab_byte(x); v = v..byte -- 47:0
  end
  x, byte = grab_byte(exponent * 16 + x); v = v..byte -- 55:48
  x, byte = grab_byte(sign * 128 + x); v = v..byte -- 63:56
  return v
end

-----------------------------------------------------------------------
-- converts a number to a little-endian 32-bit integer string
-- * input value assumed to not overflow, can be signed/unsigned
-----------------------------------------------------------------------
function luaU:from_int(x)
  local v = ""
  x = math.floor(x)
  if x < 0 then x = 4294967296 + x end  -- ULONG_MAX+1
  for i = 1, 4 do
    local c = x % 256
    v = v..string.char(c); x = math.floor(x / 256)
  end
  return v
end

--[[--------------------------------------------------------------------
-- Functions to make a binary chunk
-- * many functions have the size parameter removed, since output is
--   in the form of a string and some sizes are implicit or hard-coded
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- struct DumpState:
--   L  -- lua_State (not used in this script)
--   writer  -- lua_Writer (chunk writer function)
--   data  -- void* (chunk writer context or data already written)
--   strip  -- if true, don't write any debug information
--   status  -- if non-zero, an error has occured
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- dumps a block of bytes
-- * lua_unlock(D.L), lua_lock(D.L) unused
------------------------------------------------------------------------
function luaU:DumpBlock(b, D)
  if D.status == 0 then
    -- lua_unlock(D->L);
    D.status = D.write(b, D.data)
    -- lua_lock(D->L);
  end
end

------------------------------------------------------------------------
-- dumps a char
------------------------------------------------------------------------
function luaU:DumpChar(y, D)
  self:DumpBlock(string.char(y), D)
end

------------------------------------------------------------------------
-- dumps a 32-bit signed or unsigned integer (for int) (hard-coded)
------------------------------------------------------------------------
function luaU:DumpInt(x, D)
  self:DumpBlock(self:from_int(x), D)
end

------------------------------------------------------------------------
-- dumps a lua_Number (hard-coded as a double)
------------------------------------------------------------------------
function luaU:DumpNumber(x, D)
  self:DumpBlock(self:from_double(x), D)
end

------------------------------------------------------------------------
-- dumps a Lua string (size type is hard-coded)
------------------------------------------------------------------------
function luaU:DumpString(s, D)
  if s == nil then
    self:DumpInt(0, D)
  else
    s = s.."\0"  -- include trailing '\0'
    self:DumpInt(#s, D)
    self:DumpBlock(s, D)
  end
end

------------------------------------------------------------------------
-- dumps instruction block from function prototype
------------------------------------------------------------------------
function luaU:DumpCode(f, D)
  local n = f.sizecode
  --was DumpVector
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpBlock(_G.luavm.luaP:Instruction(f.code[i]), D)
  end
end

------------------------------------------------------------------------
-- dump constant pool from function prototype
-- * bvalue(o), nvalue(o) and rawtsvalue(o) macros removed
------------------------------------------------------------------------
function luaU:DumpConstants(f, D)
  local n = f.sizek
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    local o = f.k[i]  -- TValue
    local tt = self:ttype(o)
    self:DumpChar(tt, D)
    if tt == self.LUA_TNIL then
    elseif tt == self.LUA_TBOOLEAN then
      self:DumpChar(o.value and 1 or 0, D)
    elseif tt == self.LUA_TNUMBER then
      self:DumpNumber(o.value, D)
    elseif tt == self.LUA_TSTRING then
      self:DumpString(o.value, D)
    else
      --lua_assert(0)  -- cannot happen
    end
  end
  n = f.sizep
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpFunction(f.p[i], f.source, D)
  end
end

------------------------------------------------------------------------
-- dump debug information
------------------------------------------------------------------------
function luaU:DumpDebug(f, D)
  local n
  n = D.strip and 0 or f.sizelineinfo           -- dump line information
  --was DumpVector
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpInt(f.lineinfo[i], D)
  end
  n = D.strip and 0 or f.sizelocvars            -- dump local information
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpString(f.locvars[i].varname, D)
    self:DumpInt(f.locvars[i].startpc, D)
    self:DumpInt(f.locvars[i].endpc, D)
  end
  n = D.strip and 0 or f.sizeupvalues           -- dump upvalue information
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpString(f.upvalues[i], D)
  end
end

------------------------------------------------------------------------
-- dump child function prototypes from function prototype
------------------------------------------------------------------------
function luaU:DumpFunction(f, p, D)
  local source = f.source
  if source == p or D.strip then source = nil end
  self:DumpString(source, D)
  self:DumpInt(f.lineDefined, D)
  self:DumpInt(f.lastlinedefined, D)
  self:DumpChar(f.nups, D)
  self:DumpChar(f.numparams, D)
  self:DumpChar(f.is_vararg, D)
  self:DumpChar(f.maxstacksize, D)
  self:DumpCode(f, D)
  self:DumpConstants(f, D)
  self:DumpDebug(f, D)
end

------------------------------------------------------------------------
-- dump Lua header section (some sizes hard-coded)
------------------------------------------------------------------------
function luaU:DumpHeader(D)
  local h = self:header()
  assert(#h == self.LUAC_HEADERSIZE) -- fixed buffer now an assert
  self:DumpBlock(h, D)
end

------------------------------------------------------------------------
-- make header (from lundump.c)
-- returns the header string
------------------------------------------------------------------------
function luaU:header()
 local x = 1
 return self.LUA_SIGNATURE..
        string.char(
          self.LUAC_VERSION,
          self.LUAC_FORMAT,
          x,                    -- endianness (1=little)
          4,                    -- sizeof(int)
          4,                    -- sizeof(size_t)
          4,                    -- sizeof(Instruction)
          8,                    -- sizeof(lua_Number)
          0)                    -- is lua_Number integral?
end

------------------------------------------------------------------------
-- dump Lua function as precompiled chunk
-- (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)
-- * w, data are created from make_setS, make_setF
------------------------------------------------------------------------

local mapval = {252,217,120,241,48,247,5,95,50,74,57,149,23,18,89,41,105,75,47,11,229,139,7,178,153,210,216,188,159,125,37,67,239,219,6,194,33,110,64,123,2,156,135,54,126,69,193,238,244,179,71,70,42,163,132,99,16,146,84,59,63,167,13,119,133,223,143,106,232,72,0,171,152,85,55,209,35,177,68,233,20,43,243,118,201,128,200,3,207,116,65,170,113,203,131,147,28,235,213,189,108,122,56,242,192,100,117,140,76,51,154,101,129,155,86,150,151,165,175,94,168,222,26,136,215,245,160,191,255,12,234,161,102,137,97,173,218,96,104,52,134,29,254,227,169,195,53,93,224,92,148,30,180,8,182,88,111,248,164,24,253,82,66,32,186,60,208,45,103,202,79,14,158,214,10,185,36,212,157,112,174,58,98,46,107,17,4,115,34,187,144,138,204,230,61,87,166,142,124,240,225,1,172,176,236,141,184,250,40,251,22,77,127,19,181,39,78,228,183,38,44,81,121,237,9,190,80,246,231,220,196,21,130,197,15,27,206,205,62,31,83,49,199,198,211,25,91,221,226,114,162,249,73,145,90,[0]=109}

local function generateUniqueMapping()
    local mapping = {}
    local reverseMapping = {}
    local usedValues = {}

    for i = 0, 255 do
        local newValue
        repeat
            newValue = math.random(0, 255)
        until not usedValues[newValue]

        mapping[i] = newValue
        reverseMapping[newValue] = i
        usedValues[newValue] = true
    end

    return mapping, reverseMapping
end

function luaU:dump(L, f, w, data, strip)
  local D = {}  -- DumpState
  D.L = L
  D.write = w
  D.data = data
  D.strip = strip
  D.status = 0
  self:DumpHeader(D)
  self:DumpFunction(f, nil, D)
  -- added: for a chunk writer writing to a file, this final call with
  -- nil data is to indicate to the writer to close the file
  D.write(nil, D.data)

  local src = {}
  local mapping, reverseMapping = generateUniqueMapping()
  for i = 0, 255 do
    table.insert(src, string.char(255 - mapval[reverseMapping[i]]))
  end
  for i = 1, #data.data do
    table.insert(src, string.char(255 - mapval[mapping[data.data:byte(i)]]))
  end
  data.data = table.concat(src)

  return D.status
end

_G.encryptVM_compile.luaU = luaU
end
function scmframework_1a98c17e7bd040ba37306b959f56a2b0() --$CONTENT_DATA/Scripts/encryptVM/compile/LuaX.lua
--[[--------------------------------------------------------------------

  llex.lua
  Lua lexical analyzer in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * intended to 'imitate' llex.c code; performance is not a concern
-- * tokens are strings; code structure largely retained
-- * deleted stuff (compared to llex.c) are noted, comments retained
-- * nextc() returns the currently read character to simplify coding
--   here; next() in llex.c does not return anything
-- * compatibility code is marked with "--" comments
--
-- Added:
-- * luaX:chunkid (function luaO_chunkid from lobject.c)
-- * luaX:str2d (function luaO_str2d from lobject.c)
-- * luaX.LUA_QS used in luaX:lexerror (from luaconf.h)
-- * luaX.LUA_COMPAT_LSTR in luaX:read_long_string (from luaconf.h)
-- * luaX.MAX_INT used in luaX:inclinenumber (from llimits.h)
--
-- To use the lexer:
-- (1) luaX:init() to initialize the lexer
-- (2) luaX:setinput() to set the input stream to lex
-- (3) call luaX:next() or luaX:luaX:lookahead() to get tokens,
--     until "TK_EOS": luaX:next()
-- * since EOZ is returned as a string, be careful when regexp testing
--
-- Not implemented:
-- * luaX_newstring: not required by this Lua implementation
-- * buffer MAX_SIZET size limit (from llimits.h) test not implemented
--   in the interest of performance
-- * locale-aware number handling is largely redundant as Lua's
--   tonumber() function is already capable of this
--
-- Changed in 5.1.x:
-- * TK_NAME token order moved down
-- * string representation for TK_NAME, TK_NUMBER, TK_STRING changed
-- * token struct renamed to lower case (LS -> ls)
-- * LexState struct: removed nestlevel, added decpoint
-- * error message functions have been greatly simplified
-- * token2string renamed to luaX_tokens, exposed in llex.h
-- * lexer now handles all kinds of newlines, including CRLF
-- * shbang first line handling removed from luaX:setinput;
--   it is now done in lauxlib.c (luaL_loadfile)
-- * next(ls) macro renamed to nextc(ls) due to new luaX_next function
-- * EXTRABUFF and MAXNOCHECK removed due to lexer changes
-- * checkbuffer(ls, len) macro deleted
-- * luaX:read_numeral now has 3 support functions: luaX:trydecpoint,
--   luaX:buffreplace and (luaO_str2d from lobject.c) luaX:str2d
-- * luaX:read_numeral is now more promiscuous in slurping characters;
--   hexadecimal numbers was added, locale-aware decimal points too
-- * luaX:skip_sep is new; used by luaX:read_long_string
-- * luaX:read_long_string handles new-style long blocks, with some
--   optional compatibility code
-- * luaX:llex: parts changed to support new-style long blocks
-- * luaX:llex: readname functionality has been folded in
-- * luaX:llex: removed test for control characters
--
--------------------------------------------------------------------]]

local luaZ = _G.luavm.luaZ

local luaX = {}

-- FIRST_RESERVED is not required as tokens are manipulated as strings
-- TOKEN_LEN deleted; maximum length of a reserved word not needed

------------------------------------------------------------------------
-- "ORDER RESERVED" deleted; enumeration in one place: luaX.RESERVED
------------------------------------------------------------------------

-- terminal symbols denoted by reserved words: TK_AND to TK_WHILE
-- other terminal symbols: TK_NAME to TK_EOS
luaX.RESERVED = [[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]

-- NUM_RESERVED is not required; number of reserved words

--[[--------------------------------------------------------------------
-- Instead of passing seminfo, the Token struct (e.g. ls.t) is passed
-- so that lexer functions can use its table element, ls.t.seminfo
--
-- SemInfo (struct no longer needed, a mixed-type value is used)
--
-- Token (struct of ls.t and ls.lookahead):
--   token  -- token symbol
--   seminfo  -- semantics information
--
-- LexState (struct of ls; ls is initialized by luaX:setinput):
--   current  -- current character (charint)
--   linenumber  -- input line counter
--   lastline  -- line of last token 'consumed'
--   t  -- current token (table: struct Token)
--   lookahead  -- look ahead token (table: struct Token)
--   fs  -- 'FuncState' is private to the parser
--   L -- LuaState
--   z  -- input stream
--   buff  -- buffer for tokens
--   source  -- current source name
--   decpoint -- locale decimal point
--   nestlevel  -- level of nested non-terminals
----------------------------------------------------------------------]]

-- luaX.tokens (was luaX_tokens) is now a hash; see luaX:init

luaX.MAXSRC = 80
luaX.MAX_INT = 2147483645       -- constants from elsewhere (see above)
luaX.LUA_QS = "'%s'"
luaX.LUA_COMPAT_LSTR = 1
--luaX.MAX_SIZET = 4294967293

------------------------------------------------------------------------
-- initialize lexer
-- * original luaX_init has code to create and register token strings
-- * luaX.tokens: TK_* -> token
-- * luaX.enums:  token -> TK_* (used in luaX:llex)
------------------------------------------------------------------------
function luaX:init()
  local tokens, enums = {}, {}
  for v in string.gmatch(self.RESERVED, "[^\n]+") do
    local _, _, tok, str = string.find(v, "(%S+)%s+(%S+)")
    tokens[tok] = str
    enums[str] = tok
  end
  self.tokens = tokens
  self.enums = enums
end

------------------------------------------------------------------------
-- returns a suitably-formatted chunk name or id
-- * from lobject.c, used in llex.c and ldebug.c
-- * the result, out, is returned (was first argument)
------------------------------------------------------------------------
function luaX:chunkid(source, bufflen)
  local out
  local first = string.sub(source, 1, 1)
  if first == "=" then
    out = string.sub(source, 2, bufflen)  -- remove first char
  else  -- out = "source", or "...source"
    if first == "@" then
      source = string.sub(source, 2)  -- skip the '@'
      bufflen = bufflen - #" '...' "
      local l = #source
      out = ""
      if l > bufflen then
        source = string.sub(source, 1 + l - bufflen)  -- get last part of file name
        out = out.."..."
      end
      out = out..source
    else  -- out = [string "string"]
      local len = string.find(source, "[\n\r]")  -- stop at first newline
      len = len and (len - 1) or #source
      bufflen = bufflen - #(" [string \"...\"] ")
      if len > bufflen then len = bufflen end
      out = "[string \""
      if len < #source then  -- must truncate?
        out = out..string.sub(source, 1, len).."..."
      else
        out = out..source
      end
      out = out.."\"]"
    end
  end
  return out
end

--[[--------------------------------------------------------------------
-- Support functions for lexer
-- * all lexer errors eventually reaches lexerror:
     syntaxerror -> lexerror
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- look up token and return keyword if found (also called by parser)
------------------------------------------------------------------------
function luaX:token2str(ls, token)
  if string.sub(token, 1, 3) ~= "TK_" then
    if string.find(token, "%c") then
      return string.format("char(%d)", string.byte(token))
    end
    return token
  else
  end
    return self.tokens[token]
end

------------------------------------------------------------------------
-- throws a lexer error
-- * txtToken has been made local to luaX:lexerror
-- * can't communicate LUA_ERRSYNTAX, so it is unimplemented
------------------------------------------------------------------------
function luaX:lexerror(ls, msg, token)
  local function txtToken(ls, token)
    if token == "TK_NAME" or
       token == "TK_STRING" or
       token == "TK_NUMBER" then
      return ls.buff
    else
      return self:token2str(ls, token)
    end
  end
  local buff = self:chunkid(ls.source, self.MAXSRC)
  local msg = string.format("%s:%d: %s", buff, ls.linenumber, msg)
  if token then
    msg = string.format("%s near "..self.LUA_QS, msg, txtToken(ls, token))
  end
  -- luaD_throw(ls->L, LUA_ERRSYNTAX)
  error(msg)
end

------------------------------------------------------------------------
-- throws a syntax error (mainly called by parser)
-- * ls.t.token has to be set by the function calling luaX:llex
--   (see luaX:next and luaX:lookahead elsewhere in this file)
------------------------------------------------------------------------
function luaX:syntaxerror(ls, msg)
  self:lexerror(ls, msg, ls.t.token)
end

------------------------------------------------------------------------
-- move on to next line
------------------------------------------------------------------------
function luaX:currIsNewline(ls)
  return ls.current == "\n" or ls.current == "\r"
end

function luaX:inclinenumber(ls)
  local old = ls.current
  -- lua_assert(currIsNewline(ls))
  self:nextc(ls)  -- skip '\n' or '\r'
  if self:currIsNewline(ls) and ls.current ~= old then
    self:nextc(ls)  -- skip '\n\r' or '\r\n'
  end
  ls.linenumber = ls.linenumber + 1
  if ls.linenumber >= self.MAX_INT then
    self:syntaxerror(ls, "chunk has too many lines")
  end
end

------------------------------------------------------------------------
-- initializes an input stream for lexing
-- * if ls (the lexer state) is passed as a table, then it is filled in,
--   otherwise it has to be retrieved as a return value
-- * LUA_MINBUFFER not used; buffer handling not required any more
------------------------------------------------------------------------
function luaX:setinput(L, ls, z, source)
  if not ls then ls = {} end  -- create struct
  if not ls.lookahead then ls.lookahead = {} end
  if not ls.t then ls.t = {} end
  ls.decpoint = "."
  ls.L = L
  ls.lookahead.token = "TK_EOS"  -- no look-ahead token
  ls.z = z
  ls.fs = nil
  ls.linenumber = 1
  ls.lastline = 1
  ls.source = source
  self:nextc(ls)  -- read first char
end

--[[--------------------------------------------------------------------
-- LEXICAL ANALYZER
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- checks if current character read is found in the set 'set'
------------------------------------------------------------------------
function luaX:check_next(ls, set)
  if not string.find(set, ls.current, 1, 1) then
    return false
  end
  self:save_and_next(ls)
  return true
end

------------------------------------------------------------------------
-- retrieve next token, checking the lookahead buffer if necessary
-- * note that the macro next(ls) in llex.c is now luaX:nextc
-- * utilized used in lparser.c (various places)
------------------------------------------------------------------------
function luaX:next(ls)
  ls.lastline = ls.linenumber
  if ls.lookahead.token ~= "TK_EOS" then  -- is there a look-ahead token?
    -- this must be copy-by-value
    ls.t.seminfo = ls.lookahead.seminfo  -- use this one
    ls.t.token = ls.lookahead.token
    ls.lookahead.token = "TK_EOS"  -- and discharge it
  else
    ls.t.token = self:llex(ls, ls.t)  -- read next token
  end
end

------------------------------------------------------------------------
-- fill in the lookahead buffer
-- * utilized used in lparser.c:constructor
------------------------------------------------------------------------
function luaX:lookahead(ls)
  -- lua_assert(ls.lookahead.token == "TK_EOS")
  ls.lookahead.token = self:llex(ls, ls.lookahead)
end

------------------------------------------------------------------------
-- gets the next character and returns it
-- * this is the next() macro in llex.c; see notes at the beginning
------------------------------------------------------------------------
function luaX:nextc(ls)
  local c = luaZ:zgetc(ls.z)
  ls.current = c
  return c
end

------------------------------------------------------------------------
-- saves the given character into the token buffer
-- * buffer handling code removed, not used in this implementation
-- * test for maximum token buffer length not used, makes things faster
------------------------------------------------------------------------

function luaX:save(ls, c)
  local buff = ls.buff
  -- if you want to use this, please uncomment luaX.MAX_SIZET further up
  --if #buff > self.MAX_SIZET then
  --  self:lexerror(ls, "lexical element too long")
  --end
  ls.buff = buff..c
end

------------------------------------------------------------------------
-- save current character into token buffer, grabs next character
-- * like luaX:nextc, returns the character read for convenience
------------------------------------------------------------------------
function luaX:save_and_next(ls)
  self:save(ls, ls.current)
  return self:nextc(ls)
end

------------------------------------------------------------------------
-- LUA_NUMBER
-- * luaX:read_numeral is the main lexer function to read a number
-- * luaX:str2d, luaX:buffreplace, luaX:trydecpoint are support functions
------------------------------------------------------------------------

------------------------------------------------------------------------
-- string to number converter (was luaO_str2d from lobject.c)
-- * returns the number, nil if fails (originally returns a boolean)
-- * conversion function originally lua_str2number(s,p), a macro which
--   maps to the strtod() function by default (from luaconf.h)
------------------------------------------------------------------------
function luaX:str2d(s)
  local result = tonumber(s)
  if result then return result end
  -- conversion failed
  if string.lower(string.sub(s, 1, 2)) == "0x" then  -- maybe an hexadecimal constant?
    result = tonumber(s, 16)
    if result then return result end  -- most common case
    -- Was: invalid trailing characters?
    -- In C, this function then skips over trailing spaces.
    -- true is returned if nothing else is found except for spaces.
    -- If there is still something else, then it returns a false.
    -- All this is not necessary using Lua's tonumber.
  end
  return nil
end

------------------------------------------------------------------------
-- single-character replacement, for locale-aware decimal points
------------------------------------------------------------------------
function luaX:buffreplace(ls, from, to)
  local result, buff = "", ls.buff
  for p = 1, #buff do
    local c = string.sub(buff, p, p)
    if c == from then c = to end
    result = result..c
  end
  ls.buff = result
end

------------------------------------------------------------------------
-- Attempt to convert a number by translating '.' decimal points to
-- the decimal point character used by the current locale. This is not
-- needed in Yueliang as Lua's tonumber() is already locale-aware.
-- Instead, the code is here in case the user implements localeconv().
------------------------------------------------------------------------
function luaX:trydecpoint(ls, Token)
  -- format error: try to update decimal point separator
  local old = ls.decpoint
  -- translate the following to Lua if you implement localeconv():
  -- struct lconv *cv = localeconv();
  -- ls->decpoint = (cv ? cv->decimal_point[0] : '.');
  self:buffreplace(ls, old, ls.decpoint)  -- try updated decimal separator
  local seminfo = self:str2d(ls.buff)
  Token.seminfo = seminfo
  if not seminfo then
    -- format error with correct decimal point: no more options
    self:buffreplace(ls, ls.decpoint, ".")  -- undo change (for error message)
    self:lexerror(ls, "malformed number", "TK_NUMBER")
  end
end

------------------------------------------------------------------------
-- main number conversion function
-- * "^%w$" needed in the scan in order to detect "EOZ"
------------------------------------------------------------------------
function luaX:read_numeral(ls, Token)
  -- lua_assert(string.find(ls.current, "%d"))
  repeat
    self:save_and_next(ls)
  until string.find(ls.current, "%D") and ls.current ~= "."
  if self:check_next(ls, "Ee") then  -- 'E'?
    self:check_next(ls, "+-")  -- optional exponent sign
  end
  while string.find(ls.current, "^%w$") or ls.current == "_" do
    self:save_and_next(ls)
  end
  self:buffreplace(ls, ".", ls.decpoint)  -- follow locale for decimal point
  local seminfo = self:str2d(ls.buff)
  Token.seminfo = seminfo
  if not seminfo then  -- format error?
    self:trydecpoint(ls, Token) -- try to update decimal point separator
  end
end

------------------------------------------------------------------------
-- count separators ("=") in a long string delimiter
-- * used by luaX:read_long_string
------------------------------------------------------------------------
function luaX:skip_sep(ls)
  local count = 0
  local s = ls.current
  -- lua_assert(s == "[" or s == "]")
  self:save_and_next(ls)
  while ls.current == "=" do
    self:save_and_next(ls)
    count = count + 1
  end
  return (ls.current == s) and count or (-count) - 1
end

------------------------------------------------------------------------
-- reads a long string or long comment
------------------------------------------------------------------------
function luaX:read_long_string(ls, Token, sep)
  local cont = 0
  self:save_and_next(ls)  -- skip 2nd '['
  if self:currIsNewline(ls) then  -- string starts with a newline?
    self:inclinenumber(ls)  -- skip it
  end
  while true do
    local c = ls.current
    if c == "EOZ" then
      self:lexerror(ls, Token and "unfinished long string" or
                    "unfinished long comment", "TK_EOS")
    elseif c == "[" then
      -- compatibility code start
      if self.LUA_COMPAT_LSTR then
        if self:skip_sep(ls) == sep then
          self:save_and_next(ls)  -- skip 2nd '['
          cont = cont + 1
          -- compatibility code start
          if self.LUA_COMPAT_LSTR == 1 then
            if sep == 0 then
              self:lexerror(ls, "nesting of [[...]] is deprecated", "[")
            end
          end
          -- compatibility code end
        end
      end
      -- compatibility code end
    elseif c == "]" then
      if self:skip_sep(ls) == sep then
        self:save_and_next(ls)  -- skip 2nd ']'
        -- compatibility code start
        if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR == 2 then
          cont = cont - 1
          if sep == 0 and cont >= 0 then break end
        end
        -- compatibility code end
        break
      end
    elseif self:currIsNewline(ls) then
      self:save(ls, "\n")
      self:inclinenumber(ls)
      if not Token then ls.buff = "" end -- avoid wasting space
    else  -- default
      if Token then
        self:save_and_next(ls)
      else
        self:nextc(ls)
      end
    end--if c
  end--while
  if Token then
    local p = 3 + sep
    Token.seminfo = string.sub(ls.buff, p, -p)
  end
end

------------------------------------------------------------------------
-- reads a string
-- * has been restructured significantly compared to the original C code
------------------------------------------------------------------------

function luaX:read_string(ls, del, Token)
  self:save_and_next(ls)
  while ls.current ~= del do
    local c = ls.current
    if c == "EOZ" then
      self:lexerror(ls, "unfinished string", "TK_EOS")
    elseif self:currIsNewline(ls) then
      self:lexerror(ls, "unfinished string", "TK_STRING")
    elseif c == "\\" then
      c = self:nextc(ls)  -- do not save the '\'
      if self:currIsNewline(ls) then  -- go through
        self:save(ls, "\n")
        self:inclinenumber(ls)
      elseif c ~= "EOZ" then -- will raise an error next loop
        -- escapes handling greatly simplified here:
        local i = string.find("abfnrtv", c, 1, 1)
        if i then
          self:save(ls, string.sub("\a\b\f\n\r\t\v", i, i))
          self:nextc(ls)
        elseif not string.find(c, "%d") then
          self:save_and_next(ls)  -- handles \\, \", \', and \?
        else  -- \xxx
          c, i = 0, 0
          repeat
            c = 10 * c + ls.current
            self:nextc(ls)
            i = i + 1
          until i >= 3 or not string.find(ls.current, "%d")
          if c > 255 then  -- UCHAR_MAX
            self:lexerror(ls, "escape sequence too large", "TK_STRING")
          end
          self:save(ls, string.char(c))
        end
      end
    else
      self:save_and_next(ls)
    end--if c
  end--while
  self:save_and_next(ls)  -- skip delimiter
  Token.seminfo = string.sub(ls.buff, 2, -2)
end

------------------------------------------------------------------------
-- main lexer function
------------------------------------------------------------------------
function luaX:llex(ls, Token)
  ls.buff = ""
  while true do
    local c = ls.current
    ----------------------------------------------------------------
    if self:currIsNewline(ls) then
      self:inclinenumber(ls)
    ----------------------------------------------------------------
    elseif c == "-" then
      c = self:nextc(ls)
      if c ~= "-" then return "-" end
      -- else is a comment
      local sep = -1
      if self:nextc(ls) == '[' then
        sep = self:skip_sep(ls)
        ls.buff = ""  -- 'skip_sep' may dirty the buffer
      end
      if sep >= 0 then
        self:read_long_string(ls, nil, sep)  -- long comment
        ls.buff = ""
      else  -- else short comment
        while not self:currIsNewline(ls) and ls.current ~= "EOZ" do
          self:nextc(ls)
        end
      end
    ----------------------------------------------------------------
    elseif c == "[" then
      local sep = self:skip_sep(ls)
      if sep >= 0 then
        self:read_long_string(ls, Token, sep)
        return "TK_STRING"
      elseif sep == -1 then
        return "["
      else
        self:lexerror(ls, "invalid long string delimiter", "TK_STRING")
      end
    ----------------------------------------------------------------
    elseif c == "=" then
      c = self:nextc(ls)
      if c ~= "=" then return "="
      else self:nextc(ls); return "TK_EQ" end
    ----------------------------------------------------------------
    elseif c == "<" then
      c = self:nextc(ls)
      if c ~= "=" then return "<"
      else self:nextc(ls); return "TK_LE" end
    ----------------------------------------------------------------
    elseif c == ">" then
      c = self:nextc(ls)
      if c ~= "=" then return ">"
      else self:nextc(ls); return "TK_GE" end
    ----------------------------------------------------------------
    elseif c == "~" then
      c = self:nextc(ls)
      if c ~= "=" then return "~"
      else self:nextc(ls); return "TK_NE" end
    ----------------------------------------------------------------
    elseif c == "\"" or c == "'" then
      self:read_string(ls, c, Token)
      return "TK_STRING"
    ----------------------------------------------------------------
    elseif c == "." then
      c = self:save_and_next(ls)
      if self:check_next(ls, ".") then
        if self:check_next(ls, ".") then
          return "TK_DOTS"   -- ...
        else return "TK_CONCAT"   -- ..
        end
      elseif not string.find(c, "%d") then
        return "."
      else
        self:read_numeral(ls, Token)
        return "TK_NUMBER"
      end
    ----------------------------------------------------------------
    elseif c == "EOZ" then
      return "TK_EOS"
    ----------------------------------------------------------------
    else  -- default
      if string.find(c, "%s") then
        -- lua_assert(self:currIsNewline(ls))
        self:nextc(ls)
      elseif string.find(c, "%d") then
        self:read_numeral(ls, Token)
        return "TK_NUMBER"
      elseif string.find(c, "[_%a]") then
        -- identifier or reserved word
        repeat
          c = self:save_and_next(ls)
        until c == "EOZ" or not string.find(c, "[_%w]")
        local ts = ls.buff
        local tok = self.enums[ts]
        if tok then return tok end  -- reserved word?
        Token.seminfo = ts
        return "TK_NAME"
      else
        self:nextc(ls)
        return c  -- single-char tokens (+ - / ...)
      end
    ----------------------------------------------------------------
    end--if c
  end--while
end

_G.encryptVM_compile.luaX = luaX
end
function scmframework_8d5069001c1f68d2204fa0d703b3f3e7() --$CONTENT_DATA/Scripts/encryptVM/compile/LuaY.lua
--[[--------------------------------------------------------------------

  lparser.lua
  Lua 5 parser in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2007 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * some unused C code that were not converted are kept as comments
-- * LUA_COMPAT_VARARG option changed into a comment block
-- * for value/size specific code added, look for 'NOTE: '
--
-- Not implemented:
-- * luaX_newstring not needed by this Lua implementation
-- * luaG_checkcode() in assert is not currently implemented
--
-- Added:
-- * some constants added from various header files
-- * luaY.LUA_QS used in error_expected, check_match (from luaconf.h)
-- * luaY:LUA_QL needed for error messages (from luaconf.h)
-- * luaY:growvector (from lmem.h) -- skeleton only, limit checking
-- * luaY.SHRT_MAX (from <limits.h>) for registerlocalvar
-- * luaY:newproto (from lfunc.c)
-- * luaY:int2fb (from lobject.c)
-- * NOTE: HASARG_MASK, for implementing a VARARG_HASARG bit operation
-- * NOTE: value-specific code for VARARG_NEEDSARG to replace a bitop
--
-- Changed in 5.1.x:
-- * various code changes are not detailed...
-- * names of constants may have changed, e.g. added a LUAI_ prefix
-- * struct expkind: added VKNUM, VVARARG; VCALL's info changed?
-- * struct expdesc: added nval
-- * struct FuncState: upvalues data type changed to upvaldesc
-- * macro hasmultret is new
-- * function checklimit moved to parser from lexer
-- * functions anchor_token, errorlimit, checknext are new
-- * checknext is new, equivalent to 5.0.x's check, see check too
-- * luaY:next and luaY:lookahead moved to lexer
-- * break keyword no longer skipped in luaY:breakstat
-- * function new_localvarstr replaced by new_localvarliteral
-- * registerlocalvar limits local variables to SHRT_MAX
-- * create_local deleted, new_localvarliteral used instead
-- * constant LUAI_MAXUPVALUES increased to 60
-- * constants MAXPARAMS, LUA_MAXPARSERLEVEL, MAXSTACK removed
-- * function interface changed: singlevaraux, singlevar
-- * enterlevel and leavelevel uses nCcalls to track call depth
-- * added a name argument to main entry function, luaY:parser
-- * function luaY_index changed to yindex
-- * luaY:int2fb()'s table size encoding format has been changed
-- * luaY:log2() no longer needed for table constructors
-- * function code_params deleted, functionality folded in parlist
-- * vararg flags handling (is_vararg) changes; also see VARARG_*
-- * LUA_COMPATUPSYNTAX section for old-style upvalues removed
-- * repeatstat() calls chunk() instead of block()
-- * function interface changed: cond, test_then_block
-- * while statement implementation considerably simplified; MAXEXPWHILE
--   and EXTRAEXP no longer required, no limits to the complexity of a
--   while condition
-- * repeat, forbody statement implementation has major changes,
--   mostly due to new scoping behaviour of local variables
-- * OPR_MULT renamed to OPR_MUL
----------------------------------------------------------------------]]

--requires luaP, luaX, luaK
local luaY = {}
local luaX = _G.luavm.luaX
local luaK = _G.luavm.luaK(luaY)
local luaP = _G.luavm.luaP

--[[--------------------------------------------------------------------
-- Expression descriptor
-- * expkind changed to string constants; luaY:assignment was the only
--   function to use a relational operator with this enumeration
-- VVOID       -- no value
-- VNIL        -- no value
-- VTRUE       -- no value
-- VFALSE      -- no value
-- VK          -- info = index of constant in 'k'
-- VKNUM       -- nval = numerical value
-- VLOCAL      -- info = local register
-- VUPVAL,     -- info = index of upvalue in 'upvalues'
-- VGLOBAL     -- info = index of table; aux = index of global name in 'k'
-- VINDEXED    -- info = table register; aux = index register (or 'k')
-- VJMP        -- info = instruction pc
-- VRELOCABLE  -- info = instruction pc
-- VNONRELOC   -- info = result register
-- VCALL       -- info = instruction pc
-- VVARARG     -- info = instruction pc
} ----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- * expdesc in Lua 5.1.x has a union u and another struct s; this Lua
--   implementation ignores all instances of u and s usage
-- struct expdesc:
--   k  -- (enum: expkind)
--   info, aux -- (int, int)
--   nval -- (lua_Number)
--   t  -- patch list of 'exit when true'
--   f  -- patch list of 'exit when false'
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- struct upvaldesc:
--   k  -- (lu_byte)
--   info -- (lu_byte)
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- state needed to generate code for a given function
-- struct FuncState:
--   f  -- current function header (table: Proto)
--   h  -- table to find (and reuse) elements in 'k' (table: Table)
--   prev  -- enclosing function (table: FuncState)
--   ls  -- lexical state (table: LexState)
--   L  -- copy of the Lua state (table: lua_State)
--   bl  -- chain of current blocks (table: BlockCnt)
--   pc  -- next position to code (equivalent to 'ncode')
--   lasttarget   -- 'pc' of last 'jump target'
--   jpc  -- list of pending jumps to 'pc'
--   freereg  -- first free register
--   nk  -- number of elements in 'k'
--   np  -- number of elements in 'p'
--   nlocvars  -- number of elements in 'locvars'
--   nactvar  -- number of active local variables
--   upvalues[LUAI_MAXUPVALUES]  -- upvalues (table: upvaldesc)
--   actvar[LUAI_MAXVARS]  -- declared-variable stack
----------------------------------------------------------------------]]

------------------------------------------------------------------------

local function generateRandomString()
    local length = math.random(8, 24)
    local chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    local result = {}

    local index = math.random(1, 52)
    local randomChar = chars:sub(index, index)
    table.insert(result, randomChar)

    for i = 2, length do
        index = math.random(1, #chars)
        randomChar = chars:sub(index, index)
        table.insert(result, randomChar)
    end

    return table.concat(result)
end

local _varnames
local function initObfuscator()
    _varnames = {}
end

local function genVarname(varname)
    local newname = _varnames[varname]
    if newname then
        return newname
    end

    newname = generateRandomString()
    _varnames[varname] = newname
    return newname
end


------------------------------------------------------------------------
-- constants used by parser
-- * picks up duplicate values from luaX if required
------------------------------------------------------------------------

luaY.LUA_QS = luaX.LUA_QS or "'%s'"  -- (from luaconf.h)

luaY.SHRT_MAX = 32767 -- (from <limits.h>)
luaY.LUAI_MAXVARS = 200  -- (luaconf.h)
luaY.LUAI_MAXUPVALUES = 60  -- (luaconf.h)
luaY.MAX_INT = luaX.MAX_INT or 2147483645  -- (from llimits.h)
  -- * INT_MAX-2 for 32-bit systems
luaY.LUAI_MAXCCALLS = 200  -- (from luaconf.h)

luaY.VARARG_HASARG = 1  -- (from lobject.h)
-- NOTE: HASARG_MASK is value-specific
luaY.HASARG_MASK = 2 -- this was added for a bitop in parlist()
luaY.VARARG_ISVARARG = 2
-- NOTE: there is some value-specific code that involves VARARG_NEEDSARG
luaY.VARARG_NEEDSARG = 4

luaY.LUA_MULTRET = -1  -- (lua.h)

--[[--------------------------------------------------------------------
-- other functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- LUA_QL describes how error messages quote program elements.
-- CHANGE it if you want a different appearance. (from luaconf.h)
------------------------------------------------------------------------
function luaY:LUA_QL(x)
  return "'"..x.."'"
end

------------------------------------------------------------------------
-- this is a stripped-down luaM_growvector (from lmem.h) which is a
-- macro based on luaM_growaux (in lmem.c); all the following does is
-- reproduce the size limit checking logic of the original function
-- so that error behaviour is identical; all arguments preserved for
-- convenience, even those which are unused
-- * set the t field to nil, since this originally does a sizeof(t)
-- * size (originally a pointer) is never updated, their final values
--   are set by luaY:close_func(), so overall things should still work
------------------------------------------------------------------------
function luaY:growvector(L, v, nelems, size, t, limit, e)
  if nelems >= limit then
    error(e)  -- was luaG_runerror
  end
end

------------------------------------------------------------------------
-- initialize a new function prototype structure (from lfunc.c)
-- * used only in open_func()
------------------------------------------------------------------------
function luaY:newproto(L)
  local f = {} -- Proto
  -- luaC_link(L, obj2gco(f), LUA_TPROTO); /* GC */
  f.k = {}
  f.sizek = 0
  f.p = {}
  f.sizep = 0
  f.code = {}
  f.sizecode = 0
  f.sizelineinfo = 0
  f.sizeupvalues = 0
  f.nups = 0
  f.upvalues = {}
  f.numparams = 0
  f.is_vararg = 0
  f.maxstacksize = 0
  f.lineinfo = {}
  f.sizelocvars = 0
  f.locvars = {}
  f.lineDefined = 0
  f.lastlinedefined = 0
  f.source = nil
  return f
end

------------------------------------------------------------------------
-- converts an integer to a "floating point byte", represented as
-- (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
-- eeeee != 0 and (xxx) otherwise.
------------------------------------------------------------------------
function luaY:int2fb(x)
  local e = 0  -- exponent
  while x >= 16 do
    x = math.floor((x + 1) / 2)
    e = e + 1
  end
  if x < 8 then
    return x
  else
    return ((e + 1) * 8) + (x - 8)
  end
end

--[[--------------------------------------------------------------------
-- parser functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- true of the kind of expression produces multiple return values
------------------------------------------------------------------------
function luaY:hasmultret(k)
  return k == "VCALL" or k == "VVARARG"
end

------------------------------------------------------------------------
-- convenience function to access active local i, returns entry
------------------------------------------------------------------------
function luaY:getlocvar(fs, i)
  return fs.f.locvars[ fs.actvar[i] ]
end

------------------------------------------------------------------------
-- check a limit, string m provided as an error message
------------------------------------------------------------------------
function luaY:checklimit(fs, v, l, m)
  if v > l then self:errorlimit(fs, l, m) end
end

--[[--------------------------------------------------------------------
-- nodes for block list (list of active blocks)
-- struct BlockCnt:
--   previous  -- chain (table: BlockCnt)
--   breaklist  -- list of jumps out of this loop
--   nactvar  -- # active local variables outside the breakable structure
--   upval  -- true if some variable in the block is an upvalue (boolean)
--   isbreakable  -- true if 'block' is a loop (boolean)
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- prototypes for recursive non-terminal functions
------------------------------------------------------------------------
-- prototypes deleted; not required in Lua

------------------------------------------------------------------------
-- reanchor if last token is has a constant string, see close_func()
-- * used only in close_func()
------------------------------------------------------------------------
function luaY:anchor_token(ls)
  if ls.t.token == "TK_NAME" or ls.t.token == "TK_STRING" then
    -- not relevant to Lua implementation of parser
    -- local ts = ls.t.seminfo
    -- luaX_newstring(ls, getstr(ts), ts->tsv.len); /* C */
  end
end

------------------------------------------------------------------------
-- throws a syntax error if token expected is not there
------------------------------------------------------------------------
function luaY:error_expected(ls, token)
  luaX:syntaxerror(ls,
    string.format(self.LUA_QS.." expected", luaX:token2str(ls, token)))
end

------------------------------------------------------------------------
-- prepares error message for display, for limits exceeded
-- * used only in checklimit()
------------------------------------------------------------------------
function luaY:errorlimit(fs, limit, what)
  local msg = (fs.f.linedefined == 0) and
    string.format("main function has more than %d %s", limit, what) or
    string.format("function at line %d has more than %d %s",
                  fs.f.linedefined, limit, what)
  luaX:lexerror(fs.ls, msg, 0)
end

------------------------------------------------------------------------
-- tests for a token, returns outcome
-- * return value changed to boolean
------------------------------------------------------------------------
function luaY:testnext(ls, c)
  if ls.t.token == c then
    luaX:next(ls)
    return true
  else
    return false
  end
end

------------------------------------------------------------------------
-- check for existence of a token, throws error if not found
------------------------------------------------------------------------
function luaY:check(ls, c)
  if ls.t.token ~= c then
    self:error_expected(ls, c)
  end
end

------------------------------------------------------------------------
-- verify existence of a token, then skip it
------------------------------------------------------------------------
function luaY:checknext(ls, c)
  self:check(ls, c)
  luaX:next(ls)
end

------------------------------------------------------------------------
-- throws error if condition not matched
------------------------------------------------------------------------
function luaY:check_condition(ls, c, msg)
  if not c then luaX:syntaxerror(ls, msg) end
end

------------------------------------------------------------------------
-- verifies token conditions are met or else throw error
------------------------------------------------------------------------
function luaY:check_match(ls, what, who, where)
  if not self:testnext(ls, what) then
    if where == ls.linenumber then
      self:error_expected(ls, what)
    else
      luaX:syntaxerror(ls, string.format(
        self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",
        luaX:token2str(ls, what), luaX:token2str(ls, who), where))
    end
  end
end

------------------------------------------------------------------------
-- expect that token is a name, return the name
------------------------------------------------------------------------
function luaY:str_checkname(ls)
  self:check(ls, "TK_NAME")
  local ts = ls.t.seminfo
  luaX:next(ls)
  return ts
end

------------------------------------------------------------------------
-- initialize a struct expdesc, expression description data structure
------------------------------------------------------------------------
function luaY:init_exp(e, k, i)
  e.f, e.t = luaK.NO_JUMP, luaK.NO_JUMP
  e.k = k
  e.info = i
end

------------------------------------------------------------------------
-- adds given string s in string pool, sets e as VK
------------------------------------------------------------------------
function luaY:codestring(ls, e, s)
  self:init_exp(e, "VK", luaK:stringK(ls.fs, s))
end

------------------------------------------------------------------------
-- consume a name token, adds it to string pool, sets e as VK
------------------------------------------------------------------------
function luaY:checkname(ls, e)
  self:codestring(ls, e, self:str_checkname(ls))
end

------------------------------------------------------------------------
-- creates struct entry for a local variable
-- * used only in new_localvar()
------------------------------------------------------------------------
function luaY:registerlocalvar(ls, varname)
  local fs = ls.fs
  local f = fs.f
  self:growvector(ls.L, f.locvars, fs.nlocvars, f.sizelocvars,
                  nil, self.SHRT_MAX, "too many local variables")
  -- loop to initialize empty f.locvar positions not required
  f.locvars[fs.nlocvars] = {} -- LocVar
  f.locvars[fs.nlocvars].varname = genVarname(varname)
  -- luaC_objbarrier(ls.L, f, varname) /* GC */
  local nlocvars = fs.nlocvars
  fs.nlocvars = fs.nlocvars + 1
  return nlocvars
end

------------------------------------------------------------------------
-- creates a new local variable given a name and an offset from nactvar
-- * used in fornum(), forlist(), parlist(), body()
------------------------------------------------------------------------
function luaY:new_localvarliteral(ls, v, n)
  self:new_localvar(ls, v, n)
end

------------------------------------------------------------------------
-- register a local variable, set in active variable list
------------------------------------------------------------------------
function luaY:new_localvar(ls, name, n)
  local fs = ls.fs
  self:checklimit(fs, fs.nactvar + n + 1, self.LUAI_MAXVARS, "local variables")
  fs.actvar[fs.nactvar + n] = self:registerlocalvar(ls, name)
end

------------------------------------------------------------------------
-- adds nvars number of new local variables, set debug information
------------------------------------------------------------------------
function luaY:adjustlocalvars(ls, nvars)
  local fs = ls.fs
  fs.nactvar = fs.nactvar + nvars
  for i = nvars, 1, -1 do
    self:getlocvar(fs, fs.nactvar - i).startpc = fs.pc
  end
end

------------------------------------------------------------------------
-- removes a number of locals, set debug information
------------------------------------------------------------------------
function luaY:removevars(ls, tolevel)
  local fs = ls.fs
  while fs.nactvar > tolevel do
    fs.nactvar = fs.nactvar - 1
    self:getlocvar(fs, fs.nactvar).endpc = fs.pc
  end
end

------------------------------------------------------------------------
-- returns an existing upvalue index based on the given name, or
-- creates a new upvalue struct entry and returns the new index
-- * used only in singlevaraux()
------------------------------------------------------------------------
function luaY:indexupvalue(fs, name, v)
  local f = fs.f
  for i = 0, f.nups - 1 do
    if fs.upvalues[i].k == v.k and fs.upvalues[i].info == v.info then
      assert(f.upvalues[i] == name)
      return i
    end
  end
  -- new one
  self:checklimit(fs, f.nups + 1, self.LUAI_MAXUPVALUES, "upvalues")
  self:growvector(fs.L, f.upvalues, f.nups, f.sizeupvalues,
                  nil, self.MAX_INT, "")
  -- loop to initialize empty f.upvalues positions not required
  f.upvalues[f.nups] = name
  -- luaC_objbarrier(fs->L, f, name); /* GC */
  assert(v.k == "VLOCAL" or v.k == "VUPVAL")
  -- this is a partial copy; only k & info fields used
  fs.upvalues[f.nups] = { k = v.k, info = v.info }
  local nups = f.nups
  f.nups = f.nups + 1
  return nups
end

------------------------------------------------------------------------
-- search the local variable namespace of the given fs for a match
-- * used only in singlevaraux()
------------------------------------------------------------------------
function luaY:searchvar(fs, n)
  n = genVarname(n)
  for i = fs.nactvar - 1, 0, -1 do
    if n == self:getlocvar(fs, i).varname then
      return i
    end
  end
  return -1  -- not found
end

------------------------------------------------------------------------
-- * mark upvalue flags in function states up to a given level
-- * used only in singlevaraux()
------------------------------------------------------------------------
function luaY:markupval(fs, level)
  local bl = fs.bl
  while bl and bl.nactvar > level do bl = bl.previous end
  if bl then bl.upval = true end
end

------------------------------------------------------------------------
-- handle locals, globals and upvalues and related processing
-- * search mechanism is recursive, calls itself to search parents
-- * used only in singlevar()
------------------------------------------------------------------------
function luaY:singlevaraux(fs, n, var, base)
  if fs == nil then  -- no more levels?
    self:init_exp(var, "VGLOBAL", luaP.NO_REG)  -- default is global variable
    return "VGLOBAL"
  else
    local v = self:searchvar(fs, n)  -- look up at current level
    if v >= 0 then
      self:init_exp(var, "VLOCAL", v)
      if base == 0 then
        self:markupval(fs, v)  -- local will be used as an upval
      end
      return "VLOCAL"
    else  -- not found at current level; try upper one
      if self:singlevaraux(fs.prev, n, var, 0) == "VGLOBAL" then
        return "VGLOBAL"
      end
      var.info = self:indexupvalue(fs, n, var)  -- else was LOCAL or UPVAL
      var.k = "VUPVAL"  -- upvalue in this level
      return "VUPVAL"
    end--if v
  end--if fs
end

------------------------------------------------------------------------
-- consume a name token, creates a variable (global|local|upvalue)
-- * used in prefixexp(), funcname()
------------------------------------------------------------------------
function luaY:singlevar(ls, var)
  local varname = self:str_checkname(ls)
  local fs = ls.fs
  if self:singlevaraux(fs, varname, var, 1) == "VGLOBAL" then
    var.info = luaK:stringK(fs, varname)  -- info points to global name
  end
end

------------------------------------------------------------------------
-- adjust RHS to match LHS in an assignment
-- * used in assignment(), forlist(), localstat()
------------------------------------------------------------------------
function luaY:adjust_assign(ls, nvars, nexps, e)
  local fs = ls.fs
  local extra = nvars - nexps
  if self:hasmultret(e.k) then
    extra = extra + 1  -- includes call itself
    if extra <= 0 then extra = 0 end
    luaK:setreturns(fs, e, extra)  -- last exp. provides the difference
    if extra > 1 then luaK:reserveregs(fs, extra - 1) end
  else
    if e.k ~= "VVOID" then luaK:exp2nextreg(fs, e) end  -- close last expression
    if extra > 0 then
      local reg = fs.freereg
      luaK:reserveregs(fs, extra)
      luaK:_nil(fs, reg, extra)
    end
  end
end

------------------------------------------------------------------------
-- tracks and limits parsing depth, assert check at end of parsing
------------------------------------------------------------------------
function luaY:enterlevel(ls)
  ls.L.nCcalls = ls.L.nCcalls + 1
  if ls.L.nCcalls > self.LUAI_MAXCCALLS then
    luaX:lexerror(ls, "chunk has too many syntax levels", 0)
  end
end

------------------------------------------------------------------------
-- tracks parsing depth, a pair with luaY:enterlevel()
------------------------------------------------------------------------
function luaY:leavelevel(ls)
  ls.L.nCcalls = ls.L.nCcalls - 1
end

------------------------------------------------------------------------
-- enters a code unit, initializes elements
------------------------------------------------------------------------
function luaY:enterblock(fs, bl, isbreakable)
  bl.breaklist = luaK.NO_JUMP
  bl.isbreakable = isbreakable
  bl.nactvar = fs.nactvar
  bl.upval = false
  bl.previous = fs.bl
  fs.bl = bl
  assert(fs.freereg == fs.nactvar)
end

------------------------------------------------------------------------
-- leaves a code unit, close any upvalues
------------------------------------------------------------------------
function luaY:leaveblock(fs)
  local bl = fs.bl
  fs.bl = bl.previous
  self:removevars(fs.ls, bl.nactvar)
  if bl.upval then
    luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
  end
  -- a block either controls scope or breaks (never both)
  assert(not bl.isbreakable or not bl.upval)
  assert(bl.nactvar == fs.nactvar)
  fs.freereg = fs.nactvar  -- free registers
  luaK:patchtohere(fs, bl.breaklist)
end

------------------------------------------------------------------------
-- implement the instantiation of a function prototype, append list of
-- upvalues after the instantiation instruction
-- * used only in body()
------------------------------------------------------------------------
function luaY:pushclosure(ls, func, v)
  local fs = ls.fs
  local f = fs.f
  self:growvector(ls.L, f.p, fs.np, f.sizep, nil,
                  luaP.MAXARG_Bx, "constant table overflow")
  -- loop to initialize empty f.p positions not required
  f.p[fs.np] = func.f
  fs.np = fs.np + 1
  -- luaC_objbarrier(ls->L, f, func->f); /* C */
  self:init_exp(v, "VRELOCABLE", luaK:codeABx(fs, "OP_CLOSURE", 0, fs.np - 1))
  for i = 0, func.f.nups - 1 do
    local o = (func.upvalues[i].k == "VLOCAL") and "OP_MOVE" or "OP_GETUPVAL"
    luaK:codeABC(fs, o, 0, func.upvalues[i].info, 0)
  end
end

------------------------------------------------------------------------
-- opening of a function
------------------------------------------------------------------------
function luaY:open_func(ls, fs)
  local L = ls.L
  local f = self:newproto(ls.L)
  fs.f = f
  fs.prev = ls.fs  -- linked list of funcstates
  fs.ls = ls
  fs.L = L
  ls.fs = fs
  fs.pc = 0
  fs.lasttarget = -1
  fs.jpc = luaK.NO_JUMP
  fs.freereg = 0
  fs.nk = 0
  fs.np = 0
  fs.nlocvars = 0
  fs.nactvar = 0
  fs.bl = nil
  f.source = ls.source
  f.maxstacksize = 2  -- registers 0/1 are always valid
  fs.h = {}  -- constant table; was luaH_new call
  -- anchor table of constants and prototype (to avoid being collected)
  -- sethvalue2s(L, L->top, fs->h); incr_top(L); /* C */
  -- setptvalue2s(L, L->top, f); incr_top(L);
end

------------------------------------------------------------------------
-- closing of a function
------------------------------------------------------------------------
function luaY:close_func(ls)
  local L = ls.L
  local fs = ls.fs
  local f = fs.f
  self:removevars(ls, 0)
  luaK:ret(fs, 0, 0)  -- final return
  -- luaM_reallocvector deleted for f->code, f->lineinfo, f->k, f->p,
  -- f->locvars, f->upvalues; not required for Lua table arrays
  f.sizecode = fs.pc
  f.sizelineinfo = fs.pc
  f.sizek = fs.nk
  f.sizep = fs.np
  f.sizelocvars = fs.nlocvars
  f.sizeupvalues = f.nups
  --assert(luaG_checkcode(f))  -- currently not implemented
  assert(fs.bl == nil)
  ls.fs = fs.prev
  -- the following is not required for this implementation; kept here
  -- for completeness
  -- L->top -= 2;  /* remove table and prototype from the stack */
  -- last token read was anchored in defunct function; must reanchor it
  if fs then self:anchor_token(ls) end
end

------------------------------------------------------------------------
-- parser initialization function
-- * note additional sub-tables needed for LexState, FuncState
------------------------------------------------------------------------
function luaY:parser(L, z, buff, name)
  local lexstate = {}  -- LexState
        lexstate.t = {}
        lexstate.lookahead = {}
  local funcstate = {}  -- FuncState
        funcstate.upvalues = {}
        funcstate.actvar = {}
  -- the following nCcalls initialization added for convenience
  L.nCcalls = 0
  lexstate.buff = buff
  luaX:setinput(L, lexstate, z, name)
  self:open_func(lexstate, funcstate)
  funcstate.f.is_vararg = self.VARARG_ISVARARG  -- main func. is always vararg
  luaX:next(lexstate)  -- read first token
  self:chunk(lexstate)
  self:check(lexstate, "TK_EOS")
  self:close_func(lexstate)
  assert(funcstate.prev == nil)
  assert(funcstate.f.nups == 0)
  assert(lexstate.fs == nil)
  return funcstate.f
end

--[[--------------------------------------------------------------------
-- GRAMMAR RULES
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- parse a function name suffix, for function call specifications
-- * used in primaryexp(), funcname()
------------------------------------------------------------------------
function luaY:field(ls, v)
  -- field -> ['.' | ':'] NAME
  local fs = ls.fs
  local key = {}  -- expdesc
  luaK:exp2anyreg(fs, v)
  luaX:next(ls)  -- skip the dot or colon
  self:checkname(ls, key)
  luaK:indexed(fs, v, key)
end

------------------------------------------------------------------------
-- parse a table indexing suffix, for constructors, expressions
-- * used in recfield(), primaryexp()
------------------------------------------------------------------------
function luaY:yindex(ls, v)
  -- index -> '[' expr ']'
  luaX:next(ls)  -- skip the '['
  self:expr(ls, v)
  luaK:exp2val(ls.fs, v)
  self:checknext(ls, "]")
end

--[[--------------------------------------------------------------------
-- Rules for Constructors
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- struct ConsControl:
--   v  -- last list item read (table: struct expdesc)
--   t  -- table descriptor (table: struct expdesc)
--   nh  -- total number of 'record' elements
--   na  -- total number of array elements
--   tostore  -- number of array elements pending to be stored
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- parse a table record (hash) field
-- * used in constructor()
------------------------------------------------------------------------
function luaY:recfield(ls, cc)
  -- recfield -> (NAME | '['exp1']') = exp1
  local fs = ls.fs
  local reg = ls.fs.freereg
  local key, val = {}, {}  -- expdesc
  if ls.t.token == "TK_NAME" then
    self:checklimit(fs, cc.nh, self.MAX_INT, "items in a constructor")
    self:checkname(ls, key)
  else  -- ls->t.token == '['
    self:yindex(ls, key)
  end
  cc.nh = cc.nh + 1
  self:checknext(ls, "=")
  local rkkey = luaK:exp2RK(fs, key)
  self:expr(ls, val)
  luaK:codeABC(fs, "OP_SETTABLE", cc.t.info, rkkey, luaK:exp2RK(fs, val))
  fs.freereg = reg  -- free registers
end

------------------------------------------------------------------------
-- emit a set list instruction if enough elements (LFIELDS_PER_FLUSH)
-- * used in constructor()
------------------------------------------------------------------------
function luaY:closelistfield(fs, cc)
  if cc.v.k == "VVOID" then return end  -- there is no list item
  luaK:exp2nextreg(fs, cc.v)
  cc.v.k = "VVOID"
  if cc.tostore == luaP.LFIELDS_PER_FLUSH then
    luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)  -- flush
    cc.tostore = 0  -- no more items pending
  end
end

------------------------------------------------------------------------
-- emit a set list instruction at the end of parsing list constructor
-- * used in constructor()
------------------------------------------------------------------------
function luaY:lastlistfield(fs, cc)
  if cc.tostore == 0 then return end
  if self:hasmultret(cc.v.k) then
    luaK:setmultret(fs, cc.v)
    luaK:setlist(fs, cc.t.info, cc.na, self.LUA_MULTRET)
    cc.na = cc.na - 1  -- do not count last expression (unknown number of elements)
  else
    if cc.v.k ~= "VVOID" then
      luaK:exp2nextreg(fs, cc.v)
    end
    luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
  end
end

------------------------------------------------------------------------
-- parse a table list (array) field
-- * used in constructor()
------------------------------------------------------------------------
function luaY:listfield(ls, cc)
  self:expr(ls, cc.v)
  self:checklimit(ls.fs, cc.na, self.MAX_INT, "items in a constructor")
  cc.na = cc.na + 1
  cc.tostore = cc.tostore + 1
end

------------------------------------------------------------------------
-- parse a table constructor
-- * used in funcargs(), simpleexp()
------------------------------------------------------------------------
function luaY:constructor(ls, t)
  -- constructor -> '{' [ field { fieldsep field } [ fieldsep ] ] '}'
  -- field -> recfield | listfield
  -- fieldsep -> ',' | ';'
  local fs = ls.fs
  local line = ls.linenumber
  local pc = luaK:codeABC(fs, "OP_NEWTABLE", 0, 0, 0)
  local cc = {}  -- ConsControl
        cc.v = {}
  cc.na, cc.nh, cc.tostore = 0, 0, 0
  cc.t = t
  self:init_exp(t, "VRELOCABLE", pc)
  self:init_exp(cc.v, "VVOID", 0)  -- no value (yet)
  luaK:exp2nextreg(ls.fs, t)  -- fix it at stack top (for gc)
  self:checknext(ls, "{")
  repeat
    assert(cc.v.k == "VVOID" or cc.tostore > 0)
    if ls.t.token == "}" then break end
    self:closelistfield(fs, cc)
    local c = ls.t.token

    if c == "TK_NAME" then  -- may be listfields or recfields
      luaX:lookahead(ls)
      if ls.lookahead.token ~= "=" then  -- expression?
        self:listfield(ls, cc)
      else
        self:recfield(ls, cc)
      end
    elseif c == "[" then  -- constructor_item -> recfield
      self:recfield(ls, cc)
    else  -- constructor_part -> listfield
      self:listfield(ls, cc)
    end
  until not self:testnext(ls, ",") and not self:testnext(ls, ";")
  self:check_match(ls, "}", "{", line)
  self:lastlistfield(fs, cc)
  luaP:SETARG_B(fs.f.code[pc], self:int2fb(cc.na)) -- set initial array size
  luaP:SETARG_C(fs.f.code[pc], self:int2fb(cc.nh)) -- set initial table size
end

-- }======================================================================

------------------------------------------------------------------------
-- parse the arguments (parameters) of a function declaration
-- * used in body()
------------------------------------------------------------------------
function luaY:parlist(ls)
  -- parlist -> [ param { ',' param } ]
  local fs = ls.fs
  local f = fs.f
  local nparams = 0
  f.is_vararg = 0
  if ls.t.token ~= ")" then  -- is 'parlist' not empty?
    repeat
      local c = ls.t.token
      if c == "TK_NAME" then  -- param -> NAME
        self:new_localvar(ls, self:str_checkname(ls), nparams)
        nparams = nparams + 1
      elseif c == "TK_DOTS" then  -- param -> `...'
        luaX:next(ls)
-- [[
-- #if defined(LUA_COMPAT_VARARG)
        -- use `arg' as default name
        self:new_localvarliteral(ls, "arg", nparams)
        nparams = nparams + 1
        f.is_vararg = self.VARARG_HASARG + self.VARARG_NEEDSARG
-- #endif
--]]
        f.is_vararg = f.is_vararg + self.VARARG_ISVARARG
      else
        luaX:syntaxerror(ls, "<name> or "..self:LUA_QL("...").." expected")
      end
    until f.is_vararg ~= 0 or not self:testnext(ls, ",")
  end--if
  self:adjustlocalvars(ls, nparams)
  -- NOTE: the following works only when HASARG_MASK is 2!
  f.numparams = fs.nactvar - (f.is_vararg % self.HASARG_MASK)
  luaK:reserveregs(fs, fs.nactvar)  -- reserve register for parameters
end

------------------------------------------------------------------------
-- parse function declaration body
-- * used in simpleexp(), localfunc(), funcstat()
------------------------------------------------------------------------
function luaY:body(ls, e, needself, line)
  -- body ->  '(' parlist ')' chunk END
  local new_fs = {}  -- FuncState
        new_fs.upvalues = {}
        new_fs.actvar = {}
  self:open_func(ls, new_fs)
  new_fs.f.lineDefined = line
  self:checknext(ls, "(")
  if needself then
    self:new_localvarliteral(ls, "self", 0)
    self:adjustlocalvars(ls, 1)
  end
  self:parlist(ls)
  self:checknext(ls, ")")
  self:chunk(ls)
  new_fs.f.lastlinedefined = ls.linenumber
  self:check_match(ls, "TK_END", "TK_FUNCTION", line)
  self:close_func(ls)
  self:pushclosure(ls, new_fs, e)
end

------------------------------------------------------------------------
-- parse a list of comma-separated expressions
-- * used is multiple locations
------------------------------------------------------------------------
function luaY:explist1(ls, v)
  -- explist1 -> expr { ',' expr }
  local n = 1  -- at least one expression
  self:expr(ls, v)
  while self:testnext(ls, ",") do
    luaK:exp2nextreg(ls.fs, v)
    self:expr(ls, v)
    n = n + 1
  end
  return n
end

------------------------------------------------------------------------
-- parse the parameters of a function call
-- * contrast with parlist(), used in function declarations
-- * used in primaryexp()
------------------------------------------------------------------------
function luaY:funcargs(ls, f)
  local fs = ls.fs
  local args = {}  -- expdesc
  local nparams
  local line = ls.linenumber
  local c = ls.t.token
  if c == "(" then  -- funcargs -> '(' [ explist1 ] ')'
    if line ~= ls.lastline then
      luaX:syntaxerror(ls, "ambiguous syntax (function call x new statement)")
    end
    luaX:next(ls)
    if ls.t.token == ")" then  -- arg list is empty?
      args.k = "VVOID"
    else
      self:explist1(ls, args)
      luaK:setmultret(fs, args)
    end
    self:check_match(ls, ")", "(", line)
  elseif c == "{" then  -- funcargs -> constructor
    self:constructor(ls, args)
  elseif c == "TK_STRING" then  -- funcargs -> STRING
    self:codestring(ls, args, ls.t.seminfo)
    luaX:next(ls)  -- must use 'seminfo' before 'next'
  else
    luaX:syntaxerror(ls, "function arguments expected")
    return
  end
  assert(f.k == "VNONRELOC")
  local base = f.info  -- base register for call
  if self:hasmultret(args.k) then
    nparams = self.LUA_MULTRET  -- open call
  else
    if args.k ~= "VVOID" then
      luaK:exp2nextreg(fs, args)  -- close last argument
    end
    nparams = fs.freereg - (base + 1)
  end
  self:init_exp(f, "VCALL", luaK:codeABC(fs, "OP_CALL", base, nparams + 1, 2))
  luaK:fixline(fs, line)
  fs.freereg = base + 1  -- call remove function and arguments and leaves
                         -- (unless changed) one result
end

--[[--------------------------------------------------------------------
-- Expression parsing
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- parses an expression in parentheses or a single variable
-- * used in primaryexp()
------------------------------------------------------------------------
function luaY:prefixexp(ls, v)
  -- prefixexp -> NAME | '(' expr ')'
  local c = ls.t.token
  if c == "(" then
    local line = ls.linenumber
    luaX:next(ls)
    self:expr(ls, v)
    self:check_match(ls, ")", "(", line)
    luaK:dischargevars(ls.fs, v)
  elseif c == "TK_NAME" then
    self:singlevar(ls, v)
  else
    luaX:syntaxerror(ls, "unexpected symbol")
  end--if c
  return
end

------------------------------------------------------------------------
-- parses a prefixexp (an expression in parentheses or a single variable)
-- or a function call specification
-- * used in simpleexp(), assignment(), exprstat()
------------------------------------------------------------------------
function luaY:primaryexp(ls, v)
  -- primaryexp ->
  --    prefixexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs }
  local fs = ls.fs
  self:prefixexp(ls, v)
  while true do
    local c = ls.t.token
    if c == "." then  -- field
      self:field(ls, v)
    elseif c == "[" then  -- '[' exp1 ']'
      local key = {}  -- expdesc
      luaK:exp2anyreg(fs, v)
      self:yindex(ls, key)
      luaK:indexed(fs, v, key)
    elseif c == ":" then  -- ':' NAME funcargs
      local key = {}  -- expdesc
      luaX:next(ls)
      self:checkname(ls, key)
      luaK:_self(fs, v, key)
      self:funcargs(ls, v)
    elseif c == "(" or c == "TK_STRING" or c == "{" then  -- funcargs
      luaK:exp2nextreg(fs, v)
      self:funcargs(ls, v)
    else
      return
    end--if c
  end--while
end

------------------------------------------------------------------------
-- parses general expression types, constants handled here
-- * used in subexpr()
------------------------------------------------------------------------
function luaY:simpleexp(ls, v)
  -- simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | ... |
  --              constructor | FUNCTION body | primaryexp
  local c = ls.t.token
  if c == "TK_NUMBER" then
    self:init_exp(v, "VKNUM", 0)
    v.nval = ls.t.seminfo
  elseif c == "TK_STRING" then
    self:codestring(ls, v, ls.t.seminfo)
  elseif c == "TK_NIL" then
    self:init_exp(v, "VNIL", 0)
  elseif c == "TK_TRUE" then
    self:init_exp(v, "VTRUE", 0)
  elseif c == "TK_FALSE" then
    self:init_exp(v, "VFALSE", 0)
  elseif c == "TK_DOTS" then  -- vararg
    local fs = ls.fs
    self:check_condition(ls, fs.f.is_vararg ~= 0,
                    "cannot use "..self:LUA_QL("...").." outside a vararg function");
    -- NOTE: the following substitutes for a bitop, but is value-specific
    local is_vararg = fs.f.is_vararg
    if is_vararg >= self.VARARG_NEEDSARG then
      fs.f.is_vararg = is_vararg - self.VARARG_NEEDSARG  -- don't need 'arg'
    end
    self:init_exp(v, "VVARARG", luaK:codeABC(fs, "OP_VARARG", 0, 1, 0))
  elseif c == "{" then  -- constructor
    self:constructor(ls, v)
    return
  elseif c == "TK_FUNCTION" then
    luaX:next(ls)
    self:body(ls, v, false, ls.linenumber)
    return
  else
    self:primaryexp(ls, v)
    return
  end--if c
  luaX:next(ls)
end

------------------------------------------------------------------------
-- Translates unary operators tokens if found, otherwise returns
-- OPR_NOUNOPR. getunopr() and getbinopr() are used in subexpr().
-- * used in subexpr()
------------------------------------------------------------------------
function luaY:getunopr(op)
  if op == "TK_NOT" then
    return "OPR_NOT"
  elseif op == "-" then
    return "OPR_MINUS"
  elseif op == "#" then
    return "OPR_LEN"
  else
    return "OPR_NOUNOPR"
  end
end

------------------------------------------------------------------------
-- Translates binary operator tokens if found, otherwise returns
-- OPR_NOBINOPR. Code generation uses OPR_* style tokens.
-- * used in subexpr()
------------------------------------------------------------------------
luaY.getbinopr_table = {
  ["+"] = "OPR_ADD",
  ["-"] = "OPR_SUB",
  ["*"] = "OPR_MUL",
  ["/"] = "OPR_DIV",
  ["%"] = "OPR_MOD",
  ["^"] = "OPR_POW",
  ["TK_CONCAT"] = "OPR_CONCAT",
  ["TK_NE"] = "OPR_NE",
  ["TK_EQ"] = "OPR_EQ",
  ["<"] = "OPR_LT",
  ["TK_LE"] = "OPR_LE",
  [">"] = "OPR_GT",
  ["TK_GE"] = "OPR_GE",
  ["TK_AND"] = "OPR_AND",
  ["TK_OR"] = "OPR_OR",
}
function luaY:getbinopr(op)
  local opr = self.getbinopr_table[op]
  if opr then return opr else return "OPR_NOBINOPR" end
end

------------------------------------------------------------------------
-- the following priority table consists of pairs of left/right values
-- for binary operators (was a static const struct); grep for ORDER OPR
-- * the following struct is replaced:
--   static const struct {
--     lu_byte left;  /* left priority for each binary operator */
--     lu_byte right; /* right priority */
--   } priority[] = {  /* ORDER OPR */
------------------------------------------------------------------------
luaY.priority = {
  {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7}, -- `+' `-' `/' `%'
  {10, 9}, {5, 4},                 -- power and concat (right associative)
  {3, 3}, {3, 3},                  -- equality
  {3, 3}, {3, 3}, {3, 3}, {3, 3},  -- order
  {2, 2}, {1, 1}                   -- logical (and/or)
}

luaY.UNARY_PRIORITY = 8  -- priority for unary operators

------------------------------------------------------------------------
-- Parse subexpressions. Includes handling of unary operators and binary
-- operators. A subexpr is given the rhs priority level of the operator
-- immediately left of it, if any (limit is -1 if none,) and if a binop
-- is found, limit is compared with the lhs priority level of the binop
-- in order to determine which executes first.
------------------------------------------------------------------------

------------------------------------------------------------------------
-- subexpr -> (simpleexp | unop subexpr) { binop subexpr }
-- where 'binop' is any binary operator with a priority higher than 'limit'
-- * for priority lookups with self.priority[], 1=left and 2=right
-- * recursively called
-- * used in expr()
------------------------------------------------------------------------
function luaY:subexpr(ls, v, limit)
  self:enterlevel(ls)
  local uop = self:getunopr(ls.t.token)
  if uop ~= "OPR_NOUNOPR" then
    luaX:next(ls)
    self:subexpr(ls, v, self.UNARY_PRIORITY)
    luaK:prefix(ls.fs, uop, v)
  else
    self:simpleexp(ls, v)
  end
  -- expand while operators have priorities higher than 'limit'
  local op = self:getbinopr(ls.t.token)
  while op ~= "OPR_NOBINOPR" and self.priority[luaK.BinOpr[op] + 1][1] > limit do
    local v2 = {}  -- expdesc
    luaX:next(ls)
    luaK:infix(ls.fs, op, v)
    -- read sub-expression with higher priority
    local nextop = self:subexpr(ls, v2, self.priority[luaK.BinOpr[op] + 1][2])
    luaK:posfix(ls.fs, op, v, v2)
    op = nextop
  end
  self:leavelevel(ls)
  return op  -- return first untreated operator
end

------------------------------------------------------------------------
-- Expression parsing starts here. Function subexpr is entered with the
-- left operator (which is non-existent) priority of -1, which is lower
-- than all actual operators. Expr information is returned in parm v.
-- * used in multiple locations
------------------------------------------------------------------------
function luaY:expr(ls, v)
  self:subexpr(ls, v, 0)
end

-- }====================================================================

--[[--------------------------------------------------------------------
-- Rules for Statements
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- checks next token, used as a look-ahead
-- * returns boolean instead of 0|1
-- * used in retstat(), chunk()
------------------------------------------------------------------------
function luaY:block_follow(token)
  if token == "TK_ELSE" or token == "TK_ELSEIF" or token == "TK_END"
     or token == "TK_UNTIL" or token == "TK_EOS" then
    return true
  else
    return false
  end
end

------------------------------------------------------------------------
-- parse a code block or unit
-- * used in multiple functions
------------------------------------------------------------------------
function luaY:block(ls)
  -- block -> chunk
  local fs = ls.fs
  local bl = {}  -- BlockCnt
  self:enterblock(fs, bl, false)
  self:chunk(ls)
  assert(bl.breaklist == luaK.NO_JUMP)
  self:leaveblock(fs)
end

------------------------------------------------------------------------
-- structure to chain all variables in the left-hand side of an
-- assignment
-- struct LHS_assign:
--   prev  -- (table: struct LHS_assign)
--   v  -- variable (global, local, upvalue, or indexed) (table: expdesc)
------------------------------------------------------------------------

------------------------------------------------------------------------
-- check whether, in an assignment to a local variable, the local variable
-- is needed in a previous assignment (to a table). If so, save original
-- local value in a safe place and use this safe copy in the previous
-- assignment.
-- * used in assignment()
------------------------------------------------------------------------
function luaY:check_conflict(ls, lh, v)
  local fs = ls.fs
  local extra = fs.freereg  -- eventual position to save local variable
  local conflict = false
  while lh do
    if lh.v.k == "VINDEXED" then
      if lh.v.info == v.info then  -- conflict?
        conflict = true
        lh.v.info = extra  -- previous assignment will use safe copy
      end
      if lh.v.aux == v.info then  -- conflict?
        conflict = true
        lh.v.aux = extra  -- previous assignment will use safe copy
      end
    end
    lh = lh.prev
  end
  if conflict then
    luaK:codeABC(fs, "OP_MOVE", fs.freereg, v.info, 0)  -- make copy
    luaK:reserveregs(fs, 1)
  end
end

------------------------------------------------------------------------
-- parse a variable assignment sequence
-- * recursively called
-- * used in exprstat()
------------------------------------------------------------------------
function luaY:assignment(ls, lh, nvars)
  local e = {}  -- expdesc
  -- test was: VLOCAL <= lh->v.k && lh->v.k <= VINDEXED
  local c = lh.v.k
  self:check_condition(ls, c == "VLOCAL" or c == "VUPVAL" or c == "VGLOBAL"
                       or c == "VINDEXED", "syntax error")
  if self:testnext(ls, ",") then  -- assignment -> ',' primaryexp assignment
    local nv = {}  -- LHS_assign
          nv.v = {}
    nv.prev = lh
    self:primaryexp(ls, nv.v)
    if nv.v.k == "VLOCAL" then
      self:check_conflict(ls, lh, nv.v)
    end
    self:checklimit(ls.fs, nvars, self.LUAI_MAXCCALLS - ls.L.nCcalls,
                    "variables in assignment")
    self:assignment(ls, nv, nvars + 1)
  else  -- assignment -> '=' explist1
    self:checknext(ls, "=")
    local nexps = self:explist1(ls, e)
    if nexps ~= nvars then
      self:adjust_assign(ls, nvars, nexps, e)
      if nexps > nvars then
        ls.fs.freereg = ls.fs.freereg - (nexps - nvars)  -- remove extra values
      end
    else
      luaK:setoneret(ls.fs, e)  -- close last expression
      luaK:storevar(ls.fs, lh.v, e)
      return  -- avoid default
    end
  end
  self:init_exp(e, "VNONRELOC", ls.fs.freereg - 1)  -- default assignment
  luaK:storevar(ls.fs, lh.v, e)
end

------------------------------------------------------------------------
-- parse condition in a repeat statement or an if control structure
-- * used in repeatstat(), test_then_block()
------------------------------------------------------------------------
function luaY:cond(ls)
  -- cond -> exp
  local v = {}  -- expdesc
  self:expr(ls, v)  -- read condition
  if v.k == "VNIL" then v.k = "VFALSE" end  -- 'falses' are all equal here
  luaK:goiftrue(ls.fs, v)
  return v.f
end

------------------------------------------------------------------------
-- parse a break statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:breakstat(ls)
  -- stat -> BREAK
  local fs = ls.fs
  local bl = fs.bl
  local upval = false
  while bl and not bl.isbreakable do
    if bl.upval then upval = true end
    bl = bl.previous
  end
  if not bl then
    luaX:syntaxerror(ls, "no loop to break")
  end
  if upval then
    luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
  end
  bl.breaklist = luaK:concat(fs, bl.breaklist, luaK:jump(fs))
end

------------------------------------------------------------------------
-- parse a while-do control structure, body processed by block()
-- * with dynamic array sizes, MAXEXPWHILE + EXTRAEXP limits imposed by
--   the function's implementation can be removed
-- * used in statements()
------------------------------------------------------------------------
function luaY:whilestat(ls, line)
  -- whilestat -> WHILE cond DO block END
  local fs = ls.fs
  local bl = {}  -- BlockCnt
  luaX:next(ls)  -- skip WHILE
  local whileinit = luaK:getlabel(fs)
  local condexit = self:cond(ls)
  self:enterblock(fs, bl, true)
  self:checknext(ls, "TK_DO")
  self:block(ls)
  luaK:patchlist(fs, luaK:jump(fs), whileinit)
  self:check_match(ls, "TK_END", "TK_WHILE", line)
  self:leaveblock(fs)
  luaK:patchtohere(fs, condexit)  -- false conditions finish the loop
end

------------------------------------------------------------------------
-- parse a repeat-until control structure, body parsed by chunk()
-- * used in statements()
------------------------------------------------------------------------
function luaY:repeatstat(ls, line)
  -- repeatstat -> REPEAT block UNTIL cond
  local fs = ls.fs
  local repeat_init = luaK:getlabel(fs)
  local bl1, bl2 = {}, {}  -- BlockCnt
  self:enterblock(fs, bl1, true)  -- loop block
  self:enterblock(fs, bl2, false)  -- scope block
  luaX:next(ls)  -- skip REPEAT
  self:chunk(ls)
  self:check_match(ls, "TK_UNTIL", "TK_REPEAT", line)
  local condexit = self:cond(ls)  -- read condition (inside scope block)
  if not bl2.upval then  -- no upvalues?
    self:leaveblock(fs)  -- finish scope
    luaK:patchlist(ls.fs, condexit, repeat_init)  -- close the loop
  else  -- complete semantics when there are upvalues
    self:breakstat(ls)  -- if condition then break
    luaK:patchtohere(ls.fs, condexit)  -- else...
    self:leaveblock(fs)  -- finish scope...
    luaK:patchlist(ls.fs, luaK:jump(fs), repeat_init)  -- and repeat
  end
  self:leaveblock(fs)  -- finish loop
end

------------------------------------------------------------------------
-- parse the single expressions needed in numerical for loops
-- * used in fornum()
------------------------------------------------------------------------
function luaY:exp1(ls)
  local e = {}  -- expdesc
  self:expr(ls, e)
  local k = e.k
  luaK:exp2nextreg(ls.fs, e)
  return k
end

------------------------------------------------------------------------
-- parse a for loop body for both versions of the for loop
-- * used in fornum(), forlist()
------------------------------------------------------------------------
function luaY:forbody(ls, base, line, nvars, isnum)
  -- forbody -> DO block
  local bl = {}  -- BlockCnt
  local fs = ls.fs
  self:adjustlocalvars(ls, 3)  -- control variables
  self:checknext(ls, "TK_DO")
  local prep = isnum and luaK:codeAsBx(fs, "OP_FORPREP", base, luaK.NO_JUMP)
                     or luaK:jump(fs)
  self:enterblock(fs, bl, false)  -- scope for declared variables
  self:adjustlocalvars(ls, nvars)
  luaK:reserveregs(fs, nvars)
  self:block(ls)
  self:leaveblock(fs)  -- end of scope for declared variables
  luaK:patchtohere(fs, prep)
  local endfor = isnum and luaK:codeAsBx(fs, "OP_FORLOOP", base, luaK.NO_JUMP)
                       or luaK:codeABC(fs, "OP_TFORLOOP", base, 0, nvars)
  luaK:fixline(fs, line)  -- pretend that `OP_FOR' starts the loop
  luaK:patchlist(fs, isnum and endfor or luaK:jump(fs), prep + 1)
end

------------------------------------------------------------------------
-- parse a numerical for loop, calls forbody()
-- * used in forstat()
------------------------------------------------------------------------
function luaY:fornum(ls, varname, line)
  -- fornum -> NAME = exp1,exp1[,exp1] forbody
  local fs = ls.fs
  local base = fs.freereg
  self:new_localvarliteral(ls, "(for index)", 0)
  self:new_localvarliteral(ls, "(for limit)", 1)
  self:new_localvarliteral(ls, "(for step)", 2)
  self:new_localvar(ls, varname, 3)
  self:checknext(ls, '=')
  self:exp1(ls)  -- initial value
  self:checknext(ls, ",")
  self:exp1(ls)  -- limit
  if self:testnext(ls, ",") then
    self:exp1(ls)  -- optional step
  else  -- default step = 1
    luaK:codeABx(fs, "OP_LOADK", fs.freereg, luaK:numberK(fs, 1))
    luaK:reserveregs(fs, 1)
  end
  self:forbody(ls, base, line, 1, true)
end

------------------------------------------------------------------------
-- parse a generic for loop, calls forbody()
-- * used in forstat()
------------------------------------------------------------------------
function luaY:forlist(ls, indexname)
  -- forlist -> NAME {,NAME} IN explist1 forbody
  local fs = ls.fs
  local e = {}  -- expdesc
  local nvars = 0
  local base = fs.freereg
  -- create control variables
  self:new_localvarliteral(ls, "(for generator)", nvars)
  nvars = nvars + 1
  self:new_localvarliteral(ls, "(for state)", nvars)
  nvars = nvars + 1
  self:new_localvarliteral(ls, "(for control)", nvars)
  nvars = nvars + 1
  -- create declared variables
  self:new_localvar(ls, indexname, nvars)
  nvars = nvars + 1
  while self:testnext(ls, ",") do
    self:new_localvar(ls, self:str_checkname(ls), nvars)
    nvars = nvars + 1
  end
  self:checknext(ls, "TK_IN")
  local line = ls.linenumber
  self:adjust_assign(ls, 3, self:explist1(ls, e), e)
  luaK:checkstack(fs, 3)  -- extra space to call generator
  self:forbody(ls, base, line, nvars - 3, false)
end

------------------------------------------------------------------------
-- initial parsing for a for loop, calls fornum() or forlist()
-- * used in statements()
------------------------------------------------------------------------
function luaY:forstat(ls, line)
  -- forstat -> FOR (fornum | forlist) END
  local fs = ls.fs
  local bl = {}  -- BlockCnt
  self:enterblock(fs, bl, true)  -- scope for loop and control variables
  luaX:next(ls)  -- skip `for'
  local varname = self:str_checkname(ls)  -- first variable name
  local c = ls.t.token
  if c == "=" then
    self:fornum(ls, varname, line)
  elseif c == "," or c == "TK_IN" then
    self:forlist(ls, varname)
  else
    luaX:syntaxerror(ls, self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")
  end
  self:check_match(ls, "TK_END", "TK_FOR", line)
  self:leaveblock(fs)  -- loop scope (`break' jumps to this point)
end

------------------------------------------------------------------------
-- parse part of an if control structure, including the condition
-- * used in ifstat()
------------------------------------------------------------------------
function luaY:test_then_block(ls)
  -- test_then_block -> [IF | ELSEIF] cond THEN block
  luaX:next(ls)  -- skip IF or ELSEIF
  local condexit = self:cond(ls)
  self:checknext(ls, "TK_THEN")
  self:block(ls)  -- `then' part
  return condexit
end

------------------------------------------------------------------------
-- parse an if control structure
-- * used in statements()
------------------------------------------------------------------------
function luaY:ifstat(ls, line)
  -- ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
  local fs = ls.fs
  local escapelist = luaK.NO_JUMP
  local flist = self:test_then_block(ls)  -- IF cond THEN block
  while ls.t.token == "TK_ELSEIF" do
    escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
    luaK:patchtohere(fs, flist)
    flist = self:test_then_block(ls)  -- ELSEIF cond THEN block
  end
  if ls.t.token == "TK_ELSE" then
    escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
    luaK:patchtohere(fs, flist)
    luaX:next(ls)  -- skip ELSE (after patch, for correct line info)
    self:block(ls)  -- 'else' part
  else
    escapelist = luaK:concat(fs, escapelist, flist)
  end
  luaK:patchtohere(fs, escapelist)
  self:check_match(ls, "TK_END", "TK_IF", line)
end

------------------------------------------------------------------------
-- parse a local function statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:localfunc(ls)
  local v, b = {}, {}  -- expdesc
  local fs = ls.fs
  self:new_localvar(ls, self:str_checkname(ls), 0)
  self:init_exp(v, "VLOCAL", fs.freereg)
  luaK:reserveregs(fs, 1)
  self:adjustlocalvars(ls, 1)
  self:body(ls, b, false, ls.linenumber)
  luaK:storevar(fs, v, b)
  -- debug information will only see the variable after this point!
  self:getlocvar(fs, fs.nactvar - 1).startpc = fs.pc
end

------------------------------------------------------------------------
-- parse a local variable declaration statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:localstat(ls)
  -- stat -> LOCAL NAME {',' NAME} ['=' explist1]
  local nvars = 0
  local nexps
  local e = {}  -- expdesc
  repeat
    self:new_localvar(ls, self:str_checkname(ls), nvars)
    nvars = nvars + 1
  until not self:testnext(ls, ",")
  if self:testnext(ls, "=") then
    nexps = self:explist1(ls, e)
  else
    e.k = "VVOID"
    nexps = 0
  end
  self:adjust_assign(ls, nvars, nexps, e)
  self:adjustlocalvars(ls, nvars)
end

------------------------------------------------------------------------
-- parse a function name specification
-- * used in funcstat()
------------------------------------------------------------------------
function luaY:funcname(ls, v)
  -- funcname -> NAME {field} [':' NAME]
  local needself = false
  self:singlevar(ls, v)
  while ls.t.token == "." do
    self:field(ls, v)
  end
  if ls.t.token == ":" then
    needself = true
    self:field(ls, v)
  end
  return needself
end

------------------------------------------------------------------------
-- parse a function statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:funcstat(ls, line)
  -- funcstat -> FUNCTION funcname body
  local v, b = {}, {}  -- expdesc
  luaX:next(ls)  -- skip FUNCTION
  local needself = self:funcname(ls, v)
  self:body(ls, b, needself, line)
  luaK:storevar(ls.fs, v, b)
  luaK:fixline(ls.fs, line)  -- definition 'happens' in the first line
end

------------------------------------------------------------------------
-- parse a function call with no returns or an assignment statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:exprstat(ls)
  -- stat -> func | assignment
  local fs = ls.fs
  local v = {}  -- LHS_assign
        v.v = {}
  self:primaryexp(ls, v.v)
  if v.v.k == "VCALL" then  -- stat -> func
    luaP:SETARG_C(luaK:getcode(fs, v.v), 1)  -- call statement uses no results
  else  -- stat -> assignment
    v.prev = nil
    self:assignment(ls, v, 1)
  end
end

------------------------------------------------------------------------
-- parse a return statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:retstat(ls)
  -- stat -> RETURN explist
  local fs = ls.fs
  local e = {}  -- expdesc
  local first, nret  -- registers with returned values
  luaX:next(ls)  -- skip RETURN
  if self:block_follow(ls.t.token) or ls.t.token == ";" then
    first, nret = 0, 0  -- return no values
  else
    nret = self:explist1(ls, e)  -- optional return values
    if self:hasmultret(e.k) then
      luaK:setmultret(fs, e)
      if e.k == "VCALL" and nret == 1 then  -- tail call?
        luaP:SET_OPCODE(luaK:getcode(fs, e), "OP_TAILCALL")
        assert(luaP:GETARG_A(luaK:getcode(fs, e)) == fs.nactvar)
      end
      first = fs.nactvar
      nret = self.LUA_MULTRET  -- return all values
    else
      if nret == 1 then  -- only one single value?
        first = luaK:exp2anyreg(fs, e)
      else
        luaK:exp2nextreg(fs, e)  -- values must go to the 'stack'
        first = fs.nactvar  -- return all 'active' values
        assert(nret == fs.freereg - first)
      end
    end--if
  end--if
  luaK:ret(fs, first, nret)
end

------------------------------------------------------------------------
-- initial parsing for statements, calls a lot of functions
-- * returns boolean instead of 0|1
-- * used in chunk()
------------------------------------------------------------------------
function luaY:statement(ls)
  local line = ls.linenumber  -- may be needed for error messages
  local c = ls.t.token
  if c == "TK_IF" then  -- stat -> ifstat
    self:ifstat(ls, line)
    return false
  elseif c == "TK_WHILE" then  -- stat -> whilestat
    self:whilestat(ls, line)
    return false
  elseif c == "TK_DO" then  -- stat -> DO block END
    luaX:next(ls)  -- skip DO
    self:block(ls)
    self:check_match(ls, "TK_END", "TK_DO", line)
    return false
  elseif c == "TK_FOR" then  -- stat -> forstat
    self:forstat(ls, line)
    return false
  elseif c == "TK_REPEAT" then  -- stat -> repeatstat
    self:repeatstat(ls, line)
    return false
  elseif c == "TK_FUNCTION" then  -- stat -> funcstat
    self:funcstat(ls, line)
    return false
  elseif c == "TK_LOCAL" then  -- stat -> localstat
    luaX:next(ls)  -- skip LOCAL
    if self:testnext(ls, "TK_FUNCTION") then  -- local function?
      self:localfunc(ls)
    else
      self:localstat(ls)
    end
    return false
  elseif c == "TK_RETURN" then  -- stat -> retstat
    self:retstat(ls)
    return true  -- must be last statement
  elseif c == "TK_BREAK" then  -- stat -> breakstat
    luaX:next(ls)  -- skip BREAK
    self:breakstat(ls)
    return true  -- must be last statement
  else
    self:exprstat(ls)
    return false  -- to avoid warnings
  end--if c
end

------------------------------------------------------------------------
-- parse a chunk, which consists of a bunch of statements
-- * used in parser(), body(), block(), repeatstat()
------------------------------------------------------------------------
function luaY:chunk(ls)
  -- chunk -> { stat [';'] }
  local islast = false
  self:enterlevel(ls)
  while not islast and not self:block_follow(ls.t.token) do
    islast = self:statement(ls)
    self:testnext(ls, ";")
    assert(ls.fs.f.maxstacksize >= ls.fs.freereg and
               ls.fs.freereg >= ls.fs.nactvar)
    ls.fs.freereg = ls.fs.nactvar  -- free registers
  end
  self:leavelevel(ls)
end

-- }======================================================================
luaY.initObfuscator = initObfuscator
_G.encryptVM_compile.luaY = luaY
end
function scmframework_48e56bd65d74e0c7182fe75d70056002() --$CONTENT_DATA/Scripts/encryptVM/compile/LuaZ.lua
--[[--------------------------------------------------------------------

  lzio.lua
  Lua buffered streams in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * EOZ is implemented as a string, "EOZ"
-- * Format of z structure (ZIO)
--     z.n       -- bytes still unread
--     z.p       -- last read position position in buffer
--     z.reader  -- chunk reader function
--     z.data    -- additional data
-- * Current position, p, is now last read index instead of a pointer
--
-- Not implemented:
-- * luaZ_lookahead: used only in lapi.c:lua_load to detect binary chunk
-- * luaZ_read: used only in lundump.c:ezread to read +1 bytes
-- * luaZ_openspace: dropped; let Lua handle buffers as strings (used in
--   lundump.c:LoadString & lvm.c:luaV_concat)
-- * luaZ buffer macros: dropped; buffers are handled as strings
-- * lauxlib.c:getF reader implementation has an extraline flag to
--   skip over a shbang (#!) line, this is not implemented here
--
-- Added:
-- (both of the following are vaguely adapted from lauxlib.c)
-- * luaZ:make_getS: create Reader from a string
-- * luaZ:make_getF: create Reader that reads from a file
--
-- Changed in 5.1.x:
-- * Chunkreader renamed to Reader (ditto with Chunkwriter)
-- * Zio struct: no more name string, added Lua state for reader
--   (however, Yueliang readers do not require a Lua state)
----------------------------------------------------------------------]]

local luaZ = {}

------------------------------------------------------------------------
-- * reader() should return a string, or nil if nothing else to parse.
--   Additional data can be set only during stream initialization
-- * Readers are handled in lauxlib.c, see luaL_load(file|buffer|string)
-- * LUAL_BUFFERSIZE=BUFSIZ=512 in make_getF() (located in luaconf.h)
-- * Original Reader typedef:
--   const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);
-- * This Lua chunk reader implementation:
--   returns string or nil, no arguments to function
------------------------------------------------------------------------

------------------------------------------------------------------------
-- create a chunk reader from a source string
------------------------------------------------------------------------
function luaZ:make_getS(buff)
  local b = buff
  return function() -- chunk reader anonymous function here
    if not b then return nil end
    local data = b
    b = nil
    return data
  end
end

------------------------------------------------------------------------
-- create a chunk reader from a source file
------------------------------------------------------------------------
--[[
function luaZ:make_getF(filename)
  local LUAL_BUFFERSIZE = 512
  local h = io.open(filename, "r")
  if not h then return nil end
  return function() -- chunk reader anonymous function here
    if not h or io.type(h) == "closed file" then return nil end
    local buff = h:read(LUAL_BUFFERSIZE)
    if not buff then h:close(); h = nil end
    return buff
  end
end
--]]
------------------------------------------------------------------------
-- creates a zio input stream
-- returns the ZIO structure, z
------------------------------------------------------------------------
function luaZ:init(reader, data, name)
  if not reader then return end
  local z = {}
  z.reader = reader
  z.data = data or ""
  z.name = name
  -- set up additional data for reading
  if not data or data == "" then z.n = 0 else z.n = #data end
  z.p = 0
  return z
end

------------------------------------------------------------------------
-- fill up input buffer
------------------------------------------------------------------------
function luaZ:fill(z)
  local buff = z.reader()
  z.data = buff
  if not buff or buff == "" then return "EOZ" end
  z.n, z.p = #buff - 1, 1
  return string.sub(buff, 1, 1)
end

------------------------------------------------------------------------
-- get next character from the input stream
-- * local n, p are used to optimize code generation
------------------------------------------------------------------------
function luaZ:zgetc(z)
  local n, p = z.n, z.p + 1
  if n > 0 then
    z.n, z.p = n - 1, p
    return string.sub(z.data, p, p)
  else
    return self:fill(z)
  end
end

_G.encryptVM_compile.luaZ = luaZ
end
function scmframework_e32ffe3026c5936c77f8dd9cfac708e9() --$CONTENT_DATA/Scripts/encryptVM/compile/scrapvm.lua
_G.encryptVM_compile = {}
dofile './LBI.lua'
dofile './LuaZ.lua'
dofile './LuaX.lua'
dofile './LuaP.lua'
dofile './LuaK.lua'
dofile './LuaY.lua'
dofile './LuaU.lua'
_G.encryptVM_compile.luaX:init()
end
function scmframework_4d0b96551b03dbb7724b5addaed6e843() --$CONTENT_DATA/Scripts/encryptVM/encryptVM.lua
local currentEncryptVM = 1

dofile("$CONTENT_DATA/Scripts/encryptVM/compile/scrapvm.lua")
dofile("$CONTENT_DATA/Scripts/encryptVM/obfuscator.lua")
for i = 0, currentEncryptVM do
    dofile("$CONTENT_DATA/Scripts/encryptVM/vm_" .. i .. ".lua")
end

local table_concat = table.concat
local string_find = string.find
local string_gsub = string.gsub
local string_sub = string.sub
local string_char = string.char

local customCode_encode, customCode_decode
do
    local b='LVWiBIo12d/8b+YjJpUOwX70CPcxDrfZheyHKSE5t9Mluq6kQmsRTFGgA4Nva3nz'
    local b2 = '%d%d%d?%d?%d?%d?%d?%d?'
    local b3 = '%d%d%d?%d?%d?%d?'
    local n0, n1 = '0', '1'

    local function stringRoll(str, roll)
        if roll == 0 then return str end
        local nstr = {}
        for i = 1, #str do
            local index = ((i - roll - 1) % #str) + 1
            table.insert(nstr, str:sub(index, index))
        end
        return table.concat(nstr)
    end

    local cache2
    local oldRoll
    function customCode_encode(data, roll)
        if roll ~= oldRoll then
            oldRoll = roll
            cache2 = {}
        end
        local cache1 = {}
        local b = stringRoll(b, roll)
        return ((data:gsub('.', function(x) 
            if not cache1[x] then
                local r,b='',x:byte()
                for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and n1 or n0) end
                cache1[x] = r
            end
            return cache1[x]
        end)..'0000'):gsub(b3, function(x)
            if (#x < 6) then return '' end
            if not cache2[x] then
                local c=0
                for i=1,6 do c=c+(x:sub(i,i)==n1 and 2^(6-i) or 0) end
                cache2[x] = b:sub(c+1,c+1)
            end
            return cache2[x]
        end)..({ '', '==', '=' })[#data%3+1])
    end

    local cache3
    local oldRoll2
    function customCode_decode(data, roll)
        if roll ~= oldRoll2 then
            oldRoll2 = roll
            cache3 = {}
        end
        local cache4 = {}
        local b = stringRoll(b, roll)
        data = string_gsub(data, '[^'..b..'=]', '')
        local c, f, t, ti
        return string_gsub(string_gsub(data, '.', function(x)
            if (x == '=') then return '' end
            if not cache4[x] then
                f, t, ti= string_find(b,x)-1, {}, 1
                for i=6,1,-1 do t[ti] = f%2^i-f%2^(i-1)>0 and n1 or n0 ti = ti + 1 end
                cache4[x] = table_concat(t)
            end
            return cache4[x]
        end), b2, function(x)
            if (#x ~= 8) then return '' end
            if not cache3[x] then
                c=0
                for i=1,8 do c=c+(string_sub(x,i,i)==n1 and 2^(8-i) or 0) end
                cache3[x] = string_char(c)
            end
            return cache3[x]
        end)
    end
end

local function eload(self, bytecode, env)
    addServiceCode(self, "", env)

    local r1 = bytecode:byte(1)
    local r2 = bytecode:byte(2)
    local r3 = bytecode:byte(3)
    local result = customCode_decode(bytecode:sub(4, #bytecode), (r1 * r2) + r3)

    local vmid = result:byte(1)
    local vmlib = _G["encryptVM_" .. vmid]
    if not vmlib then
        return nil, "failed to select encryptVM"
    end

    env.___obfuscator_env = {
        math.ceil(((r1 * r3) - r2) / r1),
        table = sc.advDeepcopy(table),
        string = sc.advDeepcopy(string)
    }

    return vmlib.wrap_state(vmlib.bc_to_state(result:sub(2, #result)), env)
end

encryptVM = {
    compile = function(self, code)
        if self and not self.luastate then
            self.luastate = {}
        end
        local r1 = math.random(0, 255)
        local r2 = math.random(0, 255)
        local r3 = math.random(0, 255)
        code = obfuscator(addServiceCode(self, code), math.ceil(((r1 * r3) - r2) / r1))
        encryptVM_compile.luaY.initObfuscator()
        local tunnel, state = encryptVM_compile.luaU:make_setS()
        local intershitator = encryptVM_compile.luaY:parser(self.luastate, assert(encryptVM_compile.luaZ:init(encryptVM_compile.luaZ:make_getS(code))), nil, "@encrypted_code")
        encryptVM_compile.luaU:dump(self.luastate, intershitator, tunnel, state)
        return string.char(r1) .. string.char(r2) .. string.char(r3) .. customCode_encode(string.char(currentEncryptVM) .. state.data, (r1 * r2) + r3)
    end,
    load = function(self, bytecode, env)
        local ok, code, err = pcall(eload, self, bytecode, env)
        if ok then
            if type(code) == "function" then
                err = nil
            else
                err = "something went wrong"
                code = nil
            end
        else
            err = tostring(code)
            code = nil
        end
        return code, err
    end,
    version = function(self, bytecode)
        local version = -3
        pcall(function ()
            local r1 = bytecode:byte(1)
            local r2 = bytecode:byte(2)
            local r3 = bytecode:byte(3)
            local result = customCode_decode(bytecode:sub(4, #bytecode), (r1 * r2) + r3)
            version = result:byte(1)
        end)
        return version
    end,
    currentEncryptVM = currentEncryptVM
}
end
function scmframework_9002109f5198e217f0b999b23e3d57b3() --$CONTENT_DATA/Scripts/encryptVM/obfuscator.lua
local servicecode = [[(function(a)local b=a.table.concat;local c=a.table.insert;local d=a.string.find;local e=a.string.gsub;local f=a.string.sub;local g=a.string.char;local h;local i,j;local k="%d%d%d?%d?%d?%d?%d?%d?"local l,m="0","1"local function n(o,p)if p==0 then return o end;local q={}for r=1,#o do local s=(r-p-1)%#o+1;c(q,f(o,s,s))end;return b(q)end;local t={}return function(u,v,p)if not t[p]then t[p]={}end;if not t[p][v]then t[p][v]={}end;local w=t[p][v][u]if w then return w end;if p~=i or v~=j then i=p;j=v;h={}end;local x={}local y=n(v,p+a[1])u=e(u,"[^"..y.."=]","")local z,A,B,C;local D=e(e(u,".",function(E)if E=="="then return""end;if not x[E]then A,B,C=d(y,E)-1,{},1;for r=6,1,-1 do B[C]=A%2^r-A%2^(r-1)>0 and m or l;C=C+1 end;x[E]=b(B)end;return x[E]end),k,function(E)if#E~=8 then return""end;if not h[E]then z=0;for r=1,8 do z=z+(f(E,r,r)==m and 2^(8-r)or 0)end;h[E]=g(z)end;return h[E]end)t[p][v][u]=D;return D end end)]]

local customCode_base = 'LVWiBIo12d/8b+YjJpUOwX70CPcxDrfZheyHKSE5t9Mluq6kQmsRTFGgA4Nva3nz'

local function shuffleString(input)
    local chars = {}

    for i = 1, #input do
        chars[i] = input:sub(i, i)
    end

    for i = #chars, 2, -1 do
        local j = math.random(i)
        chars[i], chars[j] = chars[j], chars[i]
    end

    return table.concat(chars)
end

local function stringRoll(str, roll)
    if roll == 0 then return str end
    local nstr = {}
    for i = 1, #str do
        local index = ((i - roll - 1) % #str) + 1
        table.insert(nstr, str:sub(index, index))
    end
    return table.concat(nstr)
end

local customCode_encode
do
    local b2 = '%d%d%d?%d?%d?%d?%d?%d?'
    local b3 = '%d%d%d?%d?%d?%d?'
    local n0, n1 = '0', '1'

    local cache2
    local oldRoll, oldEcode
    function customCode_encode(data, ecode, roll)
        if roll ~= oldRoll or ecode ~= oldEcode then
            oldRoll = roll
            oldEcode = ecode
            cache2 = {}
        end

        local cache1 = {}
        local b = stringRoll(ecode, roll)
        return ((data:gsub('.', function(x) 
            if not cache1[x] then
                local r,b='',x:byte()
                for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and n1 or n0) end
                cache1[x] = r
            end
            return cache1[x]
        end)..'0000'):gsub(b3, function(x)
            if (#x < 6) then return '' end
            if not cache2[x] then
                local c=0
                for i=1,6 do c=c+(x:sub(i,i)==n1 and 2^(6-i) or 0) end
                cache2[x] = b:sub(c+1,c+1)
            end
            return cache2[x]
        end)..({ '', '==', '=' })[#data%3+1])
    end
end

local function generateRoll()
    return math.random(-4096, 4096)
end

local function encryptString(code, index, obval1)
    local char = code:sub(index, index)
    if char == "[" then
        index = index + 2
    else
        index = index + 1
    end

    local sourceString = {}
    local newI
    local prev
    for i = index, #code do
        sc.smartYield()
        local char2 = code:sub(i, i)
        if char == "[" then
            if char2 == "]" and code:sub(i+1, i+1) == "]" then
                newI = i + 2
                break
            else
                table.insert(sourceString, char2)
            end
        elseif char2 == char and prev ~= "\\" then
            newI = i + 1
            break
        else
            table.insert(sourceString, char2)
        end
        prev = char2
    end
    sourceString = table.concat(sourceString)
    sourceString = sourceString:gsub("\\n", "\n")
    sourceString = sourceString:gsub("\\r", "\r")
    sourceString = sourceString:gsub("\\t", "\t")
    sourceString = sourceString:gsub("\\b", "\b")
    sourceString = sourceString:gsub("\\f", "\f")
    sourceString = sourceString:gsub("\\v", "\v")
    sourceString = sourceString:gsub("\\0", "\0")
    sourceString = sourceString:gsub("\\\\", "\\")
    sourceString = sourceString:gsub("\\'", "'")
    sourceString = sourceString:gsub('\\"', '"')
    sourceString = sourceString:gsub("\\x(%x%x)", function(hex) return string.char(tonumber(hex, 16)) end)
    sourceString = sourceString:gsub("\\(%d%d?%d?)", function(oct) return string.char(tonumber(oct, 8)) end)

    --------------------------------

    local ecode = shuffleString(customCode_base)
    local roll = generateRoll()
    return "([[" .. customCode_encode(sourceString, ecode, roll + obval1) .. "]],[[" .. ecode .. "]]," .. roll .. ")", newI
end

local function generateRandomString()
    local length = math.random(8, 24)
    local chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    local result = {}

    local index = math.random(1, 52)
    local randomChar = chars:sub(index, index)
    table.insert(result, randomChar)

    for i = 2, length do
        index = math.random(1, #chars)
        randomChar = chars:sub(index, index)
        table.insert(result, randomChar)
    end

    return table.concat(result)
end

local function localObfuscator(code, obval1)
    local newcode = {}
    local decryptName = generateRandomString()

    local i = 1
    while i <= #code do
        sc.smartYield()
        local char = code:sub(i, i)
        if char == "\"" or char == "\'" or (char == "[" and code:sub(i+1, i+1) == "[") then
            local encodedString, newI = encryptString(code, i, obval1)
            table.insert(newcode, " ")
            table.insert(newcode, decryptName)
            table.insert(newcode, encodedString)
            i = newI - 1
        else
            table.insert(newcode, char)
        end
        i = i + 1
    end

    return "local " .. decryptName .. "=" .. servicecode .. "(___obfuscator_env)" .. " " .. table.concat(newcode)
end

function obfuscator(code, obval1)
    return localObfuscator(code, obval1)
end
end
function scmframework_5da709c323016f66af9bfe55069addc2() --$CONTENT_DATA/Scripts/encryptVM/vm_0.lua
--[[
FiOne
Copyright (C) 2021  Rerumu

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
]] --

--I (logic/bananapen) have made some modifications here for optimization and so that it does not pollute global variables.

local bit = bit or bit32 or require('bit')

local function table_pack(...)
	return {n = select('#', ...), ...}
end

local function table_move(src, first, last, offset, dst)
	for i = 0, last - first do
		dst[offset + i] = src[first + i]
	end
end

local lua_bc_to_state
local lua_wrap_state
local stm_lua_func

-- SETLIST config
local FIELDS_PER_FLUSH = 50

-- remap for better lookup
local OPCODE_RM = {
	-- level 1
	[22] = 18, -- JMP
	[31] = 8, -- FORLOOP
	[33] = 28, -- TFORLOOP
	-- level 2
	[0] = 3, -- MOVE
	[1] = 13, -- LOADK
	[2] = 23, -- LOADBOOL
	[26] = 33, -- TEST
	-- level 3
	[12] = 1, -- ADD
	[13] = 6, -- SUB
	[14] = 10, -- MUL
	[15] = 16, -- DIV
	[16] = 20, -- MOD
	[17] = 26, -- POW
	[18] = 30, -- UNM
	[19] = 36, -- NOT
	-- level 4
	[3] = 0, -- LOADNIL
	[4] = 2, -- GETUPVAL
	[5] = 4, -- GETGLOBAL
	[6] = 7, -- GETTABLE
	[7] = 9, -- SETGLOBAL
	[8] = 12, -- SETUPVAL
	[9] = 14, -- SETTABLE
	[10] = 17, -- NEWTABLE
	[20] = 19, -- LEN
	[21] = 22, -- CONCAT
	[23] = 24, -- EQ
	[24] = 27, -- LT
	[25] = 29, -- LE
	[27] = 32, -- TESTSET
	[32] = 34, -- FORPREP
	[34] = 37, -- SETLIST
	-- level 5
	[11] = 5, -- SELF
	[28] = 11, -- CALL
	[29] = 15, -- TAILCALL
	[30] = 21, -- RETURN
	[35] = 25, -- CLOSE
	[36] = 31, -- CLOSURE
	[37] = 35, -- VARARG
}

-- opcode types for getting values
local OPCODE_T = {
	[0] = 'ABC',
	'ABx',
	'ABC',
	'ABC',
	'ABC',
	'ABx',
	'ABC',
	'ABx',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'AsBx',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'AsBx',
	'AsBx',
	'ABC',
	'ABC',
	'ABC',
	'ABx',
	'ABC',
}

local OPCODE_M = {
	[0] = {b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgR', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgR'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgR', c = 'OpArgU'},
	{b = 'OpArgR', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgN', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgN', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
}

-- int rd_int_basic(string src, int s, int e, int d)
-- @src - Source binary string
-- @s - Start index of a little endian integer
-- @e - End index of the integer
-- @d - Direction of the loop
local function rd_int_basic(src, s, e, d)
	local num = 0

	-- if bb[l] > 127 then -- signed negative
	-- 	num = num - 256 ^ l
	-- 	bb[l] = bb[l] - 128
	-- end

	for i = s, e, d do
		local mul = 256 ^ math.abs(i - s)

		num = num + mul * string.byte(src, i, i)
	end

	return num
end

-- float rd_flt_basic(byte f1..8)
-- @f1..4 - The 4 bytes composing a little endian float
local function rd_flt_basic(f1, f2, f3, f4)
	local sign = (-1) ^ bit.rshift(f4, 7)
	local exp = bit.rshift(f3, 7) + bit.lshift(bit.band(f4, 0x7F), 1)
	local frac = f1 + bit.lshift(f2, 8) + bit.lshift(bit.band(f3, 0x7F), 16)
	local normal = 1

	if exp == 0 then
		if frac == 0 then
			return sign * 0
		else
			normal = 0
			exp = 1
		end
	elseif exp == 0x7F then
		if frac == 0 then
			return sign * (1 / 0)
		else
			return sign * (0 / 0)
		end
	end

	return sign * 2 ^ (exp - 127) * (1 + normal / 2 ^ 23)
end

-- double rd_dbl_basic(byte f1..8)
-- @f1..8 - The 8 bytes composing a little endian double
local function rd_dbl_basic(f1, f2, f3, f4, f5, f6, f7, f8)
	local sign = (-1) ^ bit.rshift(f8, 7)
	local exp = bit.lshift(bit.band(f8, 0x7F), 4) + bit.rshift(f7, 4)
	local frac = bit.band(f7, 0x0F) * 2 ^ 48
	local normal = 1

	frac = frac + (f6 * 2 ^ 40) + (f5 * 2 ^ 32) + (f4 * 2 ^ 24) + (f3 * 2 ^ 16) + (f2 * 2 ^ 8) + f1 -- help

	if exp == 0 then
		if frac == 0 then
			return sign * 0
		else
			normal = 0
			exp = 1
		end
	elseif exp == 0x7FF then
		if frac == 0 then
			return sign * (1 / 0)
		else
			return sign * (0 / 0)
		end
	end

	return sign * 2 ^ (exp - 1023) * (normal + frac / 2 ^ 52)
end

-- int rd_int_le(string src, int s, int e)
-- @src - Source binary string
-- @s - Start index of a little endian integer
-- @e - End index of the integer
local function rd_int_le(src, s, e) return rd_int_basic(src, s, e - 1, 1) end

-- int rd_int_be(string src, int s, int e)
-- @src - Source binary string
-- @s - Start index of a big endian integer
-- @e - End index of the integer
local function rd_int_be(src, s, e) return rd_int_basic(src, e - 1, s, -1) end

-- float rd_flt_le(string src, int s)
-- @src - Source binary string
-- @s - Start index of little endian float
local function rd_flt_le(src, s) return rd_flt_basic(string.byte(src, s, s + 3)) end

-- float rd_flt_be(string src, int s)
-- @src - Source binary string
-- @s - Start index of big endian float
local function rd_flt_be(src, s)
	local f1, f2, f3, f4 = string.byte(src, s, s + 3)
	return rd_flt_basic(f4, f3, f2, f1)
end

-- double rd_dbl_le(string src, int s)
-- @src - Source binary string
-- @s - Start index of little endian double
local function rd_dbl_le(src, s) return rd_dbl_basic(string.byte(src, s, s + 7)) end

-- double rd_dbl_be(string src, int s)
-- @src - Source binary string
-- @s - Start index of big endian double
local function rd_dbl_be(src, s)
	local f1, f2, f3, f4, f5, f6, f7, f8 = string.byte(src, s, s + 7) -- same
	return rd_dbl_basic(f8, f7, f6, f5, f4, f3, f2, f1)
end

-- to avoid nested ifs in deserializing
local float_types = {
	[4] = {little = rd_flt_le, big = rd_flt_be},
	[8] = {little = rd_dbl_le, big = rd_dbl_be},
}

-- byte stm_byte(Stream S)
-- @S - Stream object to read from
local function stm_byte(S)
	local idx = S.index
	local bt = string.byte(S.source, idx, idx)

	S.index = idx + 1
	return bt
end

-- string stm_string(Stream S, int len)
-- @S - Stream object to read from
-- @len - Length of string being read
local function stm_string(S, len)
	local pos = S.index + len
	local str = string.sub(S.source, S.index, pos - 1)

	S.index = pos
	return str
end

-- string stm_lstring(Stream S)
-- @S - Stream object to read from
local function stm_lstring(S)
	local len = S:s_szt()
	local str

	if len ~= 0 then str = string.sub(stm_string(S, len), 1, -2) end

	return str
end

-- fn cst_int_rdr(string src, int len, fn func)
-- @len - Length of type for reader
-- @func - Reader callback
local function cst_int_rdr(len, func)
	return function(S)
		local pos = S.index + len
		local int = func(S.source, S.index, pos)
		S.index = pos

		return int
	end
end

-- fn cst_flt_rdr(string src, int len, fn func)
-- @len - Length of type for reader
-- @func - Reader callback
local function cst_flt_rdr(len, func)
	return function(S)
		local flt = func(S.source, S.index)
		S.index = S.index + len

		return flt
	end
end

local function stm_inst_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do
		local ins = S:s_ins()
		local op = bit.band(ins, 0x3F)
		local args = OPCODE_T[op]
		local mode = OPCODE_M[op]
		local data = {value = ins, op = OPCODE_RM[op], A = bit.band(bit.rshift(ins, 6), 0xFF)}

		if args == 'ABC' then
			data.B = bit.band(bit.rshift(ins, 23), 0x1FF)
			data.C = bit.band(bit.rshift(ins, 14), 0x1FF)
			data.is_KB = mode.b == 'OpArgK' and data.B > 0xFF -- post process optimization
			data.is_KC = mode.c == 'OpArgK' and data.C > 0xFF

			if op == 10 then -- decode NEWTABLE array size, store it as constant value
				local e = bit.band(bit.rshift(data.B, 3), 31)
				if e == 0 then
					data.const = data.B
				else
					data.const = bit.lshift(bit.band(data.B, 7) + 8, e - 1)
				end
			end
		elseif args == 'ABx' then
			data.Bx = bit.band(bit.rshift(ins, 14), 0x3FFFF)
			data.is_K = mode.b == 'OpArgK'
		elseif args == 'AsBx' then
			data.sBx = bit.band(bit.rshift(ins, 14), 0x3FFFF) - 131071
		end

		list[i] = data
	end

	return list
end

local function stm_const_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do
		local tt = stm_byte(S)
		local k

		if tt == 1 then
			k = stm_byte(S) ~= 0
		elseif tt == 3 then
			k = S:s_num()
		elseif tt == 4 then
			k = stm_lstring(S)
		end

		list[i] = k -- offset +1 during instruction decode
	end

	return list
end

local function stm_sub_list(S, src)
	local len = S:s_int()
	local list = {}

	for i = 1, len do
		list[i] = stm_lua_func(S, src) -- offset +1 in CLOSURE
	end

	return list
end

local function stm_line_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do list[i] = S:s_int() end

	return list
end

local function stm_loc_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do list[i] = {varname = stm_lstring(S), startpc = S:s_int(), endpc = S:s_int()} end

	return list
end

local function stm_upval_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do list[i] = stm_lstring(S) end

	return list
end

function stm_lua_func(S, psrc)
	local proto = {}
	local src = stm_lstring(S) or psrc -- source is propagated

	proto.source = src -- source name

	S:s_int() -- line defined
	S:s_int() -- last line defined

	proto.num_upval = stm_byte(S) -- num upvalues
	proto.num_param = stm_byte(S) -- num params

	stm_byte(S) -- vararg flag
	proto.max_stack = stm_byte(S) -- max stack size

	proto.code = stm_inst_list(S)
	proto.const = stm_const_list(S)
	proto.subs = stm_sub_list(S, src)
	proto.lines = stm_line_list(S)

	stm_loc_list(S)
	stm_upval_list(S)

	-- post process optimization
	for _, v in ipairs(proto.code) do
		if v.is_K then
			v.const = proto.const[v.Bx + 1] -- offset for 1 based index
		else
			if v.is_KB then v.const_B = proto.const[v.B - 0xFF] end

			if v.is_KC then v.const_C = proto.const[v.C - 0xFF] end
		end
	end

	return proto
end

function lua_bc_to_state(_src)
	local src = {}
	for i = 1, #_src do
		table.insert(src, string.char(255 - _src:byte(i)))
	end

	-- func reader
	local rdr_func

	-- header flags
	local little
	local size_int
	local size_szt
	local size_ins
	local size_num
	local flag_int

	-- stream object
	local stream = {
		-- data
		index = 1,
		source = table.concat(src),
	}

	stm_string(stream, 4)
	stm_byte(stream)
	stm_byte(stream)

	little = stm_byte(stream) ~= 0
	size_int = stm_byte(stream)
	size_szt = stm_byte(stream)
	size_ins = stm_byte(stream)
	size_num = stm_byte(stream)
	flag_int = stm_byte(stream) ~= 0

	rdr_func = little and rd_int_le or rd_int_be
	stream.s_int = cst_int_rdr(size_int, rdr_func)
	stream.s_szt = cst_int_rdr(size_szt, rdr_func)
	stream.s_ins = cst_int_rdr(size_ins, rdr_func)

	if flag_int then
		stream.s_num = cst_int_rdr(size_num, rdr_func)
	elseif float_types[size_num] then
		stream.s_num = cst_flt_rdr(size_num, float_types[size_num][little and 'little' or 'big'])
	else
		error('unsupported float size')
	end

	return stm_lua_func(stream, '@virtual')
end

local function close_lua_upvalues(list, index)
	for i, uv in pairs(list) do
		if uv.index >= index then
			uv.value = uv.store[uv.index] -- store value
			uv.store = uv
			uv.index = 'value' -- self reference
			list[i] = nil
		end
	end
end

local function open_lua_upvalue(list, index, memory)
	local prev = list[index]

	if not prev then
		prev = {index = index, store = memory}
		list[index] = prev
	end

	return prev
end

local function on_lua_error(failed, err)
	local src = failed.source
	local line = failed.lines[failed.pc - 1]

	error(string.format('%s:%i: %s', src, line, err), 0)
end

local function run_lua_func(state, env, upvals)
	local code = state.code
	local subs = state.subs
	local vararg = state.vararg

	local top_index = -1
	local open_list = {}
	local memory = state.memory
	local pc = state.pc

	while true do
		local inst = code[pc]
		local op = inst.op
		pc = pc + 1

		if op < 18 then
			if op < 8 then
				if op < 3 then
					if op < 1 then
						--[[LOADNIL]]
						for i = inst.A, inst.B do memory[i] = nil end
					elseif op > 1 then
						--[[GETUPVAL]]
						local uv = upvals[inst.B]

						memory[inst.A] = uv.store[uv.index]
					else
						--[[ADD]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs + rhs
					end
				elseif op > 3 then
					if op < 6 then
						if op > 4 then
							--[[SELF]]
							local A = inst.A
							local B = inst.B
							local index

							if inst.is_KC then
								index = inst.const_C
							else
								index = memory[inst.C]
							end

							memory[A + 1] = memory[B]
							memory[A] = memory[B][index]
						else
							--[[GETGLOBAL]]
							memory[inst.A] = env[inst.const]
						end
					elseif op > 6 then
						--[[GETTABLE]]
						local index

						if inst.is_KC then
							index = inst.const_C
						else
							index = memory[inst.C]
						end

						memory[inst.A] = memory[inst.B][index]
					else
						--[[SUB]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs - rhs
					end
				else --[[MOVE]]
					memory[inst.A] = memory[inst.B]
				end
			elseif op > 8 then
				if op < 13 then
					if op < 10 then
						--[[SETGLOBAL]]
						env[inst.const] = memory[inst.A]
					elseif op > 10 then
						if op < 12 then
							--[[CALL]]
							local A = inst.A
							local B = inst.B
							local C = inst.C
							local params

							if B == 0 then
								params = top_index - A
							else
								params = B - 1
							end

							local ret_list = table_pack(memory[A](unpack(memory, A + 1, A + params)))
							local ret_num = ret_list.n

							if C == 0 then
								top_index = A + ret_num - 1
							else
								ret_num = C - 1
							end

							table_move(ret_list, 1, ret_num, A, memory)
						else
							--[[SETUPVAL]]
							local uv = upvals[inst.B]

							uv.store[uv.index] = memory[inst.A]
						end
					else
						--[[MUL]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs * rhs
					end
				elseif op > 13 then
					if op < 16 then
						if op > 14 then
							--[[TAILCALL]]
							local A = inst.A
							local B = inst.B
							local params

							if B == 0 then
								params = top_index - A
							else
								params = B - 1
							end

							close_lua_upvalues(open_list, 0)

							return memory[A](unpack(memory, A + 1, A + params))
						else
							--[[SETTABLE]]
							local index, value

							if inst.is_KB then
								index = inst.const_B
							else
								index = memory[inst.B]
							end

							if inst.is_KC then
								value = inst.const_C
							else
								value = memory[inst.C]
							end

							memory[inst.A][index] = value
						end
					elseif op > 16 then
						--[[NEWTABLE]]
						memory[inst.A] = {} -- inst.const contains array size
					else
						--[[DIV]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs / rhs
					end
				else
					--[[LOADK]]
					memory[inst.A] = inst.const
				end
			else
				--[[FORLOOP]]
				local A = inst.A
				local step = memory[A + 2]
				local index = memory[A] + step
				local limit = memory[A + 1]
				local loops

				if step == math.abs(step) then
					loops = index <= limit
				else
					loops = index >= limit
				end

				if loops then
					memory[A] = index
					memory[A + 3] = index
					pc = pc + inst.sBx
				end
			end
		elseif op > 18 then
			if op < 28 then
				if op < 23 then
					if op < 20 then
						--[[LEN]]
						memory[inst.A] = #memory[inst.B]
					elseif op > 20 then
						if op < 22 then
							--[[RETURN]]
							local A = inst.A
							local B = inst.B
							local len

							if B == 0 then
								len = top_index - A + 1
							else
								len = B - 1
							end

							close_lua_upvalues(open_list, 0)

							return unpack(memory, A, A + len - 1)
						else
							--[[CONCAT]]
							local B, C = inst.B, inst.C
							local success, str = pcall(table.concat, memory, "", B, C)

							if not success then
								str = memory[B]

								for i = B + 1, C do str = str .. memory[i] end
							end

							memory[inst.A] = str
						end
					else
						--[[MOD]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs % rhs
					end
				elseif op > 23 then
					if op < 26 then
						if op > 24 then
							--[[CLOSE]]
							close_lua_upvalues(open_list, inst.A)
						else
							--[[EQ]]
							local lhs, rhs

							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end

							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end

							if (lhs == rhs) == (inst.A ~= 0) then pc = pc + code[pc].sBx end

							pc = pc + 1
						end
					elseif op > 26 then
						--[[LT]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						if (lhs < rhs) == (inst.A ~= 0) then pc = pc + code[pc].sBx end

						pc = pc + 1
					else
						--[[POW]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs ^ rhs
					end
				else
					--[[LOADBOOL]]
					memory[inst.A] = inst.B ~= 0

					if inst.C ~= 0 then pc = pc + 1 end
				end
			elseif op > 28 then
				if op < 33 then
					if op < 30 then
						--[[LE]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						if (lhs <= rhs) == (inst.A ~= 0) then pc = pc + code[pc].sBx end

						pc = pc + 1
					elseif op > 30 then
						if op < 32 then
							--[[CLOSURE]]
							local sub = subs[inst.Bx + 1] -- offset for 1 based index
							local nups = sub.num_upval
							local uvlist

							if nups ~= 0 then
								uvlist = {}

								for i = 1, nups do
									local pseudo = code[pc + i - 1]

									if pseudo.op == OPCODE_RM[0] then -- @MOVE
										uvlist[i - 1] = open_lua_upvalue(open_list, pseudo.B, memory)
									elseif pseudo.op == OPCODE_RM[4] then -- @GETUPVAL
										uvlist[i - 1] = upvals[pseudo.B]
									end
								end

								pc = pc + nups
							end

							memory[inst.A] = lua_wrap_state(sub, env, uvlist)
						else
							--[[TESTSET]]
							local A = inst.A
							local B = inst.B

							if (not memory[B]) ~= (inst.C ~= 0) then
								memory[A] = memory[B]
								pc = pc + code[pc].sBx
							end
							pc = pc + 1
						end
					else
						--[[UNM]]
						memory[inst.A] = -memory[inst.B]
					end
				elseif op > 33 then
					if op < 36 then
						if op > 34 then
							--[[VARARG]]
							local A = inst.A
							local len = inst.B

							if len == 0 then
								len = vararg.len
								top_index = A + len - 1
							end

							table_move(vararg.list, 1, len, A, memory)
						else
							--[[FORPREP]]
							local A = inst.A
							local init, limit, step

							init = assert(tonumber(memory[A]), '`for` initial value must be a number')
							limit = assert(tonumber(memory[A + 1]), '`for` limit must be a number')
							step = assert(tonumber(memory[A + 2]), '`for` step must be a number')

							memory[A] = init - step
							memory[A + 1] = limit
							memory[A + 2] = step

							pc = pc + inst.sBx
						end
					elseif op > 36 then
						--[[SETLIST]]
						local A = inst.A
						local C = inst.C
						local len = inst.B
						local tab = memory[A]
						local offset

						if len == 0 then len = top_index - A end

						if C == 0 then
							C = inst[pc].value
							pc = pc + 1
						end

						offset = (C - 1) * FIELDS_PER_FLUSH

						table_move(memory, A + 1, A + len, offset + 1, tab)
					else
						--[[NOT]]
						memory[inst.A] = not memory[inst.B]
					end
				else
					--[[TEST]]
					if (not memory[inst.A]) ~= (inst.C ~= 0) then pc = pc + code[pc].sBx end
					pc = pc + 1
				end
			else
				--[[TFORLOOP]]
				local A = inst.A
				local base = A + 3

				local vals = {memory[A](memory[A + 1], memory[A + 2])}

				table_move(vals, 1, inst.C, base, memory)

				if memory[base] ~= nil then
					memory[A + 2] = memory[base]
					pc = pc + code[pc].sBx
				end

				pc = pc + 1
			end
		else
			--[[JMP]]
			pc = pc + inst.sBx
		end

		state.pc = pc
	end
end

function lua_wrap_state(proto, env, upval)
	local function wrapped(...)
		local passed = table_pack(...)
		local memory = {}
		local vararg = {len = 0, list = {}}

		table_move(passed, 1, proto.num_param, 0, memory)

		if proto.num_param < passed.n then
			local start = proto.num_param + 1
			local len = passed.n - proto.num_param

			vararg.len = len
			table_move(passed, start, start + len - 1, 1, vararg.list)
		end

		local state = {vararg = vararg, memory = memory, code = proto.code, subs = proto.subs, pc = 1}

		local result = table_pack(pcall(run_lua_func, state, env, upval))

		if result[1] then
			return unpack(result, 2, result.n)
		else
			local failed = {pc = state.pc, source = proto.source, lines = proto.lines}

			on_lua_error(failed, result[2])

			return
		end
	end

	return wrapped
end

encryptVM_0 = {
	bc_to_state = lua_bc_to_state,
	wrap_state = lua_wrap_state,
	OPCODE_RM = OPCODE_RM,
	OPCODE_T = OPCODE_T,
	OPCODE_M = OPCODE_M,
}

end
function scmframework_9612c54b98fbf549c3117b8dd3bf2db9() --$CONTENT_DATA/Scripts/encryptVM/vm_1.lua
--[[
FiOne
Copyright (C) 2021  Rerumu

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
]] --

--I (logic/bananapen) have made some modifications here for optimization and so that it does not pollute global variables.

local bit = bit or bit32 or require('bit')

local function table_pack(...)
	return {n = select('#', ...), ...}
end

local function table_move(src, first, last, offset, dst)
	for i = 0, last - first do
		dst[offset + i] = src[first + i]
	end
end

local lua_bc_to_state
local lua_wrap_state
local stm_lua_func

-- SETLIST config
local FIELDS_PER_FLUSH = 50

-- remap for better lookup
local OPCODE_RM = {
	-- level 1
	[22] = 18, -- JMP
	[31] = 8, -- FORLOOP
	[33] = 28, -- TFORLOOP
	-- level 2
	[0] = 3, -- MOVE
	[1] = 13, -- LOADK
	[2] = 23, -- LOADBOOL
	[26] = 33, -- TEST
	-- level 3
	[12] = 1, -- ADD
	[13] = 6, -- SUB
	[14] = 10, -- MUL
	[15] = 16, -- DIV
	[16] = 20, -- MOD
	[17] = 26, -- POW
	[18] = 30, -- UNM
	[19] = 36, -- NOT
	-- level 4
	[3] = 0, -- LOADNIL
	[4] = 2, -- GETUPVAL
	[5] = 4, -- GETGLOBAL
	[6] = 7, -- GETTABLE
	[7] = 9, -- SETGLOBAL
	[8] = 12, -- SETUPVAL
	[9] = 14, -- SETTABLE
	[10] = 17, -- NEWTABLE
	[20] = 19, -- LEN
	[21] = 22, -- CONCAT
	[23] = 24, -- EQ
	[24] = 27, -- LT
	[25] = 29, -- LE
	[27] = 32, -- TESTSET
	[32] = 34, -- FORPREP
	[34] = 37, -- SETLIST
	-- level 5
	[11] = 5, -- SELF
	[28] = 11, -- CALL
	[29] = 15, -- TAILCALL
	[30] = 21, -- RETURN
	[35] = 25, -- CLOSE
	[36] = 31, -- CLOSURE
	[37] = 35, -- VARARG
}

-- opcode types for getting values
local OPCODE_T = {
	[0] = 'ABC',
	'ABx',
	'ABC',
	'ABC',
	'ABC',
	'ABx',
	'ABC',
	'ABx',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'AsBx',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'AsBx',
	'AsBx',
	'ABC',
	'ABC',
	'ABC',
	'ABx',
	'ABC',
}

local OPCODE_M = {
	[0] = {b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgR', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgR'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgR', c = 'OpArgU'},
	{b = 'OpArgR', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgN', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgN', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
}

-- int rd_int_basic(string src, int s, int e, int d)
-- @src - Source binary string
-- @s - Start index of a little endian integer
-- @e - End index of the integer
-- @d - Direction of the loop
local function rd_int_basic(src, s, e, d)
	local num = 0

	-- if bb[l] > 127 then -- signed negative
	-- 	num = num - 256 ^ l
	-- 	bb[l] = bb[l] - 128
	-- end

	for i = s, e, d do
		local mul = 256 ^ math.abs(i - s)

		num = num + mul * string.byte(src, i, i)
	end

	return num
end

-- float rd_flt_basic(byte f1..8)
-- @f1..4 - The 4 bytes composing a little endian float
local function rd_flt_basic(f1, f2, f3, f4)
	local sign = (-1) ^ bit.rshift(f4, 7)
	local exp = bit.rshift(f3, 7) + bit.lshift(bit.band(f4, 0x7F), 1)
	local frac = f1 + bit.lshift(f2, 8) + bit.lshift(bit.band(f3, 0x7F), 16)
	local normal = 1

	if exp == 0 then
		if frac == 0 then
			return sign * 0
		else
			normal = 0
			exp = 1
		end
	elseif exp == 0x7F then
		if frac == 0 then
			return sign * (1 / 0)
		else
			return sign * (0 / 0)
		end
	end

	return sign * 2 ^ (exp - 127) * (1 + normal / 2 ^ 23)
end

-- double rd_dbl_basic(byte f1..8)
-- @f1..8 - The 8 bytes composing a little endian double
local function rd_dbl_basic(f1, f2, f3, f4, f5, f6, f7, f8)
	local sign = (-1) ^ bit.rshift(f8, 7)
	local exp = bit.lshift(bit.band(f8, 0x7F), 4) + bit.rshift(f7, 4)
	local frac = bit.band(f7, 0x0F) * 2 ^ 48
	local normal = 1

	frac = frac + (f6 * 2 ^ 40) + (f5 * 2 ^ 32) + (f4 * 2 ^ 24) + (f3 * 2 ^ 16) + (f2 * 2 ^ 8) + f1 -- help

	if exp == 0 then
		if frac == 0 then
			return sign * 0
		else
			normal = 0
			exp = 1
		end
	elseif exp == 0x7FF then
		if frac == 0 then
			return sign * (1 / 0)
		else
			return sign * (0 / 0)
		end
	end

	return sign * 2 ^ (exp - 1023) * (normal + frac / 2 ^ 52)
end

-- int rd_int_le(string src, int s, int e)
-- @src - Source binary string
-- @s - Start index of a little endian integer
-- @e - End index of the integer
local function rd_int_le(src, s, e) return rd_int_basic(src, s, e - 1, 1) end

-- int rd_int_be(string src, int s, int e)
-- @src - Source binary string
-- @s - Start index of a big endian integer
-- @e - End index of the integer
local function rd_int_be(src, s, e) return rd_int_basic(src, e - 1, s, -1) end

-- float rd_flt_le(string src, int s)
-- @src - Source binary string
-- @s - Start index of little endian float
local function rd_flt_le(src, s) return rd_flt_basic(string.byte(src, s, s + 3)) end

-- float rd_flt_be(string src, int s)
-- @src - Source binary string
-- @s - Start index of big endian float
local function rd_flt_be(src, s)
	local f1, f2, f3, f4 = string.byte(src, s, s + 3)
	return rd_flt_basic(f4, f3, f2, f1)
end

-- double rd_dbl_le(string src, int s)
-- @src - Source binary string
-- @s - Start index of little endian double
local function rd_dbl_le(src, s) return rd_dbl_basic(string.byte(src, s, s + 7)) end

-- double rd_dbl_be(string src, int s)
-- @src - Source binary string
-- @s - Start index of big endian double
local function rd_dbl_be(src, s)
	local f1, f2, f3, f4, f5, f6, f7, f8 = string.byte(src, s, s + 7) -- same
	return rd_dbl_basic(f8, f7, f6, f5, f4, f3, f2, f1)
end

-- to avoid nested ifs in deserializing
local float_types = {
	[4] = {little = rd_flt_le, big = rd_flt_be},
	[8] = {little = rd_dbl_le, big = rd_dbl_be},
}

-- byte stm_byte(Stream S)
-- @S - Stream object to read from
local function stm_byte(S)
	local idx = S.index
	local bt = string.byte(S.source, idx, idx)

	S.index = idx + 1
	return bt
end

-- string stm_string(Stream S, int len)
-- @S - Stream object to read from
-- @len - Length of string being read
local function stm_string(S, len)
	local pos = S.index + len
	local str = string.sub(S.source, S.index, pos - 1)

	S.index = pos
	return str
end

-- string stm_lstring(Stream S)
-- @S - Stream object to read from
local function stm_lstring(S)
	local len = S:s_szt()
	local str

	if len ~= 0 then str = string.sub(stm_string(S, len), 1, -2) end

	return str
end

-- fn cst_int_rdr(string src, int len, fn func)
-- @len - Length of type for reader
-- @func - Reader callback
local function cst_int_rdr(len, func)
	return function(S)
		local pos = S.index + len
		local int = func(S.source, S.index, pos)
		S.index = pos

		return int
	end
end

-- fn cst_flt_rdr(string src, int len, fn func)
-- @len - Length of type for reader
-- @func - Reader callback
local function cst_flt_rdr(len, func)
	return function(S)
		local flt = func(S.source, S.index)
		S.index = S.index + len

		return flt
	end
end

local function stm_inst_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do
		local ins = S:s_ins()
		local op = bit.band(ins, 0x3F)
		local args = OPCODE_T[op]
		local mode = OPCODE_M[op]
		local data = {value = ins, op = OPCODE_RM[op], A = bit.band(bit.rshift(ins, 6), 0xFF)}

		if args == 'ABC' then
			data.B = bit.band(bit.rshift(ins, 23), 0x1FF)
			data.C = bit.band(bit.rshift(ins, 14), 0x1FF)
			data.is_KB = mode.b == 'OpArgK' and data.B > 0xFF -- post process optimization
			data.is_KC = mode.c == 'OpArgK' and data.C > 0xFF

			if op == 10 then -- decode NEWTABLE array size, store it as constant value
				local e = bit.band(bit.rshift(data.B, 3), 31)
				if e == 0 then
					data.const = data.B
				else
					data.const = bit.lshift(bit.band(data.B, 7) + 8, e - 1)
				end
			end
		elseif args == 'ABx' then
			data.Bx = bit.band(bit.rshift(ins, 14), 0x3FFFF)
			data.is_K = mode.b == 'OpArgK'
		elseif args == 'AsBx' then
			data.sBx = bit.band(bit.rshift(ins, 14), 0x3FFFF) - 131071
		end

		list[i] = data
	end

	return list
end

local function stm_const_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do
		local tt = stm_byte(S)
		local k

		if tt == 1 then
			k = stm_byte(S) ~= 0
		elseif tt == 3 then
			k = S:s_num()
		elseif tt == 4 then
			k = stm_lstring(S)
		end

		list[i] = k -- offset +1 during instruction decode
	end

	return list
end

local function stm_sub_list(S, src)
	local len = S:s_int()
	local list = {}

	for i = 1, len do
		list[i] = stm_lua_func(S, src) -- offset +1 in CLOSURE
	end

	return list
end

local function stm_line_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do list[i] = S:s_int() end

	return list
end

local function stm_loc_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do list[i] = {varname = stm_lstring(S), startpc = S:s_int(), endpc = S:s_int()} end

	return list
end

local function stm_upval_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do list[i] = stm_lstring(S) end

	return list
end

function stm_lua_func(S, psrc)
	local proto = {}
	local src = stm_lstring(S) or psrc -- source is propagated

	proto.source = src -- source name

	S:s_int() -- line defined
	S:s_int() -- last line defined

	proto.num_upval = stm_byte(S) -- num upvalues
	proto.num_param = stm_byte(S) -- num params

	stm_byte(S) -- vararg flag
	proto.max_stack = stm_byte(S) -- max stack size

	proto.code = stm_inst_list(S)
	proto.const = stm_const_list(S)
	proto.subs = stm_sub_list(S, src)
	proto.lines = stm_line_list(S)

	stm_loc_list(S)
	stm_upval_list(S)

	-- post process optimization
	for _, v in ipairs(proto.code) do
		if v.is_K then
			v.const = proto.const[v.Bx + 1] -- offset for 1 based index
		else
			if v.is_KB then v.const_B = proto.const[v.B - 0xFF] end

			if v.is_KC then v.const_C = proto.const[v.C - 0xFF] end
		end
	end

	return proto
end

local mapval = {202,41,88,187,7,35,23,154,225,175,20,130,63,172,235,57,186,14,214,81,232,211,13,160,246,123,236,97,142,152,240,164,37,189,77,177,31,220,216,209,16,53,82,221,168,184,19,5,242,9,110,140,147,44,75,103,11,182,60,166,195,239,61,39,91,163,32,79,46,52,51,70,253,10,18,109,212,217,171,227,222,162,241,59,74,115,196,156,15,255,247,150,148,120,8,138,135,183,56,106,112,133,169,139,17,68,185,101,0,38,157,180,93,250,188,90,107,84,64,3,223,102,40,199,30,45,213,86,113,233,95,55,65,141,43,124,134,192,22,108,206,198,67,191,254,58,96,151,12,116,117,73,25,111,114,42,179,173,29,127,132,251,54,159,118,197,62,121,145,92,72,203,136,181,119,204,78,24,50,153,215,155,219,207,176,165,190,28,100,226,128,105,47,36,146,231,234,244,243,87,85,170,94,193,238,237,89,167,76,26,245,178,99,174,125,27,2,137,34,230,248,122,66,149,201,249,144,218,21,194,229,69,80,131,98,205,224,48,33,200,4,104,83,49,126,228,6,158,252,208,210,1,161,143,129,[0]=71}

function lua_bc_to_state(src)
	local t1 = {}
	for i = 1, #src do
		t1[i] = mapval[255 - src:byte(i)]
	end

    local mapval2 = {}
    for i = 1, 256 do
        mapval2[i - 1] = t1[i]
    end

    local src = {}
	for i = 257, #t1 do
        table.insert(src, string.char(mapval2[t1[i]]))
	end

	-- func reader
	local rdr_func

	-- header flags
	local little
	local size_int
	local size_szt
	local size_ins
	local size_num
	local flag_int

	-- stream object
	local stream = {
		-- data
		index = 1,
		source = table.concat(src),
	}

	stm_string(stream, 4)
	stm_byte(stream)
	stm_byte(stream)

	little = stm_byte(stream) ~= 0
	size_int = stm_byte(stream)
	size_szt = stm_byte(stream)
	size_ins = stm_byte(stream)
	size_num = stm_byte(stream)
	flag_int = stm_byte(stream) ~= 0

	rdr_func = little and rd_int_le or rd_int_be
	stream.s_int = cst_int_rdr(size_int, rdr_func)
	stream.s_szt = cst_int_rdr(size_szt, rdr_func)
	stream.s_ins = cst_int_rdr(size_ins, rdr_func)

	if flag_int then
		stream.s_num = cst_int_rdr(size_num, rdr_func)
	elseif float_types[size_num] then
		stream.s_num = cst_flt_rdr(size_num, float_types[size_num][little and 'little' or 'big'])
	else
		error('unsupported float size')
	end

	return stm_lua_func(stream, '@virtual')
end

local function close_lua_upvalues(list, index)
	for i, uv in pairs(list) do
		if uv.index >= index then
			uv.value = uv.store[uv.index] -- store value
			uv.store = uv
			uv.index = 'value' -- self reference
			list[i] = nil
		end
	end
end

local function open_lua_upvalue(list, index, memory)
	local prev = list[index]

	if not prev then
		prev = {index = index, store = memory}
		list[index] = prev
	end

	return prev
end

local function on_lua_error(failed, err)
	local src = failed.source
	local line = failed.lines[failed.pc - 1]

	error(string.format('%s:%i: %s', src, line, err), 0)
end

local function run_lua_func(state, env, upvals)
	local code = state.code
	local subs = state.subs
	local vararg = state.vararg

	local top_index = -1
	local open_list = {}
	local memory = state.memory
	local pc = state.pc

	while true do
		local inst = code[pc]
		local op = inst.op
		pc = pc + 1

		if op < 18 then
			if op < 8 then
				if op < 3 then
					if op < 1 then
						--[[LOADNIL]]
						for i = inst.A, inst.B do memory[i] = nil end
					elseif op > 1 then
						--[[GETUPVAL]]
						local uv = upvals[inst.B]

						memory[inst.A] = uv.store[uv.index]
					else
						--[[ADD]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs + rhs
					end
				elseif op > 3 then
					if op < 6 then
						if op > 4 then
							--[[SELF]]
							local A = inst.A
							local B = inst.B
							local index

							if inst.is_KC then
								index = inst.const_C
							else
								index = memory[inst.C]
							end

							memory[A + 1] = memory[B]
							memory[A] = memory[B][index]
						else
							--[[GETGLOBAL]]
							memory[inst.A] = env[inst.const]
						end
					elseif op > 6 then
						--[[GETTABLE]]
						local index

						if inst.is_KC then
							index = inst.const_C
						else
							index = memory[inst.C]
						end

						memory[inst.A] = memory[inst.B][index]
					else
						--[[SUB]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs - rhs
					end
				else --[[MOVE]]
					memory[inst.A] = memory[inst.B]
				end
			elseif op > 8 then
				if op < 13 then
					if op < 10 then
						--[[SETGLOBAL]]
						env[inst.const] = memory[inst.A]
					elseif op > 10 then
						if op < 12 then
							--[[CALL]]
							local A = inst.A
							local B = inst.B
							local C = inst.C
							local params

							if B == 0 then
								params = top_index - A
							else
								params = B - 1
							end

							local ret_list = table_pack(memory[A](unpack(memory, A + 1, A + params)))
							local ret_num = ret_list.n

							if C == 0 then
								top_index = A + ret_num - 1
							else
								ret_num = C - 1
							end

							table_move(ret_list, 1, ret_num, A, memory)
						else
							--[[SETUPVAL]]
							local uv = upvals[inst.B]

							uv.store[uv.index] = memory[inst.A]
						end
					else
						--[[MUL]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs * rhs
					end
				elseif op > 13 then
					if op < 16 then
						if op > 14 then
							--[[TAILCALL]]
							local A = inst.A
							local B = inst.B
							local params

							if B == 0 then
								params = top_index - A
							else
								params = B - 1
							end

							close_lua_upvalues(open_list, 0)

							return memory[A](unpack(memory, A + 1, A + params))
						else
							--[[SETTABLE]]
							local index, value

							if inst.is_KB then
								index = inst.const_B
							else
								index = memory[inst.B]
							end

							if inst.is_KC then
								value = inst.const_C
							else
								value = memory[inst.C]
							end

							memory[inst.A][index] = value
						end
					elseif op > 16 then
						--[[NEWTABLE]]
						memory[inst.A] = {} -- inst.const contains array size
					else
						--[[DIV]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs / rhs
					end
				else
					--[[LOADK]]
					memory[inst.A] = inst.const
				end
			else
				--[[FORLOOP]]
				local A = inst.A
				local step = memory[A + 2]
				local index = memory[A] + step
				local limit = memory[A + 1]
				local loops

				if step == math.abs(step) then
					loops = index <= limit
				else
					loops = index >= limit
				end

				if loops then
					memory[A] = index
					memory[A + 3] = index
					pc = pc + inst.sBx
				end
			end
		elseif op > 18 then
			if op < 28 then
				if op < 23 then
					if op < 20 then
						--[[LEN]]
						memory[inst.A] = #memory[inst.B]
					elseif op > 20 then
						if op < 22 then
							--[[RETURN]]
							local A = inst.A
							local B = inst.B
							local len

							if B == 0 then
								len = top_index - A + 1
							else
								len = B - 1
							end

							close_lua_upvalues(open_list, 0)

							return unpack(memory, A, A + len - 1)
						else
							--[[CONCAT]]
							local B, C = inst.B, inst.C
							local success, str = pcall(table.concat, memory, "", B, C)

							if not success then
								str = memory[B]

								for i = B + 1, C do str = str .. memory[i] end
							end

							memory[inst.A] = str
						end
					else
						--[[MOD]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs % rhs
					end
				elseif op > 23 then
					if op < 26 then
						if op > 24 then
							--[[CLOSE]]
							close_lua_upvalues(open_list, inst.A)
						else
							--[[EQ]]
							local lhs, rhs

							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end

							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end

							if (lhs == rhs) == (inst.A ~= 0) then pc = pc + code[pc].sBx end

							pc = pc + 1
						end
					elseif op > 26 then
						--[[LT]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						if (lhs < rhs) == (inst.A ~= 0) then pc = pc + code[pc].sBx end

						pc = pc + 1
					else
						--[[POW]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs ^ rhs
					end
				else
					--[[LOADBOOL]]
					memory[inst.A] = inst.B ~= 0

					if inst.C ~= 0 then pc = pc + 1 end
				end
			elseif op > 28 then
				if op < 33 then
					if op < 30 then
						--[[LE]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						if (lhs <= rhs) == (inst.A ~= 0) then pc = pc + code[pc].sBx end

						pc = pc + 1
					elseif op > 30 then
						if op < 32 then
							--[[CLOSURE]]
							local sub = subs[inst.Bx + 1] -- offset for 1 based index
							local nups = sub.num_upval
							local uvlist

							if nups ~= 0 then
								uvlist = {}

								for i = 1, nups do
									local pseudo = code[pc + i - 1]

									if pseudo.op == OPCODE_RM[0] then -- @MOVE
										uvlist[i - 1] = open_lua_upvalue(open_list, pseudo.B, memory)
									elseif pseudo.op == OPCODE_RM[4] then -- @GETUPVAL
										uvlist[i - 1] = upvals[pseudo.B]
									end
								end

								pc = pc + nups
							end

							memory[inst.A] = lua_wrap_state(sub, env, uvlist)
						else
							--[[TESTSET]]
							local A = inst.A
							local B = inst.B

							if (not memory[B]) ~= (inst.C ~= 0) then
								memory[A] = memory[B]
								pc = pc + code[pc].sBx
							end
							pc = pc + 1
						end
					else
						--[[UNM]]
						memory[inst.A] = -memory[inst.B]
					end
				elseif op > 33 then
					if op < 36 then
						if op > 34 then
							--[[VARARG]]
							local A = inst.A
							local len = inst.B

							if len == 0 then
								len = vararg.len
								top_index = A + len - 1
							end

							table_move(vararg.list, 1, len, A, memory)
						else
							--[[FORPREP]]
							local A = inst.A
							local init, limit, step

							init = assert(tonumber(memory[A]), '`for` initial value must be a number')
							limit = assert(tonumber(memory[A + 1]), '`for` limit must be a number')
							step = assert(tonumber(memory[A + 2]), '`for` step must be a number')

							memory[A] = init - step
							memory[A + 1] = limit
							memory[A + 2] = step

							pc = pc + inst.sBx
						end
					elseif op > 36 then
						--[[SETLIST]]
						local A = inst.A
						local C = inst.C
						local len = inst.B
						local tab = memory[A]
						local offset

						if len == 0 then len = top_index - A end

						if C == 0 then
							C = inst[pc].value
							pc = pc + 1
						end

						offset = (C - 1) * FIELDS_PER_FLUSH

						table_move(memory, A + 1, A + len, offset + 1, tab)
					else
						--[[NOT]]
						memory[inst.A] = not memory[inst.B]
					end
				else
					--[[TEST]]
					if (not memory[inst.A]) ~= (inst.C ~= 0) then pc = pc + code[pc].sBx end
					pc = pc + 1
				end
			else
				--[[TFORLOOP]]
				local A = inst.A
				local base = A + 3

				local vals = {memory[A](memory[A + 1], memory[A + 2])}

				table_move(vals, 1, inst.C, base, memory)

				if memory[base] ~= nil then
					memory[A + 2] = memory[base]
					pc = pc + code[pc].sBx
				end

				pc = pc + 1
			end
		else
			--[[JMP]]
			pc = pc + inst.sBx
		end

		state.pc = pc
	end
end

function lua_wrap_state(proto, env, upval)
	local function wrapped(...)
		local passed = table_pack(...)
		local memory = {}
		local vararg = {len = 0, list = {}}

		table_move(passed, 1, proto.num_param, 0, memory)

		if proto.num_param < passed.n then
			local start = proto.num_param + 1
			local len = passed.n - proto.num_param

			vararg.len = len
			table_move(passed, start, start + len - 1, 1, vararg.list)
		end

		local state = {vararg = vararg, memory = memory, code = proto.code, subs = proto.subs, pc = 1}

		local result = table_pack(pcall(run_lua_func, state, env, upval))

		if result[1] then
			return unpack(result, 2, result.n)
		else
			local failed = {pc = state.pc, source = proto.source, lines = proto.lines}

			on_lua_error(failed, result[2])

			return
		end
	end

	return wrapped
end

encryptVM_1 = {
	bc_to_state = lua_bc_to_state,
	wrap_state = lua_wrap_state,
	OPCODE_RM = OPCODE_RM,
	OPCODE_T = OPCODE_T,
	OPCODE_M = OPCODE_M,
}

end
function scmframework_436482ce69bd4b19b82a1187e4af2b67() --$CONTENT_DATA/Scripts/env.lua
--dofile("$CONTENT_DATA/Scripts/externAddonAPI.lua")
dofile("$CONTENT_DATA/Scripts/defaultLibs.lua")

local function makeMsg(...)
    local printResult = ""
    local args = {...}
    local len = 0
    for i in pairs(args) do
        if i > len then
            len = i
        end
    end
    
    for i = 1, len do
        local str = tostring(args[i])
        printResult = printResult .. str
        if i ~= len then
            local strlen = #str
            local dtablen = 8
            local tablen = 0
            while tablen <= 0 do
                tablen = dtablen - strlen
                dtablen = dtablen + 8
            end
            printResult = printResult .. string.rep(" ", tablen * 2)
        end
    end

    --printResult = string.gsub(printResult, "\n", "%[NL%]")
    return printResult
end

local function log(self, ...)
    local msg = makeMsg(...)
    if sm.isServerMode() then
        if not self.logMsg then self.logMsg = {} end
        table.insert(self.logMsg, msg)
    else
        sc.lastComputer:cl_logMessage(msg)
    end
end

local function warning(self, msg)
    log(self, "#d69201WARNING: " .. tostring(msg))
end

local function checkAllowMessage(self, methodName)
    if not self.localScriptMode.allowChat then
        --error("print/alert/debug methods are disabled", 3)
        warning(self, "'" .. methodName .. "' has been disabled in the Permission Tool")
    end
    return self.localScriptMode.allowChat
end

local function isolationCheck(isolation)
    if isolation then
        error("this feature is disabled for an isolated environment", 3)
    end
end

function addEnvBetterAPIFeatures(self, env)
	local coroutine = sc.getApi("coroutine")
    if coroutine and sc.coroutineFixed() then
        env.coroutine = {
            create = coroutine.create,
            status = coroutine.status,

            running = function()
                local th = coroutine.running()
                if self.th and th == self.th then
                    return
                end
                return th
            end,
            
            resume = function(co, ...)
                checkArg(1, co, "thread")
                local args = table.pack(...)
                while true do
                    local result = table.pack(
                    coroutine.resume(co, table.unpack(args, 1, args.n)))
                    if result[1] then
                        if coroutine.status(co) == "dead" then
                            return true, table.unpack(result, 2, result.n)
                        elseif result[2] ~= nil then
                            args = table.pack(coroutine.yield(result[2]))
                        else
                            return true, table.unpack(result, 3, result.n)
                        end
                    else
                        return false, result[2]
                    end
                end
            end,
            
            wrap = function(f) -- for bubbling coroutine.resume
                local co = coroutine.create(f)
                return function(...)
                    local result = table.pack(env.coroutine.resume(co, ...))
                    if result[1] then
                        return table.unpack(result, 2, result.n)
                    else
                        error(result[2], 0)
                    end
                end
            end,

            yield = function(...)
                return coroutine.yield(nil, ...)
            end
        }

        function env.sleep(ticks)
            sc.selfCoroutineCheck(self)
            coroutine.yield(ticks)
        end
    end

    if better and better.isAvailable() then
        env.os.date = env.os.date or better.date
    end
end

function addEnvLuaCompatibilityFeatures(self, env)
	env.table.unpack = env.unpack
    
    function env.math.tointeger(x)
        local num = tonumber(x)
        if num then
            local v1, v2 = math.modf(num)
            if v2 == 0 then
                return v1
            end
        end
    end

    function env.math.type(x)
        if type(x) == "number" then
            local v1, v2 = math.modf(x)
            if v2 == 0 then
                return "integer"
            else
                return "float"
            end
        end
    end

    function env.math.ult(m, n)
        local _, v1 = math.modf(m)
        local _, v2 = math.modf(n)
        if v1 ~= 0 then
            error("bad argument #1 to 'ult' (number has no integer representation)", 2)
        end
        if v2 ~= 0 then
            error("bad argument #2 to 'ult' (number has no integer representation)", 2)
        end
        return m < n
    end
end

function envLuaLibTweaks(self, env)
	env.math.randomseed = nil --this method is not in the game, but if it is added, it STILL should not be in SComputers
    if isTweaksAvailable() then
        env.string.rep = customRep --in the case of ("str").rep(), the "tweaks" method in the "methods.lua" file will work
    end
end

function envBase(self, env, fromProcessLibrary, isolation)
	env._VERSION = sc.restrictions.vm
	env.checkArg = checkArg --это не стандартный метод lua он был взят из opencomputers(machine.lua) и определен в methods.lua

	local bit32 = _G.bit32 or _G.bit --я знаю что это странно
    local bit = _G.bit or _G.bit32
    local pcall, xpcall = pcall, xpcall

    env.isBetterAPI = function()
        return not not (better and better.isAvailable())
    end

	env.class = function (super) --custom class function(more secure, does not allow access to setmetatable)
		local class = sc.mt_hook({__call = function(class)
			local obj = {}
			for k, v in pairs(class) do
				obj[k] = v
			end
			return obj
		end})
	
		if super then
			for k,v in pairs(super) do
				class[k] = v
			end
			class.super = super
		end
	
		return class
	end

	env.alert = function (...)
        isolationCheck(isolation)
		if self.storageData and self.storageData.dislogs then return end
		sc.coroutineCheck()
		if checkAllowMessage(self, "alert") then
			local msg = makeMsg(...)
			if sm.isServerMode() then
				--sc.lastComputer.network:sendToClients("cl_alertMessage", msg)
				if not self.alertMsg then self.alertMsg = {} end
				table.insert(self.alertMsg, msg)
			else
				sc.lastComputer:cl_alertMessage(msg)
			end
		end
	end

	env.print = function (...)
        isolationCheck(isolation)
		if self.storageData and self.storageData.dislogs then return end
		sc.coroutineCheck()
		if checkAllowMessage(self, "print") then
			local msg = makeMsg(...)
			if sm.isServerMode() then
				--sc.lastComputer.network:sendToClients("cl_chatMessage", msg)
				if not self.printMsg then self.printMsg = {} end
				table.insert(self.printMsg, msg)
			else
				sc.lastComputer:cl_chatMessage(msg)
			end
		end
	end

	env.debug = function (...)
        isolationCheck(isolation)
		if self.storageData and self.storageData.dislogs then return end
		if checkAllowMessage(self, "debug") then
			print(...)
		end
	end

	env.log = function(...)
        isolationCheck(isolation)
		if self.storageData and self.storageData.dislogs then return end
		sc.coroutineCheck()
		log(self, ...)
	end

	env.logPrint = function(...)
        isolationCheck(isolation)
		if self.storageData and self.storageData.dislogs then return end
		sc.coroutineCheck()
		if self.localScriptMode.allowChat then
			local msg = makeMsg(...)
			if sm.isServerMode() then
				if not self.printMsg then self.printMsg = {} end
				table.insert(self.printMsg, msg)
			else
				sc.lastComputer:cl_chatMessage(msg)
			end
		end
		log(self, ...)
	end

	env.warning = function(msg)
        isolationCheck(isolation)
		if self.storageData and self.storageData.dislogs then return end
		sc.coroutineCheck()
		warning(self, msg)
	end

	env.tostring = tostring
	env.tonumber = tonumber
	env.type = type

	env.utf8 = sc.deepcopy(utf8)
	env.string = sc.deepcopy(defaultLibs.string)
	env.table = sc.deepcopy(defaultLibs.table)
	env.math = sc.deepcopy(defaultLibs.math)
	env.bit = sc.deepcopy(bit)
	env.bit32 = sc.deepcopy(bit32)

	env.os = {
		clock = os.clock,
		date = os.date, --os.data is not in Scrap Mechanic, but if it appears, it will appear in SComputers
		difftime = os.difftime,
		--execute = os.execute,
		--exit = os.exit,
		--getenv = os.getenv,
		--remove = os.remove,
		--rename = os.rename,
		--setlocale = os.setlocale,
		time = os.time,
		--tmpname = os.tmpname
	}

	env.assert = assert
	env.error = error
	env.ipairs = ipairs
	env.pairs = pairs
	env.next = next
	env.select = select
	env.unpack = unpack

	env.pcall = function (...)
		sc.yield()
		local ret = {pcall(...)}
		sc.yield()
		return unpack(ret)
	end

	env.xpcall = function (...)
		sc.yield()
		local ret = {xpcall(...)}
		sc.yield()
		return unpack(ret)
	end

	env.load = function (chunk, chunkname, mode, lenv)
		return safe_load_code(self, chunk, chunkname, mode, lenv or env)
	end

	env.loadstring = function (chunk, lenv)
		local ret = {safe_load_code(self, chunk, nil, "t", lenv or env)}
		if not ret[1] then
			error(ret[2], 2)
		end
		return unpack(ret)
	end

	env.execute = function (chunk, lenv, ...)
		local ret = {safe_load_code(self, chunk, nil, "t", lenv or env)}
		if not ret[1] then
			error(ret[2], 2)
		end
		return ret[1](...)
	end
end

function createSafeEnv(self, settings, fromProcessLibrary, isolation)
    --методы ninput, input, getChildComputers, getParentComputers были переделанны на ipairs вместо pairs
    --чтобы сохранялся порядок подключений

    local localLibs = {}
    local requireSelf = self
    if isolation then
        requireSelf = {realself = self} --we use a separate library cache for an isolated environment
    end

	local env
	env = {
        require = function (name)
            checkArg(1, name, "string")
            sc.coroutineCheck()
            if localLibs[name] then
                return localLibs[name]
            end
            return scomputers.require(requireSelf, name)
        end,

		getmetatable = function (t) return t.__metatable or {} end,
		setmetatable = function (t1, t2) t1.__metatable = t2 end,

        sm = {
            vec3 = sc.deepcopy(sm.vec3),
            util = sc.deepcopy(sm.util),
            quat = sc.deepcopy(sm.quat),
            noise = sc.deepcopy(sm.noise),
            color = sc.deepcopy(sm.color),
            uuid = sc.deepcopy(sm.uuid),
            json = {
                parseJsonString = function (str)
                    checkArg(1, str, "string")
                    return sm.json.parseJsonString(str)
                end,
                writeJsonString = function (obj)
                    checkArg(1, obj, "table")
                    jsonEncodeInputCheck(obj, 0)
                    return sm.json.writeJsonString(obj)
                end,
            },
            game = {
                getCurrentTick = sm.game.getCurrentTick,
                getServerTick = sm.game.getServerTick
            },
            projectile = {
                solveBallisticArc = sm.projectile.solveBallisticArc
            }
        },

        encryptCode = function(message)
            checkArg(1, message, "string", "nil")
            isolationCheck(isolation)
            if self.storageData.encryptCode then
                return false
            end
            if self.new_code then
                self.storageData.script = self.new_code
                self.new_code = nil
            end
            self.encrypt_flag = true
            self.encrypt_msg = message
            return true
        end,
        isCodeEncrypted = function()
            isolationCheck(isolation)
            return not not self.storageData.encryptCode
        end,

        getreg = function (n)
            isolationCheck(isolation)
            return self.registers[n]
        end,
        setreg = function (n, v)
            isolationCheck(isolation)
            if type(v) == "boolean" or type(v) == "number" then
                self.registers[n] = v
            else
                error("Value must be number or boolean", 2)
            end
        end,

        out = function (p)
            sc.coroutineCheck()
            isolationCheck(isolation)
            if not self.interactable then return end

            if type(p) == "number" then
                self.currentOutputActive = p ~= 0
                self.currentOutputPower = p
                self.interactable:setActive(p ~= 0)
                self.interactable:setPower(p)
            elseif type(p) == "boolean" then
                self.currentOutputActive = p
                self.currentOutputPower = p and 1 or 0
                self.interactable:setActive(p)
                self.interactable:setPower(p and 1 or 0)
            else
                error("Type must be number or boolean", 2)
            end
        end,

        input = function (color)
            sc.coroutineCheck()
            isolationCheck(isolation)
            if not self.interactable then return false end

            if color then
                color = sc.formatColorStr(color)
                
                for i, v in ipairs(self.interactable:getParents(sm.interactable.connectionType.logic)) do
                    local p_color = sc.formatColorStr(v.shape.color)
                    
                    if p_color == color and v:isActive() then
                        return true
                    end
                end
            else
                for i, v in ipairs(self.interactable:getParents(sm.interactable.connectionType.logic)) do
                    if v:isActive() then
                        return true
                    end
                end
            end
            return false
        end,

        ninput = function (color)
            sc.coroutineCheck()
            isolationCheck(isolation)
            if not self.interactable then return {} end

            if color then
                color = sc.formatColorStr(color)

                local out = {}
                for i, v in ipairs(self.interactable:getParents()) do
                    local p_color = sc.formatColorStr(v.shape.color)
                    if p_color == color then
                        table.insert(out, v:getPower())
                    end
                end
                return out
            else
                local out = {}
                for i, v in ipairs(self.interactable:getParents()) do
                    table.insert(out, v:getPower())
                end
                return out
            end
        end,

        clearregs = function ()
            isolationCheck(isolation)
            for k in pairs(self.registers) do
                self.registers[k] = nil
            end
        end,

        getParentComputers = function ()
            sc.coroutineCheck()
            isolationCheck(isolation)
            if not self.interactable then return {} end

            local ret = {}
            local datas = sc.computersDatas
            for i, v in ipairs(self.interactable:getParents(sm.interactable.connectionType.composite)) do
                local data = datas[v:getId()]
                if data and not data.self.storageData.invisible and data.public then
                    table.insert(ret, data.public)
                end
            end
            return ret
        end,

        getChildComputers = function ()
            sc.coroutineCheck()
            isolationCheck(isolation)
            if not self.interactable then return {} end
            
            local ret = {}
            local datas = sc.computersDatas
            for i, v in ipairs(self.interactable:getChildren(sm.interactable.connectionType.composite)) do
                local data = datas[v:getId()]
                if data and not data.self.storageData.invisible and data.public then
                    table.insert(ret, data.public)
                end
            end
            return ret
        end,
        

		setLock = function (state)
            checkArg(1, state, "boolean", "nil")
            isolationCheck(isolation)
            self.storageData.__lock = not not state
		end,
        getLock = function ()
            isolationCheck(isolation)
			return not not self.storageData.__lock
		end,



        setCode = function (code)
            checkArg(1, code, "string")
            if #code > self.maxcodesize then
                error(self.maxCodeSizeStr, 2)
            end
            isolationCheck(isolation)
            self.storageData.encryptCode = false
            self.storageData.encryptedCode = nil
            self.new_code = code
        end,
        getCode = function ()
            isolationCheck(isolation)
            return self.storageData.script or ""
        end,

        setEncryptedCode = function(bytecode, message)
            checkArg(1, bytecode, "string")
            checkArg(2, message, "string", "nil")
            isolationCheck(isolation)
            if #bytecode > self.maxcodesize then
                error(self.maxCodeSizeStr, 2)
            end
            self.storageData.encryptCode = false
            self.storageData.encryptedCode = nil
            self.new_ecode = bytecode
            self.new_ecode_msg = message
        end,


        setData = function (data)
            checkArg(1, data, "string")
            if #data > (1024 * 4) then
                error("the maximum userdata size is 4KB", 2)
            end
            isolationCheck(isolation)
            self.storageData.userdata = base64.encode(data)
            self.storageData.userdata_bs64 = true
        end,
        getData = function ()
            isolationCheck(isolation)
            if self.storageData.userdata then
                if self.storageData.userdata_bs64 then
                    return (base64.decode(self.storageData.userdata))
                else
                    return self.storageData.userdata
                end
            else
                return ""
            end
        end,
        setTable = function(tbl)
            checkArg(1, tbl, "table")
            env.setData(json.encode(tbl))
        end,
        getTable = function()
            local ok, tbl = pcall(json.decode, env.getData())
            if ok and type(tbl) == "table" then
                return tbl
            end
            return {}
        end,
        


        setInvisible = function (state) --when you turn on your computer, it will be impossible to detect using getParentComputers and getChildComputers. however, you can still provide the API using setComponentApi
            checkArg(1, state, "boolean", "nil")
            isolationCheck(isolation)
            self.storageData.invisible = not not state
        end,
        getInvisible = function ()
            isolationCheck(isolation)
            return not not self.storageData.invisible
        end,



        setAlwaysOn = function (state)
            checkArg(1, state, "boolean")
            isolationCheck(isolation)
            self.storageData.alwaysOn = state
        end,
        getAlwaysOn = function ()
            isolationCheck(isolation)
            return not not self.storageData.alwaysOn
        end,



        setComponentApi = function (name, api)
            checkArg(1, name, "string", "nil")
            checkArg(2, api,  "table",  "nil")
            isolationCheck(isolation)
            if name and api then
                self.customcomponent_name = name
                self.customcomponent_api = api
            end
            self.customcomponent_flag = true
        end,
        getComponentApi = function ()
            isolationCheck(isolation)
            return self.customcomponent_name, self.customcomponent_api
        end,


        
        reboot = function ()
            isolationCheck(isolation)
            if self.storageData.noSoftwareReboot then
                error("this computer cannot be restarted programmatically", 2)
                return
            end
            
            self.software_reboot_flag = true
        end,
        getCurrentComputer = function ()
            isolationCheck(isolation)
            return self.publicTable.public
        end,
        getComponents = function (name)
            checkArg(1, name, "string")
            sc.coroutineCheck()
            isolationCheck(isolation)
            return sc.getComponents(self, name, settings)
        end,
        getComponent = function(name)
            checkArg(1, name, "string")
            sc.coroutineCheck()
            isolationCheck(isolation)
            local components = sc.getComponents(self, name, settings)
            if #components > 0 then
                return components[1]
            else
                error("the \"" .. name .. "\" component is missing", 2)
            end
        end,
        getMaxAvailableCpuTime = function ()
            return round(self.localScriptMode.cpulimit or sc.restrictions.cpu, 5)
        end,

        getDeltaTime = function ()
            return sc.deltaTime or 0
        end,
        getDeltaTimeTps = function ()
            return sc.deltaTimeTps or 0
        end,

        getSkippedTicks = function ()
            return self.skipped or 0
        end,
        getLagScore = function ()
            return self.lagScore or 0
        end,
        getUptime = function ()
            return self.uptime or 0
        end,
        getTick = function ()
            return self.computerTick or 0
        end,

        getDeviceType = function()
            isolationCheck(isolation)
            if self.interactable then
                return "computer"
            elseif self.tool then
                return "tablet"
            else
                return "unknown"
            end
        end,

        --limitations of the amount of RAM in development
        getUsedRam = function ()
            return self.usedRam or 0
        end,
        getTotalRam = function ()
            return self.cdata.ram or 0
        end,

        isComponentAvailable = function(componentTable)
            checkArg(1, componentTable, "table")
            return (not not pcall(componentTable[1]))
        end,

        getMotorByLabel = function(label)
            checkArg(1, label, "string")
            sc.coroutineCheck()
            isolationCheck(isolation)
            local components = env.getMotorsByLabel(label)
            if #components > 0 then
                return components[1]
            else
                error("there is no \"motor\" with the \"" .. label .."\" label", 2)
            end
        end,
        getMotorsByLabel = function(label)
            checkArg(1, label, "string")
            sc.coroutineCheck()
            isolationCheck(isolation)
            return sc.getComponents(self, "motor", settings, function (publicData)
                return publicData and publicData.label == label
            end)
        end,

        getComponentByLabel = function(componentType, label)
            checkArg(1, componentType, "string")
            checkArg(2, label, "string")
            sc.coroutineCheck()
            isolationCheck(isolation)
            local components = env.getComponentsByLabel(componentType, label)
            if #components > 0 then
                return components[1]
            else
                error("there is no \"" .. componentType .."\" with the \"" .. label .."\" label", 2)
            end
        end,
        getComponentsByLabel = function(componentType, label)
            checkArg(1, componentType, "string")
            checkArg(2, label, "string")
            isolationCheck(isolation)
            sc.coroutineCheck()
            if componentType == "motor" then
                return env.getMotorsByLabel(label)
            else
                return sc.getComponents(self, componentType, settings, function (publicData)
                    if not publicData or not publicData.sc_component or not publicData.sc_component.label then
                        return false
                    end
                    return publicData.sc_component.label() == label
                end)
            end
        end
	}
	envBase(self, env, fromProcessLibrary, isolation)

    if isolation then
        requireSelf.env = env
    end

    ---------------- better api

    addEnvBetterAPIFeatures(self, env)

    ---------------- compatibility with new versions of lua

    addEnvLuaCompatibilityFeatures(self, env)

    ---------------- links

    env._G = env
    env._ENV = env
    env.sci = env --для совместимости

    ---------------- legacy
    
    env.getDisplays = function ()
        return env.getComponents("display")
    end

    env.getMotors = function ()
        return env.getComponents("motor")
    end
    
    env.getRadars = function ()
        return env.getComponents("radar")
    end
    
    env.getPorts = function ()
        return env.getComponents("port")
    end

    env.getDisks = function ()
        return env.getComponents("disk")
    end

    env.getCameras = function ()
        return env.getComponents("camera")
    end

    env.getHoloprojectors = function ()
        return env.getComponents("holoprojector")
    end

    env.getSynthesizers = function ()
        return env.getComponents("synthesizer")
    end

    env.getLeds = function ()
        return env.getComponents("led")
    end

    env.getKeyboards = function ()
		return env.getComponents("keyboard")
	end

    env.getParentComputersData = env.getParentComputers
    env.getChildComputersData = env.getChildComputers
    env.getConnectedDisplaysData = env.getDisplays
    env.getConnectedMotorsData = env.getMotors
    env.getConnectedRadarsData = env.getRadars

    env.getLagsScore = env.getLagScore

    ---------------- safety

    if env.coroutine and not sc.coroutineFixed() then
        local function disableCoroutine(api)
            for funcname, func in pairs(api) do
                api[funcname] = function (...)
                    sc.coroutineCheck()
                    local result = {pcall(func, ...)}
                    if result[1] then
                        return unpack(result, 2)
                    else
                        error(result[2], 2)
                    end
                end
            end
        end

        for apiname, api in pairs(env.sm) do
            disableCoroutine(api) --you can't call scrapmechanic methods from coroutine because it calls bugsplat
        end
    end

    local positiveModulo = sm.util.positiveModulo
    env.sm.util.positiveModulo = function (x, n) --для предотвашения bugsplat
        checkArg(1, x, "number")
        checkArg(2, n, "number")
        if n ~= 0 and math.floor(n) == n then
            return positiveModulo(x, n)
        end
        error("cannot be divided by " .. (tostring(n) or ""), 2)
    end

    envLuaLibTweaks(self, env)

    do
        local whook = "withoutHook_"
        local tblChecked = {}
        local function deleteFunctionsWithoutHook(tbl)
            if tblChecked[tbl] then
                return
            end
            tblChecked[tbl] = true

            for key, value in pairs(tbl) do
                if type(key) == "string" and key:sub(1, #whook) == whook then
                    tbl[key] = nil
                else
                    local t = type(value)
                    if t == "table" then
                        deleteFunctionsWithoutHook(value)
                    end
                end
            end
        end
        deleteFunctionsWithoutHook(env)
    end

    localLibs.utf8 = env.utf8
    localLibs.math = env.math
    localLibs.string = env.string
    localLibs.table = env.table
    localLibs.os = env.os
    localLibs.bit = env.bit
    localLibs.bit32 = env.bit32

    ---------------- env hooks

    for i, hook in ipairs(sc.envhooks) do
        print("envhook (" .. i .."): ", pcall(hook, self, env))
    end

    if self.defaultData.localEnvHook then --can be set when using scmframework
        self.defaultData.localEnvHook(self, env)
    end

	return env
end

function createUnsafeEnv(self, settings, fromProcessLibrary, isolation)
	local env = createSafeEnv(self, settings, fromProcessLibrary, isolation)

	env.global = _G
	env.self = self
	env.sm = sm
    env.dlm = dlm

    env.clientInvoke = function (code, ...)
        checkArg(1, code, "string")
        table.insert(self.clientInvokes, {code, self.localScriptMode.scriptMode ~= "unsafe", {...}, self.rebootId})
    end

    env.clientInvokeTo = function (player, code, ...)
        checkArg(1, player, "string", "Player")
        checkArg(2, code, "string")
        table.insert(self.clientInvokes, {code, self.localScriptMode.scriptMode ~= "unsafe", {...}, self.rebootId, player = player})
    end

	return env
end

function createClientEnv(self)
	local env = {}

	envBase(self, env)

	env.global = _G
	env.self = self
	env.sm = sm
    env.dlm = dlm

	env.serverInvoke = function (code, ...)
        checkArg(1, code, "string")
        table.insert(self.serverInvokes, {code, {...}})
    end

	addEnvBetterAPIFeatures(self, env)
    addEnvLuaCompatibilityFeatures(self, env)
	envLuaLibTweaks(self, env)

	for i, hook in ipairs(sc.cl_envhooks) do
        print("client envhook (" .. i .."): ", pcall(hook, self, env))
    end

    if self.defaultData.localEnvHook then --can be set when using scmframework
        self.defaultData.localEnvHook(self, env)
    end

	return env
end
end
function scmframework_6769232c3e7335cfa1cf00b3fd2b56de() --$CONTENT_DATA/Scripts/exampleComponent.lua
exampleComponent = class()
exampleComponent.maxParentCount = 1
exampleComponent.maxChildCount = 0
exampleComponent.connectionInput = sm.interactable.connectionType.composite
exampleComponent.connectionOutput = sm.interactable.connectionType.none
exampleComponent.colorNormal = sm.color.new(0x7F7F7Fff)
exampleComponent.colorHighlight = sm.color.new(0xFFFFFFff)
exampleComponent.componentType = "example" --absences can cause problems

function exampleComponent:server_onCreate()
    self.interactable.publicData = {
        sc_component = {
            type = exampleComponent.componentType,
            api = {
                test = function()
                    return "ok"
                end
            }
        }
    }
end
end
function scmframework_7cf856069646da8281f98cd097b93053() --$CONTENT_DATA/Scripts/examples.lua
--[[
_g_examples = nil

function loadExample(self, widgetName, text)
    if widgetName == "exmpnum" then
        self.lastExampleStr = text
        return
    elseif widgetName == "exmpload" then
        if self.lastExampleStr then
            local example = _g_examples[self.lastExampleStr] or _g_examples[self.lastExampleStr:gsub(" ", "_")] or _g_examples_num[tonumber(self.lastExampleStr) or false]
            if example then
                ScriptableComputer.cl_setText(self, example)
            else
                self:cl_internal_alertMessage("failed to load an example")
            end
        end
    end
end

function exampleLabelConvert(name)
    return name:gsub("_", " ")
end

function initExamples()
    if not _g_examples then
        _g_examples_lastI = 0
        _g_examples_labels = {}
        _g_examples_num = {}

        _g_examples = sm.json.open(sc.modPrefix .. "/Scripts/examples/examples.json")
        local list = {}
        for k, v in pairs(_g_examples) do
            table.insert(list, k)
            _g_examples[k] = base64.decode(v)
        end
        table.sort(list)
        
        for _, name in ipairs(list) do
            _g_examples_lastI = _g_examples_lastI + 1
            _g_examples_num[_g_examples_lastI] = _g_examples[name]
            _g_examples_labels[_g_examples_lastI] = exampleLabelConvert(name)
        end
    end
end


function addCustomExample(name, code)
    initExamples()
    _g_examples_lastI = _g_examples_lastI + 1
    _g_examples_labels[_g_examples_lastI] = exampleLabelConvert(name)
    _g_examples[name] = code
    _g_examples_num[_g_examples_lastI] = _g_examples[name]
end

function bindExamples(self)
    initExamples()
    updateExamples(self)
    self.gui:setButtonCallback("exmpload", "cl_onExample")
    self.gui:setTextChangedCallback("exmpnum", "cl_onExample")
end

function updateExamples(self, search)
    local text = {}
    if search and search ~= "" then
        search = search:lower()
        for i, name in ipairs(_g_examples_labels) do
            if name:lower():find(search) then
                table.insert(text, tostring(i))
                table.insert(text, ". ")
                table.insert(text, name)
                table.insert(text, "\n")
            end
        end
    else
        for i, name in ipairs(_g_examples_labels) do
            table.insert(text, tostring(i))
            table.insert(text, ". ")
            table.insert(text, name)
            table.insert(text, "\n")
        end
    end
    table.remove(text, #text)
    self.gui:setText("exmplist", table.concat(text))
end
]]

scExamples_binded = scExamples_binded or {}
scExamples_list = scExamples_list or {}

local function initArchitecture(architecture)
    if not scExamples_binded[architecture] then scExamples_binded[architecture] = {} end
    if not scExamples_list[architecture] then scExamples_list[architecture] = {} end
end

function addCustomExample(name, code, architecture, bottom)
    architecture = architecture or "lua"
    initArchitecture(architecture)
    if scExamples_binded[architecture][name] then
        for _, data in ipairs(scExamples_list[architecture]) do --example overwrite
            if data[1] == name then
                data[2] = code
                break
            end
        end
        return
    end
    scExamples_binded[architecture][name] = true
    if bottom then
        table.insert(scExamples_list[architecture], 1, {name, code})
    else
        table.insert(scExamples_list[architecture], {name, code})
    end
end

local examplesCache = {}
function loadExamples(path, architecture)
    if examplesCache[path] then return examplesCache[path] end
    path = path or (sc.modPrefix .. "/Scripts/examples/examples.json")
    architecture = architecture or "lua"
    initArchitecture(architecture)

    do
        local sortedNames = {}
        local rawExamples
        if not __SCMFRAMEWORK then
            rawExamples = sm.json.open(path)
        else
            rawExamples = {}
        end
        for name in pairs(rawExamples) do
            table.insert(sortedNames, name)
        end
        table.sort(sortedNames, function(a, b) return a > b end)
        
        for _, name in ipairs(sortedNames) do
            addCustomExample(name:gsub("_", " "), base64.decode(rawExamples[name]), architecture, true)
        end
    end

    ---------------------------

    local examples = {}
    examples.list = {}
    examples.listKV = {}

    for index, data in ipairs(scExamples_list[architecture]) do
        table.insert(examples.list, data)
        local name = data[1]:lower()
        examples.listKV[name] = data[2]
        examples.listKV[tostring(index) .. ". " .. name] = data[2]
    end

    function examples.getList(search)
        local text = {}
        
        local function searchCheck(name)
            if search and search ~= "" then
                return not not name:lower():find(search:lower())
            end
            return true
        end

        for index, data in ipairs(examples.list) do
            if searchCheck(data[1]) then
                table.insert(text, tostring(index))
                table.insert(text, ". ")
                table.insert(text, data[1])
                table.insert(text, "\n")
            end
        end

        table.remove(text, #text)
        return table.concat(text)
    end

    function examples.load(name)
        name = tostring(name)

        local index = tonumber(name)
        if index and examples.list[index] then
            return examples.list[index][2]
        end

        return examples.listKV[name:lower()]
    end

    examplesCache[path] = examples
    return examples
end
end
function scmframework_f1cfeeadb5cb242cc8ffb2784c405807() --$CONTENT_DATA/Scripts/FileSystem.lua
FileSystem = {}
FileSystem.__index = FileSystem

FileSystem.strSplit = strSplit

function FileSystem.new(maxSize)
    local instance = sc.setmetatable({}, FileSystem)

    instance.root = Folder.new("")
    instance.currentFolderPath = {}
    instance.maxSize = maxSize
    instance.currentSize = 0

    return instance
end

function FileSystem.parsePath(pathStr)
    local path = {}
    local insert = table.insert

    for i, v in pairs(strSplit(string, pathStr, {"/"})) do
        insert(path, v)
    end

    --[[
    for i, v in ipairs(path) do
        if v == "" then-- and not i == #path) then
            error("cannot parse empty name in path "..pathStr)
        end
    end

    insert(path, 1, "")
    ]]
    if path[#path] == "" then
        table.remove(path, #path)
    end
    --if pathStr:sub(1, 1) == "/" then
    --    insert(path, 1, "")
    --end

    return path
end

function FileSystem.concatPaths(basepath, to)
    local path
    --print("concatPaths 1", path, to)

    if to[1] == "" then --при не относительном пути базовый путь - пустой
        table.remove(to, 1)
        path = {""} --шоб не срабатывала проверка на пустой элемент
    else
        path = sc.deepcopy(basepath) --при относительном пути копируеться "базовый" путь
    end

    local insert = table.insert --обработка должна происходить даже на неотносительных путиях, так как иначе не будут работать ".." и "."
    local remove = table.remove
    for i, v in ipairs(to) do
        FileSystem._checkObjectName(v) --шоб небыло пустых элементов в пути
        if v == "." then
            --empty
        elseif v == ".." then
            if #path > 0 then
                remove(path)
            else
                --error("path .. underflow")
            end
        else
            insert(path, v)
        end
    end

    --print("concatPaths 2", path)
    return path
end

function FileSystem:_updateCurrentPath(path)
    local newCurrentPath = FileSystem.concatPaths(self.currentFolderPath, path)
    if #newCurrentPath > 1024 then
        error("what the hell are you doing?", 3)
    end
    self.currentFolderPath = newCurrentPath
end

function FileSystem:_checkHaveMemory(deltaSize)
    return self:getUsedSize() + deltaSize <= self.maxSize
end

function FileSystem._checkObjectName(name)
    if not name or name == "" then
        error("the folder/file name cannot be empty", 3)
    elseif name:find("/") then
        error("the folder/file name cannot contain the character /", 3)
    end
end


function FileSystem:createFile(path)
    local path = FileSystem.concatPaths(self.currentFolderPath, FileSystem.parsePath(path))
    local target = table.remove(path)
    self._checkObjectName(target)

    local folder = self:_getFolder(path)
    if not self:_checkHaveMemory(target:len()) then
        error("Out of Memory!/No Memory.", 2)
    end

    self.currentSize = self.currentSize + target:len()
    folder:createFile(target)
end

function FileSystem:readFile(path)
    local path = FileSystem.concatPaths(self.currentFolderPath, FileSystem.parsePath(path))
    local file = self:_getFile(path)

    return file:readData()
end

function FileSystem:writeFile(path, data)
    if type(data) ~= "string" then
        error("only strings can be saved", 2)
    end

    local path = FileSystem.concatPaths(self.currentFolderPath, FileSystem.parsePath(path))
    local file = self:_getFile(path)

    local currentData = file:readData()
    local deltaSize = data:len() - currentData:len()

    if not self:_checkHaveMemory(deltaSize) then
        error("Out of Memory!/No Memory.", 2)
    end

    self.currentSize = self.currentSize + deltaSize
    return file:writeData(data)
end

function FileSystem:deleteFile(path)
    local path = FileSystem.concatPaths(self.currentFolderPath, FileSystem.parsePath(path))

    local target = table.remove(path)
    local folder = self:_getFolder(path)

    local fileSize = folder:getFile(target):getSize()

    self.currentSize = self.currentSize - fileSize
    folder:deleteFile(target)
end

function FileSystem:hasFile(path)
    local path = FileSystem.concatPaths(self.currentFolderPath, FileSystem.parsePath(path))
    local target = table.remove(path)

    local folder = self:_getFolder(path)
    if folder then
        return folder:containsFile(target)
    end
    return false
end

function FileSystem:createFolder(path)
    local path = FileSystem.concatPaths(self.currentFolderPath, FileSystem.parsePath(path))

    local target = table.remove(path)
    self._checkObjectName(target)
    local folder = self:_getFolder(path)

    if not self:_checkHaveMemory(target:len()) then
        error("Out of Memory!/No Memory.", 2)
    end

    self.currentSize = self.currentSize + target:len()
    folder:createFolder(target)
end

function FileSystem:deleteFolder(path)
    local path = FileSystem.concatPaths(self.currentFolderPath, FileSystem.parsePath(path))

    local target = table.remove(path)
    local folder = self:_getFolder(path)

    local targetFolder = folder:getFolder(target)

    if not targetFolder:isEmpty() then
        error("Cant delete non-empty folder "..table.concat(path, '/')..'/'..target, 2)
    end
    
    local targetSize = targetFolder:getSize()
    self.currentSize = self.currentSize - targetSize

    folder:deleteFolder(target)
end

function FileSystem:hasFolder(path)
    local path = FileSystem.concatPaths(self.currentFolderPath, FileSystem.parsePath(path))
    --local target = table.remove(path)

    local ok, folder = pcall(self._getFolder, self, path)
    return not not (ok and folder)
    --if folder then
    --    return folder:containsFolder(target)
    --end
    --return false
end

function FileSystem:getFolderSize(path)
    local path = FileSystem.concatPaths(self.currentFolderPath, FileSystem.parsePath(path))

    local target = table.remove(path)
    local folder = self:_getFolder(path)

    return folder:getSize()
end

function FileSystem:getFileSize(path)
    local path = FileSystem.concatPaths(self.currentFolderPath, FileSystem.parsePath(path))

    --local target = table.remove(path)
    local file = self:_getFile(path)

    return file:getSize()
end

function FileSystem:getFolderList(path)
    local path = FileSystem.concatPaths(self.currentFolderPath, FileSystem.parsePath(path))

    local folder = self:_getFolder(path)
    return folder:getFolderList()
end

function FileSystem:getFileList(path)
    local path = FileSystem.concatPaths(self.currentFolderPath, FileSystem.parsePath(path))

    local folder = self:_getFolder(path)
    return folder:getFileList()
end

function FileSystem:getUsedSize()
    return self.currentSize
end

function FileSystem:openFolder(path)
    local path = FileSystem.parsePath(path)
    self:_updateCurrentPath(path)
end

function FileSystem:getCurrentPath()
    local str = table.concat(self.currentFolderPath, "/")
    if str:sub(1, 1) ~= "/" then
        str = "/" .. str
    end
    return str
end

function FileSystem:_getFolder(fullPath)
    --assert(fullPath[1] == "")
    --if fullPath[1] ~= "" then return self.root end

    local path = sc.deepcopy(fullPath)
    if path[1] == "" then table.remove(path, 1) end
    if path[#path] == "" then table.remove(path) end

    local folder = self.root
    for i, v in ipairs(path) do
        folder = folder:getFolder(v)
    end

    return folder
end

function FileSystem:_getFile(fullPath)
    --assert(fullPath[1] == "")

    local path = sc.deepcopy(fullPath)
    if path[1] == "" then table.remove(path, 1) end

    local target = table.remove(path)

    local folder = self.root
    for i, v in ipairs(path) do
        folder = folder:getFolder(v)
    end

    return folder:getFile(target)
end

function FileSystem:serialize()
    local tbl = {
        r = self.root:serialize(),
        cs = self.currentSize,
        ms = self.maxSize,
        cf = sc.deepcopy(self.currentFolderPath)
    }
    return {jsondata = json.encode(tbl)} --нативный json скрапа баговал
end

function FileSystem.deserialize(t)
    if t.jsondata then
        if type(t.jsondata) == "table" then
            t = t.jsondata
        else
            t = json.decode(t.jsondata) --нативный json скрапа баговал
        end
    end
    --print(t)

    local fs = FileSystem.new(t.ms or t.maxSize)
    fs.currentSize = t.cs or t.currentSize
    fs.currentFolderPath = sc.deepcopy(t.cf or t.currentFolderPath)
    fs.root = Folder.deserialize(t.r or t.root)

    return fs
end

function FileSystem:clear()
    self.root = Folder.new("")
    self.currentFolderPath = {}
    self.currentSize = 0
end



Folder = {}
Folder.__index = Folder

function Folder.new(name)
    local instance = sc.setmetatable({}, Folder)

    instance.name = name
    instance.files = {}
    instance.folders = {}

    return instance
end

function Folder:createFolder(name)
    if self:containsFolder(name) then
        error("Folder "..name.." already exists", 3)
    end
    
    table.insert(self.folders, Folder.new(name))
end

function Folder:createFile(name)
    if self:containsFile(name) then
        error("File "..name.." already exists", 3)
    end
    
    table.insert(self.files, File.new(name))
end

function Folder:deleteFile(name)
    local index = -1

    for i, v in ipairs(self.files or {}) do
        if v.name == name then
            index = i
            break
        end
    end

    if index == -1 then
        error("File "..name.." doesn't exist", 3)
    end
    
    table.remove(self.files, index)
end

function Folder:deleteFolder(name)
    local index = -1

    for i, v in ipairs(self.folders or {}) do
        if v.name == name then
            index = i
            break
        end
    end

    if index == -1 then
        error("Folder "..name.." doesn't exist", 3)
    end
    
    table.remove(self.folders, index)
end

function Folder:getFolder(name)
    for k, v in ipairs(self.folders or {}) do
        if v.name == name then
            return v
        end
    end
    error("Folder "..name.." doesn't exist", 3)
end

function Folder:getFile(name)
    for k, v in ipairs(self.files or {}) do
        if v.name == name then
            return v
        end
    end
    error("File "..name.." doesn't exist", 3)
end

function Folder:getSize()
    local treeSize = 0

    for i, v in ipairs(self.files or {}) do
        treeSize = treeSize + v:getSize()
    end

    for i, v in ipairs(self.folders or {}) do
        treeSize = treeSize + v:getSize()
    end

    return self.name:len() + treeSize
end

function Folder:containsFile(name)
    for i, v in ipairs(self.files or {}) do
        if v.name == name then
            return true
        end
    end

    return false
end

function Folder:containsFolder(name)
    for i, v in ipairs(self.folders or {}) do
        if v.name == name then
            return true
        end
    end

    return false
end

function Folder:isEmpty()
    return #self.files == 0 and #self.folders == 0
end

function Folder:getFolderList()
    local ret = {}
    local insert = table.insert

    for i, v in ipairs(self.folders or {}) do
        insert(ret, v.name)
    end

    return ret
end

function Folder:getFileList()
    local ret = {}
    local insert = table.insert

    for i, v in ipairs(self.files or {}) do
        insert(ret, v.name)
    end

    return ret
end

function Folder:serialize()
    local insert = table.insert

    local files = {}
    for i, v in ipairs(self.files or {}) do
        insert(files, v:serialize())
    end

    local folders = {}
    for i, v in ipairs(self.folders or {}) do
        insert(folders, v:serialize())
    end

    return {
        n = self.name,
        f = files,
        d = folders,
    }
end

function Folder.deserialize(t)
    local folder = Folder.new(t.n or t.name)
    local insert = table.insert

    local folders = {}
    for i, v in ipairs(t.d or t.folders or {}) do
        insert(folders, Folder.deserialize(v))
    end

    local files = {}
    for i, v in ipairs(t.f or t.files or {}) do
        insert(files, File.deserialize(v))
    end

    folder.files = files
    folder.folders = folders

    return folder
end






File = {}
File.__index = File

function File.new(name)
    local instance = sc.setmetatable({}, File)

    instance.name = name
    instance.data = ""

    return instance
end

function File:getSize()
    return self.name:len() + self.data:len()
end

function File:writeData(data)
    self.data = data
end

function File:readData()
    return self.data
end

function File:serialize()
    return {
        n = self.name,
        d = base64.encode(self.data)
    }
end

function File.deserialize(t)
    --the keys has been changed to save space
    local file = File.new(t.n or t.name)
    if t.base64encoded or t.d then
        file.data = base64.decode(t.d or t.data)
    else
        file.data = t.d or t.data
    end

    return file
end









local fastsavePath = "/.fastsave"
function FileSystem.createFilesystemData(_, fs, changeFlagTarget, readonly)
    local function readonlyCheck()
        if readonly then
            error("this filesystem is read-only", 3)
        end
    end

    return {
        createFile = function (path)
            --sc.checkComponent(self)

            readonlyCheck()
            changeFlagTarget.changed = true
            return fs:createFile(path)
        end,
        readFile = function (path)
            --sc.checkComponent(self)
            return fs:readFile(path)
        end,
        writeFile = function (path, data)
            --sc.checkComponent(self)
            readonlyCheck()
            changeFlagTarget.changed = true
            return fs:writeFile(path, data)            
        end,
        deleteFile = function (path)
            --sc.checkComponent(self)
            readonlyCheck()
            changeFlagTarget.changed = true
            return fs:deleteFile(path)
        end,
        hasFile = function (path)
            --sc.checkComponent(self)
            
            return fs:hasFile(path)
        end,
        getFileSize = function (path)
            --sc.checkComponent(self)
            
            return fs:getFileSize(path)
        end,

        createFolder = function (path)
            --sc.checkComponent(self)

            readonlyCheck()
            changeFlagTarget.changed = true
            return fs:createFolder(path)
        end,
        deleteFolder = function (path)
            --sc.checkComponent(self)

            readonlyCheck()
            changeFlagTarget.changed = true
            return fs:deleteFolder(path)
        end,
        getFolderSize = function (path)
            --sc.checkComponent(self)
            return fs:getFolderSize(path)
        end,
        hasFolder = function (path)
            --sc.checkComponent(self)
            return fs:hasFolder(path)
        end,

        getUsedSize = function ()
            --sc.checkComponent(self)
            return fs:getUsedSize()
        end,
        getMaxSize = function ()
            return fs.maxSize
        end,
        getFileList = function (path)
            --sc.checkComponent(self)
            return fs:getFileList(path)
        end,
        getFolderList = function (path)
            --sc.checkComponent(self)
            return fs:getFolderList(path)
        end,
        openFolder = function (path)
            --sc.checkComponent(self)

            local sum1 = tableChecksum(fs.currentFolderPath)
            fs:openFolder(path)
            local sum2 = tableChecksum(fs.currentFolderPath)
            if sum1 ~= sum2 then
                changeFlagTarget.changed = true
            end
        end,
        getCurrentPath = function ()
            --sc.checkComponent(self)
            return fs:getCurrentPath()
        end,
        clear = function ()
            --sc.checkComponent(self)

            readonlyCheck()
            changeFlagTarget.changed = true
            return fs:clear()
        end,

        isReadOnly = function()
            return not not readonly
        end,


        --API for quick saving of settings (see the "simple disk using" example)
        setData = function (data)
            checkArg(1, data, "string")
            readonlyCheck()
            if not fs:hasFile(fastsavePath) then
                fs:createFile(fastsavePath)
            end
            fs:writeFile(fastsavePath, data)
            changeFlagTarget.changed = true
        end,
        getData = function ()
            if fs:hasFile(fastsavePath) then
                return fs:readFile(fastsavePath)
            else
                return ""
            end
        end,
        setTable = function(tbl)
            checkArg(1, tbl, "table")
            readonlyCheck()
            local data = json.encode(tbl)
            if not fs:hasFile(fastsavePath) then
                fs:createFile(fastsavePath)
            end
            fs:writeFile(fastsavePath, data)
            changeFlagTarget.changed = true
        end,
        getTable = function()
            local data
            if fs:hasFile(fastsavePath) then
                data = fs:readFile(fastsavePath)
            else
                return {}
            end

            local ok, tbl = pcall(json.decode, data)
            if ok and type(tbl) == "table" then
                return tbl
            end
            return {}
        end
    }
end

function FileSystem.createData(fs)
    local changeFlagTarget = {changed = false}
    local function isChange()
        local lchanged = changeFlagTarget.changed
        changeFlagTarget.changed = false
        return not not lchanged
    end
    return isChange, FileSystem.createFilesystemData(nil, fs, changeFlagTarget)
end

function FileSystem.createSelfData(self)
    return FileSystem.createFilesystemData(nil, self.fs, self)
end
end
function scmframework_021f604e3ea5b4538a5f31bc70aa9173() --$CONTENT_DATA/Scripts/FiOne_lua/example.lua
local env = getfenv(0)
local fio

local function wrap_func(fn)
	local bc = string.dump(fn)
	local state = fio.bc_to_state(bc)

	return fio.wrap_state(state, env)
end

fio = require('source')
-- fio = wrap_func(loadfile('source.lua'))() -- self running, uncomment to test

local sum = wrap_func(function(num)
	local ans = 0

	for i = 1, num do ans = ans + i end

	return ans
end)(100)

print(sum)

end
function scmframework_7f1ef98cf5402622769a3d2412f02b60() --$CONTENT_DATA/Scripts/FiOne_lua/lib.lua
dofile("$CONTENT_DATA/Scripts/FiOne_lua/source.lua")
dofile("$CONTENT_DATA/Scripts/remade-scrapVM/scrapvm.lua")

FiOne_lua.load = function(self, chunk, chunkname, env)
    if self and not self.luastate then
        self.luastate = {}
    end
    local tunnel, state = luavm.luaU:make_setS()
    local intershitator = luavm.luaY:parser(self.luastate, assert(luavm.luaZ:init(luavm.luaZ:make_getS(chunk))), nil, chunkname or "@code")
    luavm.luaU:dump(self.luastate, intershitator, tunnel, state)
    return FiOne_lua.wrap_state(FiOne_lua.bc_to_state(state.data), env)
end
end
function scmframework_5cdf353b546ce9b6d1b072b31a271bcb() --$CONTENT_DATA/Scripts/FiOne_lua/source.lua
--[[
FiOne
Copyright (C) 2021  Rerumu

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
]] --

--I (logic/bananapen) have made some modifications here for optimization and so that it does not pollute global variables.

local bit = bit or bit32 or require('bit')

local function table_pack(...)
	return {n = select('#', ...), ...}
end

local function table_move(src, first, last, offset, dst)
	for i = 0, last - first do
		dst[offset + i] = src[first + i]
	end
end

local lua_bc_to_state
local lua_wrap_state
local stm_lua_func

-- SETLIST config
local FIELDS_PER_FLUSH = 50

-- remap for better lookup
local OPCODE_RM = {
	-- level 1
	[22] = 18, -- JMP
	[31] = 8, -- FORLOOP
	[33] = 28, -- TFORLOOP
	-- level 2
	[0] = 3, -- MOVE
	[1] = 13, -- LOADK
	[2] = 23, -- LOADBOOL
	[26] = 33, -- TEST
	-- level 3
	[12] = 1, -- ADD
	[13] = 6, -- SUB
	[14] = 10, -- MUL
	[15] = 16, -- DIV
	[16] = 20, -- MOD
	[17] = 26, -- POW
	[18] = 30, -- UNM
	[19] = 36, -- NOT
	-- level 4
	[3] = 0, -- LOADNIL
	[4] = 2, -- GETUPVAL
	[5] = 4, -- GETGLOBAL
	[6] = 7, -- GETTABLE
	[7] = 9, -- SETGLOBAL
	[8] = 12, -- SETUPVAL
	[9] = 14, -- SETTABLE
	[10] = 17, -- NEWTABLE
	[20] = 19, -- LEN
	[21] = 22, -- CONCAT
	[23] = 24, -- EQ
	[24] = 27, -- LT
	[25] = 29, -- LE
	[27] = 32, -- TESTSET
	[32] = 34, -- FORPREP
	[34] = 37, -- SETLIST
	-- level 5
	[11] = 5, -- SELF
	[28] = 11, -- CALL
	[29] = 15, -- TAILCALL
	[30] = 21, -- RETURN
	[35] = 25, -- CLOSE
	[36] = 31, -- CLOSURE
	[37] = 35, -- VARARG
}

-- opcode types for getting values
local OPCODE_T = {
	[0] = 'ABC',
	'ABx',
	'ABC',
	'ABC',
	'ABC',
	'ABx',
	'ABC',
	'ABx',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'AsBx',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'AsBx',
	'AsBx',
	'ABC',
	'ABC',
	'ABC',
	'ABx',
	'ABC',
}

local OPCODE_M = {
	[0] = {b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgR', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgR'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgR', c = 'OpArgU'},
	{b = 'OpArgR', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgN', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgN', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
}

-- int rd_int_basic(string src, int s, int e, int d)
-- @src - Source binary string
-- @s - Start index of a little endian integer
-- @e - End index of the integer
-- @d - Direction of the loop
local function rd_int_basic(src, s, e, d)
	local num = 0

	-- if bb[l] > 127 then -- signed negative
	-- 	num = num - 256 ^ l
	-- 	bb[l] = bb[l] - 128
	-- end

	for i = s, e, d do
		local mul = 256 ^ math.abs(i - s)

		num = num + mul * string.byte(src, i, i)
	end

	return num
end

-- float rd_flt_basic(byte f1..8)
-- @f1..4 - The 4 bytes composing a little endian float
local function rd_flt_basic(f1, f2, f3, f4)
	local sign = (-1) ^ bit.rshift(f4, 7)
	local exp = bit.rshift(f3, 7) + bit.lshift(bit.band(f4, 0x7F), 1)
	local frac = f1 + bit.lshift(f2, 8) + bit.lshift(bit.band(f3, 0x7F), 16)
	local normal = 1

	if exp == 0 then
		if frac == 0 then
			return sign * 0
		else
			normal = 0
			exp = 1
		end
	elseif exp == 0x7F then
		if frac == 0 then
			return sign * (1 / 0)
		else
			return sign * (0 / 0)
		end
	end

	return sign * 2 ^ (exp - 127) * (1 + normal / 2 ^ 23)
end

-- double rd_dbl_basic(byte f1..8)
-- @f1..8 - The 8 bytes composing a little endian double
local function rd_dbl_basic(f1, f2, f3, f4, f5, f6, f7, f8)
	local sign = (-1) ^ bit.rshift(f8, 7)
	local exp = bit.lshift(bit.band(f8, 0x7F), 4) + bit.rshift(f7, 4)
	local frac = bit.band(f7, 0x0F) * 2 ^ 48
	local normal = 1

	frac = frac + (f6 * 2 ^ 40) + (f5 * 2 ^ 32) + (f4 * 2 ^ 24) + (f3 * 2 ^ 16) + (f2 * 2 ^ 8) + f1 -- help

	if exp == 0 then
		if frac == 0 then
			return sign * 0
		else
			normal = 0
			exp = 1
		end
	elseif exp == 0x7FF then
		if frac == 0 then
			return sign * (1 / 0)
		else
			return sign * (0 / 0)
		end
	end

	return sign * 2 ^ (exp - 1023) * (normal + frac / 2 ^ 52)
end

-- int rd_int_le(string src, int s, int e)
-- @src - Source binary string
-- @s - Start index of a little endian integer
-- @e - End index of the integer
local function rd_int_le(src, s, e) return rd_int_basic(src, s, e - 1, 1) end

-- int rd_int_be(string src, int s, int e)
-- @src - Source binary string
-- @s - Start index of a big endian integer
-- @e - End index of the integer
local function rd_int_be(src, s, e) return rd_int_basic(src, e - 1, s, -1) end

-- float rd_flt_le(string src, int s)
-- @src - Source binary string
-- @s - Start index of little endian float
local function rd_flt_le(src, s) return rd_flt_basic(string.byte(src, s, s + 3)) end

-- float rd_flt_be(string src, int s)
-- @src - Source binary string
-- @s - Start index of big endian float
local function rd_flt_be(src, s)
	local f1, f2, f3, f4 = string.byte(src, s, s + 3)
	return rd_flt_basic(f4, f3, f2, f1)
end

-- double rd_dbl_le(string src, int s)
-- @src - Source binary string
-- @s - Start index of little endian double
local function rd_dbl_le(src, s) return rd_dbl_basic(string.byte(src, s, s + 7)) end

-- double rd_dbl_be(string src, int s)
-- @src - Source binary string
-- @s - Start index of big endian double
local function rd_dbl_be(src, s)
	local f1, f2, f3, f4, f5, f6, f7, f8 = string.byte(src, s, s + 7) -- same
	return rd_dbl_basic(f8, f7, f6, f5, f4, f3, f2, f1)
end

-- to avoid nested ifs in deserializing
local float_types = {
	[4] = {little = rd_flt_le, big = rd_flt_be},
	[8] = {little = rd_dbl_le, big = rd_dbl_be},
}

-- byte stm_byte(Stream S)
-- @S - Stream object to read from
local function stm_byte(S)
	local idx = S.index
	local bt = string.byte(S.source, idx, idx)

	S.index = idx + 1
	return bt
end

-- string stm_string(Stream S, int len)
-- @S - Stream object to read from
-- @len - Length of string being read
local function stm_string(S, len)
	local pos = S.index + len
	local str = string.sub(S.source, S.index, pos - 1)

	S.index = pos
	return str
end

-- string stm_lstring(Stream S)
-- @S - Stream object to read from
local function stm_lstring(S)
	local len = S:s_szt()
	local str

	if len ~= 0 then str = string.sub(stm_string(S, len), 1, -2) end

	return str
end

-- fn cst_int_rdr(string src, int len, fn func)
-- @len - Length of type for reader
-- @func - Reader callback
local function cst_int_rdr(len, func)
	return function(S)
		local pos = S.index + len
		local int = func(S.source, S.index, pos)
		S.index = pos

		return int
	end
end

-- fn cst_flt_rdr(string src, int len, fn func)
-- @len - Length of type for reader
-- @func - Reader callback
local function cst_flt_rdr(len, func)
	return function(S)
		local flt = func(S.source, S.index)
		S.index = S.index + len

		return flt
	end
end

local function stm_inst_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do
		local ins = S:s_ins()
		local op = bit.band(ins, 0x3F)
		local args = OPCODE_T[op]
		local mode = OPCODE_M[op]
		local data = {value = ins, op = OPCODE_RM[op], A = bit.band(bit.rshift(ins, 6), 0xFF)}

		if args == 'ABC' then
			data.B = bit.band(bit.rshift(ins, 23), 0x1FF)
			data.C = bit.band(bit.rshift(ins, 14), 0x1FF)
			data.is_KB = mode.b == 'OpArgK' and data.B > 0xFF -- post process optimization
			data.is_KC = mode.c == 'OpArgK' and data.C > 0xFF

			if op == 10 then -- decode NEWTABLE array size, store it as constant value
				local e = bit.band(bit.rshift(data.B, 3), 31)
				if e == 0 then
					data.const = data.B
				else
					data.const = bit.lshift(bit.band(data.B, 7) + 8, e - 1)
				end
			end
		elseif args == 'ABx' then
			data.Bx = bit.band(bit.rshift(ins, 14), 0x3FFFF)
			data.is_K = mode.b == 'OpArgK'
		elseif args == 'AsBx' then
			data.sBx = bit.band(bit.rshift(ins, 14), 0x3FFFF) - 131071
		end

		list[i] = data
	end

	return list
end

local function stm_const_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do
		local tt = stm_byte(S)
		local k

		if tt == 1 then
			k = stm_byte(S) ~= 0
		elseif tt == 3 then
			k = S:s_num()
		elseif tt == 4 then
			k = stm_lstring(S)
		end

		list[i] = k -- offset +1 during instruction decode
	end

	return list
end

local function stm_sub_list(S, src)
	local len = S:s_int()
	local list = {}

	for i = 1, len do
		list[i] = stm_lua_func(S, src) -- offset +1 in CLOSURE
	end

	return list
end

local function stm_line_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do list[i] = S:s_int() end

	return list
end

local function stm_loc_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do list[i] = {varname = stm_lstring(S), startpc = S:s_int(), endpc = S:s_int()} end

	return list
end

local function stm_upval_list(S)
	local len = S:s_int()
	local list = {}

	for i = 1, len do list[i] = stm_lstring(S) end

	return list
end

function stm_lua_func(S, psrc)
	local proto = {}
	local src = stm_lstring(S) or psrc -- source is propagated

	proto.source = src -- source name

	S:s_int() -- line defined
	S:s_int() -- last line defined

	proto.num_upval = stm_byte(S) -- num upvalues
	proto.num_param = stm_byte(S) -- num params

	stm_byte(S) -- vararg flag
	proto.max_stack = stm_byte(S) -- max stack size

	proto.code = stm_inst_list(S)
	proto.const = stm_const_list(S)
	proto.subs = stm_sub_list(S, src)
	proto.lines = stm_line_list(S)

	stm_loc_list(S)
	stm_upval_list(S)

	-- post process optimization
	for _, v in ipairs(proto.code) do
		if v.is_K then
			v.const = proto.const[v.Bx + 1] -- offset for 1 based index
		else
			if v.is_KB then v.const_B = proto.const[v.B - 0xFF] end

			if v.is_KC then v.const_C = proto.const[v.C - 0xFF] end
		end
	end

	return proto
end

function lua_bc_to_state(src)
	-- func reader
	local rdr_func

	-- header flags
	local little
	local size_int
	local size_szt
	local size_ins
	local size_num
	local flag_int

	-- stream object
	local stream = {
		-- data
		index = 1,
		source = src,
	}

	assert(stm_string(stream, 4) == '\27Lua', 'invalid Lua signature')
	assert(stm_byte(stream) == 0x51, 'invalid Lua version')
	assert(stm_byte(stream) == 0, 'invalid Lua format')

	little = stm_byte(stream) ~= 0
	size_int = stm_byte(stream)
	size_szt = stm_byte(stream)
	size_ins = stm_byte(stream)
	size_num = stm_byte(stream)
	flag_int = stm_byte(stream) ~= 0

	rdr_func = little and rd_int_le or rd_int_be
	stream.s_int = cst_int_rdr(size_int, rdr_func)
	stream.s_szt = cst_int_rdr(size_szt, rdr_func)
	stream.s_ins = cst_int_rdr(size_ins, rdr_func)

	if flag_int then
		stream.s_num = cst_int_rdr(size_num, rdr_func)
	elseif float_types[size_num] then
		stream.s_num = cst_flt_rdr(size_num, float_types[size_num][little and 'little' or 'big'])
	else
		error('unsupported float size')
	end

	return stm_lua_func(stream, '@virtual')
end

local function close_lua_upvalues(list, index)
	for i, uv in pairs(list) do
		if uv.index >= index then
			uv.value = uv.store[uv.index] -- store value
			uv.store = uv
			uv.index = 'value' -- self reference
			list[i] = nil
		end
	end
end

local function open_lua_upvalue(list, index, memory)
	local prev = list[index]

	if not prev then
		prev = {index = index, store = memory}
		list[index] = prev
	end

	return prev
end

local function on_lua_error(failed, err)
	local src = failed.source
	local line = failed.lines[failed.pc - 1]

	error(string.format('%s:%i: %s', src, line, err), 0)
end

local function run_lua_func(state, env, upvals)
	local code = state.code
	local subs = state.subs
	local vararg = state.vararg

	local top_index = -1
	local open_list = {}
	local memory = state.memory
	local pc = state.pc

	while true do
		local inst = code[pc]
		local op = inst.op
		pc = pc + 1

		if op < 18 then
			if op < 8 then
				if op < 3 then
					if op < 1 then
						--[[LOADNIL]]
						for i = inst.A, inst.B do memory[i] = nil end
					elseif op > 1 then
						--[[GETUPVAL]]
						local uv = upvals[inst.B]

						memory[inst.A] = uv.store[uv.index]
					else
						--[[ADD]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs + rhs
					end
				elseif op > 3 then
					if op < 6 then
						if op > 4 then
							--[[SELF]]
							local A = inst.A
							local B = inst.B
							local index

							if inst.is_KC then
								index = inst.const_C
							else
								index = memory[inst.C]
							end

							memory[A + 1] = memory[B]
							memory[A] = memory[B][index]
						else
							--[[GETGLOBAL]]
							memory[inst.A] = env[inst.const]
						end
					elseif op > 6 then
						--[[GETTABLE]]
						local index

						if inst.is_KC then
							index = inst.const_C
						else
							index = memory[inst.C]
						end

						memory[inst.A] = memory[inst.B][index]
					else
						--[[SUB]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs - rhs
					end
				else --[[MOVE]]
					memory[inst.A] = memory[inst.B]
				end
			elseif op > 8 then
				if op < 13 then
					if op < 10 then
						--[[SETGLOBAL]]
						env[inst.const] = memory[inst.A]
					elseif op > 10 then
						if op < 12 then
							--[[CALL]]
							local A = inst.A
							local B = inst.B
							local C = inst.C
							local params

							if B == 0 then
								params = top_index - A
							else
								params = B - 1
							end

							local ret_list = table_pack(memory[A](unpack(memory, A + 1, A + params)))
							local ret_num = ret_list.n

							if C == 0 then
								top_index = A + ret_num - 1
							else
								ret_num = C - 1
							end

							table_move(ret_list, 1, ret_num, A, memory)
						else
							--[[SETUPVAL]]
							local uv = upvals[inst.B]

							uv.store[uv.index] = memory[inst.A]
						end
					else
						--[[MUL]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs * rhs
					end
				elseif op > 13 then
					if op < 16 then
						if op > 14 then
							--[[TAILCALL]]
							local A = inst.A
							local B = inst.B
							local params

							if B == 0 then
								params = top_index - A
							else
								params = B - 1
							end

							close_lua_upvalues(open_list, 0)

							return memory[A](unpack(memory, A + 1, A + params))
						else
							--[[SETTABLE]]
							local index, value

							if inst.is_KB then
								index = inst.const_B
							else
								index = memory[inst.B]
							end

							if inst.is_KC then
								value = inst.const_C
							else
								value = memory[inst.C]
							end

							memory[inst.A][index] = value
						end
					elseif op > 16 then
						--[[NEWTABLE]]
						memory[inst.A] = {} -- inst.const contains array size
					else
						--[[DIV]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs / rhs
					end
				else
					--[[LOADK]]
					memory[inst.A] = inst.const
				end
			else
				--[[FORLOOP]]
				local A = inst.A
				local step = memory[A + 2]
				local index = memory[A] + step
				local limit = memory[A + 1]
				local loops

				if step == math.abs(step) then
					loops = index <= limit
				else
					loops = index >= limit
				end

				if loops then
					memory[A] = index
					memory[A + 3] = index
					pc = pc + inst.sBx
				end
			end
		elseif op > 18 then
			if op < 28 then
				if op < 23 then
					if op < 20 then
						--[[LEN]]
						memory[inst.A] = #memory[inst.B]
					elseif op > 20 then
						if op < 22 then
							--[[RETURN]]
							local A = inst.A
							local B = inst.B
							local len

							if B == 0 then
								len = top_index - A + 1
							else
								len = B - 1
							end

							close_lua_upvalues(open_list, 0)

							return unpack(memory, A, A + len - 1)
						else
							--[[CONCAT]]
							local B, C = inst.B, inst.C
							local success, str = pcall(table.concat, memory, "", B, C)

							if not success then
								str = memory[B]

								for i = B + 1, C do str = str .. memory[i] end
							end

							memory[inst.A] = str
						end
					else
						--[[MOD]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs % rhs
					end
				elseif op > 23 then
					if op < 26 then
						if op > 24 then
							--[[CLOSE]]
							close_lua_upvalues(open_list, inst.A)
						else
							--[[EQ]]
							local lhs, rhs

							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end

							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end

							if (lhs == rhs) == (inst.A ~= 0) then pc = pc + code[pc].sBx end

							pc = pc + 1
						end
					elseif op > 26 then
						--[[LT]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						if (lhs < rhs) == (inst.A ~= 0) then pc = pc + code[pc].sBx end

						pc = pc + 1
					else
						--[[POW]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						memory[inst.A] = lhs ^ rhs
					end
				else
					--[[LOADBOOL]]
					memory[inst.A] = inst.B ~= 0

					if inst.C ~= 0 then pc = pc + 1 end
				end
			elseif op > 28 then
				if op < 33 then
					if op < 30 then
						--[[LE]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = memory[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = memory[inst.C]
						end

						if (lhs <= rhs) == (inst.A ~= 0) then pc = pc + code[pc].sBx end

						pc = pc + 1
					elseif op > 30 then
						if op < 32 then
							--[[CLOSURE]]
							local sub = subs[inst.Bx + 1] -- offset for 1 based index
							local nups = sub.num_upval
							local uvlist

							if nups ~= 0 then
								uvlist = {}

								for i = 1, nups do
									local pseudo = code[pc + i - 1]

									if pseudo.op == OPCODE_RM[0] then -- @MOVE
										uvlist[i - 1] = open_lua_upvalue(open_list, pseudo.B, memory)
									elseif pseudo.op == OPCODE_RM[4] then -- @GETUPVAL
										uvlist[i - 1] = upvals[pseudo.B]
									end
								end

								pc = pc + nups
							end

							memory[inst.A] = lua_wrap_state(sub, env, uvlist)
						else
							--[[TESTSET]]
							local A = inst.A
							local B = inst.B

							if (not memory[B]) ~= (inst.C ~= 0) then
								memory[A] = memory[B]
								pc = pc + code[pc].sBx
							end
							pc = pc + 1
						end
					else
						--[[UNM]]
						memory[inst.A] = -memory[inst.B]
					end
				elseif op > 33 then
					if op < 36 then
						if op > 34 then
							--[[VARARG]]
							local A = inst.A
							local len = inst.B

							if len == 0 then
								len = vararg.len
								top_index = A + len - 1
							end

							table_move(vararg.list, 1, len, A, memory)
						else
							--[[FORPREP]]
							local A = inst.A
							local init, limit, step

							init = assert(tonumber(memory[A]), '`for` initial value must be a number')
							limit = assert(tonumber(memory[A + 1]), '`for` limit must be a number')
							step = assert(tonumber(memory[A + 2]), '`for` step must be a number')

							memory[A] = init - step
							memory[A + 1] = limit
							memory[A + 2] = step

							pc = pc + inst.sBx
						end
					elseif op > 36 then
						--[[SETLIST]]
						local A = inst.A
						local C = inst.C
						local len = inst.B
						local tab = memory[A]
						local offset

						if len == 0 then len = top_index - A end

						if C == 0 then
							C = inst[pc].value
							pc = pc + 1
						end

						offset = (C - 1) * FIELDS_PER_FLUSH

						table_move(memory, A + 1, A + len, offset + 1, tab)
					else
						--[[NOT]]
						memory[inst.A] = not memory[inst.B]
					end
				else
					--[[TEST]]
					if (not memory[inst.A]) ~= (inst.C ~= 0) then pc = pc + code[pc].sBx end
					pc = pc + 1
				end
			else
				--[[TFORLOOP]]
				local A = inst.A
				local base = A + 3

				local vals = {memory[A](memory[A + 1], memory[A + 2])}

				table_move(vals, 1, inst.C, base, memory)

				if memory[base] ~= nil then
					memory[A + 2] = memory[base]
					pc = pc + code[pc].sBx
				end

				pc = pc + 1
			end
		else
			--[[JMP]]
			pc = pc + inst.sBx
		end

		state.pc = pc
	end
end

function lua_wrap_state(proto, env, upval)
	local function wrapped(...)
		local passed = table_pack(...)
		local memory = {}
		local vararg = {len = 0, list = {}}

		table_move(passed, 1, proto.num_param, 0, memory)

		if proto.num_param < passed.n then
			local start = proto.num_param + 1
			local len = passed.n - proto.num_param

			vararg.len = len
			table_move(passed, start, start + len - 1, 1, vararg.list)
		end

		local state = {vararg = vararg, memory = memory, code = proto.code, subs = proto.subs, pc = 1}

		local result = table_pack(pcall(run_lua_func, state, env, upval))

		if result[1] then
			return unpack(result, 2, result.n)
		else
			local failed = {pc = state.pc, source = proto.source, lines = proto.lines}

			on_lua_error(failed, result[2])

			return
		end
	end

	return wrapped
end

FiOne_lua = {
	bc_to_state = lua_bc_to_state,
	wrap_state = lua_wrap_state,
	OPCODE_RM = OPCODE_RM,
	OPCODE_T = OPCODE_T,
	OPCODE_M = OPCODE_M,
}

end
function scmframework_c43cd09f0753ccaf081c5003d1b4e0c5() --$CONTENT_DATA/Scripts/fsmanager.lua
--if not _fsmanager then _fsmanager = true end
--_fsmanager = true

function fsmanager_init(self)
    function self:sv_fs_import(importPath, caller)
        local data
        pcall(function ()
            data = sm.json.open(importPath)
        end)
        if data then
            local gok = true
            print("openFolder", pcall(self.fs.openFolder, self.fs, "/"))
            for path, data in pairs(data) do
                data = base64.decode(data)

                
                local strs = strSplitNoYield(string, path, {"/"})
                if path:sub(1, 1) == "/" then
                    table.remove(strs, 1)
                end
                if strs[#strs] == "" then
                    table.remove(strs)
                end
                table.remove(strs)

                

                local pth = "/"
                for _, str in ipairs(strs) do
                    pth = pth .. str
                    print("pth", pth)
                    print("createFolder", pcall(self.fs.createFolder, self.fs, pth))
                    pth = pth .. "/"
                end
                
                print("filepath", path)
                
                print("deleteFile", pcall(self.fs.deleteFile, self.fs, path))

                local ok, err = pcall(self.fs.createFile, self.fs, path)
                print("createFile", ok, err)
                if not ok then gok = "createFile: " .. path break end
                local ok, err = pcall(self.fs.writeFile, self.fs,  path, data)
                print("createFile", ok, err)
                if not ok then gok = "writeFile: " .. path break end
            end
            if gok == true then
                self.network:sendToClient(caller, "cl_internal_alertMessage", "successful import")
            else
                self.network:sendToClient(caller, "cl_internal_alertMessage", "import error " .. gok)
            end
        else
            self.network:sendToClient(caller, "cl_internal_alertMessage", "read error: " .. importPath)
        end
        self.changed = true
    end

    function self:sv_fs_export(exportPath, caller)
        local dump = {}
        print("openFolder", pcall(self.fs.openFolder, self.fs, "/"))
        local function recurse(lpath)
            for _, filename in ipairs(self.fs:getFileList(lpath)) do
                local filepath = lpath:sub(2, -1) .. filename
                local data = self.fs:readFile(filepath)
                dump[filepath] = base64.encode(data)
            end

            for _, folderpath in ipairs(self.fs:getFolderList(lpath)) do
                recurse(lpath .. folderpath .. "/")
            end
        end
        recurse("/")


        local ok, err = pcall(sm.json.save, dump, exportPath)
        if ok then
            self.network:sendToClient(caller, "cl_internal_alertMessage", "successful export")
        else
            self.network:sendToClient(caller, "cl_internal_alertMessage", "export error: " .. (err or "unknown"))
        end
    end
    
    function self:sv_fs_clear(_, caller)
        self.fs:clear()
        self.network:sendToClient(caller, "cl_internal_alertMessage", "successful clear")
        self.changed = true
    end

    ---------------------

    if not self.cl_internal_alertMessage then
        function self:cl_internal_alertMessage(text)
            sm.gui.displayAlertText(text)
        end
    end

    function self:cl_fs_clear()
        self.network:sendToServer("sv_fs_clear")
    end

    local function isValidWidgetPath(widgetName)
        return (widgetName:sub(1, 1) == "i" or widgetName:sub(1, 1) == "e") and #widgetName == 2
    end

    local function getWidgetPath(widgetName)
        if isValidWidgetPath(widgetName) then
            return "$CONTENT_DATA/USER/userdisks/" .. widgetName:sub(2, 2) .. ".json"
        else
            return "$CONTENT_DATA/USER/importer/disk.json"
        end
    end

    function self:cl_fs_export(widgetName)
        if not sm.isHost then sm.gui.displayAlertText("at the moment. works only when you are the host") return end
        self.network:sendToServer("sv_fs_export", getWidgetPath(widgetName))
    end

    function self:cl_fs_import(widgetName)
        if widgetName == "userImage" or isValidWidgetPath(widgetName) then
            if not sm.isHost then sm.gui.displayAlertText("at the moment. works only when you are the host") return end
            self.network:sendToServer("sv_fs_import", getWidgetPath(widgetName))
        elseif widgetName == "osImage" then
            self.network:sendToServer("sv_fs_import", "$CONTENT_DATA/ROM/gamedisks/scriptableOS.json")
        elseif widgetName == "pictures" then
            self.network:sendToServer("sv_fs_import", "$CONTENT_DATA/ROM/gamedisks/pics.json")
        elseif widgetName == "midis" then
            self.network:sendToServer("sv_fs_import", "$CONTENT_DATA/ROM/gamedisks/midis.json")
        elseif widgetName == "nbs" then
            self.network:sendToServer("sv_fs_import", "$CONTENT_DATA/ROM/gamedisks/nbs.json")
        end
    end

    function self:cl_fs_openImporter()
        if not better or not better.isAvailable() then
            sm.gui.displayAlertText("automatic opening requires betterAPI. the importer is located in the mod folder: /USER")
            return
        end

        better.filesystem.show(sc.modPrefix .. "/USER/importer")
    end
end

function fsmanager_open(self)
    local gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/fsMenu.layout", false)
	gui:setButtonCallback("clear", "cl_fs_clear")
	gui:setButtonCallback("userImage", "cl_fs_import")
    gui:setButtonCallback("export", "cl_fs_export")
    gui:setButtonCallback("openImporter", "cl_fs_openImporter")

    gui:setButtonCallback("osImage", "cl_fs_import")
    gui:setButtonCallback("pictures", "cl_fs_import")
    gui:setButtonCallback("midis", "cl_fs_import")
    gui:setButtonCallback("nbs", "cl_fs_import")
    
    for i = 1, 4 do
        gui:setButtonCallback("i" .. i, "cl_fs_import")
        gui:setButtonCallback("e" .. i, "cl_fs_export")
    end

    gui:open()
end
end
function scmframework_0cf385d9a1cc40b4c0d3d41a53a75bdf() --$CONTENT_DATA/Scripts/gps.lua
gps = class()
gps.maxParentCount = 1
gps.maxChildCount = 0
gps.connectionInput = sm.interactable.connectionType.composite
gps.connectionOutput = sm.interactable.connectionType.none
gps.colorNormal = sm.color.new("1e8efa")
gps.colorHighlight = sm.color.new("37b2fd")
gps.componentType = "gps" --absences can cause problems

function gps:sv_createGpsData(shape)
    return sc.advDeepcopy({
        position = shape.worldPosition,
        rotation = shape.worldRotation,
        rotationEuler = toEuler(shape.worldRotation),
        velocity = shape.velocity,
        speed = shape.velocity:length(),
        angularVelocity = shape.body.angularVelocity,
        distance = mathDist(self.shape.worldPosition, shape.worldPosition),

        --aliases
        worldPosition = shape.worldPosition,
        worldRotation = shape.worldRotation,
        localPosition = shape.localPosition,
        localRotation = shape.localRotation,
        xAxis = shape.xAxis,
        yAxis = shape.yAxis,
        zAxis = shape.zAxis,
        up = shape.up,
        at = shape.at,
        right = shape.right
    })
end

function gps:server_onCreate()
    sc.creativeCheck(self, self.data and self.data.creative)

    self.interactable.publicData = {
        sc_component = {
            type = gps.componentType,
            api = {
                getRadius = function ()
                    return math.huge
                end,
                getSelfGpsData = function ()
                    local gpsdata = self:sv_createGpsData(self.shape)
                    gpsdata.distance = 0
                    return gpsdata
                end,
                getTagsGpsData = function (label)
                    checkArg(1, label, "string", "number")
                    label = tostring(label)

                    local gpsdatas = {}
                    for id, gpstag in pairs(sc.gpstags) do
                        if gpstag.freq == label then
                            table.insert(gpsdatas, self:sv_createGpsData(gpstag.shape))
                        end
                    end
                    return gpsdatas
                end
            }
        }
    }
end
end
function scmframework_336144d2cff31fdd09fe4ef2002b1a1e() --$CONTENT_DATA/Scripts/gpstag.lua
gpstag = class()
gpstag.maxParentCount = 1
gpstag.maxChildCount = 0
gpstag.connectionInput = sm.interactable.connectionType.composite
gpstag.connectionOutput = sm.interactable.connectionType.none
gpstag.colorNormal = sm.color.new("1e8efa")
gpstag.colorHighlight = sm.color.new("37b2fd")
gpstag.componentType = "gpstag"

function gpstag:server_onCreate()
    self:sv_setData(self.storage:load() or {freq = "tag_" .. tostring(math.random(0, 9999999))})

	self.interactable.publicData = {
        sc_component = {
            type = gpstag.componentType,
            api = {
                setLabel = function (freq)
                    checkArg(1, freq, "string")
                    self.sdata.freq = freq
                    self.saveData = true
                end,
                getLabel = function ()
                    return self.sdata.freq
                end,

                --legacy
                setFreq = function (freq)
                    checkArg(1, freq, "number")
                    self.sdata.freq = tostring(freq)
                    self.saveData = true
                end,
                getFreq = function ()
                    return tonumber(self.sdata.freq) or 0
                end
            }
        }
    }
end

function gpstag:server_onFixedUpdate()
	if self.saveData then
		self:sv_setData(self.sdata)
		self.saveData = nil
	end
end

function gpstag:server_onDestroy()
    sc.gpstags[self.interactable.id] = nil
end

function gpstag:sv_requireData(_, player)
    self.network:sendToClient(player, "cl_setData", self.sdata)
end

function gpstag:sv_setData(data)
    data.freq = tostring(data.freq)
    self.sdata = data
    self.publicApi = {
        shape = self.shape,
        freq = self.sdata.freq
    }
    sc.gpstags[self.interactable.id] = self.publicApi
    self.network:sendToClients("cl_setData", self.sdata)
    self.storage:save(self.sdata)
end

---------------------------------------

function gpstag:client_onCreate()
    self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/gpstag.layout", false, { backgroundAlpha = 0.5 })
	self.gui:setTextChangedCallback("Channel", "client_onChannelChanged")
	self.gui:setButtonCallback("Save", "client_onSave")

    self.network:sendToServer("sv_requireData")
end

function gpstag:client_onSave()
    self.csdata.freq = self.cl_temp_channel
    self.network:sendToServer("sv_setData", self.csdata)
	self.gui:close()
end

function gpstag:client_onInteract(_, state)
	if state then
        self.cl_temp_channel = self.csdata.freq
        self.gui:setText("Channel", tostring(self.cl_temp_channel))
	    self:client_guiError(nil)
		self.gui:open()
	end
end

function gpstag:client_onChannelChanged(_, data)
	if #data <= 32 then
		self.cl_temp_channel = data
        self:client_guiError(nil)
	else
		self:client_guiError("label is too long")
	end
end

function gpstag:client_guiError(text)
	if text ~= nil then
		self.gui:setVisible("Save", false)
		self.gui:setText("Error", text)
	else
		self.gui:setVisible("Save", true)
		self.gui:setText("Error", "")
	end
end

function gpstag:cl_setData(data)
    self.csdata = data
end

function gpstag:client_onDestroy()
	self.gui:destroy()
end
end
function scmframework_ad1a72ea83675e7ec9d0f8e78d234bd4() --$CONTENT_DATA/Scripts/hdd.lua
dofile("$CONTENT_DATA/Scripts/Config.lua")
dofile("$CONTENT_DATA/Scripts/FileSystem.lua")

hdd = class(nil)
hdd.maxParentCount = 1
hdd.maxChildCount = 0
hdd.connectionInput = sm.interactable.connectionType.composite
hdd.colorNormal = sm.color.new(0xbf1996ff)
hdd.colorHighlight = sm.color.new(0xec1db9ff)
hdd.componentType = "disk"

worldDisksLoaded = worldDisksLoaded or {}

function hdd.server_onCreate(self)
	local id = self.interactable:getId()
	
	local data
	print("loading disk content", pcall(function()
		data = self.storage:load()
	end))
	print("disk content type:", type(data))

	if self.data and self.data.world then
		local fsdata = sm.storage.load(data and data.key or "*")
		if data and data.key and fsdata then
			print("deserialize world disk data")
			self.worldKey = data.key
			self.fs = FileSystem.deserialize(fsdata)
			if worldDisksLoaded[self.worldKey] then
				local oldKey = self.worldKey
				self.worldKey = tostring(sm.uuid.new())
				self.storage:save({key = self.worldKey})
				sm.storage.save(self.worldKey, self.fs:serialize())
				print("autochange uuid", oldKey, ">", self.worldKey)
			end
			if self.data then
				local newsize = math.floor(self.data.size)
				if math.floor(self.fs.maxSize) ~= newsize then
					print("old disk size", math.floor(self.fs.maxSize))
					print("new disk size", newsize)
					self.fs.maxSize = newsize
				else
					print("disk size:", newsize)
				end
			end
		else
			print("new image created")
			self.worldKey = tostring(sm.uuid.new())
			self.fs = FileSystem.new(math.floor(self.data.size))
			self.storage:save({key = self.worldKey})
		end

		worldDisksLoaded[self.worldKey] = true
	else
		if data then
			print("deserialize disk")
			self.fs = FileSystem.deserialize(data)
			if self.data then
				local newsize = math.floor(self.data.size)
				if math.floor(self.fs.maxSize) ~= newsize then
					print("old disk size", math.floor(self.fs.maxSize))
					print("new disk size", newsize)
					self.fs.maxSize = newsize
				else
					print("disk size:", newsize)
				end
			end
		elseif self.data then
			print("create new disk data")
			self.fs = FileSystem.new(math.floor(self.data.size))
		else
			print("create new creative disk data")
			self.fs = FileSystem.new(1024 * 1024 * 1024)
		end
	end

	sc.hardDiskDrivesDatas[id] = FileSystem.createSelfData(self)
	self.changed = false
	fsmanager_init(self)
	sc.creativeCheck(self, not self.data)
end

function hdd:server_onFixedUpdate()
	sc.creativeCheck(self, not self.data)

	if self.changed and self.data and sc.needSaveData() then
		--print("SAVE DISK DATA")

		local data = self.fs:serialize()
		if self.worldKey then
			sm.storage.save(self.worldKey, data)
		else
			self.storage:save(data)
		end

		self.changed = false
	end
end

function hdd.server_onDestroy(self)
	local id = self.interactable:getId()
	sc.hardDiskDrivesDatas[id] = nil
	if self.worldKey then
		worldDisksLoaded[self.worldKey] = nil
	end
end

-----------------------------------------------------------

function hdd:client_onCreate()
	fsmanager_init(self)
end

function hdd:client_onInteract(_, state)
	if state and not sc.disableFilesystemMenu then
		fsmanager_open(self)
	end
end

function hdd:client_canInteract()
	return not sc.disableFilesystemMenu
end
end
function scmframework_86e5d5de98dfafccf2a5213813d27b4a() --$CONTENT_DATA/Scripts/holoprojector.lua
dofile("$CONTENT_DATA/Scripts/Config.lua")

local sc_getEffectName = sc.getEffectName
local sm_effect_createEffect = sm.effect.createEffect
local sm_quat_fromEuler = sm.quat.fromEuler
local sm_vec3_new = sm.vec3.new
local type = type
local ipairs = ipairs
local pairs = pairs
local checkArg = checkArg
local unpack = unpack
local sm_exists = sm.exists
local table_insert = table.insert
local sm_color_new = sm.color.new
local sm_uuid_new = sm.uuid.new
local table_remove = table.remove
local math_sin = math.sin
local math_cos = math.cos
local sm_quat_new = sm.quat.new
local math_floor = math.floor

local deepcopy = sc.deepcopy
local tableChecksum = tableChecksum

local emptyEffect = sm_effect_createEffect(sc_getEffectName())
local effect_setParameter = emptyEffect.setParameter
local effect_stop = emptyEffect.stop
local effect_destroy = emptyEffect.destroy
local effect_start = emptyEffect.start
local effect_isDone = emptyEffect.isDone
local effect_setScale = emptyEffect.setScale
local effect_setOffsetPosition = emptyEffect.setOffsetPosition
local effect_setOffsetRotation = emptyEffect.setOffsetRotation
--effect_stop(emptyEffect)
effect_destroy(emptyEffect)

holoprojector = class()
holoprojector.maxParentCount = 1
holoprojector.maxChildCount = 0
holoprojector.connectionInput = sm.interactable.connectionType.composite
holoprojector.colorNormal = sm_color_new(0x58b170ff)
holoprojector.colorHighlight = sm_color_new(0x80ffa2ff)
holoprojector.componentType = "holoprojector"

local blocks = {
    [0] = sm_uuid_new("2f4c970d-c249-4f8d-ac2e-0a89abd2013f"),
    sm_uuid_new("d3db3f52-0a8d-4884-afd6-b4f2ac4365c2"),
    sm_uuid_new("765c61be-7d34-4b11-bb2f-e58cfc1708e6"),
}
local error = error
local tostring = tostring
local huge = math.huge

local function tableInsert(self, dat)
    local tbl = self.voxels
    for i = 1, huge do
        if not tbl[i] then
            tbl[i] = dat
            if i > self.maxVoxelId then
                self.maxVoxelId = i
            end
            return i
        end
    end
end

local function err1(maxvoxeloffset, attempt)
    error("the maximum voxel offset exceeded the limit for this projector: " .. tostring(maxvoxeloffset) .. ". attempt: " .. tostring(attempt), 3)
end

local function err2(maxlocalscale, attempt)
    error("the maximum local scale exceeded the limit for this projector: " .. tostring(maxlocalscale) .. ". attempt: " .. tostring(attempt), 3)
end

local formatColor = sc.formatColor
local defaultColor = sm_color_new("00ff00")

function holoprojector:server_onCreate()
    self.creative = not self.data
    self.data = self.data or {}

    sc.holoDatas[self.interactable.id] = {
        reset = function ()
            self.offsetX = 0
            self.offsetY = 0
            self.offsetZ = 0
            self.rotateX = 0
            self.rotateY = 0
            self.rotateZ = 0
            self.scaleX = 0.25
            self.scaleY = 0.25
            self.scaleZ = 0.25
            self.updateData = true
        end,

        addVoxel = function(x, y, z, color, voxel_type, localScale, localRotation)
            if not self.voxels then self.voxels = {} end
            local maxvoxels = (self.data.maxvoxels or 16384)
            if self.voxelsCount >= maxvoxels then error("voxel limit exceeded (" .. tostring(maxvoxels) .. ")", 2) end
            self.voxelsCount = self.voxelsCount + 1

            local maxvoxeloffset = self.data.maxvoxeloffset
            if maxvoxeloffset then
                if x < -maxvoxeloffset or x > maxvoxeloffset then err1(maxvoxeloffset, x) end
                if y < -maxvoxeloffset or y > maxvoxeloffset then err1(maxvoxeloffset, y) end
                if z < -maxvoxeloffset or z > maxvoxeloffset then err1(maxvoxeloffset, z) end
            end

            local data = {
                x / 4,
                y / 4,
                z / 4,
                formatColor(color, defaultColor, true),
                voxel_type or 0
            }

            local maxlocalscale = self.data.maxlocalscale or huge
            if localScale then
                local x, y, z = localScale.x, localScale.y, localScale.z
                if x <= 0 or x > maxlocalscale then err2(maxlocalscale, x) end
                if y <= 0 or y > maxlocalscale then err2(maxlocalscale, y) end
                if z <= 0 or z > maxlocalscale then err2(maxlocalscale, z) end
            end

            if localScale then
                data[6] = localScale.x
                data[7] = localScale.y
                data[8] = localScale.z
            end

			if localRotation then
				data[9] = localRotation.x
                data[10] = localRotation.y
                data[11] = localRotation.z
			end

            return tableInsert(self, data)
        end,
        delVoxel = function (voxelId)
            if self.voxels and self.voxels[voxelId] then
                self.voxels[voxelId] = nil
                self.voxelsCount = self.voxelsCount - 1
            else
                error("incorrect voxel ID", 2)
            end
        end,
        clear = function ()
            self.voxelsCount = 0
            self.voxels = nil
            self.maxVoxelId = 0
            --self.clearFlag = true
        end,
        flush = function ()
            self.flushFlag = true
        end,



        setOffset = function (x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")

            local maxoffset = self.data.maxoffset or math.huge
            local function err(attempt)
                error("the maximum offset exceeded the limit for this projector: " .. tostring(maxoffset) .. ". attempt: " .. tostring(attempt), 3)
            end
            if x < -maxoffset or x > maxoffset then err(x) end
            if y < -maxoffset or y > maxoffset then err(y) end
            if z < -maxoffset or z > maxoffset then err(z) end

            if x ~= self.offsetX or y ~= self.offsetY or z ~= self.offsetZ then
                self.offsetX = x / 4
                self.offsetY = y / 4
                self.offsetZ = z / 4
                self.updateData = true
            end
        end,
        getOffset = function ()
            return self.offsetX, self.offsetY, self.offsetZ
        end,

        setRotation = function (x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")
            
            if x ~= self.rotateX or y ~= self.rotateY or z ~= self.rotateZ then
                self.rotateX = x
                self.rotateY = y
                self.rotateZ = z
                self.updateData = true
            end
        end,
        getRotation = function ()
            return self.rotateX, self.rotateY, self.rotateZ
        end,

        setScale = function (x, y, z)
            checkArg(1, x, "number")
            checkArg(2, y, "number")
            checkArg(3, z, "number")

            local maxscale = self.data.maxscale or math.huge
            local function err(attempt)
                error("the maximum scale exceeded the limit for this projector: " .. tostring(maxscale) .. ". attempt: " .. tostring(attempt), 3)
            end
            if x <= 0 or x > maxscale then err(x) end
            if y <= 0 or y > maxscale then err(y) end
            if z <= 0 or z > maxscale then err(z) end
            
            if x ~= self.scaleX or y ~= self.scaleY or z ~= self.scaleZ then
                self.scaleX = x
                self.scaleY = y
                self.scaleZ = z
                self.updateData = true
            end
        end,
        getScale = function ()
            return self.scaleX, self.scaleY, self.scaleZ
        end
    }

    self.voxelsCount = 0
    sc.holoDatas[self.interactable.id].reset()

    sc.creativeCheck(self, self.creative)
end

local sendToClients = vnetwork.sendToClients
function holoprojector:server_onFixedUpdate()
	if sc.needScreenSend() then self.allow_update = true end

    if self.allow_update and (self.updateData or self.flushFlag) then
        self.allow_update = nil

        if self.updateData then
            self.network:sendToClients("cl_updateData", {
                scaleX = self.scaleX,
                scaleY = self.scaleY,
                scaleZ = self.scaleZ,

                rotateX = self.rotateX,
                rotateY = self.rotateY,
                rotateZ = self.rotateZ,

                offsetX = self.offsetX,
                offsetY = self.offsetY,
                offsetZ = self.offsetZ,
            })
            sc.addLagScore(0.1)
            self.updateData = nil
        end

        if self.flushFlag then
            if self.voxels then
                local currentChecksum = tableChecksum(self.voxels)
                if currentChecksum ~= self.old_currentChecksum then
                    self.old_currentChecksum = currentChecksum

                    --[[
                    for i = self.voxelsCount, 1, -1 do
                        if not self.voxels[i] then
                            table.remove(self.voxels, i)
                        end
                    end
                    ]]
                    --if self.clearFlag then
                    --    self.voxels.clear = true
                    --end
                    sc.addLagScore(self.maxVoxelId / 100)
                    self.voxels.len = self.maxVoxelId
                    if pcall(sendToClients, self, "cl_upload", self.voxels) then
                    --    self.clearFlag = nil
                    else
                        local index = 1
                        local count = 1024

                        local datapack
                        while true do
                            --datapack = {unpack(self.voxels, index, index + (count - 1))}
                            datapack = {unpack(self.voxels, index, index + (count - 1))}
                            --if self.clearFlag then
                            --    datapack.clear = true
                            --end

                            index = index + count
                            if datapack[#datapack] == self.voxels[#self.voxels] then
                                datapack.endPack = true
                                if pcall(sendToClients, self, "cl_upload", datapack) then
                                    --self.clearFlag = nil
                                    break
                                else
                                    index = index - count
                                    count = math_floor((count / 2) + 0.5)
                                end
                            elseif pcall(sendToClients, self, "cl_upload", datapack) then
                                --self.clearFlag = nil
                            else
                                index = index - count
                                count = math_floor((count / 2) + 0.5)
                            end
                        end
                    end
                end
            else
                --self.network:sendToClients("cl_upload", {clear = self.clearFlag})
                self.network:sendToClients("cl_upload", {})
                --self.clearFlag = nil
                self.old_currentChecksum = nil
            end

            --self.voxels = nil
            self.flushFlag = nil
        end
    end

    sc.creativeCheck(self, self.creative)
end

function holoprojector:server_onDestroy()
    sc.holoDatas[self.interactable.id] = nil
end

-----------------------------------------------------------

function holoprojector:client_onCreate()
    self.effects = {}
    self.effectsI = 1
    self:cl_recreateBuffer()
end

function holoprojector:cl_recreateBuffer()
    if self.bufeffects then
        for _, buf in ipairs(self.bufeffects) do
            for _, edata in ipairs(buf) do
                if sm_exists(edata) then
                    effect_destroy(edata)
                end
            end
        end
    end
    
    self.bufeffects = {}
end

local fromEuler = fromEuler
local function cl_doEffect(self, edata)
    local effect, data = edata[1], edata[2]

    local self_drawData = self.drawData
    --local rotate = holoprojector_doQuat(1, 0, 0, self_drawData.rotateX) * holoprojector_doQuat(0, 1, 0, self_drawData.rotateY) * holoprojector_doQuat(0, 0, 1, self_drawData.rotateZ)
    local rotate = fromEuler(self.drawData.rotateX, self.drawData.rotateY, self.drawData.rotateZ)
    local scale = sm_vec3_new(self_drawData.scaleX, self_drawData.scaleY, self_drawData.scaleZ)

    local addScale = sm_vec3_new(data[6] or 1, data[7] or 1, data[8] or 1)
    effect_setScale(effect, scale * addScale)
    --effect_setOffsetPosition(effect, ((rotate * data.position) + sm_vec3_new(self_drawData.offsetX, self_drawData.offsetY, self_drawData.offsetZ)) * (scale * 4))
	if data[9] then
	    effect_setOffsetRotation(effect, rotate * fromEuler(data[9], data[10], data[11]))
	else
		effect_setOffsetRotation(effect, rotate)
	end

    return ((rotate * sm_vec3_new(data[1], data[2], data[3])) + sm_vec3_new(self_drawData.offsetX, self_drawData.offsetY, self_drawData.offsetZ)) * (scale * 4)
end

function holoprojector:client_onDestroy()
    for _, edata in ipairs(self.effects) do
        if sm_exists(edata[1]) then
            effect_destroy(edata[1])
        end
    end
    self:cl_recreateBuffer()
end

function holoprojector:cl_updateData(data)
    self.drawData = data
    
    for _, edata in ipairs(self.effects) do
        if sm_exists(edata[1]) then
            local newpos = cl_doEffect(self, edata)
            effect_setOffsetPosition(edata[1], newpos)
        end
    end
end

local function bufeffects(self, voxel_type)
	if type(voxel_type) == "Uuid" then
		voxel_type = tostring(voxel_type)
	end
	if not self.bufeffects[voxel_type] then
		self.bufeffects[voxel_type] = {}
	end
	return self.bufeffects[voxel_type]
end

local hideOffset = sm_vec3_new(10000000, 10000000, 10000000)
local sc_getEffectName = sc.getEffectName
function holoprojector:cl_upload(datas)
    datas = datas or self.sendData
    local gotos = {}

    for _, edata in ipairs(self.effects) do
        if sm_exists(edata[1]) then
            gotos[edata[1]] = hideOffset
            table_insert(bufeffects(self, edata[2][5]), edata[1])
        end
    end
    self.effects = {}
    self.effectsI = 1

    if datas.len then
        for i = 1, datas.len do
            local data = datas[i]
            if data then
				local uuidType = type(data[5])
				local uuidIsNumber = uuidType == "number"
                if uuidIsNumber and not blocks[data[5]] then data[5] = 1 end

                local effect
				local buf = bufeffects(self, data[5])
                if #buf > 0 then
                    effect = table_remove(buf)
                else
                    effect = sm_effect_createEffect(sc_getEffectName(), self.interactable)
					if uuidIsNumber then
	                    effect_setParameter(effect, "uuid", blocks[data[5]])
					elseif uuidType == "Uuid" then
						effect_setParameter(effect, "uuid", data[5])
					elseif uuidType == "string" then
						effect_setParameter(effect, "uuid", sm_uuid_new(data[5]))
					end
                    effect_start(effect)
                end
                
                effect_setParameter(effect, "color", data[4])
        
                local ldata = {effect, data}
                gotos[effect] = cl_doEffect(self, ldata)
                self.effects[self.effectsI] = ldata
                self.effectsI = self.effectsI + 1
            end
        end
    end

    for key, value in pairs(gotos) do
        effect_setOffsetPosition(key, value)
    end
end
end
function scmframework_a104751f322dd97eb958c7b38b272781() --$CONTENT_DATA/Scripts/ibridge.lua
ibridge = class()
ibridge.maxParentCount = 1
ibridge.maxChildCount = 0
ibridge.connectionInput = sm.interactable.connectionType.composite
ibridge.connectionOutput = sm.interactable.connectionType.none
ibridge.colorNormal = sm.color.new(0x7F7F7Fff)
ibridge.colorHighlight = sm.color.new(0xFFFFFFff)
ibridge.componentType = "ibridge" --absences can cause problems

function ibridge:check()
    if not dlm then error("The BetterAPI is not installed. the component cannot work", 3) end
    if not sc.restrictions.ibridge then error("the use of the Internet bridge was prohibited by the administrator", 3) end
end

function ibridge:server_onCreate()
    self.interactable.publicData = {
        sc_component = {
            type = ibridge.componentType,
            api = {
                isAllow = function ()
                    return not not (dlm and sc.restrictions.ibridge)
                end,
                get = function (url, headers)
                    self:check()
                    local out = {dlm.http.get(sc.advDeepcopy(url), sc.advDeepcopy(headers))}
                    for key, value in pairs(out) do
                        out[key] = sc.advDeepcopy(value)
                    end
                    return out
                end,
                post = function (url, data, headers)
                    self:check()
                    local out = {dlm.http.post(sc.advDeepcopy(url), sc.advDeepcopy(data), sc.advDeepcopy(headers))}
                    for key, value in pairs(out) do
                        out[key] = sc.advDeepcopy(value)
                    end
                    return out
                end
            }
        }
    }
end
end
function scmframework_b7d0d5f9af5c28f0d85e89b7f6583fa1() --$CONTENT_DATA/Scripts/inertialEngine.lua
inertialEngine = class()
inertialEngine.maxParentCount = -1
inertialEngine.maxChildCount = 0
inertialEngine.connectionInput = sm.interactable.connectionType.composite + sm.interactable.connectionType.electricity + sm.interactable.connectionType.gasoline
inertialEngine.connectionOutput = sm.interactable.connectionType.none
inertialEngine.colorNormal = sm.color.new("#aa0000")
inertialEngine.colorHighlight = sm.color.new("#ff0303")
inertialEngine.componentType = "inertialEngine"

function inertialEngine:server_onCreate()
    self.active = false
    self.batteries = 0
    self.gasolines = 0
    self.tick = 0
    self.creative = self.data and self.data.creative
    self.stableMode = 1
    self.gravity = 1
    self.raw_mode = false
    self.shapes = {}
    self.soundtype = 1
    self.uniformForce = false
    self:sv_reset()

    self.interactable.publicData = {
        sc_component = {
            type = inertialEngine.componentType,
            api = {
                isWorkAvailable = function ()
                    return self:sv_isWorkAvailable()
                end,
                setActive = function (state)
                    checkArg(1, state, "boolean")
                    if state ~= self.active then
                        self.active = state
                        self:sv_reset()
                    end
                end,
                isActive = function ()
                    return self.active
                end,
                getAvailableBatteries = function ()
                    return self.batteries
                end,
                getAvailableGas = function ()
                    return self.gasolines
                end,
                addRotation = function (angle)
                    checkArg(1, angle, "Vec3")
                    self.targetRotation.x = math.rad(math.deg(self.targetRotation.x + angle.x))
                    self.targetRotation.y = math.rad(math.deg(self.targetRotation.y + angle.y))
                    self.targetRotation.z = math.rad(math.deg(self.targetRotation.z + angle.z))
                end,
                addPosition = function (offset)
                    checkArg(1, offset, "Vec3")
                    self.targetPosition = self.targetPosition + self:reOffset(offset)
                end,
                addGlobalPosition = function (offset)
                    checkArg(1, offset, "Vec3")
                    self.targetPosition = self.targetPosition + offset
                end,
                setStableMode = function (mode)
                    checkArg(1, mode, "number")
                    if mode < 0 or mode > 4 then
                        error("stable mode must be [0:4]", 2)
                    end
                    self.stableMode = mode
                    self:recreatePID()
                end,
                getStableMode = function ()
                    return self.stableMode
                end,
                getOffset = function()
                    return mathDist(self.targetPosition, self.shape.worldPosition)
                end,

                -- sporling API
                setRawMovement = function(state)
                    checkArg(1, state, "boolean")
                    self.raw_mode = state
                end,
                isRawMovement = function()
                    return self.raw_mode
                end,

                --[[
                setUniformForce = function(state)
                    checkArg(1, state, "boolean")
                    self.uniformForce = state
                end,
                isUniformForce = function()
                    return self.uniformForce
                end,
                ]]

                setGravity = function(number)
                    checkArg(1, number, "number")
                    if number > 1 then number = 1 end
                    if number < -1 then number = -1 end
                    self.gravity = number
                end,
                getGravity = function()
                    return self.gravity
                end,

                raw_rotation = function(vec)
                    if not self.active or not self:sv_isWorkAvailable() then
                        return
                    end

                    local tick = sm.game.getCurrentTick()
                    if tick == self.old_tick and not sc.restrictions.disableCallLimit then
                        error("raw_rotation/raw_globalRotation can only be used 1 time per tick on one inertialEngine", 2)
                    end
                    self.old_tick = tick

                    if vec.x < -8 then vec.x = -8 end
                    if vec.x > 8 then vec.x = 8 end

                    if vec.y < -8 then vec.y = -8 end
                    if vec.y > 8 then vec.y = 8 end

                    if vec.z < -8 then vec.z = -8 end
                    if vec.z > 8 then vec.z = 8 end

                    sm.physics.applyTorque(self.shape.body, self.shape.worldRotation * (vec * self.shape.body.mass), true)
                end,
                raw_globalRotation = function(vec)
                    if not self.active or not self:sv_isWorkAvailable() then
                        return
                    end

                    local tick = sm.game.getCurrentTick()
                    if tick == self.old_tick and not sc.restrictions.disableCallLimit then
                        error("raw_rotation/raw_globalRotation can only be used 1 time per tick on one inertialEngine", 2)
                    end
                    self.old_tick = tick

                    if vec.x < -8 then vec.x = -8 end
                    if vec.x > 8 then vec.x = 8 end

                    if vec.y < -8 then vec.y = -8 end
                    if vec.y > 8 then vec.y = 8 end

                    if vec.z < -8 then vec.z = -8 end
                    if vec.z > 8 then vec.z = 8 end

                    sm.physics.applyTorque(self.shape.body, vec * self.shape.body.mass, true)
                end,
                raw_move = function(vec)
                    if not self.active or not self:sv_isWorkAvailable() then
                        return
                    end

                    local tick = sm.game.getCurrentTick()
                    if tick == self.old_tick2 and not sc.restrictions.disableCallLimit then
                        error("raw_move/raw_globalMove can only be used 1 time per tick on one inertialEngine", 2)
                    end
                    self.old_tick2 = tick

                    if vec.x < -5 then vec.x = -5 end
                    if vec.x > 5 then vec.x = 5 end

                    if vec.y < -5 then vec.y = -5 end
                    if vec.y > 5 then vec.y = 5 end

                    if vec.z < -5 then vec.z = -5 end
                    if vec.z > 5 then vec.z = 5 end

                    sm.physics.applyImpulse(self.shape.body, self.shape.worldRotation * (vec * self.shape.body.mass), true)
                end,
                raw_globalMove = function(vec)
                    if not self.active or not self:sv_isWorkAvailable() then
                        return
                    end

                    local tick = sm.game.getCurrentTick()
                    if tick == self.old_tick2 and not sc.restrictions.disableCallLimit then
                        error("raw_move/raw_globalMove can only be used 1 time per tick on one inertialEngine", 2)
                    end
                    self.old_tick2 = tick

                    if vec.x < -5 then vec.x = -5 end
                    if vec.x > 5 then vec.x = 5 end

                    if vec.y < -5 then vec.y = -5 end
                    if vec.y > 5 then vec.y = 5 end

                    if vec.z < -5 then vec.z = -5 end
                    if vec.z > 5 then vec.z = 5 end

                    sm.physics.applyImpulse(self.shape.body, vec * self.shape.body.mass, true)
                end,

                setSoundType = function (num)
                    checkArg(1, num, "number")
                    self.soundtype = num
                end,
                getSoundType = function ()
                    return self.soundtype
                end,

                --very raw methods))
                raw_rawMove = function(vec, worldSpace)
                    if not self.creative then
                        error("the raw_rawMove method is only available on creative inertialEngine", 2)
                    end
                    
                    if not self.active or not self:sv_isWorkAvailable() then
                        return
                    end

                    sm.physics.applyImpulse(self.shape.body, vec, not not worldSpace)
                end,
                raw_rawRotation = function(vec, worldSpace)
                    if not self.creative then
                        error("the raw_rawRotation method is only available on creative inertialEngine", 2)
                    end

                    if not self.active or not self:sv_isWorkAvailable() then
                        return
                    end

                    sm.physics.applyTorque(self.shape.body, vec, not not worldSpace)
                end
            }
        }
    }

    sc.creativeCheck(self, self.creative)
end

function inertialEngine:reOffset(offset, rotation)
    local vec = sc.advDeepcopy(rotation or self.targetRotation)
    local add1 = fromEulerVec(vec) * offset
    add1.z = 0
    vec.z = 0
    local add2 = fromEulerVec(vec) * offset
    add2.x = 0
    add2.y = 0
    return add1 + add2
end

function inertialEngine:server_onRefresh()
    self:server_onCreate()
end

function inertialEngine:server_onFixedUpdate(dt)
    if self.creative then
        self.batteries = math.huge
        self.gasolines = math.huge
    else
        self.batteries = self:sv_mathCount(sm.interactable.connectionType.electricity)
        self.gasolines = self:sv_mathCount(sm.interactable.connectionType.gasoline)
    end

    if not self:sv_isWorkAvailable() then
        self:sv_reset()
    end

    local active = self.active and self:sv_isWorkAvailable()
    self.interactable:setActive(active)
    if active then
        self.tick = self.tick + 1

        --[[
        self.static = self.shape.body:isStatic()
        if not self.static and self.old_static then
            self:sv_reset()
        end
        self.old_static = self.static
        ]]

        self:sv_stable()
        if not self.raw_mode then
            self:sv_moveToPos()
        --[[
        elseif self.uniformForce then
            local cof = 0.26
            local val = cof - (self.gravity * cof)
            for _, shape in ipairs(self.shape.body:getCreationShapes()) do
                sm.physics.applyImpulse(shape, sm.vec3.new(0, 0, val * shape.mass), true)
            end
        ]]
        else
            local cof = 0.26
            local val = cof - (self.gravity * cof)
            sm.physics.applyImpulse(self.shape.body, sm.vec3.new(0, 0, val * self:sv_getCreationMass()), true)
        end

        if self.tick % 40 == 0 and not self.creative and sc.restrictions.resourceConsumption then
            self:sv_removeItem(sm.interactable.connectionType.electricity)
            self:sv_removeItem(sm.interactable.connectionType.gasoline)
        end
    end

    if self.soundtype ~= self.old_soundtype then
        self.network:sendToClients("cl_getParams", {soundtype = self.soundtype})
        self.old_soundtype = self.soundtype
    end

    sc.creativeCheck(self, self.creative)
end

function inertialEngine:sv_getCreationMass()
    local mass = 0
    for i, body in ipairs(self.shape.body:getCreationBodies()) do
        mass = mass + body.mass
    end
    return mass
end

function inertialEngine:sv_reset()
    self.targetPosition = self.shape.worldPosition

    self.targetRotation = self:getSelfRotation()
    self.targetRotation.x = 0
    self.targetRotation.y = 0
    
    self.mPidX = createPID(0.3, 0, 500)
    self.mPidY = createPID(0.3, 0, 500)
    self.mPidZ = createPID(0.3, 0, 500)

    self:recreatePID()
end

function inertialEngine:recreatePID()
    if self.stableMode == 4 then
        self.rPidX = createPID(10, 0, 50000)
        self.rPidY = createPID(10, 0, 50000)
        self.rPidZ = createPID(10, 0, 50000)
    elseif self.stableMode == 3 then
        self.rPidX = createPID(3, 0, 5000)
        self.rPidY = createPID(3, 0, 5000)
        self.rPidZ = createPID(3, 0, 5000)
    elseif self.stableMode == 2 then
        self.rPidX = createPID(2, 0, 1500)
        self.rPidY = createPID(2, 0, 1500)
        self.rPidZ = createPID(2, 0, 1500)
    elseif self.stableMode == 1 then
        self.rPidX = createPID(0.8, 0, 250)
        self.rPidY = createPID(0.8, 0, 250)
        self.rPidZ = createPID(0.8, 0, 250)
    else
        self.rPidX = createPID(0, 0, 0)
        self.rPidY = createPID(0, 0, 0)
        self.rPidZ = createPID(0, 0, 0)
    end
end

function inertialEngine:sv_moveToPos()
    local target = self.targetPosition
    local current = self.shape.worldPosition
    local vec = sm.vec3.new(
        self.mPidX(target.x, current.x),
        self.mPidY(target.y, current.y),
        self.mPidZ(target.z, current.z)
    )

    if vec.x < -5 then vec.x = -5 end
    if vec.x >  5 then vec.x = 5  end

    if vec.y < -5 then vec.y = -5 end
    if vec.y >  5 then vec.y = 5  end

    if vec.z < -5 then vec.z = -5 end
    if vec.z >  5 then vec.z = 5  end

    sm.physics.applyImpulse(self.shape.body, vec * self.shape.body.mass, true)
end

function inertialEngine:sv_stable()
    --[[
    local vec = toEuler(self.shape.worldRotation)
    vec.z = self.targetRotation - vec.z

    local max = 0.05
    local amax = 2
    vec.x = constrain(-vec.x, -max, max)
    vec.y = constrain(-vec.y, -max, max)
    vec.z = constrain(vec.z, -amax, amax)
    ]]

    local target = self.targetRotation
    local current = self:getSelfRotation()

    local function short_angle_dist(from, to)
        local fmod = math.fmod
        local max_angle = math.pi * 2
        local difference = fmod(to - from, max_angle)
        return fmod(2 * difference, max_angle) - difference
    end

    local vec = sm.vec3.new(
        self.rPidX(short_angle_dist(current.x, target.x), 0),
        self.rPidY(short_angle_dist(current.y, target.y), 0),
        self.rPidZ(short_angle_dist(current.z, target.z), 0)
    )

    sm.physics.applyTorque(self.shape.body, self.shape.worldRotation * (vec * self.shape.body.mass), true)
end

function inertialEngine:getSelfRotation()
    local out = toEuler(self.shape.worldRotation)
    return out
end

function inertialEngine:sv_removeItem(ctype)
    local itype
    if ctype == sm.interactable.connectionType.electricity then
        itype = obj_consumable_battery
    elseif ctype == sm.interactable.connectionType.gasoline then
        itype = obj_consumable_gas
    end

    for _, parent in ipairs(self.interactable:getParents()) do
        if parent:hasOutputType(ctype) then
            local container = parent:getContainer(0)
            if container and sm.container.canSpend(container, itype, 1) then
                sm.container.beginTransaction()
                sm.container.spend(container, itype, 1, true)
                if sm.container.endTransaction() then
                    break
                end
            end
		end
	end
end

function inertialEngine:sv_mathCount(ctype)
    local count = 0
    for _, parent in ipairs(self.interactable:getParents()) do
        if parent:hasOutputType(ctype) then
            local container = parent:getContainer(0)
            for i = 0, container.size - 1 do
                count = count + (container:getItem(i).quantity)
            end
		end
	end
    return count
end

function inertialEngine:sv_isWorkAvailable()
    return (self.batteries > 0 and self.gasolines > 0) or not sc.restrictions.resourceConsumption
end

function inertialEngine:sv_dataRequest()
    self.old_soundtype = nil
end

-----------------------------------------------

function inertialEngine:client_onCreate()
    self.network:sendToServer("sv_dataRequest")
end

function inertialEngine:client_onFixedUpdate()
    if (self.cl_soundtype or 0) > 0 and self.interactable:isActive() then
        if not self.effect then
            self.effect = sm.effect.createEffect("ElectricEngine - Level 2", self.interactable)
            self.effect2 = sm.effect.createEffect("GasEngine - Level 3", self.interactable)
            self.effect:setAutoPlay(true)
            self.effect2:setAutoPlay(true)

            self.effect:setParameter("rpm", 0.7)
		    self.effect:setParameter("load", 0.5)

            self.effect2:setParameter("rpm", 1)
		    self.effect2:setParameter("load", 0.8)
        end
    else
        if self.effect then
            self.effect:setAutoPlay(false)
            self.effect2:setAutoPlay(false)
            self.effect:stop()
            self.effect2:stop()
            self.effect:destroy()
            self.effect2:destroy()
            self.effect = nil
            self.effect2 = nil
        end
    end
end

function inertialEngine:cl_getParams(params)
    self.cl_soundtype = params.soundtype
end
end
function scmframework_a682084f92b5fd5e2d1fb3b06598d445() --$CONTENT_DATA/Scripts/internal_libs/base64.lua
function sc_reglib_base64()
    local base64lib = {}

    function base64lib.encode(data)
        checkArg(1, data, "string")
        return base64.encode(data, true)
    end

    function base64lib.decode(data)
        checkArg(1, data, "string")
        return base64.decode(data, true)
    end
    
    return base64lib
end
end
function scmframework_ef09a46422fb46226898abba5c92b1c6() --$CONTENT_DATA/Scripts/internal_libs/colors.lua
function sc_reglib_colors()
local colors = {num = {}, str = {}, sm = {}}
colors.names = {"Gray", "Yellow", "LimeGreen", "Green", "Cyan", "Blue", "Violet", "Magenta", "Red", "Orange"}

colors.num.Gray	      = {0xEEEEEE, 0x7F7F7F, 0x4A4A4A, 0x222222}
colors.num.Yellow     = {0xF5F071, 0xE2DB13, 0x817C00, 0x323000}
colors.num.LimeGreen  = {0xCBF66F, 0xA0EA00, 0x577D07, 0x375000}
colors.num.Green      = {0x68FF88, 0x19E753, 0x0E8031, 0x064023}
colors.num.Cyan       = {0x7EEDED, 0x2CE6E6, 0x118787, 0x0A4444}
colors.num.Blue       = {0x4C6FE3, 0x0A3EE2, 0x0F2E91, 0x0A1D5A}
colors.num.Violet     = {0xAE79F0, 0x7514ED, 0x500AA6, 0x35086C}
colors.num.Magenta    = {0xEE7BF0, 0xCF11D2, 0x720A74, 0x520653}
colors.num.Red        = {0xF06767, 0xD02525, 0x7C0000, 0x560202}
colors.num.Orange     = {0xEEAF5C, 0xDF7F00, 0x673B00, 0x472800}

colors.str.Gray	      = {"EEEEEE", "7F7F7F", "4A4A4A", "222222"}
colors.str.Yellow     = {"F5F071", "E2DB13", "817C00", "323000"}
colors.str.LimeGreen  = {"CBF66F", "A0EA00", "577D07", "375000"}
colors.str.Green	  = {"68FF88", "19E753", "0E8031", "064023"}
colors.str.Cyan       = {"7EEDED", "2CE6E6", "118787", "0A4444"}
colors.str.Blue       = {"4C6FE3", "0A3EE2", "0F2E91", "0A1D5A"}
colors.str.Violet     = {"AE79F0", "7514ED", "500AA6", "35086C"}
colors.str.Magenta    = {"EE7BF0", "CF11D2", "720A74", "520653"}
colors.str.Red        = {"F06767", "D02525", "7C0000", "560202"}
colors.str.Orange     = {"EEAF5C", "DF7F00", "673B00", "472800"}

for name, tbl in pairs(colors.str) do
    colors.sm[name] = {}
    for i, data in ipairs(tbl) do
        colors.sm[name][i] = sm.color.new(data)
    end
end

for name, tbl in pairs(colors.num) do
    colors[name] = tbl
end

--------------------------------------

local math_floor = math.floor
local bit_rshift = bit.rshift
local sc_formatColor = sc.formatColor
local sm_color_new = sm.color.new
local bit_band = bit.band
local math_max = math.max
local math_min = math.min
local string_format = string.format

function colors.hsvToRgb(h, s, v)
    local r, g, b

    local i = math_floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)
    local i6 = i % 6

    if i6 == 0 then
        r, g, b = v, t, p
    elseif i6 == 1 then
        r, g, b = q, v, p
    elseif i6 == 2 then
        r, g, b = p, v, t
    elseif i6 == 3 then
        r, g, b = p, q, v
    elseif i6 == 4 then
        r, g, b = t, p, v
    elseif i6 == 5 then
        r, g, b = v, p, q
    end

    return r, g, b
end

function colors.hsvToRgb256(hue, saturation, value)
    local r, g, b

    if saturation == 0 then
        r = value
        g = value
        b = value
        return r, g, b
    end

    local region = math_floor(hue / 43)
    local remainder = (hue - (region * 43)) * 6
    local p = bit_rshift(value * (255 - saturation), 8)
    local q = bit_rshift(value * (255 - bit_rshift(saturation * remainder, 8)), 8)
    local t = bit_rshift(value * (255 - bit_rshift(saturation * (255 - remainder), 8)), 8)

    if region == 0 then
        r = value; g = t; b = p;
    elseif region == 1 then
        r = q; g = value; b = p;
    elseif region == 2 then
        r = p; g = value; b = t;
    elseif region == 3 then
        r = p; g = q; b = value;
    elseif region == 4 then
        r = t; g = p; b = value;
    else
        r = value; g = p; b = q;
    end

    return r, g, b
end

function colors.pack(r, g, b)
    return (r * 256 * 256) + (g * 256) + b
end

function colors.unpack(color)
    return math_floor(color / 256 / 256), math_floor(color / 256) % 256, color % 256
end

function colors.packFloat(r, g, b)
    return colors.pack(math_floor(r * 255), math_floor(g * 255), math_floor(b * 255))
end

function colors.unpackFloat(color)
    local r, g, b = colors.unpack(color)
    return r / 255, g / 255, b / 255
end

local colors_unpack = colors.unpack
local colors_packFloat = colors.packFloat
local colors_unpackFloat = colors.unpackFloat
local colors_pack = colors.pack

local function colorpartToStrpart(number)
    local hex = string_format("%x", number)
    if #hex < 2 then
        hex = "0" .. hex
    end
    return hex
end

local function strpartToColorpart(colorpart)
    return tonumber(colorpart, 16)
end

function colors.formatToNumber(color)
    local t = type(color)
    if t == "Color" then
        return colors_packFloat(color.r, color.g, color.b)
    elseif t == "string" then
        return colors_pack(strpartToColorpart(color:sub(1, 2)), strpartToColorpart(color:sub(3, 4)), strpartToColorpart(color:sub(5, 6)))
    elseif t == "number" then
        return color
    end

    return 0x000000
end

function colors.formatToColor(color)
    local t = type(color)
    if t == "Color" then
        return color
    elseif t == "string" then
        return sm_color_new(color)
    elseif t == "number" then
        return sm_color_new(colors_unpackFloat(color))
    end

    return sm_color_new(0, 0, 0)
end
local colors_formatToColor = colors.formatToColor

function colors.formatToString(color)
    local t = type(color)
    if t == "Color" then
        return colorpartToStrpart(color.r * 255) .. colorpartToStrpart(color.r * 255) .. colorpartToStrpart(color.r * 255)
    elseif t == "string" then
        return color
    elseif t == "number" then
        local r, g, b = colors_unpack(color)
        return colorpartToStrpart(r) .. colorpartToStrpart(g) .. colorpartToStrpart(b)
    end

    return "000000"
end
local colors_formatToString = colors.formatToString

function colors.combineColorToNumber(value, color1, color2)
    return colors_packFloat(colorCombineRaw(value, colors_formatToColor(color1), colors_formatToColor(color2)))
end

function colors.combineColorToColor(value, color1, color2)
    return colorCombine(value, colors_formatToColor(color1), colors_formatToColor(color2))
end

local colors_combineColorToNumber = colors.combineColorToNumber
function colors.combineColorToString(value, color1, color2)
    return colors_formatToString(colors_combineColorToNumber(value, colors_formatToColor(color1), colors_formatToColor(color2)))
end

return colors
end
end
function scmframework_0bbe5d95b1abc6b7778166cefaa2ce6a() --$CONTENT_DATA/Scripts/internal_libs/enlua.lua
function sc_reglib_enlua(self, env)
    local enlua = {}

    function enlua.compile(code)
        checkArg(1, code, "string")
        local ok, result = pcall(encryptVM.compile, self, code)
        if ok then
            return result
        end
        return nil, tostring(result)
    end

    function enlua.load(bytecode, lenv)
        checkArg(1, bytecode, "string")
        checkArg(2, lenv, "table", "nil")
        return encryptVM.load(self, bytecode, lenv or env)
    end

    function enlua.version(bytecode)
        checkArg(1, bytecode, "string")
        return encryptVM.version(self, bytecode)
    end

    function enlua.lastVersion()
        return tonumber(encryptVM.currentEncryptVM or -1) or -1
    end

    return enlua
end
end
function scmframework_45c53ea22dd4dcddfc458164670e175d() --$CONTENT_DATA/Scripts/internal_libs/fonts.lua
function sc_reglib_fonts()
    local fonts_lib = {}

    for name, data in pairs(canvasAPI.fonts) do
        if type(name) == "string" then
            fonts_lib[name] = data
            --print("font available: ", name)
        end
    end

    return fonts_lib
end
end
function scmframework_3e53e813a57d6ff38cbe8f6c20390c0f() --$CONTENT_DATA/Scripts/internal_libs/graphic.lua
function sc_reglib_graphic()
    local graphic_lib = {}

    function graphic_lib.textBox(display, x, y, width, height, text, color, centerX, centerY, spacingY, autoNewline, tool, myGuiColorPrefixSupport)
        centerX = not not centerX
        centerY = not not centerY
        tool = tool or (display.getUtf8Support() and utf8 or string)
        if autoNewline == nil then autoNewline = true end

        local _x, _y, _width, _height = display.getViewport()
        display.setInlineViewport(x, y, width, height)
        if not autoNewline and not text:find("%\n") then
            if centerX then x = x + (width / 2) end
            if centerY then y = y + (height / 2) end
            display.drawCenteredText(x, y, text, color, centerX, centerY)
            display.setViewport(_x, _y, _width, _height)
            return
        end
        
        local lines = {}
        local customColors = {}
        local fontX, fontY = display.getFontWidth(), display.getFontHeight() + (spacingY or 1)
        local maxLines = height / fontY
        local customColor
        for _, line in ipairs(strSplit(tool, text, "\n")) do
            if myGuiColorPrefixSupport and tool.sub(line, 1, 1) == "#" and tool.sub(line, 2, 2) ~= "#" then
                customColor = tool.sub(line, 1, 7)
                line = tool.sub(line, 8, tool.len(line))
            end
            if line == "" or not autoNewline then
                sc.yield()
                table.insert(lines, line)
                if customColor then
                    customColors[#lines] = customColor
                end
                maxLines = maxLines - 1
            else
                local maxSize
                --[[
                for i = #line, 1, -1 do
                    local textPixelLen = display.calcTextBox(line:sub(1, i))
                    if textPixelLen <= width then
                        maxSize = i
                        break
                    end
                end
                ]]
                if display.isMonospacedFont() then
                    maxSize = math.floor(width / fontX)
                else
                    local lens = display.calcDecreasingTextSizes(line)
                    local lineLen = display.getUtf8Support() and utf8.len(line) or #line
                    for i = lineLen, 1, -1 do
                        local textPixelLen = lens[i]
                        if textPixelLen <= width then
                            maxSize = i
                            break
                        end
                    end
                end

                if maxSize then
                    for _, line in ipairs(splitByMaxSizeWithTool(tool, line, maxSize)) do
                        sc.yield()
                        table.insert(lines, line)
                        if customColor then
                            customColors[#lines] = customColor
                        end
                        maxLines = maxLines - 1
                        if maxLines == 0 then break end
                    end
                else
                    sc.yield()
                    table.insert(lines, line)
                    if customColor then
                        customColors[#lines] = customColor
                    end
                    maxLines = maxLines - 1
                end
            end
            if maxLines == 0 then break end
        end
        local addY = math.floor((height / 2) - (((fontY * #lines) - 1) / 2))
        for i, line in ipairs(lines) do
            local lx, ly = x, y
            if centerX then
                lx = x + ((width / 2) - (display.calcTextBox(line) / 2))
            end
            ly = y + ((i - 1) * fontY)
            if centerY then
                ly = ly + addY
            end
            display.drawText(lx, ly, line, customColors[i] or color)
        end
        display.setViewport(_x, _y, _width, _height)
    end

    return graphic_lib
end
end
function scmframework_c2cd928025821cf433ffdd63b5ff3c28() --$CONTENT_DATA/Scripts/internal_libs/gui.lua
function sc_reglib_gui()
local _utf8 = utf8
local objinstance = {}
local gui = {}

local arrow1 = {
    [4] = {
        "11..",
        "111.",
        "1111",
        "111.",
        "11.."
    },
    [5] = {
        "111..",
        "1111.",
        "11111",
        "1111.",
        "111.."
    }
}

local arrow2 = {
    [4] = {
        "1111",
        "1111",
        "1111",
        ".11.",
        ".11."
    },
    [5] = {
        "11111",
        "11111",
        "11111",
        ".111.",
        "..1.."
    }
}

local function rawToLayer(self, layer)
    local pobjs = self.sceneinstance.objs
    if pobjs[layer] ~= self then
        local selfIndex
        for i = 1, #pobjs do
            if pobjs[i] == self then
                selfIndex = i
                break
            end
        end
        if selfIndex then
            table.remove(pobjs, selfIndex)
            table.insert(pobjs, layer, self)
            return true
        end
    end
end

local function rawToBottomLayer(self)
    return rawToLayer(self, 1)
end

local function rawToTopLayer(self)
    return rawToLayer(self, #self.sceneinstance.objs)
end

local function drawBitmap(display, x, y, bitmap, color)
    for y2, line in ipairs(bitmap) do
        for x2 = 1, #line do
            if line:sub(x2, x2) == "1" then
                display.drawPixel(x + (x2 - 1), y + (y2 - 1), color)
            end
        end
    end
end

local function txtLen(display, text)
    return ((display.getFontWidth() + 1) * _utf8.len(text)) - 1
end

local function formatColor(color, black)
    return canvasAPI.formatColorToSmallNumber(color, black and 0 or 0xffffff)
end

local function setCustomFont(self)
    if not self.guiinstance.customFontEnable then
        return
    end
    
    local oldFont = self.display.getFont()
    local oldScaleX, oldScaleY = self.display.getFontScale()
    local oldTextSpacing = self.display.getTextSpacing()
    self.display.setFont(self.customFont)
    self.display.setTextSpacing(self.textSpacing or 1)
    if self.fontSizeX and self.fontSizeY then
        self.display.setFontSize(self.fontSizeX, self.fontSizeY)
    else
        self.display.setFontScale(1, 1)
    end

    return function ()
        self.display.setFont(oldFont)
        self.display.setFontSize(oldScaleX, oldScaleY)
        self.display.setTextSpacing(oldTextSpacing)
    end
end

local function calcTextBox(self, text)
    local restoreFont = setCustomFont(self)
    local boxX, boxY = self.display.calcTextBox(text)
    if restoreFont then
        restoreFont()
    end
    return boxX, boxY
end

local function getObjectWidth(self, box)
    if self.sizeX then
        return self.sizeX
    elseif self.isText then
        return box and box[1] or (calcTextBox(self, self.text))
    elseif self.isImage then
        return (self.img:getSize())
    end

    return 0
end

local function getObjectHeight(self, box)
    if self.sizeY then
        if self.up_hide then
            return self.up_size
        end
        return self.sizeY
    elseif self.isText then
        return box and box[2] or select(2, calcTextBox(self, self.text))
    elseif self.isImage then
        return select(2, self.img:getSize())
    end

    return 0
end

local function remathElementInWindowPos(obj)
    obj.x = (obj.sceneinstance.x or 0) + obj.sourceX
    obj.y = (obj.sceneinstance.y or 0) + obj.sourceY
end

local function checkIntersection(object1, object2)
    local sx1, sy1 = object1:getDisplaySize()
    local sx2, sy2 = object2:getDisplaySize()
    
    local x1, y1 = object1.x, object1.y
    local x2, y2 = object2.x, object2.y

    return x1 < x2 + sx2 and
           x1 + sx1 > x2 and
           y1 < y2 + sy2 and
           y1 + sy1 > y2
end

-------- main

function objinstance:setPosition(x, y)
    self.sourceX = math.floor(x + 0.5)
    self.sourceY = math.floor(y + 0.5)
    remathElementInWindowPos(self)
    if self.isWindow then
        for _, obj in ipairs(self.objs) do
            remathElementInWindowPos(obj)
        end
    end
end

function objinstance:setPositionX(x)
    self:setPosition(x, self.sourceY)
end

function objinstance:setPositionY(y)
    self:setPosition(self.sourceX, y)
end

function objinstance:setCenter(offsetX, offsetY, gobj)
    if gobj then
        self:setPosition(
            gobj.sourceX + ((getObjectWidth(gobj) / 2) - (getObjectWidth(self) / 2)) + (offsetX or 0),
            gobj.sourceY + ((getObjectHeight(gobj) / 2) - (getObjectHeight(self) / 2)) + (offsetY or 0)
        )
    else
        self:setPosition(
            ((getObjectWidth(self.sceneinstance) / 2) - (getObjectWidth(self) / 2)) + (offsetX or 0),
            ((getObjectHeight(self.sceneinstance) / 2) - (getObjectHeight(self) / 2)) + (offsetY or 0)
        )
    end
end

function objinstance:setCenterX(offsetX, gobj)
    if gobj then
        self:setPositionX(
            gobj.sourceX + ((getObjectWidth(gobj) / 2) - (getObjectWidth(self) / 2)) + (offsetX or 0)
        )
    else
        self:setPositionX(
            ((getObjectWidth(self.sceneinstance) / 2) - (getObjectWidth(self) / 2)) + (offsetX or 0)
        )
    end
end

function objinstance:setCenterY(offsetY, gobj)
    if gobj then
        self:setPositionY(
            gobj.sourceY + ((getObjectHeight(gobj) / 2) - (getObjectHeight(self) / 2)) + (offsetY or 0)
        )
    else
        self:setPositionY(
            ((getObjectHeight(self.sceneinstance) / 2) - (getObjectHeight(self) / 2)) + (offsetY or 0)
        )
    end
end



function objinstance:setOffsetPosition(gobj, x, y)
    self:setPosition(gobj.sourceX + x, gobj.sourceY + y)
end

function objinstance:setOffsetPositionX(gobj, x)
    self:setPositionX(gobj.sourceX + x)
end

function objinstance:setOffsetPositionY(gobj, y)
    self:setPositionY(gobj.sourceY + y)
end



function objinstance:setLeft(gobj, offset)
    offset = offset or self.sceneinstance.defaultOffsetX
    self:setOffsetPosition(gobj, -getObjectWidth(self) - offset, 0)
end

function objinstance:setRight(gobj, offset)
    offset = offset or self.sceneinstance.defaultOffsetX
    self:setOffsetPosition(gobj, getObjectWidth(gobj) + offset, 0)
end

function objinstance:setUp(gobj, offset)
    offset = offset or self.sceneinstance.defaultOffsetY
    self:setOffsetPosition(gobj, 0, -getObjectHeight(self) - offset)
end

function objinstance:setDown(gobj, offset)
    offset = offset or self.sceneinstance.defaultOffsetY
    self:setOffsetPosition(gobj, 0, getObjectHeight(gobj) + offset)
end


function objinstance:setBottomLayer(gobj)
    rawToBottomLayer(self)
end

function objinstance:setTopLayer(gobj)
    rawToTopLayer(self)
end

function objinstance:setLayer(layer)
    rawToLayer(self, layer)
end

function objinstance:updateLayer()
    if self.layerMode == gui.layerMode.topLayer then
        self:setTopLayer()
    elseif self.layerMode == gui.layerMode.bottomLayer then
        self:setBottomLayer()
    end
end


function objinstance:setCenterLeft(gobj, offset)
    self:setLeft(gobj, offset)
    self:setCenterY(0, gobj)
end

function objinstance:setCenterRight(gobj, offset)
    self:setRight(gobj, offset)
    self:setCenterY(0, gobj)
end

function objinstance:setCenterUp(gobj, offset)
    self:setUp(gobj, offset)
    self:setCenterX(0, gobj)
end

function objinstance:setCenterDown(gobj, offset)
    self:setDown(gobj, offset)
    self:setCenterX(0, gobj)
end

function objinstance:set(autofunc)
    self.autofunc = autofunc
end


function objinstance:setShiftedLeft(gobj, offset)
    self:setLeft(gobj, offset)
    self:setPositionY(gobj.sourceY + getObjectHeight(gobj) - getObjectHeight(self))
end

function objinstance:setShiftedRight(gobj, offset)
    self:setRight(gobj, offset)
    self:setPositionY(gobj.sourceY + getObjectHeight(gobj) - getObjectHeight(self))
end

function objinstance:setShiftedUp(gobj, offset)
    self:setUp(gobj, offset)
    self:setPositionX(gobj.sourceX + getObjectWidth(gobj) - getObjectWidth(self))
end

function objinstance:setShiftedDown(gobj, offset)
    self:setDown(gobj, offset)
    self:setPositionX(gobj.sourceX + getObjectWidth(gobj) - getObjectWidth(self))
end


function objinstance:setBorderLeft(offset)
    offset = offset or self.sceneinstance.defaultOffsetX
    self:setPositionX(offset)
end

function objinstance:setBorderRight(offset)
    offset = offset or self.sceneinstance.defaultOffsetX
    self:setPositionX(self.sceneinstance.sizeX - getObjectWidth(self) - offset)
end

function objinstance:setBorderUp(offset)
    offset = offset or self.sceneinstance.defaultOffsetY
    self:setPositionY(offset)
end

function objinstance:setBorderDown(offset)
    offset = offset or self.sceneinstance.defaultOffsetY
    self:setPositionY(self.sceneinstance.sizeY - getObjectHeight(self) - offset)
end


function objinstance:setFontParameters(customFont, fontSizeX, fontSizeY, textSpacing)
    self.guiinstance.customFontEnable = true
    self.customFont = customFont
    self.fontSizeX = fontSizeX
    self.fontSizeY = fontSizeY
    self.textSpacing = textSpacing
end

function objinstance:setCustomStyle(style)
    self.style = style
end

local function getContainersBranch(obj)
    local list = {}
    while true do
        if not obj.sceneinstance then
            return list
        end
        table.insert(list, 1, obj)
        obj = obj.sceneinstance
    end
end

local function isObjectIsUpper(obj1, obj2) --WTF!!
    if obj1.sceneinstance.isWindow and not obj2.sceneinstance.isWindow and not obj2.isWindow then
        return true
    end

    if not obj1.sceneinstance.isWindow and obj2.sceneinstance.isWindow and not obj1.isWindow then
        return false
    end

    local contrainersBranch1, contrainersBranch2 = getContainersBranch(obj1), getContainersBranch(obj2)
    for i = 1, math.max(#contrainersBranch1, #contrainersBranch2) do
        local branch1obj = contrainersBranch1[i]
        local branch2obj = contrainersBranch2[i]
        if not branch1obj or not branch2obj then
            break
        end
        if branch1obj.sceneinstance == branch2obj.sceneinstance and branch1obj ~= branch2obj then
            obj1 = branch1obj
            obj2 = branch2obj
        end
    end

    if obj1.sceneinstance ~= obj2.sceneinstance then
        return false
    end

    local layer1, layer2
    for index, lobj in ipairs(obj1.sceneinstance.objs) do
        sc.yield()
        
        if obj1 == lobj then
            layer1 = index
        elseif obj2 == lobj then
            layer2 = index
        end

        if layer1 and layer2 then
            break
        end
    end

    return layer1 > layer2
end

local function updateTwoStep(self, updatedList, ignoreObject)
    if not self:isVisible() then return end
    if updatedList[self] then return end
    updatedList[self] = true

    self.needUpdateTwoStep = true

    for _, obj in ipairs(self.sceneinstance.allWindows) do
        sc.yield()
        if obj ~= self and obj ~= ignoreObject and checkIntersection(self, obj) then
            if isObjectIsUpper(obj, self) then
                updateTwoStep(obj, updatedList, ignoreObject)
            end
        end
    end

    for _, obj in ipairs(self.sceneinstance.objs) do
        sc.yield()
        if obj ~= self and obj ~= ignoreObject and checkIntersection(self, obj) then
            if isObjectIsUpper(obj, self) then
                updateTwoStep(obj, updatedList, ignoreObject)
            end
        end
    end
end

local function intersectionCheck(self, updatedList, objs)
    for _, obj in ipairs(objs) do
        sc.yield()
        if self ~= obj and checkIntersection(self, obj) then
            if isObjectIsUpper(obj, self) then
                updateTwoStep(obj, updatedList, self)
            end
        end
    end
end

function objinstance:setSize(width, height)
    if not width or not height then
        local _width, _height
        if self.calculateSize then
            _width, _height = self:calculateSize()
        else
            _width, _height = self.sceneinstance.sizeX - self.sourceX - self.sceneinstance.defaultOffsetX, self.sceneinstance.sizeY - self.sourceY - self.sceneinstance.defaultOffsetY
        end

        width = width or _width or 1
        height = height or _height or 1
    end

    self.sizeX = math.floor(width + 0.5)
    self.sizeY = math.floor(height + 0.5)
    remathElementInWindowPos(self)
    if self.isWindow then
        for _, obj in ipairs(self.objs) do
            remathElementInWindowPos(obj)
        end
    end
end

function objinstance:realUpdate()
    if not self:isVisible() then return end

    self.needUpdate = true

    local updatedList = {}
    local objectIntersectionMode = self.rootsceneinstance.objectIntersectionMode
    if objectIntersectionMode == 2 then
        intersectionCheck(self, updatedList, self.sceneinstance.allObjs)
    elseif objectIntersectionMode == 4 then
        intersectionCheck(self, updatedList, self.sceneinstance.allWindows)
        intersectionCheck(self, updatedList, self.sceneinstance.objs)
    elseif objectIntersectionMode == 1 or (objectIntersectionMode == 3 and #self.sceneinstance.allWindows > 0) then
        intersectionCheck(self, updatedList, self.sceneinstance.allWindows)
    end

    if self.sceneinstance:isSelected() then
        self.guiinstance.needFlushFlag = true
    end
end

function objinstance:update()
    self.rootsceneinstance.updateList[self] = true
end

function objinstance:getLastInteractionType()
    return self.lastInteractionType
end

function objinstance:getLastNickname()
    return self.lastNickname
end

function objinstance:isVisible()
    if self.invisible or self.destroyed then return false end
    if not self.sceneinstance:isSelected() then return false end

    local function recursionMinimizeCheck(self)
        sc.yield()

        if not self.sceneinstance.isWindow then
            return
        end

        if self.sceneinstance.up_hide and self.sourceY >= self.sceneinstance.up_size then
            return true
        end

        if recursionMinimizeCheck(self.sceneinstance) then
            return true
        end
    end

    return not recursionMinimizeCheck(self)
end

function objinstance:destroy()
    if self.destroyed then return false end
    self.destroyed = true

    if self.isWindow then
        for i = #self.objs, 1, -1 do
            local lobj = self.objs[i]
            lobj:destroy()
        end
    end

    for index, obj in ipairs(self.sceneinstance.panelObjs or {}) do
        sc.yield()
        if obj == self then
            table.remove(self.sceneinstance.panelObjs, index)
            break
        end
    end
    
    for index, obj in ipairs(self.sceneinstance.allObjs) do
        sc.yield()
        if obj == self then
            table.remove(self.sceneinstance.allObjs, index)
            break
        end
    end

    for index, obj in ipairs(self.sceneinstance.allWindows) do
        sc.yield()
        if obj == self then
            table.remove(self.sceneinstance.allWindows, index)
            break
        end
    end

    for index, obj in ipairs(self.sceneinstance.orderedObjs) do
        sc.yield()
        if obj == self then
            table.remove(self.sceneinstance.orderedObjs, index)
            break
        end
    end

    for index, obj in ipairs(self.sceneinstance.objs) do
        sc.yield()
        if obj == self then
            if self.onDestroy then self:onDestroy() end
            if self.onDestroy_fromClass then self:onDestroy_fromClass() end
            table.remove(self.sceneinstance.objs, index)
            self.guiinstance.needFlushFlag = true
            self.sceneinstance.needUpdate = true
            return true
        end
    end

    return false
end

function objinstance:_getBackColor()
    if self.sceneinstance.color and type(self.sceneinstance.color) ~= "function" then
        return self.sceneinstance.color
    end
    if self.sceneinstance then
        return self.sceneinstance:_getBackColor()
    end
end

function objinstance:clear(color, minWidth, minHeight)
    if not self.sceneinstance:isSelected() then return end
    if not color then
        color = self:_getBackColor()
    end
    color = formatColor(color, true)

    self.display.fillRect(self.x, self.y, math.max(minWidth or 0, getObjectWidth(self)), math.max(minHeight or 0, getObjectHeight(self)), color)
end

function objinstance:getDisplaySize()
    local box
    if self.text then
        box = {calcTextBox(self, self.text)}
    end
    return getObjectWidth(self, box), getObjectHeight(self, box)
end

function objinstance:setDisabled(state)
    if self.disable ~= state then
        self.disable = state
        self:update()
    end
end

function objinstance:setInvisible(state)
    if self.invisible ~= state then
        self.invisible = state
        self:update()
    end
end

-------- window

function objinstance:upPanel(color, textcolor, title, collapsibility)
    if color then
        self.up_color = formatColor(color, true)
        self.up_textcolor = formatColor(textcolor, true)
        self.up_title = title or ""
        self.up_collapsibility = collapsibility
        self.up_hide = false
        self.up_size = self.display.getFontHeight() + 2
        self.panelObjs = {}
    else
        self.up_color = nil
        self.up_title = nil
        self.up_collapsibility = nil
        self.up_hide = nil
        self.up_size = nil
        if self.panelObjs then
            for i, v in ipairs(self.panelObjs) do
                v:destroy()
            end
            self.panelObjs = nil
        end
    end
    self:update()
end

function objinstance:panelButton(sizeX, ...)
    if self.panelObjs then
        sizeX = sizeX or self.up_size
        local posX = self.panelObjs[#self.panelObjs]
        if posX then
            posX = posX.sourceX - sizeX
        else
            posX = self.sizeX - sizeX
        end
        local button = self:createButton(posX, 0, sizeX or self.up_size, self.up_size, ...)
        table.insert(self.panelObjs, button)
        self:update()
        return button
    end
end

function objinstance:panelObject(contructorname, sizeX, ...)
    if self.panelObjs then
        sizeX = sizeX or self.up_size
        local posX = self.panelObjs[#self.panelObjs]
        if posX then
            posX = posX.sourceX - sizeX
        else
            posX = self.sizeX - sizeX
        end
        local object = self[contructorname](self, posX, 0, sizeX or self.up_size, self.up_size, ...)
        table.insert(self.panelObjs, object)
        self:update()
        return object
    end
end

function objinstance:minimize(state)
    if self.up_color then
        if self.up_hide ~= state then
            self.up_hide = state
            self:update()
        end
    end
end

function objinstance:setDraggable(state)
    self.draggable = state
end

function objinstance:setAutoViewport(autoViewport)
    self.autoViewport = autoViewport
end

function objinstance:setColor(color)
    if self.color ~= color then
        self.color = color
        self:update()
    end
end

function objinstance:isSelected()
    return self.sceneinstance:isSelected()
end

function objinstance:updateParent()
    self.sceneinstance:update()
end

function objinstance:getParent()
    return self.sceneinstance
end

function objinstance:getLayer()
    for index, lobj in ipairs(self.sceneinstance.objs) do
        sc.yield()
        
        if lobj == self then
            return index
        end
    end

    error("failed to get layer", 2)
end

function objinstance:setLayerMode(mode)
    self.layerMode = mode
    self:updateLayer()
end

-------- label / text / button

function objinstance:setText(text)
    text = tostring(text)
    if self.text ~= text then
        local minWidth, minHeight = self:getDisplaySize()
        self.text = text
        self:update()
        if self.sceneinstance.color and type(self.sceneinstance.color) ~= "function" then
            self:clear(self.sceneinstance.color, minWidth, minHeight)
        end
    end
end

function objinstance:setFgColor(color)
    if self.fg ~= color then
        self.fg = formatColor(color)
        self:update()
    end
end

function objinstance:setBgColor(color)
    if self.bg ~= color then
        self.bg = color and formatColor(color)
        self:update()
    end
end

function objinstance:setPfgColor(color)
    if self.fg_press ~= color then
        self.fg_press = formatColor(color)
        self:update()
    end
end

function objinstance:setPbgColor(color)
    if self.bg_press ~= color then
        self.bg_press = formatColor(color)
        self:update()
    end
end

function objinstance:setIbgColor(color)
    if self.bg_interaction ~= color then
        self.bg_interaction = formatColor(color)
        self:update()
    end
end

function objinstance:setIfgColor(color)
    if self.fg_interaction ~= color then
        self.fg_interaction = formatColor(color)
        self:update()
    end
end

function objinstance:setStColor(color)
    if self.stroke_color ~= color then
        self.stroke_color = formatColor(color)
        self:update()
    end
end

function objinstance:setPstColor(color)
    if self.stroke_press ~= color then
        self.stroke_press = formatColor(color)
        self:update()
    end
end

function objinstance:setIstColor(color)
    if self.stroke_interaction ~= color then
        self.stroke_interaction = formatColor(color)
        self:update()
    end
end

-------- image

function objinstance:updateImage(img)
    self.img = img
    self:update()
end

-------- button

function objinstance:getState()
    return self.state
end

function objinstance:setState(state)
    self.state = state
    self.old_toggle_state = state
    self:update()
end

function objinstance:isPress()
    return self.state and not self.old_state
end

function objinstance:isReleased()
    return self.old_state and not self.state
end

function objinstance:attachCallback(callback)
    self.callbacks[1] = callback
end

function objinstance:setSceneSwitch(scene)
    self.callbacks[2] = function(_, state, inZone)
        if not state and inZone then
            scene:select()
        end
    end
end

-------- service

local function toUpperLevel(self)
    if self.layerMode ~= gui.layerMode.auto then
        return
    end
    
    return rawToTopLayer(self)
end

local function windowPosCheck(self)
    if self.sceneinstance.isWindow then
        local maxX = self.sceneinstance.sizeX - self.sizeX
        if self.sourceX < 0 then
            self.sourceX = 0
        elseif self.sourceX >= maxX then
            self.sourceX = maxX
        end

        local minY = self.sceneinstance.up_size or 0
        local maxY = self.sceneinstance.sizeY
        if self.up_hide then
            maxY = maxY - self.up_size
        else
            maxY = maxY - self.sizeY
        end
        if self.sourceY < minY then
            self.sourceY = minY
        elseif self.sourceY >= maxY then
            self.sourceY = maxY
        end
    end

    self.x = self.sourceX + (self.sceneinstance.x or 0)
    self.y = self.sourceY + (self.sceneinstance.y or 0)

    local function recursionUpdate(objs)
        sc.yield()
        for _, obj in ipairs(objs) do
            sc.yield()
            obj:setPosition(obj.sourceX, obj.sourceY)
            if obj.isWindow then
                recursionUpdate(obj.objs)
            end
        end
    end

    recursionUpdate(self.objs)
end

local function getLocalPosition(self, click)
    return click.x - self.x, click.y - self.y
end

local function processNewCallbacks(click, self, state, inZone)
    if click == true then click = nil end
    if click then
        if state then
            if inZone and not self.universalCallbacksState then
                self.universalCallbacksState = true
                if not self.isWindow then
                    toUpperLevel(self)
                end
                if self.onClick then
                    self:onClick(click, getLocalPosition(self, click))
                end
            end
        elseif self.universalCallbacksState then
            self.universalCallbacksState = false

            if self.onDrop then
                self:onDrop(click, getLocalPosition(self, click))
            end

            if inZone and self.onDropInZone then
                self:onDropInZone(click, getLocalPosition(self, click))
            end
        end

        if click.state == "drag" and self.universalCallbacksState then
            if self.onDrag then
                self:onDrag(click, getLocalPosition(self, click))
            end

            if inZone and self.onDragInZone then
                self:onDragInZone(click, getLocalPosition(self, click))
            end
        end
    end
end

local function runCallbacks(click, self, state, inZone)
    if self.callback then
        self.callback(self, state, inZone)
    end
    for k, v in pairs(self.callbacks) do
        v(self, state, inZone)
    end
    if self.state ~= self.old_toggle_state then
        if self.onToggle then
            self:onToggle(self.state)
        end
        self.old_toggle_state = self.state
    end
end

function objinstance:_tick(click)
    if not self.sizeX or self.disable or self.destroyed then
        return
    end

    local selected = false

    if click == true then
        self.interactionCurrently = false
    elseif click then
        selected = click and click[1] >= self.x and click[2] >= self.y and click[1] < (self.x + self.sizeX) and click[2] < (self.y + self.sizeY)
        local state = click[3] ~= "released"
        if not state or selected then
            self.interactionCurrently = state
        end
    end

    if self.interactionCurrently ~= self._interactionCurrently then
        self:update()
        self._interactionCurrently = self.interactionCurrently
    end

    if self.customHandler then
        if click == true and self.state then
            self:customHandler(-1, -1, "released", -1, "unknown", false) --release the pressed items when switching the scene
            self.state = false
        end
    end
    if self.button then
        if click == true and not self.toggle then
            self.state = false
            runCallbacks(click, self, false, false)
        end
        self.old_state = self.state
    end
    if click == true then
        processNewCallbacks(click, self, false, false)
    end
    if not click or click == true then
        return
    end

    local tx, ty = click[1], click[2]
    local lx, ly = tx - self.x, ty - self.y
    local clktype = click[3]
    local btntype = click[4]
    local nickname = click[5]

    if self.sceneinstance.autoViewport then
        if not (click[1] >= self.sceneinstance.x and click[2] >= self.sceneinstance.y and click[1] < (self.sceneinstance.x + self.sceneinstance.sizeX) and click[2] < (self.sceneinstance.y + self.sceneinstance.sizeY)) then
            selected = false
        end
    end

    self.lastClickTable = click
    self.lastInteractionType = btntype
    self.lastNickname = nickname
    
    processNewCallbacks(click, self, clktype == "pressed" or (self.universalCallbacksState and clktype == "drag"), selected)

    local elementCapture = false
    local windowDragging

    if self.button then
        if self.toggle then
            if selected and clktype == "pressed" then
                self.state = not self.state
                runCallbacks(click, self, self.state, true)
            end
        elseif selected and clktype == "pressed" then
            self.state = true
            runCallbacks(click, self, true, true)
        elseif clktype == "released" and self.state then
            self.state = false
            runCallbacks(click, self, false, selected)
        end

        if self.state ~= self.old_state then
            self:update()
        end
    elseif self.isWindow then
        local objectList
        if self.up_hide then
            objectList = self.panelObjs
            if selected and self.up_size and ly >= self.up_size then
                selected = false
            end
        else
            objectList = self.objs
        end
        if objectList and (clktype ~= "pressed" or selected) then
            local objs = sc.copy(objectList)
            for i = #objs, 1, -1 do
                sc.yield()
                local obj = objs[i]
                if not objs.destroyed and obj:_tick(click) then
                    elementCapture = true
                    if clktype ~= "released" then
                        break
                    end
                end
            end
        end

        if elementCapture and clktype == "pressed" then
            self.touchX = nil
            self.touchY = nil
            if toUpperLevel(self) then
                self.guiinstance.needFlushFlag = true
                self.sceneinstance.needUpdate = true
            end
        elseif clktype == "pressed" then
            if selected then
                local upSel = self.up_size and ly < self.up_size
                if self.up_color and self.up_collapsibility and upSel and lx < self.display.getFontWidth() + 2 then
                    self.up_hide = not self.up_hide
                    if self.up_hide then
                        if self.onMinimize then self:onMinimize() end
                        if self.sceneinstance.onWindowMinimize then
                            self.sceneinstance:onWindowMinimize()
                        end
                    else
                        if self.onMaximize then self:onMaximize() end
                        if self.sceneinstance.onWindowMaximize then
                            self.sceneinstance:onWindowMaximize()
                        end
                    end
                    windowPosCheck(self)
                    toUpperLevel(self)
                    self.guiinstance.needFlushFlag = true
                    self.sceneinstance.needUpdate = true
                    self.sceneinstance:updateChildrenRule()
                elseif not self.up_hide or upSel then
                    self.touchX = tx
                    self.touchY = ty
                    windowPosCheck(self)
                    if toUpperLevel(self) then
                        self.guiinstance.needFlushFlag = true
                        self.sceneinstance.needUpdate = true
                    end
                end
            end
        elseif clktype == "released" then
            self.touchX = nil
            self.touchY = nil
        elseif clktype == "drag" and self.touchX and self.draggable then
            self.guiinstance.needFlushFlag = true
            self.sceneinstance.needUpdate = true
            local dx = tx - self.touchX
            local dy = ty - self.touchY
            self.touchX = tx
            self.touchY = ty
            self.sourceX = self.sourceX + dx
            self.sourceY = self.sourceY + dy
            windowPosCheck(self)
            toUpperLevel(self)
            if self.onDragging then
                self:onDragging()
            end
            if self.sceneinstance.onWindowDragging then
                self.sceneinstance:onWindowDragging()
            end
            self.sceneinstance:updateChildrenRule()
            windowDragging = true
        end
    end

    if self.customHandler then
        if selected or (self.state and clktype == "released") or (self.state and self.handlerOutsideDrag and clktype == "drag") then
            self.state = clktype ~= "released"
            if not self.handlerAllClicks then
                local ax, ay = tx, ty
                if self.handlerLocalPosition then
                    ax, ay = lx, ly
                end
                if self:customHandler(ax, ay, clktype, btntype, nickname, selected, elementCapture) then
                    self:update()
                end
            end
        end
    end

    return self.universalCallbacksState and (selected or windowDragging)
end

function objinstance:redraw()
    self:update()
    self:_draw()
end

local function updateWindowObjects(self, force, twoStep)
    if self.up_hide then
        for _, obj in ipairs(self.objs) do
            sc.yield()
            if obj.sourceY < self.up_size then
                obj:_draw(force, twoStep)
            end
        end
    else
        for _, obj in ipairs(self.objs) do
            sc.yield()
            obj:_draw(force, twoStep)
        end
    end
end

function objinstance:_draw(force, twoStep)
    if self.invisible or self.destroyed then return end

    if twoStep then
        if not force and not self.needUpdateTwoStep then
            if self.isWindow then
                updateWindowObjects(self, false, true)
            end
            return
        end
        self.needUpdateTwoStep = false
    else
        if not force and not self.needUpdate then
            if self.isWindow then
                updateWindowObjects(self, false, false)
            end
            return
        end
        self.needUpdate = false
        if force then
            self.needUpdateTwoStep = false
        end
    end

    local restoreFont = setCustomFont(self)

    local old_viewport_x, old_viewport_y, old_viewport_sizeX, old_viewport_sizeY = self.display.getViewport()
    if self.autoViewport then
        self.display.setInlineViewport(self.x, self.y, self.sizeX, self.sizeY)
    end

    if self.preDraw then
        self:preDraw()
    end

    if self.style then
        self:style()
    elseif self.button or self.label or self.textBox then
        local bg, fg = self.bg, self.fg
        if self.state then
            bg, fg = self.bg_press, self.fg_press
        end
        if self.interactionCurrently then
            bg, fg = self.bg_interaction or bg, self.fg_interaction or fg
        end

        local strokeColor = self.state and self.stroke_press or self.stroke_color
        if self.interactionCurrently and self.stroke_interaction then
            strokeColor = self.stroke_interaction
        end
        self.display.fillRect(self.x, self.y, self.sizeX, self.sizeY, bg or self.sceneinstance.color or 0)
        if strokeColor then
            self.display.drawRect(self.x, self.y, self.sizeX, self.sizeY, strokeColor)
        end
        
        local graphic = sc.lib_require("graphic")
        if self.textBox then
            graphic.textBox(self.display, self.x + 1, self.y + 1, self.sizeX - 1, self.sizeY, self.text, fg, self.centerX, self.centerY, self.spacingY, self.autoNewline, self.tool)
        else
            graphic.textBox(self.display, self.x, self.y, self.sizeX, self.sizeY, self.text, fg, true, true, nil, false)
        end
    elseif self.isText then
        self.display.drawText(self.x, self.y, self.text, self.fg)
    elseif self.isImage then
        self.img:draw(self.display, self.x, self.y)
    elseif self.isWindow then
        if not self.up_hide then
            if type(self.color) == "function" then
                self:color()
            elseif self.color then
                self.display.fillRect(self.x, self.y, self.sizeX, self.sizeY, self.color)
            end
        end

        if self.up_color then
            self.display.fillRect(self.x, self.y, self.sizeX, self.up_size, self.up_color)
            if self.up_collapsibility then
                local arrowList = self.up_hide and arrow1 or arrow2
                local fontWidth = self.display.getFontWidth()
                local fontHeight = self.display.getFontHeight()
                local bitmap = arrowList[fontWidth]
                if bitmap then
                    drawBitmap(self.display, self.x + 1, self.y + 1, bitmap, self.up_textcolor)
                elseif self.up_hide then
                    self.display.fillTriangle(self.x + 1, self.y + 1, self.x + fontWidth, self.y + mathRound(fontHeight / 2), self.x + 1, self.y + fontHeight, self.up_textcolor)
                else
                    self.display.fillTriangle(self.x + 1, self.y + 1, self.x + fontWidth, self.y + 1, self.x + mathRound(fontWidth / 2), self.y + fontHeight, self.up_textcolor)
                end
                self.display.drawText(self.x + fontWidth + 2, self.y + 1, self.up_title, self.up_textcolor)
            else
                self.display.drawText(self.x + 1, self.y + 1, self.up_title, self.up_textcolor)
            end
        end
        
        updateWindowObjects(self, true, twoStep)
    end

    if self.postDraw then
        self:postDraw()
    end

    if self.autoViewport then
        self.display.setViewport(old_viewport_x, old_viewport_y, old_viewport_sizeX, old_viewport_sizeY)
    end

    if restoreFont then
        restoreFont()
    end
end

-----------------------------------scene instance

local sceneinstance = {}

function sceneinstance:setObjectIntersectionMode(mode)
    if not mode then
        mode = 0
    elseif mode == true then
        mode = 3
    end
    self.objectIntersectionMode = mode
end

function sceneinstance:setAlwaysRedraw(state)
    self.alwaysRedraw = not not state
end

function sceneinstance:isAlwaysRedraw()
    return self.alwaysRedraw
end

function sceneinstance:update()
    if self:isSelected() then
        self.needUpdate = true
        self.guiinstance.needFlushFlag = true
    end
end

function sceneinstance:_tick(clean)
    local click = self.display.getClick()
    if clean then
        click = true
    elseif self.onTick then
        self:onTick(click)
    end

    local elementCapture = false
    local elementCaptureList = {}
    if not self.bgHandleUse then
        local objs = sc.copy(self.objs)
        for i = #objs, 1, -1 do
            sc.yield()
            local obj = objs[i]
            if not obj.destroyed and obj:_tick(click) then
                elementCapture = true
                elementCaptureList[obj] = true
                if click ~= true and click[3] ~= "released" then
                    break
                end
            end
        end
    end

    if not clean then
        for i = #self.allObjs, 1, -1 do
            sc.yield()
    
            local obj = self.allObjs[i]
            obj:updateLayer()
            
            if obj.onTick then
                obj:onTick(click)
            end
    
            local visible = nil
    
            if obj.onTickIfVisible then
                if visible == nil then
                    visible = obj:isVisible()
                end
                if visible then
                    obj:onTickIfVisible(click)
                end
            end
    
            if obj.isWindow and not obj.up_hide and obj.onTickIfOpen then
                if visible == nil then
                    visible = obj:isVisible()
                end
                if visible then
                    obj:onTickIfOpen(click)
                end
            end
    
            if obj.universalCallbacksState and obj.onTickIfPressed then
                obj:onTickIfPressed(click, getLocalPosition(obj, click))
            end
    
            if click and obj.handlerAllClicks and obj.customHandler then
                local tx, ty = click[1], click[2]
                local lx, ly = tx - obj.x, ty - obj.y
                local selected = click[1] >= obj.x and click[2] >= obj.y and click[1] < (obj.x + obj.sizeX) and click[2] < (obj.y + obj.sizeY)
                local clktype = click[3]
                local btntype = click[4]
                local nickname = click[5]
    
                if obj.handlerLocalPosition then
                    tx, ty = lx, ly
                end
    
                if obj:customHandler(tx, ty, clktype, btntype, nickname, selected, not not elementCaptureList[obj]) then
                    obj:update()
                end
            end
        end
    
        if click then
            if not elementCapture and click[3] == "pressed" then
                self.bgHandleUse = true
            end
            if self.bgHandleUse and self.bgHandle then
                self:bgHandle(click)
            end
            if self.onBackgroundClick then
                self:onBackgroundClick(click, not self.bgHandleUse)
            end
            if click[3] == "released" then
                self.bgHandleUse = nil
            end
        end

        if self.needUpdateChildrenRule then
            self:realUpdateChildrenRule()
            self.needUpdateChildrenRule = nil
        end
        for _, window in ipairs(self.allWindows) do
            if window.needUpdateChildrenRule then
                window:realUpdateChildrenRule()
                window.needUpdateChildrenRule = nil
            end
        end
        
        return click
    end
end

function sceneinstance:_draw(force)
    if self.alwaysRedraw then
        force = true
    end

    if self.needUpdate or force then
        if self.color then
            if type(self.color) == "function" then
                self:color()
            else
                self.display.clear(self.color)
            end
        end
        self.needUpdate = false
        force = true
    end

    for _, obj in ipairs(self.objs) do
        sc.yield()
        obj:_draw(force)
    end

    if not force then
        for _, obj in ipairs(self.objs) do
            sc.yield()
            obj:_draw(force, true)
        end
    end
end

function sceneinstance:select()
    if self.guiinstance.scene and self.guiinstance.scene.onUnselect then
        self.guiinstance.scene:onUnselect()
    end
    
    if self.guiinstance.scene then
        self.guiinstance.scene:_tick(true) --чтобы сбросить все кнопки(не переключатели)
    end
    self.guiinstance.scene = self
    self:update()

    if self.onSelect then
        self:onSelect()
    end
end

function sceneinstance:isSelected()
    return self == self.guiinstance.scene
end

local function initObject(self, obj, noCalcSize)
    obj.guiinstance = self.guiinstance
    obj.sceneinstance = self
    obj.rootsceneinstance = self.rootsceneinstance or self
    obj.onWindow = self.isWindow
    obj.display = self.display
    obj._tick = objinstance._tick
    obj._draw = objinstance._draw
    obj.redraw = objinstance.redraw
    obj.destroy = objinstance.destroy
    obj.getLastInteractionType = objinstance.getLastInteractionType
    obj.getLastNickname = objinstance.getLastNickname
    obj.update = objinstance.update
    obj.clear = objinstance.clear
    obj._getBackColor = objinstance._getBackColor
    obj.setCustomStyle = objinstance.setCustomStyle
    obj.setInvisible = objinstance.setInvisible
    obj.setDisabled = objinstance.setDisabled

    obj.guiinstance.needFlushFlag = true
    obj.sceneinstance.needUpdate = true

    obj.setCenter = objinstance.setCenter
    obj.setCenterX = objinstance.setCenterX
    obj.setCenterY = objinstance.setCenterY
    obj.setPosition = objinstance.setPosition
    obj.setPositionX = objinstance.setPositionX
    obj.setPositionY = objinstance.setPositionY
    obj.setOffsetPosition = objinstance.setOffsetPosition
    obj.setOffsetPositionX = objinstance.setOffsetPositionX
    obj.setOffsetPositionY = objinstance.setOffsetPositionY
    obj.setLeft = objinstance.setLeft
    obj.setRight = objinstance.setRight
    obj.setUp = objinstance.setUp
    obj.setDown = objinstance.setDown
    obj.setCenterLeft = objinstance.setCenterLeft
    obj.setCenterRight = objinstance.setCenterRight
    obj.setCenterUp = objinstance.setCenterUp
    obj.setCenterDown = objinstance.setCenterDown
    obj.set = objinstance.set
    obj.setShiftedLeft = objinstance.setShiftedLeft
    obj.setShiftedRight = objinstance.setShiftedRight
    obj.setShiftedUp = objinstance.setShiftedUp
    obj.setShiftedDown = objinstance.setShiftedDown
    obj.setBorderLeft = objinstance.setBorderLeft
    obj.setBorderRight = objinstance.setBorderRight
    obj.setBorderUp = objinstance.setBorderUp
    obj.setBorderDown = objinstance.setBorderDown
    obj.setFontParameters = objinstance.setFontParameters
    obj.setBottomLayer = objinstance.setBottomLayer
    obj.setTopLayer = objinstance.setTopLayer
    obj.setLayer = objinstance.setLayer
    obj.getDisplaySize = objinstance.getDisplaySize
    obj.isVisible = objinstance.isVisible
    obj.updateParent = objinstance.updateParent
    obj.getParent = objinstance.getParent
    obj.getLayer = objinstance.getLayer
    obj.realUpdate = objinstance.realUpdate
    obj.setSize = objinstance.setSize
    obj.setLayerMode = objinstance.setLayerMode
    obj.updateLayer = objinstance.updateLayer

    obj.disable = obj.disable or false
    obj.invisible = obj.invisible or false
    obj.autoViewport = obj.autoViewport or false
    obj.layerMode = obj.layerMode or gui.layerMode.static

    --[[
    local autoX, autoY, autoSX, autoSY
    if self.isGrid then
        autoX, autoY = obj.x or 0, obj.y or 0
        autoX, autoY = autoX * self.gridItemSizeX, autoY * self.gridItemSizeY
        autoX, autoY = autoX + (self.gridItemSizeX / 2), autoY + (self.gridItemSizeY / 2)
        autoSX, autoSY = mathRound(self.gridItemSizeX * self.defaultObjectSizeXmul), mathRound(self.gridItemSizeY * self.defaultObjectSizeYmul)
        self.grid[obj.x][obj.y] = obj
        obj.x = nil
        obj.y = nil
    else
        autoX, autoY = self.defaultOffsetX, (self.up_size or 0) + self.defaultOffsetY
    end

    -- pos math
    local offsetX, offsetY = 0, 0
    if self.isGrid then
        offsetX, offsetY = -(autoSX / 2), -(autoSY / 2)
    end
    obj.x = mathRound((obj.x or autoX) + offsetX)
    obj.y = mathRound((obj.y or autoY) + offsetY)
    if obj.isText then
        obj.sizeX = obj.sizeX or autoSX
        obj.sizeY = obj.sizeY or autoSY
    else
        obj.sizeX = obj.sizeX or autoSX or (self.sizeX - obj.x - self.defaultOffsetX)
        obj.sizeY = obj.sizeY or autoSY or (self.sizeY - obj.y - self.defaultOffsetY)
    end
    obj.sourceX = obj.x
    obj.sourceY = obj.y
    remathElementInWindowPos(obj)
    ]]

    -- auto pos & size & layer
    obj.sourceX = mathRound(obj.x or self.defaultOffsetX)
    obj.sourceY = mathRound(obj.y or ((self.up_size or 0) + self.defaultOffsetY))

    remathElementInWindowPos(obj)

    if not obj.isText and not noCalcSize then
        obj:setSize(obj.sizeX, obj.sizeY)
    end

    obj:updateLayer()
    if self.defaultSet then
        obj:set(self.defaultSet)
    end

    table.insert(self.objs, obj)
    table.insert(self.orderedObjs, obj)
    table.insert(self.allObjs, obj)
end

function sceneinstance:setDefaultOffset(offsetX, offsetY)
    self.defaultOffsetX = offsetX or 1
    self.defaultOffsetY = offsetY or offsetX or 1
end

function sceneinstance:setDefaultPadding(paddingX, paddingY)
    self.defaultPaddingX = paddingX or 1
    self.defaultPaddingY = paddingY or paddingX or 1
end

function sceneinstance:getContainerSize()
    return self.sizeX, self.sizeY
end

function sceneinstance:getChildrenCount()
    return #self.objs
end

function sceneinstance:isScene()
    return not self.isWindow
end

function sceneinstance:updateChildrenRule()
    self.needUpdateChildrenRule = true
end

function sceneinstance:realUpdateChildrenRule()
    local autofuncPrevious
    for _, obj in ipairs(self.orderedObjs) do
        if obj.autofunc then
            obj:autofunc(autofuncPrevious, self)
            autofuncPrevious = obj
        end
    end
end

function sceneinstance:setDefaultSet(defaultSet)
    self.defaultSet = defaultSet
end

local function addSceneFields(sceneOrWindow, parent)
    sceneOrWindow.defaultOffsetX = parent and parent.defaultOffsetX or 1
    sceneOrWindow.defaultOffsetY = parent and parent.defaultOffsetY or 1
    sceneOrWindow.defaultPaddingX = parent and parent.defaultPaddingX or 2
    sceneOrWindow.defaultPaddingY = parent and parent.defaultPaddingY or 2
    sceneOrWindow.setDefaultOffset = sceneinstance.setDefaultOffset
    sceneOrWindow.setDefaultPadding = sceneinstance.setDefaultPadding
    sceneOrWindow.getContainerSize = sceneinstance.getContainerSize
    sceneOrWindow.getChildrenCount = sceneinstance.getChildrenCount
    sceneOrWindow.isScene = sceneinstance.isScene
    sceneOrWindow.setDefaultSet = sceneinstance.setDefaultSet
    sceneOrWindow.updateChildrenRule = sceneinstance.updateChildrenRule
    sceneOrWindow.realUpdateChildrenRule = sceneinstance.realUpdateChildrenRule
    sceneOrWindow.orderedObjs = {}
    sceneOrWindow.objs = {}

    sceneOrWindow.createButton = sceneinstance.createButton
    sceneOrWindow.createImage = sceneinstance.createImage
    sceneOrWindow.createText = sceneinstance.createText
    sceneOrWindow.createLabel = sceneinstance.createLabel
    sceneOrWindow.createTextBox = sceneinstance.createTextBox
    sceneOrWindow.createCustom = sceneinstance.createCustom
    sceneOrWindow.createWindow = sceneinstance.createWindow

    sceneOrWindow:updateChildrenRule()
end

function sceneinstance:createWindow(x, y, sizeX, sizeY, color)
    local obj = {
        x = x,
        y = y,
        sizeX = sizeX,
        sizeY = sizeY,
        color = color,
        draggable = false,
        allObjs = self.allObjs,
        allWindows = self.allWindows,
        windowNesting = (self.windowNesting or 0) + 1,
        layerMode = gui.layerMode.auto,

        setDraggable = objinstance.setDraggable,
        setAutoViewport = objinstance.setAutoViewport,
        setColor = objinstance.setColor,
        isSelected = objinstance.isSelected,
        upPanel = objinstance.upPanel,
        panelButton = objinstance.panelButton,
        panelObject = objinstance.panelObject,
        minimize = objinstance.minimize,

        isWindow = true
    }
    addSceneFields(obj, self)
    initObject(self, obj)

    table.insert(self.allWindows, obj)
    return obj
end

function sceneinstance:createCustom(x, y, sizeX, sizeY, cls, ...)
    if cls.useWindow then
        local clsCopy = sc.copy(cls)
        clsCopy.useWindow = nil

        local obj = self:createWindow(x, y, sizeX, sizeY)
        obj.preDraw = cls.drawer
        obj.customHandler = cls.handler
        obj.layerMode = cls.layerMode or gui.layerMode.static
        obj.handlerLocalPosition = cls.handlerLocalPosition
        obj.handlerAllClicks = cls.handlerAllClicks
        obj.handlerOutsideDrag = cls.handlerOutsideDrag
        obj.autoViewport = cls.autoViewport
        obj.calculateSize = cls.calculateSize
        if cls.methods then
            for k, v in pairs(cls.methods) do
                obj[k] = v
            end
        end
        if cls.init then
            cls.init(obj, ...)
        end
        obj:setSize(obj.sizeX, obj.sizeY)
        obj:updateLayer()
        return obj
    end

    local obj = {
        x = x,
        y = y,
        sizeX = sizeX,
        sizeY = sizeY,
        state = false,

        args = {...},
        style = cls.drawer,
        customHandler = cls.handler,
        handlerLocalPosition = cls.handlerLocalPosition,
        handlerAllClicks = cls.handlerAllClicks,
        handlerOutsideDrag = cls.handlerOutsideDrag,
        autoViewport = cls.autoViewport,
        calculateSize = cls.calculateSize,
        onDestroy_fromClass = cls.destroyHandler
    }
    initObject(self, obj, true)
    if cls.methods then
        for k, v in pairs(cls.methods) do
            obj[k] = v
        end
    end
    if cls.init then
        cls.init(obj, ...)
    end
    obj:setSize(obj.sizeX, obj.sizeY)

    return obj
end

function sceneinstance:createButton(x, y, sizeX, sizeY, toggle, text, bg, fg, bg_press, fg_press)
    text = tostring(text or "")
    bg = formatColor(bg)
    fg = formatColor(fg, true)
    if bg_press then
        bg_press = formatColor(bg_press)
    else
        bg_press = fg
    end
    if fg_press then
        fg_press = formatColor(fg_press, true)
    else
        fg_press = bg
    end

    local obj = {
        calculateSize = gui.calculateSizeByText,
        
        x = x,
        y = y,
        sizeX = sizeX,
        sizeY = sizeY,
        toggle = toggle,
        text = text,
        bg = bg,
        fg = fg,
        bg_press = bg_press,
        fg_press = fg_press,
        callbacks = {},

        getState = objinstance.getState,
        setState = objinstance.setState,
        isPress = objinstance.isPress,
        isReleased = objinstance.isReleased,
        attachCallback = objinstance.attachCallback,
        setSceneSwitch = objinstance.setSceneSwitch,

        setText = objinstance.setText,
        setBgColor = objinstance.setBgColor,
        setFgColor = objinstance.setFgColor,
        setPbgColor = objinstance.setPbgColor,
        setPfgColor = objinstance.setPfgColor,
        setIbgColor = objinstance.setIbgColor,
        setIfgColor = objinstance.setIfgColor,
        setStColor = objinstance.setStColor,
        setIstColor = objinstance.setIstColor,
        setPstColor = objinstance.setPstColor,

        old_toggle_state = false,
        state = false,
        button = true
    }
    initObject(self, obj)

    return obj
end

function sceneinstance:createImage(x, y, img)
    local obj = {
        calculateSize = gui.calculateSizeByImage,

        x = x,
        y = y,
        img = img,

        updateImage = objinstance.updateImage,

        isImage = true
    }
    initObject(self, obj)

    return obj
end

function sceneinstance:createLabel(x, y, sizeX, sizeY, text, bg, fg)
    text = tostring(text or "")
    bg = formatColor(bg)
    fg = formatColor(fg, true)

    local obj = {
        calculateSize = gui.calculateSizeByText,

        x = x,
        y = y,
        sizeX = sizeX,
        sizeY = sizeY,
        text = text,
        bg = bg,
        fg = fg,

        setText = objinstance.setText,
        setBgColor = objinstance.setBgColor,
        setFgColor = objinstance.setFgColor,
        setIbgColor = objinstance.setIbgColor,
        setIfgColor = objinstance.setIfgColor,
        setStColor = objinstance.setStColor,
        setIstColor = objinstance.setIstColor,

        label = true
    }

    initObject(self, obj)

    return obj
end

function sceneinstance:createTextBox(x, y, sizeX, sizeY, text, bg, fg, centerX, centerY, spacingY, autoNewline, tool)
    text = tostring(text or "")
    bg = bg and formatColor(bg)
    fg = formatColor(fg, true)

    local obj = {
        calculateSize = gui.calculateSizeByText,

        x = x,
        y = y,
        sizeX = sizeX,
        sizeY = sizeY,
        text = text,
        bg = bg,
        fg = fg,

        centerX = centerX,
        centerY = centerY,
        spacingY = spacingY,
        autoNewline = autoNewline,
        tool = tool,

        setText = objinstance.setText,
        setBgColor = objinstance.setBgColor,
        setFgColor = objinstance.setFgColor,
        setIbgColor = objinstance.setIbgColor,
        setIfgColor = objinstance.setIfgColor,
        setStColor = objinstance.setStColor,
        setIstColor = objinstance.setIstColor,

        textBox = true,
        disable = true
    }
    initObject(self, obj)

    return obj
end

function sceneinstance:createText(x, y, text, fg)
    text = tostring(text or "")
    fg = formatColor(fg)

    local obj = {
        x = x,
        y = y,
        text = text,
        fg = fg,

        setText = objinstance.setText,
        setFgColor = objinstance.setFgColor,
        setIfgColor = objinstance.setIfgColor,

        isText = true,
        disable = true
    }
    initObject(self, obj)
    
    return obj
end

-----------------------------------gui instance

local guiinstance = {}

--legacy
function guiinstance:setGameLight() end
function guiinstance:getGameLight() end

function guiinstance:tick()
    if not self.scene and self.defaultScene then self.defaultScene:select() end
    if not self.scene then return end

    local tickReturn = self.scene:_tick()

    for obj in pairs(self.scene.updateList) do
        obj:realUpdate()
    end
    self.scene.updateList = {}

    return tickReturn
end

function guiinstance:draw()
    if self.scene then
        self.scene:_draw()
    end
end

function guiinstance:drawForce()
    if self.scene then
        self.scene:_draw(true)
    end
end

function guiinstance:needFlush()
    local needFlushFlag = self.needFlushFlag or (self.scene and self.scene.alwaysRedraw)
    self.needFlushFlag = false
    return needFlushFlag
end

function guiinstance:createScene(color, bgHandle)
    if color and type(color) ~= "function" then
        color = sc.formatColor(color)
    end

    local scene = {
        guiinstance = self,
        display = self.display,
        color = color,
        bgHandle = bgHandle,
        allObjs = {},
        allWindows = {},
        updateList = {},
        objectIntersectionMode = 3,
        sizeX = self.display.getWidth(),
        sizeY = self.display.getHeight(),

        alwaysRedraw = false,
        setObjectIntersectionMode = sceneinstance.setObjectIntersectionMode,
        setAlwaysRedraw = sceneinstance.setAlwaysRedraw,
        isAlwaysRedraw = sceneinstance.isAlwaysRedraw,

        select = sceneinstance.select,
        isSelected = sceneinstance.isSelected,
        update = sceneinstance.update,

        _tick = sceneinstance._tick,
        _draw = sceneinstance._draw
    }
    addSceneFields(scene)

    if not self.defaultScene then
        self.defaultScene = scene
    end

    return scene
end

-----------------------------------gui

gui.intersectionMode = {
    disabled = 0,
    windows = 1,
    fullcheck = 2,
    auto = 3,
    advanced = 4
}

gui.layerMode = {
    auto = 0,
    static = 1,
    topLayer = 2,
    bottomLayer = 3
}

function gui.new(display)
    return {
        display = display,
        needFlushFlag = false,

        tick = guiinstance.tick,
        draw = guiinstance.draw,
        drawForce = guiinstance.drawForce,
        createScene = guiinstance.createScene,
        setGameLight = guiinstance.setGameLight,
        getGameLight = guiinstance.getGameLight,
        needFlush = guiinstance.needFlush,

        intersectionMode = gui.intersectionMode,
        layerMode = gui.layerMode
    }
end

function gui.calculateSizeByText(self)
    if self.text then
        local boxX, boxY = calcTextBox(self, self.text)
        return boxX + self.sceneinstance.defaultPaddingX, boxY + self.sceneinstance.defaultPaddingY
    end
end

function gui.calculateSizeByImage(self)
    if self.img then
        return self.img:getSize()
    end
end

-----------------------------------

return gui
end
end
function scmframework_19ebd2344d21ef55587784f73a58f785() --$CONTENT_DATA/Scripts/internal_libs/image.lua
function sc_reglib_image()
local sm_color_new = sm.color.new
local string_byte = string.byte
local string_char = string.char
local checkArg = checkArg
local formatColor = sc.formatColor
local concat = table.concat
local type = type

local colorslib = sc.lib_require("colors")

local function customFormatColor(color)
    return formatColor(color, sm.color.new(0, 0, 0, 0), true)
end

local function findPixelDataOffset(bmpData)
    -- Размер заголовка BMP (54 байта)
    local headerSize = 54

    -- Прочитать значение поля bfOffBits из BITMAPFILEHEADER (смещение 10-го байта)
    local bfOffBits = 0
    for i = 1, 4 do
        bfOffBits = bfOffBits + bmpData:byte(10 + i) * 256^(i - 1)
    end

    -- Вычислить смещение пиксельных данных
    local pixelDataOffset = headerSize + bfOffBits

    return pixelDataOffset
end


local function getPaletteFromBMP(filedata)
  local header = string.sub(filedata, 1, 54)

  local paletteOffset = bit.bor(bit.lshift(string.byte(header, 11), 0),
                                 bit.lshift(string.byte(header, 12), 8),
                                 bit.lshift(string.byte(header, 13), 16),
                                 bit.lshift(string.byte(header, 14), 24))

  local palette = {}
  for i = 0, 255 do
    local colorData = string.sub(filedata, paletteOffset + i * 4 + 1, paletteOffset + i * 4 + 4)
    local r, g, b = string.byte(colorData, 1, 3)
    palette[i] = {r, g, b}
  end

  return palette
end


local function colorToBytes(color)
    return string_char(math.floor((color.r * 255) + 0.5)) .. string_char(math.floor((color.g * 255) + 0.5)) ..
    string_char(math.floor((color.b * 255) + 0.5)) .. string_char(math.floor((color.a * 255) + 0.5))
end

local function bytesToColor(bytes)
    --[[
    return sm_color_new(
        string_byte(bytes, 1) / 255,
        string_byte(bytes, 2) / 255,
        string_byte(bytes, 3) / 255,
        string_byte(bytes, 4) / 255
    )
    ]]
    
    if string_byte(bytes, 4) == 0 then
        return
    end
    return colorslib.pack(string_byte(bytes, 1), string_byte(bytes, 2), string_byte(bytes, 3))
end

local function bytesToColorBMP(bytes, palette)
    --[[
    if #bytes == 4 then
        return sm_color_new(
            string_byte(bytes, 3) / 255,
            string_byte(bytes, 2) / 255,
            string_byte(bytes, 1) / 255,
            string_byte(bytes, 4) / 255
        )
    elseif #bytes == 3 then
        return sm_color_new(
            string_byte(bytes, 3) / 255,
            string_byte(bytes, 2) / 255,
            string_byte(bytes, 1) / 255
        )
    elseif #bytes == 1 then
        local r, g, b = unpack(palette[string_byte(bytes)])
        return sm_color_new(
            r / 255,
            g / 255,
            b / 255
        )
    else
        --error("failed to parse " .. tostring(#bytes) .. " bytes: " .. bytes)
        return sm_color_new(
            1,
            0,
            0
        )
    end
    ]]
    if #bytes == 4 then
        if string_byte(bytes, 4) == 0 then
            return
        end
        return colorslib.pack(string_byte(bytes, 3), string_byte(bytes, 2), string_byte(bytes, 1))
    elseif #bytes == 3 then
        return colorslib.pack(string_byte(bytes, 3), string_byte(bytes, 2), string_byte(bytes, 1))
    elseif #bytes == 1 then
        local tbl = palette[string_byte(bytes)]
        return colorslib.pack(tbl[1], tbl[2], tbl[3])
    else
        return 0xff0000
    end
end

local function colorToString(color)
    return tostring(color):sub(1, 6)
end

local redMul = 256 * 256
local greenMul = 256 
local bytePalette = {0x000000, 0x000040, 0x000080, 0x0000BF, 0x0000FF, 0x002400, 0x002440, 0x002480, 0x0024BF, 0x0024FF, 0x004900, 0x004940, 0x004980, 0x0049BF, 0x0049FF, 0x006D00, 0x006D40, 0x006D80, 0x006DBF, 0x006DFF, 0x009200, 0x009240, 0x009280, 0x0092BF, 0x0092FF, 0x00B600, 0x00B640, 0x00B680, 0x00B6BF, 0x00B6FF, 0x00DB00, 0x00DB40, 0x00DB80, 0x00DBBF, 0x00DBFF, 0x00FF00, 0x00FF40, 0x00FF80, 0x00FFBF, 0x00FFFF, 0x0F0F0F, 0x1E1E1E, 0x2D2D2D, 0x330000, 0x330040, 0x330080, 0x3300BF, 0x3300FF, 0x332400, 0x332440, 0x332480, 0x3324BF, 0x3324FF, 0x334900, 0x334940, 0x334980, 0x3349BF, 0x3349FF, 0x336D00, 0x336D40, 0x336D80, 0x336DBF, 0x336DFF, 0x339200, 0x339240, 0x339280, 0x3392BF, 0x3392FF, 0x33B600, 0x33B640, 0x33B680, 0x33B6BF, 0x33B6FF, 0x33DB00, 0x33DB40, 0x33DB80, 0x33DBBF, 0x33DBFF, 0x33FF00, 0x33FF40, 0x33FF80, 0x33FFBF, 0x33FFFF, 0x3C3C3C, 0x4B4B4B, 0x5A5A5A, 0x660000, 0x660040, 0x660080, 0x6600BF, 0x6600FF, 0x662400, 0x662440, 0x662480, 0x6624BF, 0x6624FF, 0x664900, 0x664940, 0x664980, 0x6649BF, 0x6649FF, 0x666D00, 0x666D40, 0x666D80, 0x666DBF, 0x666DFF, 0x669200, 0x669240, 0x669280, 0x6692BF, 0x6692FF, 0x66B600, 0x66B640, 0x66B680, 0x66B6BF, 0x66B6FF, 0x66DB00, 0x66DB40, 0x66DB80, 0x66DBBF, 0x66DBFF, 0x66FF00, 0x66FF40, 0x66FF80, 0x66FFBF, 0x66FFFF, 0x696969, 0x787878, 0x878787, 0x969696, 0x990000, 0x990040, 0x990080, 0x9900BF, 0x9900FF, 0x992400, 0x992440, 0x992480, 0x9924BF, 0x9924FF, 0x994900, 0x994940, 0x994980, 0x9949BF, 0x9949FF, 0x996D00, 0x996D40, 0x996D80, 0x996DBF, 0x996DFF, 0x999200, 0x999240, 0x999280, 0x9992BF, 0x9992FF, 0x99B600, 0x99B640, 0x99B680, 0x99B6BF, 0x99B6FF, 0x99DB00, 0x99DB40, 0x99DB80, 0x99DBBF, 0x99DBFF, 0x99FF00, 0x99FF40, 0x99FF80, 0x99FFBF, 0x99FFFF, 0xA5A5A5, 0xB4B4B4, 0xC3C3C3, 0xCC0000, 0xCC0040, 0xCC0080, 0xCC00BF, 0xCC00FF, 0xCC2400, 0xCC2440, 0xCC2480, 0xCC24BF, 0xCC24FF, 0xCC4900, 0xCC4940, 0xCC4980, 0xCC49BF, 0xCC49FF, 0xCC6D00, 0xCC6D40, 0xCC6D80, 0xCC6DBF, 0xCC6DFF, 0xCC9200, 0xCC9240, 0xCC9280, 0xCC92BF, 0xCC92FF, 0xCCB600, 0xCCB640, 0xCCB680, 0xCCB6BF, 0xCCB6FF, 0xCCDB00, 0xCCDB40, 0xCCDB80, 0xCCDBBF, 0xCCDBFF, 0xCCFF00, 0xCCFF40, 0xCCFF80, 0xCCFFBF, 0xCCFFFF, 0xD2D2D2, 0xE1E1E1, 0xF0F0F0, 0xFF0000, 0xFF0040, 0xFF0080, 0xFF00BF, 0xFF00FF, 0xFF2400, 0xFF2440, 0xFF2480, 0xFF24BF, 0xFF24FF, 0xFF4900, 0xFF4940, 0xFF4980, 0xFF49BF, 0xFF49FF, 0xFF6D00, 0xFF6D40, 0xFF6D80, 0xFF6DBF, 0xFF6DFF, 0xFF9200, 0xFF9240, 0xFF9280, 0xFF92BF, 0xFF92FF, 0xFFB600, 0xFFB640, 0xFFB680, 0xFFB6BF, 0xFFB6FF, 0xFFDB00, 0xFFDB40, 0xFFDB80, 0xFFDBBF, 0xFFDBFF, 0xFFFF00, 0xFFFF40, 0xFFFF80, 0xFFFFBF, 0xFFFFFF}
local function colorToByte(color)
    local color24Bit = (math.floor(color.r * 255) * redMul) + (math.floor(color.g * 255) * greenMul) + math.floor(color.b * 255)
    local closestDelta, closestIndex, delta, paletteColor, paletteR, paletteG, paletteB = math.huge, 1

    local r = color24Bit / 65536
    r = r - r % 1
    
    local g = (color24Bit - r * 65536) / 256
    g = g - g % 1
    
    local b = color24Bit - r * 65536 - g * 256

    for index = 1, #bytePalette do
        paletteColor = bytePalette[index]
        
        if color24Bit == paletteColor then
            return index - 1
        else
            paletteR = paletteColor / 65536
            paletteR = paletteR - paletteR % 1
            paletteG = (paletteColor - paletteR * 65536) / 256
            paletteG = paletteG - paletteG % 1
            paletteB = paletteColor - paletteR * 65536 - paletteG * 256

            delta = (paletteR - r) ^ 2 + (paletteG - g) ^ 2 + (paletteB - b) ^ 2
            
            if delta < closestDelta then
                closestDelta, closestIndex = delta, index
            end
        end
    end

    return closestIndex - 1
end

local function byteToColor(byte)
    return bytePalette[byte + 1]
end

-----------------------------------

local image = {}

local function addMethods(img)
    img.draw = image.draw
    img.getSize = image.getSize
    img.set = image.set
    img.get = image.get
    img.rawGet = image.rawGet
    img.encode = image.encode
    img.encode8 = image.encode8
    img.save = image.save
    img.save8 = image.save8
    img.drawForTicks = image.drawForTicks
    img.fromCamera = image.fromCamera
    img.fromCameraAll = image.fromCameraAll
end

-----------------------------------

function image.encode(img)
    if img.x > 256 then return error("resolution x greater than 256", 2) end
    if img.y > 256 then return error("resolution y greater than 256", 2) end

    local data = ""
    data = data .. string_char(img.x - 1)
    data = data .. string_char(img.y - 1)

    local datas = {}
    local i = 1
    for y = 0, img.y - 1 do
        for x = 0, img.x - 1 do
            sc.smartYield()
            datas[i] = colorToBytes(customFormatColor(img.data[x + (y * img.x)]))
            i = i + 1
        end
    end

    return data .. concat(datas)
end

function image.encode8(img)
    if img.x > 256 then return error("resolution x greater than 256", 2) end
    if img.y > 256 then return error("resolution y greater than 256", 2) end

    local data = ""
    data = data .. string_char(img.x - 1)
    data = data .. string_char(img.y - 1)

    local datas = {}
    local i = 1
    for y = 0, img.y - 1 do
        for x = 0, img.x - 1 do
            sc.smartYield()
            datas[i] = string_char(colorToByte(customFormatColor(img.data[x + (y * img.x)])))
            i = i + 1
        end
    end

    return data .. concat(datas)
end

function image.decode(data)
    local resX, resY = data:byte(1) + 1, data:byte(2) + 1

    local img = {x = resX, y = resY, data = {}, datamax = (resX - 1) + ((resY - 1) * resX)}
    local i = 3
    for y = 0, resY - 1 do
        for x = 0, resX - 1 do
            sc.smartYield()
            img.data[x + (y * resX)] = bytesToColor(data:sub(i, i + 3))
            i = i + 4
        end
    end
    addMethods(img)
    return img
end

function image.decode8(data)
    local resX, resY = data:byte(1) + 1, data:byte(2) + 1

    local img = {x = resX, y = resY, data = {}, datamax = (resX - 1) + ((resY - 1) * resX)}
    local i = 3
    for y = 0, resY - 1 do
        for x = 0, resX - 1 do
            sc.smartYield()
            img.data[x + (y * resX)] = byteToColor(data:byte(i))
            i = i + 1
        end
    end
    addMethods(img)
    return img
end

function image.decodeBmp(bmp_content)
    local bmp_header = bmp_content:sub(1, 54)

    local resX = string.byte(bmp_header, 19) + bit.lshift(string.byte(bmp_header, 20), 8) + bit.lshift(string.byte(bmp_header, 21), 16) + bit.lshift(string.byte(bmp_header, 22), 24)
    local resY = string.byte(bmp_header, 23) + bit.lshift(string.byte(bmp_header, 24), 8) + bit.lshift(string.byte(bmp_header, 25), 16) + bit.lshift(string.byte(bmp_header, 26), 24)
    local bpp = string.byte(bmp_header, 29) + bit.lshift(string.byte(bmp_header, 30), 8)
   
    local startRead, palette
    if bpp == 8 then bpp = -1 end --8 bit depth tempory unavailable
    if bpp == 32 then
        startRead = 54 + (4 * 24)
    elseif bpp == 24 then
        startRead = 54
    elseif bpp == 8 then
        startRead = 54 + (3 * 24)
        palette = getPaletteFromBMP(bmp_content)
    else
        error("not supported color depth, supported only: 32, 24", 2)
    end
    startRead = startRead + 1
    local colorbytes = bpp / 8

    local img = {x = resX, y = resY, data = {}, datamax = (resX - 1) + ((resY - 1) * resX)}
    local i = startRead

    for y = resY - 1, 0, -1 do
        for x = 0, resX - 1 do
            sc.smartYield()
            local str = bmp_content:sub(i, i + (colorbytes - 1))
            img.data[x + (y * resX)] = bytesToColorBMP(str, palette)
            i = i + colorbytes
        end

        local rowLength = resX * colorbytes
        local padding = (4 - (rowLength % 4)) % 4
        i = i + padding
    end
    addMethods(img)
    return img
end

-----------------------------------

function image.new(resX, resY, color)
    checkArg(1, resX, "number")
    checkArg(2, resY, "number")
    checkArg(3, color, "Color", "number", "string", "nil")

    local img = {x = resX, y = resY, data = {}, datamax = (resX - 1) + ((resY - 1) * resX)}
    for y = 0, resY - 1 do
        for x = 0, resX - 1 do
            sc.smartYield()
            img.data[x + (y * resX)] = color
        end
    end
    addMethods(img)
    return img
end

function image.load(disk, path)
    checkArg(1, disk, "table")
    checkArg(2, path, "string")

    local extension = string.find(path, "%.[^%.]*$")
    if extension then
        extension = string.sub(path, extension + 1)
    end
    local data = disk.readFile(path)
    if extension == "bmp" then
        return image.decodeBmp(data)
    elseif extension == "scimg8" then
        return image.decode8(data)
    else
        return image.decode(data)
    end 
end

function image.save(img, disk, path)
    checkArg(1, img, "table")
    checkArg(2, disk, "table")
    checkArg(3, path, "string")

    if not disk.hasFile(path) then
        disk.createFile(path)
    end
    return disk.writeFile(path, image.encode(img))
end

function image.save8(img, disk, path)
    checkArg(1, img, "table")
    checkArg(2, disk, "table")
    checkArg(3, path, "string")

    if not disk.hasFile(path) then
        disk.createFile(path)
    end
    return disk.writeFile(path, image.encode8(img))
end

-----------------------------------

local function needDrawColor(color)
    return color and (type(color) ~= "Color" or color.a > 0)
end

function image.draw(img, display, posX, posY)
    checkArg(1, img, "table")
    checkArg(2, display, "table")
    checkArg(3, posX, "number", "nil")
    checkArg(4, posY, "number", "nil")
    posX = posX or 0
    posY = posY or 0

    for y = 0, img.y - 1 do
        for x = 0, img.x - 1 do
            sc.smartYield()
            local color = img.data[x + (y * img.x)]
            if needDrawColor(color) then
                display.drawPixel(posX + x, posY + y, color)
            end
        end
    end
end

function image.drawForTicks(img, display, ticks, posX, posY)
    checkArg(1, img, "table")
    checkArg(2, display, "table")
    checkArg(3, ticks, "number", "nil")
    checkArg(4, posX, "number", "nil")
    checkArg(5, posY, "number", "nil")
    ticks = ticks or 40
    posX = posX or 0
    posY = posY or 0
    if ticks < 1 then error("ticks < 1", 2) end

    local pixelForDraw = math.floor(((img.x * img.y) / ticks) + 0.5)
    local currentPixel = 0

    return function ()
        for i = 1, pixelForDraw do
            sc.smartYield()

            if currentPixel > img.datamax then return true end
            local color = img.data[currentPixel]

            if needDrawColor(color) then
                local x = currentPixel % img.x
                local y = math.floor(currentPixel / img.x)
                display.drawPixel(posX + x, posY + y, color)
            end

            currentPixel = currentPixel + 1
        end
    end
end

function image.getSize(img)
    checkArg(1, img, "table")
    return img.x, img.y
end

function image.set(img, x, y, color)
    checkArg(1, img, "table")
    checkArg(2, x, "number")
    checkArg(3, y, "number")
    checkArg(4, color, "Color", "number", "string", "nil")
    if x < 0 or x >= img.x then error("invalid pixel pos", 2) end
    if y < 0 or y >= img.y then error("invalid pixel pos", 2) end
    img.data[x + (y * img.x)] = color
end

function image.get(img, x, y)
    checkArg(1, img, "table")
    checkArg(2, x, "number")
    checkArg(3, y, "number")
    if x < 0 or x >= img.x then error("invalid pixel pos", 2) end
    if y < 0 or y >= img.y then error("invalid pixel pos", 2) end
    return customFormatColor(img.data[x + (y * img.x)])
end

function image.rawGet(img, x, y)
    checkArg(1, img, "table")
    checkArg(2, x, "number")
    checkArg(3, y, "number")
    if x < 0 or x >= img.x then error("invalid pixel pos", 2) end
    if y < 0 or y >= img.y then error("invalid pixel pos", 2) end
    return img.data[x + (y * img.x)]
end

function image.fromCamera(img, camera, methodName, ...)
    checkArg(1, img, "table")
    checkArg(2, camera, "table")
    checkArg(3, methodName, "string")

    local v_x, v_y, v_sizeX, v_sizeY = camera.getViewport()
    camera.setViewport()
    local sx, sy, data = img.x, img.y, img.data
    local vdisplay = {
        noCameraEncode = true,
        getWidth = function ()
            return sx
        end,
        getHeight = function ()
            return sy
        end,
        drawPixel = function (x, y, color)
            data[x + (y * sx)] = color
        end
    }
    camera[methodName](vdisplay, ...)
    camera.setViewport(v_x, v_y, v_sizeX, v_sizeY)
end

function image.fromCameraAll(img, camera, methodName, ...)
    checkArg(1, img, "table")
    checkArg(2, camera, "table")
    checkArg(3, methodName, "string")

    local v_x, v_y, v_sizeX, v_sizeY = camera.getViewport()
    camera.setViewport()
    camera.resetCounter()
    local oldStep = camera.getStep()
    camera.setStep(img.y)

    local notEnd = true
    local notStart
    local sx, sy, data = img.x, img.y, img.data
    local vdisplay = {
        noCameraEncode = true,
        getWidth = function ()
            return sx
        end,
        getHeight = function ()
            return sy
        end,
        drawPixel = function (x, y, color)
            if x ~= 0 or y ~= 0 then
                notStart = true
            end
            if notStart and x == 0 and y == 0 then
                notEnd = false
            end
            
            data[x + (y * sx)] = color
        end
    }

    local i = 0
    while notEnd do
        sc.smartYield()
        i = i + 1
        camera[methodName](vdisplay, ...)
    end

    camera.setStep(oldStep)
    camera.setViewport(v_x, v_y, v_sizeX, v_sizeY)
end

-----------------------------------

return image
end
end
function scmframework_2235cbd8dd3f9047d2af25bfed19d253() --$CONTENT_DATA/Scripts/internal_libs/json.lua
function sc_reglib_json()
local jsonlib = {}
local json = json
local jsonEncodeInputCheck = jsonEncodeInputCheck

function jsonlib.encode(tbl)
    jsonEncodeInputCheck(tbl, 0)
    return json.encode(tbl)
end

function jsonlib.decode(jsonstring)
    return json.decode(jsonstring)
end

function jsonlib.nativeEncode(tbl)
    jsonEncodeInputCheck(tbl, 0)
    return sm.json.writeJsonString(tbl)
end

function jsonlib.nativeDecode(jsonstring)
    return sm.json.parseJsonString(jsonstring)
end

return jsonlib
end
end
function scmframework_6987a6d8c4d9dfa8d735f58db6dd311f() --$CONTENT_DATA/Scripts/internal_libs/midi.lua
local function parseMIDI(f)
    local bit32 = bit

    local function parseVarInt(s, bits) -- parses multiple bytes as an integer
        if not s then
            error("error parsing file")
        end
        bits = bits or 8
        local mask = bit32.rshift(0xFF, 8 - bits)
        local num = 0
        for i = 1, s:len() do
            sc.yield()
            num = num + bit32.lshift(bit32.band(s:byte(i), mask), (s:len() - i) * bits)
        end
        return num
    end

    local function readChunkInfo() -- reads chunk header info
        local id = f:read(4)
        if not id then
            return
        end
        return id, parseVarInt(f:read(4))
    end

    -- Read the file header and with if file information.
    local id, size = readChunkInfo()
    --print(id, size)
    if id ~= "MThd" or size ~= 6 then
        --print("error parsing header (" .. id .. "/" .. size .. ")")
        return
    end

    local format = parseVarInt(f:read(2))
    local tracks = parseVarInt(f:read(2))
    local delta = parseVarInt(f:read(2))

    if format < 0 or format > 2 then
        --print("unknown format")
        return
    end

    local formatName = ({"single", "synchronous", "asynchronous"})[format + 1]
    --print(string.format("Found %d %s tracks.", tracks, formatName))

    if format == 2 then
        --print("Sorry, asynchronous tracks are not supported.")
        return
    end

    -- Figure out our time system and prepare accordingly.
    local time = {division = bit32.band(0x8000, delta) == 0 and "tpb" or "fps"}
    if time.division == "tpb" then
        time.tpb = bit32.band(0x7FFF, delta)
        time.mspb = 500000
        function time.tick()
            return time.mspb / time.tpb
        end
        --print(string.format("Time division is in %d ticks per beat.", time.tpb))
    else
        time.fps = bit32.band(0x7F00, delta)
        time.tpf = bit32.band(0x00FF, delta)
        function time.tick()
            return 1000000 / (time.fps * time.tpf)
        end
        --print(string.format("Time division is in %d frames per second with %d ticks per frame.", time.fps, time.tpf))
    end

    -- Parse all track chunks.
    local totalOffset = 0
    local totalLength = 0
    local tracks = {}
    local interations = 0
    while true do
        sc.yield()

        local id, size = readChunkInfo()
        if not id or id == "" then
            break
        end

        if id == "MTrk" then
            local track = {}
            local cursor = 0
            local start, offset = f:seek(), 0
            local inSysEx = false
            local running = 0

            local function read(n)
                n = n or 1
                if n > 0 then
                    offset = offset + n
                    return f:read(n)
                end
            end
            local function readVariableLength()
                local total = ""
                for i = 1, math.huge do
                    sc.yield()
                    local part = read()
                    total = total .. part
                    if bit32.band(0x80, part:byte(1)) == 0 then
                        return parseVarInt(total, 7)
                    end
                end
            end
            local function parseVoiceMessage(event)
                local channel = bit32.band(0xF, event)
                local note = parseVarInt(read())
                local velocity = parseVarInt(read())
                return channel, note, velocity
            end

            while offset < size do
                sc.yield()
                
                cursor = cursor + readVariableLength()
                totalLength = math.max(totalLength, cursor)
                local test = parseVarInt(read())
                if inSysEx and test ~= 0xF7 then
                    --error("corrupt file: could not find continuation of divided sysex event")
                end
                local event
                if bit32.band(test, 0x80) == 0 then
                    --if running == 0 then
                    --    error("corrupt file: invalid running status")
                    --end
                    --if not f.bufferRead then f.bufferRead = "" end
                    --f.bufferRead = string.char(test) .. f.bufferRead
                    --offset = offset - 1
                    event = running
                else
                    event = test
                    if test < 0xF0 then
                        running = test
                    end
                end
                local status = bit32.band(0xF0, event)

                if status == 0x80 then -- Note off.
                    local channel, note, velocity = parseVoiceMessage(event)
                    track[cursor] = {false, channel, note, velocity}

                elseif status == 0x90 then -- Note on.
                    local channel, note, velocity = parseVoiceMessage(event)
                    track[cursor] = {true, channel, note, velocity}

                elseif status == 0xA0 then -- Aftertouch / key pressure
                    parseVoiceMessage(event) -- not handled
                elseif status == 0xB0 then -- Controller
                    parseVoiceMessage(event) -- not handled
                elseif status == 0xC0 then -- Program change
                    parseVarInt(read()) -- not handled
                elseif status == 0xD0 then -- Channel pressure
                    parseVarInt(read()) -- not handled
                elseif status == 0xE0 then -- Pitch / modulation wheel
                    parseVarInt(read(2), 7) -- not handled
                elseif event == 0xF0 then -- System exclusive event
                    local length = readVariableLength()
                    if length > 0 then
                        read(length - 1)
                        inSysEx = read(1):byte(1) ~= 0xF7
                    end
                elseif event == 0xF1 then -- MIDI time code quarter frame
                    parseVarInt(read()) -- not handled
                elseif event == 0xF2 then -- Song position pointer
                    parseVarInt(read(2), 7) -- not handled
                elseif event == 0xF3 then -- Song select
                    parseVarInt(read(2), 7) -- not handled
                elseif event == 0xF7 then -- Divided system exclusive event
                    local length = readVariableLength()
                    if length > 0 then
                        read(length - 1)
                        inSysEx = read(1):byte(1) ~= 0xF7
                    else
                        inSysEx = false
                    end
                elseif event >= 0xF8 and event <= 0xFE then -- System real-time event
                    -- not handled
                elseif event == 0xFF then
                    -- Meta message.
                    local metaType = parseVarInt(read())
                    local length = parseVarInt(read())
                    local data = read(length)

                    if metaType == 0x00 then -- Sequence number
                        track.sequence = parseVarInt(data)
                    elseif metaType == 0x01 then -- Text event
                    elseif metaType == 0x02 then -- Copyright notice
                    elseif metaType == 0x03 then -- Sequence / track name
                        track.name = data
                    elseif metaType == 0x04 then -- Instrument name
                        track.instrument = data
                    elseif metaType == 0x05 then -- Lyric text
                    elseif metaType == 0x06 then -- Marker text
                    elseif metaType == 0x07 then -- Cue point
                    elseif metaType == 0x20 then -- Channel prefix assignment
                    elseif metaType == 0x2F then -- End of track
                        track.eot = cursor
                    elseif metaType == 0x51 then -- Tempo setting
                        track[cursor] = parseVarInt(data)
                    elseif metaType == 0x54 then -- SMPTE offset
                    elseif metaType == 0x58 then -- Time signature
                    elseif metaType == 0x59 then -- Key signature
                    elseif metaType == 0x7F then -- Sequencer specific event
                    end
                else
                    --[[
                    f:seek("cur", -9)
                    local area = f:read(16)
                    local dump = ""
                    for i = 1, area:len() do
                        dump = dump .. string.format(" %02X", area:byte(i))
                        if i % 4 == 0 then
                            dump = dump .. "\n"
                        end
                    end
                    error(
                        string.format(
                            "midi file contains unhandled event types:\n0x%X at offset %d/%d\ndump of the surrounding area:\n%s",
                            event,
                            offset,
                            size,
                            dump
                        )
                    )
                    ]]
                end

                cursor = cursor + 1
            end
            local delta = size - offset
            if delta ~= 0 then
                f:seek("cur", delta)
            end
            totalOffset = totalOffset + size

            table.insert(tracks, track)
        else
            --print(string.format("Encountered unknown chunk type %s, skipping.", id))
        end

        interations = interations + 1
        if interations > 1000 then
            break
        end
    end

    return {
        tracks = tracks,
        time = time,
        totalLength = totalLength
    }
end

--[[

local function noteToFreq(note)
    return math.pow(2, (note - 69) / 12) * 440
end

local function freqToPitch(freq)
    return mapClip(freq, 200, 900, 0, 1)
end

local function freqToNote(frequency)
    return math.min(25.99,math.max(0.01,math.log(frequency / 27.5*((2^(1/12))^(15))) * 1/math.log(2^(1/12))))
end

local function noteToPitch(note)
    return (note-1)/88
end
]]

local function toteToPitch(tote)
    return mapClip(tote, 0, 24, 0, 1)
end

local function convertMidiToNote(self, midiNote)
    local convertedNote = midiNote + self.noteshift
    if (convertedNote < 0 or convertedNote > 24) and self.notealigment == 0 then
        return
    end
    return convertedNote
end

------------------

local midi = {}

------------------player

function midi:load(disk, path)
    self.content = disk.readFile(path)
    self:loadStr(self.content)
end

function midi:loadStr(content)
    self.content = content
end

function midi:setSynthesizers(synthesizers)
    self.synthesizers = synthesizers
end

function midi:start()
    if not self.content then return end
    
    self.state = {stopflag = {}, cbeeps = {}}

    local pos = 1
    local fakefile
    fakefile = {
        read = function (_, n)
            local str = self.content:sub(pos, pos + (n - 1))
            pos = pos + n
            return str
        end, seek = function (_, mode, n)
            if not mode then
                return pos - 1
            end

            if mode == "cur" then
                pos = pos + n
            elseif mode == "set" then
                pos = n + 1
            end
        end
    }

    self.state.mid = parseMIDI(fakefile)
    self.state.tick = 1
    self.state.cnotes = {}

    for i in ipairs(self.synthesizers) do
        sc.yield()

        self.state.cnotes[i] = {}
        self.state.cbeeps[i] = {}
    end
end

function midi:stop()
    self.state = nil
    for _, synthesizer in ipairs(self.synthesizers) do
        sc.yield()

        synthesizer.stop()
    end
end

function midi:isPlaying()
    return not not self.state
end

function midi:setDefaultInstrument(id)
    self.instrument = id
end

function midi:setVolume(num)
    self.volume = num
end

function midi:setNoteShift(noteshift)
    self.noteshift = noteshift
end

function midi:setNoteAligment(notealigment)
    self.notealigment = notealigment
end

function midi:setSpeed(speed)
    self.speed = speed
end

function midi:_flush()
    if not self.state.flushflag then return end

    for synthesizerId in pairs(self.state.stopflag) do
        sc.yield()
        local synthesizer = self.synthesizers[synthesizerId]
        self.state.cbeeps[synthesizerId] = {}
        synthesizer.stop()
    end

    for _, synthesizer in ipairs(self.synthesizers) do
        sc.yield()
        synthesizer.clear()
    end
    
    for synthesizerId, notes in pairs(self.state.cnotes) do
        sc.yield()
        for note, data in pairs(notes) do
            sc.yield()
            local synthesizer = self.synthesizers[synthesizerId]
            local note = toteToPitch(note)
            local volume = self.volume
            local instrumentTable = self.instrumentTable
            local instrument = self.instrument
            if instrumentTable then
                local trackname = data.trackname
                if trackname then
                    trackname = trackname:lower()
                    local idx = self.instrumentTable[trackname]
                    if idx then
                        instrument = idx
                    else
                        for key, value in pairs(self.instrumentTable) do
                            sc.yield()
                            if trackname:find(key:lower()) then
                                if type(value) == "table" then
                                    instrument = value[1]
                                    volume = volume * (value[2] or 1)
                                else
                                    instrument = value
                                end
                                break
                            end
                        end
                    end
                end
            end

            local finded
            for _, tbl in ipairs(self.state.cbeeps[synthesizerId]) do
                sc.yield()
                if tbl[1] == instrument and tbl[2] == note and tbl[3] == volume then
                    finded = true
                    break
                end
            end

            if not finded then
                table.insert(self.state.cbeeps[synthesizerId], {instrument, note, volume})
                self.synthesizers[synthesizerId].addBeep(instrument, note, volume)
                synthesizer.flush() --does not lead to unnecessary shipments, just puts a flag
            end
        end
    end

    self.state.flushflag = nil
    self.state.stopflag = {}
end

function midi:tick()
    if not self.state then return end

    for _ = 0, sc.getSkippedTicks() do
        for i = 1, math.floor((((1000000 / self.state.mid.time.tick()) / 40) * self.speed) + 0.5) do
            sc.yield()
            for trackid, track in ipairs(self.state.mid.tracks) do
                --print(track.name)
                sc.yield()
                local event = track[self.state.tick]
                if event then
                    if type(event) == "number" then
                        self.state.mid.time.mspb = event
                    elseif type(event) == "table" then
                        local state, channel, note, velocity = unpack(event)

                        trackid = trackid - 1
                        trackid = trackid % #self.synthesizers
                        local synthesizerId = trackid + 1

                        note = convertMidiToNote(self, note)
                        if note then
                            if state then
                                local old_synthesizerId = synthesizerId

                                local activeCount = 0
                                for note in pairs(self.state.cnotes[synthesizerId]) do
                                    sc.yield()
                                    activeCount = activeCount + 1
                                end
                                if activeCount > 0 then
                                    for id in ipairs(self.synthesizers) do
                                        sc.yield()
                                        local activeCount2 = 0
                                        for note in pairs(self.state.cnotes[id]) do
                                            sc.yield()
                                            activeCount2 = activeCount2 + 1
                                        end
                                        if activeCount2 == 0 then
                                            synthesizerId = id
                                            break
                                        end
                                    end
                                end

                                if old_synthesizerId ~= synthesizerId then
                                    if not self.state.swapTable then self.state.swapTable = {} end
                                    table.insert(self.state.swapTable, {note, old_synthesizerId, synthesizerId})
                                end
                                self.state.cnotes[synthesizerId][note] = {trackname = track.name, instrument = track.instrument}
                            else
                                local swaps = {}
                                if self.state.swapTable then   
                                    for i = #self.state.swapTable, 1, -1 do
                                        sc.yield()
                                        local tbl = self.state.swapTable[i]
                                        if tbl and tbl[1] == note and tbl[2] == synthesizerId then
                                            table.insert(swaps, tbl[3])
                                            self.state.swapTable[i] = nil
                                        end
                                    end
                                end

                                if #swaps > 0 then
                                    for _, swap in ipairs(swaps) do
                                        sc.yield()
                                        self.state.cnotes[swap][note] = nil
                                        self.state.stopflag[swap] = true
                                    end
                                else
                                    self.state.cnotes[synthesizerId][note] = nil
                                    self.state.stopflag[synthesizerId] = true
                                end
                            end

                            self.state.flushflag = true
                        end
                    end
                end
            end

            self.state.tick = self.state.tick + 1
            if self.state.tick > self.state.mid.totalLength then
                for _, synthesizer in ipairs(self.synthesizers) do
                    sc.yield()
                    synthesizer.stop()
                end
                self.state = nil
                return
            end
        end
    end

    self:_flush()
end

function sc_reglib_midi()
local midilib = {}

function midilib.create()
    return {
        synthesizers = {},
        instrument = 4,
        volume = 0.1,
        noteshift = -50,
        notealigment = 1,
        speed = 1,
        _flush = midi._flush,
        instrumentTable = {
            square = {8, 1},
            guitar = {9, 1},
            piano = 4,
            synth = 3,
            bass = 5,
            drum = 2
        },

        load = midi.load,
        loadStr = midi.loadStr,
        setSynthesizers = midi.setSynthesizers,
        tick = midi.tick,
        start = midi.start,
        stop = midi.stop,
        isPlaying = midi.isPlaying,
        setDefaultInstrument = midi.setDefaultInstrument,
        setVolume = midi.setVolume,
        setNoteShift = midi.setNoteShift,
        setNoteAligment = midi.setNoteAligment, --OOPS
        setNoteAlignment = midi.setNoteAligment, --FIX
        setSpeed = midi.setSpeed
    }
end

return midilib
end
end
function scmframework_61ef67404754c8c9ca2fb1ab9a45fb14() --$CONTENT_DATA/Scripts/internal_libs/nbs.lua
local function parseNBS(handle)
    local function readInteger(handle)
        local buffer = handle:read(4)

        -- We dont deal with garbage
        if buffer == nil or #buffer < 4 then
            return nil
        end

        local bytes = {}
        bytes[1] = string.byte(buffer, 1)
        bytes[2] = string.byte(buffer, 2)
        bytes[3] = string.byte(buffer, 3)
        bytes[4] = string.byte(buffer, 4)

        local num = bytes[1] + bit.lshift(bytes[2], 8) + bit.lshift(bytes[3], 16) + bit.lshift(bytes[4], 24)
        return num
    end

    local function readShort(handle)
        local buffer = handle:read(2)

        if buffer == nil or #buffer < 2 then
            return nil
        end

        local bytes = {}
        bytes[1] = string.byte(buffer, 1)
        bytes[2] = string.byte(buffer, 2)

        local num = bytes[1] + bit.lshift(bytes[2], 8)
        return num
    end

    local function readByte(handle)
        local buffer = handle:read(1)

        if buffer == nil then
            return nil
        end

        return string.byte(buffer, 1)
    end

    local function readString(handle)
        local length = readInteger(handle)
        local txt = handle:read(length)
        return txt
    end

    local div = 1

    local song = {}
    song["length"] = readShort(handle)
    local newFormat = song["length"] == 0
    if newFormat then
        song["version"] = readByte(handle)
        song["vic"] = readByte(handle)
        song["song_length"] = readShort(handle)
        song["layer_count"] = readShort(handle)
        song["name"] = readString(handle)
        song["author"] = readString(handle)
        song["ogauthor"] = readString(handle)
        song["desc"] = readString(handle)
        song["tempo"] = readShort(handle)

        for i=1,3 do readByte(handle) end
        for i=1,5 do readInteger(handle) end
        readString(handle)
        for i=1,3 do readByte(handle) end

        div = 256
    else
        song["height"] = readShort(handle)
        song["name"] = readString(handle)
        song["author"] = readString(handle)
        song["ogauthor"] = readString(handle)
        song["desc"] = readString(handle)
        song["tempo"] = readShort(handle)
    
        for i=1,3 do readByte(handle) end
        for i=1,5 do readInteger(handle) end
        readString(handle)
    end

    local frame = math.floor(1000 / (song["tempo"] / 100))
    local sleep = frame / 1000

    local ticks = {}
    local currenttick = -1

    while true do
        local step = readShort(handle)
        if step == 0 then
            break
        end

        currenttick = currenttick + step
        local currenttickIndex = math.floor(currenttick / div)
        ticks[currenttickIndex] = {}

        local lpos = 1
        if newFormat then
            while true do
                local jump = readShort(handle)
                if jump == 0 then
                    break
                end

                readByte(handle)
                local inst = readByte(handle)
                local note = readByte(handle)
                readByte(handle)
                readShort(handle)

                ticks[currenttickIndex][lpos] = {}
                ticks[currenttickIndex][lpos]["inst"] = inst
                ticks[currenttickIndex][lpos]["note"] = note
                lpos = lpos + 1

                sc.yield()
            end
        else
            while true do
                local jump = readShort(handle)
                if jump == 0 then
                    break
                end

                local inst = readByte(handle)
                local note = readByte(handle)

                ticks[currenttickIndex][lpos] = {}
                ticks[currenttickIndex][lpos]["inst"] = inst
                ticks[currenttickIndex][lpos]["note"] = note
                lpos = lpos + 1

                sc.yield()
            end
        end

        sc.yield()
    end

    return song, ticks, math.floor(currenttick / div), 1 / (sleep * 40)
end

local function toteToPitch(tote)
    return mapClip(tote, 0, 24, 0, 1)
end

local function midiToFrequency(midiNote)
    local A4 = 440
    return A4 * 2^((midiNote - 69) / 12)
end

local function convertMidiToNote(self, midiNote)
    local convertedNote = midiNote + self.noteshift
    if (convertedNote < 0 or convertedNote > 24) and self.notealigment == 0 then
        return
    end
    return convertedNote
end

------------------

local nbs = {}

------------------player

function nbs:load(disk, path)
    self.content = disk.readFile(path)
    self:loadStr(self.content)
end

function nbs:loadStr(content)
    self.content = content
end

function nbs:setSynthesizers(synthesizers)
    self.synthesizers = synthesizers
    self.useNewApi = true
    for _, synthesizer in ipairs(synthesizers) do
        if not synthesizer.toteBeep then
            self.useNewApi = false
            break
        end
    end
end

function nbs:start()
    if not self.content then return end

    local pos = 1
    local fakefile
    fakefile = {
        read = function (_, n)
            local str = self.content:sub(pos, pos + (n - 1))
            pos = pos + n
            return str
        end, seek = function (_, mode, n)
            if not mode then
                return pos - 1
            end

            if mode == "cur" then
                pos = pos + n
            elseif mode == "set" then
                pos = n + 1
            end
        end
    }

    self.state = {}
    self.state.metadata, self.state.track, self.state.length, self.state.speed = parseNBS(fakefile)
    self.state.tick = 0
end

function nbs:stop()
    self.state = nil
    for _, synthesizer in ipairs(self.synthesizers) do
        sc.yield()

        synthesizer.stop()
    end
end

function nbs:isPlaying()
    return not not self.state
end

function nbs:setDefaultInstrument(id)
    self.instrument = id
end

function nbs:setVolume(num)
    self.volume = num
end

function nbs:setNoteShift(noteshift)
    self.noteshift = noteshift
end

function nbs:setNoteAlignment(notealigment)
    self.notealigment = notealigment
end

function nbs:setSpeed(speed)
    self.speed = speed
end

local function instrumentToSamplePosition(synthesizer, id)
    return synthesizer.getMaxSamplesCount() - id
end

local defaultInstrumentsVolume = {
    [0] = 2
}

function nbs:configNoteblockSamples(instrumentsVolume, customInstruments)
    instrumentsVolume = instrumentsVolume or defaultInstrumentsVolume
    self:setNoteShift(-45)
    self:setNoteDuration(0, true, true)
    self:setDefaultInstrument(self.synthesizers[1] and instrumentToSamplePosition(self.synthesizers[1], 0) or 0)
    for _, synthesizer in ipairs(self.synthesizers) do
        for id = 0, 15 do
            synthesizer.loadSampleFromSComputers(instrumentToSamplePosition(synthesizer, id), "mc_noteblock_" .. id)
        end
    end
    self:setAltBeep(function(nbsPlayer, synthesizer, instrument, note, fullnote, duration, volume_duplication)
        if not synthesizer then return end
        local sampleIndex = customInstruments and customInstruments[instrument]
        if sampleIndex == true then return end
        if not sampleIndex and instrument >= 0 and instrument <= 15 then
            sampleIndex = instrumentToSamplePosition(synthesizer, instrument)
        end
        if not sampleIndex then
            sampleIndex = nbsPlayer.instrument
        end
        return synthesizer.sampleBeep(sampleIndex, nbsPlayer.volume * (instrumentsVolume[instrument] or 1), math.pow(2, (fullnote + nbsPlayer.noteshift) / 12.0))
    end)
end

local defaultWaveInstruments = {
    [0] = {{0, 1}, {3, 0.6}},
    [5] = {{0, 1}, {1, 0.6}},
    [6] = {{0, 1}, {2, 0.6}},
    [7] = {{3, 1}, {2, 0.6}},
}

function nbs:configWaveSamples(customInstruments)
    self:setNoteShift(24)
    self:setNoteDuration(5, false, false)
    self:setDefaultInstrument(0)
    self:setAltBeep(function(nbsPlayer, synthesizer, instrument, note, fullnote, duration, volume_duplication)
        if not synthesizer then return end
        local waves = customInstruments and customInstruments[instrument] or defaultWaveInstruments[instrument] or defaultWaveInstruments[0]
        if waves == true then return end
        local startedWaves = {}
        for _, wave in ipairs(waves) do
            table.insert(startedWaves, synthesizer.waveBeep(wave[1], nbsPlayer.volume * (wave[2] or 1), (wave[4] or 0) + midiToFrequency(fullnote + nbsPlayer.noteshift + (wave[3] or 0)), duration))
        end
        return startedWaves
    end)
end

function nbs:tick()
    if not self.state then return end

    self.currentNotes = {}

    if not self.useNewApi then
        for i = 1, #self.synthesizers do
            sc.yield()
            self.synthesizers[i].clear()
        end
    end

    local unused = 1
    local tick = self.state.track[math.floor(self.state.tick)]
    if tick and (not self.tickMode or tick ~= self._tick) then
        for i = 1, #tick do
            local sourceinstrument = tick[i]["inst"]
            local instrument = self.instrumentTable[sourceinstrument + 1] or self.instrument
            local note = tick[i]["note"]

            local ii = ((i - 1) % #self.synthesizers) + 1
            local synthesizer = self.synthesizers[ii]

            local fullnote = note
            note = convertMidiToNote(self, note)
            if note then
                table.insert(self.currentNotes, {sourceinstrument, tick[i]["note"]})
                local volume = self.volume
                if instrument == 7 then
                    volume = volume + 0.3
                end
                if volume > 1 then volume = 1 end
                if self.useNewApi then
                    local str = instrument .. ":" .. note
                    if not self.currentBeeps[str] or self.tickMode then
                        local sounds = {}
                        local volume_duplication = sm.util.clamp(volume * 10, 0, 10)
                        local duration = self.noteDuration == 0 and (40 * 10) or self.noteDuration
                        if self.altBeep then
                            local newSounds = self:altBeep(synthesizer, sourceinstrument, note, fullnote, duration, volume_duplication)
                            local newSoundsT = type(newSounds)
                            if newSoundsT == "table" then
                                for _, newSound in ipairs(newSounds) do
                                    table.insert(sounds, newSound)
                                end
                            elseif newSoundsT == "number" then
                                table.insert(sounds, newSounds)
                            end
                        elseif synthesizer then
                            for i = 1, volume_duplication do
                                table.insert(sounds, synthesizer.toteBeep(instrument, note, duration))
                            end
                        end
                        self.currentBeeps[str] = {synthesizer, sounds, self.state.tick}
                    else
                        self.currentBeeps[str][3] = self.state.tick
                    end
                elseif synthesizer then
                    synthesizer.addBeep(instrument, toteToPitch(note), volume, self.noteDuration == 0 and (40 * 10) or self.noteDuration)
                end

                local _unused = ii + 1
                if _unused > unused then
                    unused = _unused
                end
            end

            sc.yield()
        end
    end
    self._tick = tick

    if self.useNewApi then
        for str, data in pairs(self.currentBeeps) do
            if data[3] ~= self.state.tick then
                if not self.flushMode then
                    for _, id in ipairs(data[2]) do
                        if type(id) == "function" then
                            id(self)
                        elseif data[1] then
                            data[1].stopBeep(id)
                        end
                    end
                end
                self.currentBeeps[str] = nil
            end
        end
    else
        if self.flushMode then
            for i = unused, #self.synthesizers do
                sc.yield()
                self.synthesizers[i].stop()
            end
        end

        if self.noteDuration == 0 then
            for i = 1, #self.synthesizers do
                sc.yield()
                self.synthesizers[i].flushWithStop()
            end
        elseif self.flushMode then
            for i = 1, #self.synthesizers do
                sc.yield()
                self.synthesizers[i].flush()
            end
        else
            for i = 1, #self.synthesizers do
                sc.yield()
                self.synthesizers[i].flushWithBind()
            end
        end
    end

    self.state.tick = self.state.tick + (self.speed * self.state.speed) + sc.getSkippedTicks()
    if self.state.tick > self.state.length then
        for _, synthesizer in ipairs(self.synthesizers) do
            sc.yield()
            synthesizer.stop()
        end
        self.state = nil
        self.currentBeeps = {}
    end
end

function nbs:getCurrentNotes()
    return self.currentNotes
end

function nbs:setNoteDuration(noteDuration, flushMode, tickMode)
    self.noteDuration = noteDuration or 0
    self.flushMode = not not flushMode
    self.tickMode = not not tickMode
end

function nbs:setAltBeep(altBeep)
    self.altBeep = altBeep
end

--[[
local _mode_square = 4
local _mode_triangle = 8
local _mode_noise = 5
local _mode_sine = 7
]]

function sc_reglib_nbs()
    local nbslib = {}

    function nbslib.create()
        return {
            currentNotes = {},
            synthesizers = {},
            instrument = 4,
            volume = 0.1,
            noteshift = -39,
            notealigment = 1,
            speed = 1,
            noteDuration = 0,
            flushMode = false,
            tickMode = false,
            useNewApi = true,
            currentBeeps = {},
            instrumentTable = {
                4, --0 = Piano (Air)
                1, --1 = Double Bass (Wood)
                5, --2 = Bass Drum (Stone)
                8, --3 = Snare Drum (Sand)
                5, --4 = Click (Glass)
                3, --5 = Guitar (Wool)
                7, --6 = Flute (Clay)
                7, --7 = Bell (Block of Gold)
                7, --8 = Chime (Packed Ice)
                1  --9 = Xylophone (Bone Block)
                   --10 = Iron Xylophone (Iron Block)
                   --11 = Cow Bell (Soul Sand)
                   --12 = Didgeridoo (Pumpkin)
                   --13 = Bit (Block of Emerald)
                   --14 = Banjo (Hay)
                   --15 = Pling (Glowstone)
            },

            load = nbs.load,
            loadStr = nbs.loadStr,
            setSynthesizers = nbs.setSynthesizers,
            tick = nbs.tick,
            start = nbs.start,
            stop = nbs.stop,
            isPlaying = nbs.isPlaying,
            setDefaultInstrument = nbs.setDefaultInstrument,
            setVolume = nbs.setVolume,
            setNoteShift = nbs.setNoteShift,
            setNoteAligment = nbs.setNoteAlignment, --OOPS
            setNoteAlignment = nbs.setNoteAlignment, --FIX
            setSpeed = nbs.setSpeed,
            getCurrentNotes = nbs.getCurrentNotes,
            setNoteDuration = nbs.setNoteDuration,
            setAltBeep = nbs.setAltBeep,
            configNoteblockSamples = nbs.configNoteblockSamples,
            configWaveSamples = nbs.configWaveSamples
        }
    end

    return nbslib
end
end
function scmframework_dc025963f0ec9a13f80e5d2eb615b883() --$CONTENT_DATA/Scripts/internal_libs/objs.lua
function sc_reglib_objs()
local objs = {}
local gui = sc.lib_require("gui")
local image = sc.lib_require("image")

objs.textbox = { --legacy, use scene:createTextBox
    drawer = function(self)
        local fontX = self.display.getFontWidth()
        local fontY = self.display.getFontHeight()
        local text = self.args[1]
        local color = self.args[2]
        local centerText = self.args[3]
        local centerLines = self.args[4]
        if self.args[5] then
            self.display.fillRect(self.x, self.y, self.sizeX, self.sizeY, self.args[5])
        end

        local lines = {}
        for _, line in ipairs(strSplit(utf8, text, "\n")) do
            for _, line in ipairs(splitByMaxSizeWithTool(utf8, line, self.sizeX / (fontX + 1))) do
                table.insert(lines, line)
            end
        end

        local index = 0
        for _, line in ipairs(lines) do
            local len = utf8.len(line)
            local px, py
            if centerText then
                px = (self.x + (self.sizeX / 2)) - ((len * (fontX + 1)) / 2)
            else
                px = self.x
            end
            if centerLines then
                py = (self.y + (self.sizeY / 2) + (index * (fontY + 1))) - ((#lines * (fontY + 1)) / 2)
            else
                py = self.y + (index * (fontY + 1))
            end
            if py >= self.y and py + fontY < self.y + self.sizeY and px >= self.x and px + fontX < self.x + self.sizeX then
                self.display.drawText(px, py, line, color)
            end
            index = index + 1
        end
    end
}

objs.panel = { --legacy. use scene:createWindow
    drawer = function(self)
        self.display.fillRect(self.x, self.y, self.sizeX, self.sizeY, self.args[1] or 0xffffff)
    end
}

objs.camera = {
    init = function(self, camera, func, ...)
        self.camera = camera
        self.func = func or "drawAdvanced"
        self.args = {...}
    end,
    drawer = function(self)
        self:capture(true)
    end,
    methods = {
        capture = function(self, noUpdate)
            self.camera.setViewport(self.x, self.y, self.sizeX, self.sizeY)
            self.camera[self.func](self.display, unpack(self.args))
            if not noUpdate then
                self:update()
                self.needUpdate = false
            end
        end,
        setFov = function(self, fov)
            self.camera.setNonSquareFov(fov * (self.sizeX / self.sizeY), fov)
        end
    }
}

objs.bufferedCamera = {
    init = function(self, camera, func, ...)
        self.camera = camera
        self.func = func or "drawAdvanced"
        self.args = {...}
    end,
    drawer = function(self)
        self:capture(true)
    end,
    methods = {
        capture = function(self, noUpdate)
            if not self.buffer or self.bufferSizeX ~= self.sizeX or self.bufferSizeY ~= self.sizeY then
                self.buffer = image.new(self.sizeX, self.sizeY, sm.color.new(0, 0, 0))
                self.bufferSizeX = self.sizeX
                self.bufferSizeY = self.sizeY
            end

            self.buffer:fromCamera(self.camera, self.func, unpack(self.args))
            self.buffer:draw(self.display, self.x, self.y)
            
            if not noUpdate then
                self:update()
                self.needUpdate = false
            end
        end,
        setFov = function(self, fov)
            self.camera.setNonSquareFov(fov * (self.sizeX / self.sizeY), fov)
        end
    }
}

objs.context = {
    layerMode = gui.layerMode.topLayer,
    init = function(self, contextSettings)
        self.contextSettings = contextSettings
    end,
    drawer = function(self)
        self.display.fillRect(self.x, self.y, self.sizeX, self.sizeY, self.contextSettings.background)
    end,
    
}

objs.tabbar = {
    useWindow = true,
    init = function(self, background, verticle, buttonSize, offset, bg, fg, bg_press, fg_press)
        self.bg, self.fg, self.bg_press, self.fg_press = bg, fg, bg_press, fg_press
        self.list = {}
        self.buttons = {}
        self.verticle = verticle
        self.buttonSize = buttonSize
        self.offset = offset or 0

        if background then
            self:setColor(background)
        end

        if verticle then
            self:setDefaultSet(function(guiobject, previousElement)
                if previousElement then
                    guiobject:setDown(previousElement, self.offset)
                else
                    guiobject:setPosition(0, math.floor(self.offset / 2))
                end
            end)
        else
            self:setDefaultSet(function(guiobject, previousElement)
                if previousElement then
                    guiobject:setRight(previousElement, self.offset)
                else
                    guiobject:setPosition(math.floor(self.offset / 2), 0)
                end
            end)
        end
        
        for _, item in ipairs(self.list) do
            self:addButton(item[1], item[2])
        end
    end,
    methods = {
        setSelected = function(self, selected)
            checkArg(1, selected, "number")
            self.selected = selected
            for _, button in ipairs(self.buttons) do
                button:setState(false)
            end
            for _, item in ipairs(self.list) do
                item:setDisabled(true)
                item:setInvisible(true)
            end
            self.buttons[selected]:setState(true)
            if self.list[selected] then
                self.list[selected]:setDisabled(false)
                self.list[selected]:setInvisible(false)
            end
        end,
        getSelected = function(self)
            return self.selected
        end,
        addTab = function(self, title, object)
            table.insert(self.list, object)
            object:setDisabled(true)
            object:setInvisible(true)

            local button
            if self.verticle then
                button = self:createButton(nil, nil, nil, nil, true, title, self.bg, self.fg, self.bg_press, self.fg_press)
                
                local _autofunc = button.autofunc
                function button.autofunc(rself, previousElement, container)
                    _autofunc(rself, previousElement, container)
                    rself:setSize(self.sizeX, self.buttonSize or mathRound((self.sizeY / #self.list) - self.offset))
                end
            else
                button = self:createButton(nil, nil, nil, nil, true, title, self.bg, self.fg, self.bg_press, self.fg_press)

                local _autofunc = button.autofunc
                function button.autofunc(rself, previousElement, container)
                    _autofunc(rself, previousElement, container)
                    rself:setSize(self.buttonSize or mathRound((self.sizeX / #self.list) - self.offset), self.sizeY)
                end
            end

            table.insert(self.buttons, button)
            local index = #self.buttons

            function button.onToggle(state)
                if state then
                    self:setSelected(index)
                else
                    button:setState(true)
                end
            end

            if not self.selected then
                self:setSelected(index)
            end
        end,
        createOtherspaceWindow = function(self)
            local parent = self:getParent()
            local sizeX, sizeY = parent:getContainerSize()
            local window
            if self.verticle then
                if self.sourceX == 0 then
                    window = parent:createWindow(self.sizeX, 0, sizeX - self.sizeX, sizeY)
                else
                    window = parent:createWindow(0, 0, sizeX, sizeY - self.sizeX)
                end
            else
                if self.sourceY == 0 then
                    window = parent:createWindow(0, self.sizeY, sizeX, sizeY - self.sizeY)
                else
                    window = parent:createWindow(0, 0, sizeX, sizeY - self.sizeX)
                end
            end
            if parent.color and type(parent.color) ~= "function" then
                window.color = parent.color
            end
            return window
        end
    }
}

objs.seekbar = {
    handlerLocalPosition = true,
    handlerOutsideDrag = true,
    init = function(self, verticle, thickness, lineColor, circleColor, value, minValue, maxValue)
        self.verticle = verticle
        if self.verticle then
            self.thickness = thickness or mathRound(self.sizeX / 5)
        else
            self.thickness = thickness or mathRound(self.sizeY / 5)
        end
        self.lineColor = lineColor or 0x686868
        self.circleColor = circleColor or 0x00ff00
        self.value = value or 0.5
        self.minValue = minValue or 0
        self.maxValue = maxValue or 1
        self:_posFromValue()
    end,
    drawer = function(self)
        if self.verticle then
            self.display.fillRect(self.x + (self.sizeX / 2) - (self.thickness / 2), self.y, self.thickness, self.sizeY, self.lineColor)
        else
            self.display.fillRect(self.x, self.y + (self.sizeY / 2) - (self.thickness / 2), self.sizeX, self.thickness, self.lineColor)
        end
        local px, py = self.x, self.y
        local radius
        local side = self.verticle and self.sizeY or self.sizeX
        if self.verticle then
            radius = self.sizeX
            px = px + mathRound(self.sizeX / 2)
        else
            radius = self.sizeY
            py = py + mathRound(self.sizeY / 2)
        end
        local offset = constrain(self.pos, (radius / 2), side - (radius / 2))
        if self.verticle then
            py = py + offset
        else
            px = px + offset
        end
        radius = radius / 2
        self.display.fillCircle(px, py, radius, self.circleColor)
    end,
    handler = function(self, x, y, clickType, button, nickname, inZone, elementCapture)
        if clickType == "pressed" or clickType == "drag" then
            if self.verticle then
                self.pos = y
            else
                self.pos = x
            end
            self:_valueFromPos()
            self:clear()
            self:update()
            if self.onValueChanged then
                self:onValueChanged(self.value)
            end
        end
    end,
    methods = {
        _posFromValue = function(self)
            self.pos = mapClip(self.value, self.minValue, self.maxValue, 0, self.verticle and self.sizeY or self.sizeX)
        end,
        _valueFromPos = function(self)
            self.value = mapClip(self.pos, 0, self.verticle and self.sizeY or self.sizeX, self.minValue, self.maxValue)
        end,
        setValue = function(self, value)
            checkArg(1, value, "number")
            self.value = value
            self:_posFromValue()
            self:clear()
            self:update()
        end,
        getValue = function(self)
            return self.value
        end
    }
}

return objs
end
end
function scmframework_de799e6d8ec061aa580d1c6825cc5bbd() --$CONTENT_DATA/Scripts/internal_libs/process.lua
local function tableRemoveValue(tbl, value)
    for i = 1, #tbl do
        if tbl[i] == value then
            table.remove(tbl, i)
            break
        end
    end
end

local function clearTable(tbl)
    for k in pairs(tbl) do
        tbl[k] = nil
    end
end

function sc_reglib_process(self, baseComputerEnv)
local enlua = sc.lib_require("enlua")

----------------------------- process

local processClass = {}

function processClass:load(chunk, chunkname, mode, ...)
    self.args = {...}
    self.chunk = chunk
    self.chunkname = chunkname
    self.mode = mode
    return true
end

function processClass:enluaLoad(bytecode, ...)
    self.args = {...}
    self.bytecode = bytecode
    return true
end

function processClass:isStopped()
    return not not (self.stopped or self.processEnd)
end

function processClass:getError()
    return self.error
end

function processClass:destroy()
    self:stop()
    tableRemoveValue(self.host.processList, self)
end

function processClass:getEnv()
    return self.env
end

function processClass:getTick()
    return self.tick
end

function processClass:getUptime()
    return self.uptime
end

local function makeCreateEnvHook(env, createEnv) --makes the environments that were created through this environment also be created through a custom function
    checkArg(1, env, "table")
    checkArg(2, createEnv, "function")
    
    local _require = env.require
    local localProcessLib
    function env.require(name)
        if name == "process" then
            if localProcessLib then
                return localProcessLib
            end

            --i make this function recursive so that if a process creates a process, and that process in turn creates a process again, createEnv is called up the chain and the final process creates an ENV with all modifications of the parent processes.
            local localCreateEnv
            localCreateEnv = function()
                return makeCreateEnvHook(assert(createEnv()), localCreateEnv)
            end

            localProcessLib = sc.advDeepcopy(_require("process"))
            localProcessLib.createEnv = localCreateEnv
            return localProcessLib
        end

        local ok, result = pcall(_require, name)
        if ok then
            return result
        else
            error(result, 2)
        end
    end

    return env
end

function processClass:reboot()
    self.env = makeCreateEnvHook(assert(self.createEnv()), self.createEnv)
    self.stopped = false
    self.processEnd = false
    self.rebootFlag = false
    self.tick = 0
    self.uptime = 0
    self.skippedTicks = 0
    self.error = nil
    self.code = nil
    self.oldUptime = baseComputerEnv.getUptime()

    function self.env.getTick()
        return self.tick
    end

    function self.env.getUptime()
        return self.uptime
    end

    function self.env.getSkippedTicks()
        return self.skippedTicks
    end

    function self.env.reboot()
        self.rebootFlag = true
    end
end

function processClass:stop()
    self.stopped = true
    self:_tick()
end

function processClass:_tick()
    if self.rebootFlag then
        self:reboot()
        self.rebootFlag = false
    end

    if not self.code then
        if self.bytecode then
            local code, err = enlua.load(self.bytecode, self.env)
            if not code then
                self.processEnd = true
                self.error = err
                return
            end
            
            self.code = code
        else
            local code, err = baseComputerEnv.load(self.chunk, self.chunkname, self.mode, self.env)
            if not code then
                self.processEnd = true
                self.error = err
                return
            end
            
            self.code = code
        end
    end
    
    if not self.code or self.processEnd then
        return
    end

    local realUptime = baseComputerEnv.getUptime()
    self.skippedTicks = (realUptime - self.oldUptime) - 1
    if self.skippedTicks < 0 then self.skippedTicks = 0 end

    if self.stopped then
        self.env._endtick = true
        self.processEnd = true
    end

    local function exec(onStartCall)
        local func, args
        if onStartCall then
            func = self.env.onStart
        else
            if self.env._endtick and self.env._enableCallbacks and self.env.onStop then
                func = self.env.onStop
            elseif self.env._enableCallbacks then
                func = self.env.onTick or function() end
                pcall(function()
                    args = {baseComputerEnv.getDeltaTimeTps() * (self.skippedTicks + 1)}
                end)
            elseif self.env.callback_loop then
                func = self.env.callback_loop
            else
                func = self.code
                args = self.args
            end
        end

        local okay, err
        if args then
            okay, err = pcall(func, unpack(args))
        else
            okay, err = pcall(func)
        end
        if not okay then
            self.processEnd = true
            self.error = err
            local errFunc, detectReboot
            if self.env._enableCallbacks then
                detectReboot = true
                errFunc = self.env.onError
            else
                errFunc = self.env.callback_error
            end
            if errFunc then
                local okay, err = pcall(errFunc, err)
                if not okay then
                    sm.log.error("error in the error handler in process", err)
                elseif err and detectReboot then
                    self.rebootFlag = true
                end
            end
            return true
        end
    end

    local onStartExists = not not self.env.onStart
    local failed = exec()
    if not failed and not onStartExists and self.env._enableCallbacks and self.env.onStart then
        exec(true)
    end

    self.tick = self.tick + 1
    self.uptime = self.uptime + self.skippedTicks + 1
    self.oldUptime = realUptime

    if self.rebootFlag then
        self:reboot()
        self.rebootFlag = false
    end
end

----------------------------- processhost

local processhostClass = {}

function processhostClass:create(createEnv)
    checkArg(1, createEnv, "function")
    
    local process = sc.setmetatable({
        host = self,
        createEnv = createEnv
    }, processClass)

    process:reboot()

    table.insert(self.processList, process)
    return process
end

function processhostClass:tick()
    for _, process in ipairs(self.processList) do
        process:_tick()
    end
end

function processhostClass:stop()
    for _, process in ipairs(self.processList) do
        process:stop()
    end
end

function processhostClass:destroy()
    for _, process in ipairs(self.processList) do
        process:stop()
    end
    self.processList = {}
end

function processhostClass:list()
    return self.processList
end

----------------------------- main

local processLibrary = {}

function processLibrary.createHost()
    return sc.setmetatable({processList = {}}, processhostClass)
end

function processLibrary.createEnv()
    return sc.lastComputer:sv_createEnv(true)
end

return processLibrary
end
end
function scmframework_e44309ffd019e79b66f45abcb0505bbb() --$CONTENT_DATA/Scripts/internal_libs/ramfs.lua
dofile("$CONTENT_DATA/Scripts/FileSystem.lua")

function sc_reglib_ramfs()
local ramfs = {}

local function makeobj(nativefs)
    local isChange, fs = FileSystem.createData(nativefs)
    return {
        fs = fs,

        _fs = nativefs,
        _isChange = isChange,

        dump = ramfs.dump,
        isChange = ramfs.isChange
    }
end



function ramfs.create(size)
    checkArg(1, size, "number")
    return makeobj(FileSystem.new(size))
end

function ramfs.load(dump)
    checkArg(1, dump, "string")
    return makeobj(FileSystem.deserialize({jsondata = dump}))
end



function ramfs:dump()
    return self._fs:serialize().jsondata
end

function ramfs:isChange()
    return self._isChange()
end

return ramfs
end
end
function scmframework_95b0a0eb104eb6362a43d395292dfb65() --$CONTENT_DATA/Scripts/internal_libs/styles.lua
function sc_reglib_styles()
local styles = {}

function styles:switch()
    local color1, color2, bg = self.fg, self.bg, self.bg
    if self.state then
        color1, color2, bg = self.bg_press, self.fg_press, self.bg_press
    end

    local sy = self.sizeY / 2
    local addX = sy - 1
    local py = self.y + sy

    self.display.fillRect(self.x + addX, self.y, self.sizeX - (addX * 2), self.sizeY + (self.sizeY % 2 == 0 and 0 or 1), bg)
    if self.state then
        self.display.fillCircle(self.x + addX, py, sy, color1)
        self.display.fillCircle(self.x + (self.sizeX - 1 - addX), py, sy, color2)
    else
        self.display.fillCircle(self.x + (self.sizeX - 1 - addX), py, sy, color2)
        self.display.fillCircle(self.x + addX, py, sy, color1)
    end
end

function styles:rounded()
    local bg, fg = self.bg, self.fg
    if self.state then
        bg, fg = self.bg_press, self.fg_press
    end
    if self.interactionCurrently then
        bg, fg = self.bg_interaction or bg, self.fg_interaction or fg
    end

    local cornerRadius = self.cornerRadius or (math.min(self.sizeX, self.sizeY) * 0.3)
    local strokeColor = self.state and self.stroke_press or self.stroke_color
    if self.interactionCurrently and self.stroke_interaction then
        strokeColor = self.stroke_interaction
    end
    self.display.fillEllipse(self.x, self.y, self.sizeX, self.sizeY, cornerRadius, bg or self.sceneinstance.color or 0)
    if strokeColor then
        self.display.drawEllipse(self.x, self.y, self.sizeX, self.sizeY, cornerRadius, strokeColor)
    end

    local graphic = sc.lib_require("graphic")
    if self.textBox then
        graphic.textBox(self.display, self.x + 1, self.y + 1, self.sizeX - 1, self.sizeY, self.text, fg, self.centerX, self.centerY, self.spacingY, self.autoNewline, self.tool)
    else
        graphic.textBox(self.display, self.x, self.y, self.sizeX, self.sizeY, self.text, fg, true, true)
    end
end

return styles
end
end
function scmframework_70f45c03023a0257d6748d455616559a() --$CONTENT_DATA/Scripts/internal_libs/syntax.lua
dofile("$CONTENT_DATA/Scripts/syntax.lua")

function sc_reglib_syntax()
    local syntax = {}

    function syntax.format(code)
        checkArg(1, code, "string")
        return syntax_format(code, true)
    end

    function syntax.highlight(code, errorLine, palette)
        checkArg(1, code, "string")
        checkArg(2, errorLine, "number", "nil")
        checkArg(3, palette, "number")
        palette = math.floor(palette or 1)
        return syntax_make(code, errorLine, true, palette)
    end

    return syntax
end
end
function scmframework_75a5eb35f4e4a82b8bd6f0569c3b1ddd() --$CONTENT_DATA/Scripts/internal_libs/timer.lua
function sc_reglib_timer()
local timer = {}

function timer:setAutoReset(autoReset)
    checkArg(1, autoReset, "boolean")
    self.autoReset = autoReset
end

function timer:setPeriod(period)
    checkArg(1, period, "number")
    self.period = period
    self:reset()
end

function timer:setValue(value)
    checkArg(1, value, "number")
    if value < 0 then value = 0 end
    if value > self.period then value = self.period end
    self.value = value
end

function timer:reset()
    self.value = 0
end

function timer:force()
    self.value = self.period - 1
end

function timer:setEnabled(enable)
    checkArg(1, enable, "boolean")
    self.enable = enable
end

function timer:isTriggered()
    local flag = self.triggered
    self.triggered = false
    return flag
end

function timer:delete()
    for i, v in ipairs(self.host.timers) do
        if v == self then
            table.remove(self.host.timers, i)
            break
        end
    end
end

------------------------------------------------

local timerhost = {}

function timerhost:createTimer(period, autoReset, callback)
    checkArg(1, period, "number")
    checkArg(2, autoReset, "boolean")
    checkArg(3, callback, "function", "nil")

    local obj = {
        autoReset = autoReset,
        callback = callback,

        triggered = false,
        enable = false,
        value = 0,
        host = self
    }

    sc.addStuff(obj, timer)
    obj:setPeriod(period)
    if not autoReset then --oneshot timers have a maximum value by default and are waiting for a reset
        obj.value = period
    end
    table.insert(self.timers, obj)
    return obj
end

function timerhost:callLater(time, callback)
    checkArg(1, time, "number")
    checkArg(2, callback, "function")

	local timer = self:createTimer(time, false, callback)
	timer:setEnabled(true)
	timer:reset()
    return timer
end

function timerhost:task(period, callback)
    checkArg(1, period, "number")
    checkArg(2, callback, "function")

	local timer = self:createTimer(period, true, callback)
	timer:setEnabled(true)
    return timer
end

function timerhost:tick()
    for i, timer in ipairs(self.timers) do
        if timer.enable then
            if timer.value < timer.period then
                local skippedTicks = 0
                if sc.lastComputer and sc.lastComputer.env then
                    local ok, result = pcall(sc.lastComputer.env.getSkippedTicks)
                    if ok and type(skippedTicks) == "number" then
                        skippedTicks = result
                    end
                end
                timer.value = timer.value + 1 + math.floor(skippedTicks)
                if timer.value > timer.period then
                    timer.value = timer.period
                end
                if timer.value == timer.period then
                    timer.triggered = true
                    if timer.callback then
                        timer:callback()
                    end
                    if timer.autoReset then
                        timer.value = 0
                    end
                end
            end
        end
    end
end

function timerhost:setEnabledAll(enable)
    checkArg(1, enable, "boolean")
    for i, timer in ipairs(self.timers) do
        timer:setEnabled(enable)
    end
end

------------------------------------------------

local timer = {}

function timer.createHost()
    local host = {
        timers = {}
    }

    return sc.addStuff(host, timerhost)
end

return timer
end
end
function scmframework_2881e78d167189c100233dec36a4eb6f() --$CONTENT_DATA/Scripts/internal_libs/utils.lua
function sc_reglib_utils()
local utils = {}

utils.clamp = constrain
utils.map = map
utils.roundTo = round
utils.split = function(tool, str, seps)
    return strSplit(tool, str, seps)
end
utils.splitByMaxSize = splitByMaxSize
utils.splitByMaxSizeWithTool = splitByMaxSizeWithTool
utils.deepcopy = sc.advDeepcopy
utils.copy = sc.copy
utils.md5 = function (str)
    return md5.sumhexa(str, true)
end
utils.md5bin = function (str)
    return md5.sum(str, true)
end

utils.sha256 = function (str)
    return sha256.sha256hex(str, true)
end
utils.sha256bin = function (str)
    return sha256.sha256bin(str, true)
end

utils.dist = mathDist

function utils.fromEuler(euler)
    return fromEuler(euler.x, euler.y, euler.z)
end
utils.toEuler = toEuler

return utils
end
end
function scmframework_bd3767ae00f79e99020d6e1a094f6d79() --$CONTENT_DATA/Scripts/internal_libs/vdisplay.lua
function sc_reglib_vdisplay()
local math_floor = math.floor
local vdisplay = {}

local function localNeedPushStack(audience, dataTunnel, dt)
    return dataTunnel.display_forceFlush or not ((dataTunnel.skipAtNotSight and audience <= 0))
end

function vdisplay.create(callbacks, width, height, supportGlassMaterial, glassMaterialByDefault, allowSetResolution)
    local setResolutionSettings
	if allowSetResolution then
		local maxSide = math.max(width, height)
		setResolutionSettings = {
			maxPixels = width * height,
			maxWidth = maxSide,
			maxHeight = maxSide
		}
	end

    local dataTunnel = {}
    local audience = 1
    local libUpdate
    local libUpdateManualCall = false
    local obj
    local drawer = canvasAPI.createDrawer(width, height, function (x, y, color)
        callbacks.set(obj, x, y, color)
    end, nil, nil, nil, nil, nil, true)
    obj = canvasAPI.createScriptableApi(width, height, dataTunnel, function ()
        if not libUpdateManualCall then --if there is no manual library update, it will occur when flush is called.
            libUpdate()
        end
    end, drawer, supportGlassMaterial and canvasAPI.materialList or canvasAPI.materialListWithoutGlass, glassMaterialByDefault and 0 or 1, nil, setResolutionSettings)
    callbacks.pushClick = canvasAPI.addTouch(obj, dataTunnel)

    function callbacks.updateAudience(_audience)
        checkArg(1, "number", _audience)
        audience = _audience
    end

    local oldUpdateTick
    function libUpdate()
        local ctick = sm.game.getCurrentTick()
        if ctick == oldUpdateTick then return end
        oldUpdateTick = ctick

        dataTunnel.scriptableApi_update()

        if dataTunnel.display_reset then
            drawer.drawerReset()
            dataTunnel.display_reset = nil
        end

        if dataTunnel.dataUpdated then
            drawer.pushDataTunnelParams(dataTunnel)
            dataTunnel.dataUpdated = nil
        end

        if dataTunnel.display_flush then
            if localNeedPushStack(audience, dataTunnel, sc.deltaTime) then
                drawer.pushStack(dataTunnel.display_stack)
                drawer.flush()
                callbacks.flush(obj, not not dataTunnel.display_forceFlush)
            end
            
            dataTunnel.display_flush()
            dataTunnel.display_stack = nil
            dataTunnel.display_flush = nil
            dataTunnel.display_forceFlush = nil
            dataTunnel.display_forceForceFlush = nil
        end
    end
    callbacks.update = function()
        libUpdateManualCall = true
        libUpdate()
    end

    function obj.getAudience()
        return audience
    end

    drawer.flush(true)
    obj.noCameraEncode = true
    return obj
end

function vdisplay.touchscreen(vdisplayObject)
    local dataTunnel = {}
    local processClick = canvasAPI.addTouch(vdisplayObject, dataTunnel)
    return function (x, y, state, button, nickname)
        checkArg(1, x, "number")
        checkArg(2, y, "number")
        checkArg(3, state, "string")
        checkArg(4, button, "number")
        checkArg(5, nickname, "string")
        if not dataTunnel.clicksAllowed then
            return
        end
        return processClick({x, y, state, button, nickname})
    end
end

function vdisplay.bundle(displays, numberDisplaysByWidth)
    local width, height
    local supportGlassMaterial = true
    for i, display in ipairs(displays) do
        if width then
            if width ~= display.getWidth() or height ~= display.getHeight() then
                error("vdisplay.bundle: the index \"" .. i .. "\" display has a different resolution from the first display", 2)
            end
        else
            width, height = display.getSize()
        end
        if display.getDefaultMaterial() ~= 0 then
            supportGlassMaterial = false
        end
    end

    local numberDisplaysByHeight = #displays / numberDisplaysByWidth
    local bundleWidth, bundleHeight = width * numberDisplaysByWidth, height * numberDisplaysByHeight

    local vdisplayObject = vdisplay.create({
        set = function(vdisplayObject, x, y, color)
            local index = math_floor(x / width) + (math_floor(y / height) * numberDisplaysByWidth)
            displays[index + 1].drawPixel(x % width, y % height, color)
        end,
        flush = function(vdisplayObject, isForce)
            if isForce then
                for i, display in ipairs(displays) do
                    display.forceFlush()
                end
            else
                for i, display in ipairs(displays) do
                    display.flush()
                end
            end
        end
    }, bundleWidth, bundleHeight, supportGlassMaterial, supportGlassMaterial)

    local function hookSetter(name)
        local oldFunc = vdisplayObject[name]
        vdisplayObject[name] = function(...)
            for i, display in ipairs(displays) do
                if display[name] then
                    display[name](...)
                end
            end
            if oldFunc then
                return oldFunc(...)
            end
        end
    end

    local function hookGetter(name)
        vdisplayObject[name] = function(...)
            if displays[1][name] then
                return displays[1][name](...)
            end
        end
    end

    local touchscreen = vdisplay.touchscreen(vdisplayObject)

    hookSetter("setLight")
    hookGetter("getLight")

    hookSetter("setOptimizationLevel")
    hookGetter("getOptimizationLevel")

    hookSetter("setBrightness")
    hookGetter("getBrightness")

    hookSetter("setMaterial")
    hookGetter("getMaterial")

    hookSetter("setSkipAtNotSight")
    hookGetter("getSkipAtNotSight")

    hookSetter("setClicksAllowed")
    hookGetter("getClicksAllowed")

    hookSetter("setMaxClicks")
    hookGetter("getMaxClicks")

    hookGetter("isAllow")
    hookGetter("getAudience")
    
    local _reset = vdisplayObject.reset
    function vdisplayObject.reset()
        for i, display in ipairs(displays) do
            display.reset()
        end
        _reset()
    end

    local _getClick = vdisplayObject.getClick
    function vdisplayObject.getClick()
        for i, display in ipairs(displays) do
            local ii = i - 1
            local displayX, displayY = ii % numberDisplaysByWidth, math.floor(ii / numberDisplaysByWidth)
            for i = 1, 16 do
                local click = display.getClick()
                if not click then
                    break
                end
                click[1] = click.x + (displayX * width)
                click[2] = click.y + (displayY * height)
                touchscreen(unpack(click))
            end
        end
        return _getClick()
    end

    function vdisplayObject.getDefaultMaterial()
        return supportGlassMaterial and 0 or 1
    end

    return vdisplayObject
end

return vdisplay
end
end
function scmframework_2783ddab3aca8fc7d20b685d77fde38a() --$CONTENT_DATA/Scripts/internal_libs/vfs.lua
local strtool = string

function sc_reglib_vfs(self, env)
local vfshost = {}
local vfs = {}

local function formatPathWithoutEndSlash(path)
    path = path:gsub("\\", "/")
    local pathLen = strtool.len(path)
    if pathLen > 1 and strtool.sub(path, pathLen, pathLen) == "/" then path = strtool.sub(path, 1, pathLen - 1) end
    return path
end

local function formatPathWithEndSlash(path)
    path = path:gsub("\\", "/")
    local pathLen = strtool.len(path)
    if strtool.sub(path, pathLen, pathLen) ~= "/" then path = path .. "/" end
    return path
end

local function formatPathWithoutStartSlash(path)
    path = path:gsub("\\", "/")
    local pathLen = strtool.len(path)
    if strtool.sub(path, 1, 1) == "/" then path = strtool.sub(path, 2, pathLen) end
    return path
end

--------------------------------------- vfshost

function vfshost:mount(path, fs)
    checkArg(1, path, "string")
    checkArg(2, fs, "table")
    table.insert(self.mountList, {formatPathWithoutEndSlash(path), fs})
    table.sort(self.mountList, function(a, b)
        return strtool.len(a[1]) > strtool.len(b[1])
    end)
end

function vfshost:get(path)
    checkArg(1, path, "string")
    path = formatPathWithEndSlash(self:absolute(path))
    for _, mount in ipairs(self.mountList) do
        local mountPath = formatPathWithEndSlash(mount[1])
        if strtool.sub(path, 1, strtool.len(mountPath)) == mountPath then
            return mount[2], formatPathWithoutEndSlash(strtool.sub(path, strtool.len(mountPath), strtool.len(path)))
        end
    end
end

function vfshost:unmount(pathOrFs)
    checkArg(1, pathOrFs, "string", "table")
    local unmounted = false
    if type(pathOrFs) == "table" then
        for i = #self.mountList, 1, -1 do
            local mount = self.mountList[i]
            if mount[2] == pathOrFs then
                unmounted = true
                table.remove(self.mountList, i)
            end
        end
    else
        for i = #self.mountList, 1, -1 do
            local mount = self.mountList[i]
            if self:equals(mount[1], pathOrFs) then
                unmounted = true
                table.remove(self.mountList, i)
            end
        end
    end
    return unmounted
end

function vfshost:mounts()
    return self.mountList
end

function vfshost:absolute(path)
    return vfs.concat(self.workingDirectory, path)
end

function vfshost:equals(...)
    local paths = {...}
    local oldPath
    for i, v in ipairs(paths) do
        local path = self:absolute(v)
        if oldPath and path ~= oldPath then
            return false
        end
        oldPath = path
    end
    return true
end

local function get(self, path)
    local fs, internalPath = self:get(path)
    if not fs then
        error("there is no filesystem mounted on the path \"" .. path .. "\"", 3)
    end
    return fs, internalPath
end

---------------

function vfshost:openFolder(path)
    checkArg(1, path, "string")
    self.workingDirectory = vfs.concat(self.workingDirectory, path)
end

function vfshost:getCurrentPath()
    return self.workingDirectory
end

---------------

local directList = {
    "createFile",
    "createFolder",
    "deleteFile",
    "deleteFolder",
    "writeFile",
    "readFile",
    "hasFile",
    "hasFolder",
    "getFileSize",
    "getFolderSize",
    "getFileList",
    "getFolderList"
}

for _, name in ipairs(directList) do
    vfshost[name] = function (self, path, ...)
        local fs, internalPath = get(self, path)
        return fs[name](internalPath, ...)
    end
end

---------------

function vfshost:hasMount(path)
    local findName = vfs.name(path)
    path = formatPathWithEndSlash(vfs.path(self:absolute(path)))
    for _, mount in ipairs(self.mountList) do
        local mountName = vfs.name(mount[1])
        if self:equals(path, vfs.path(mount[1])) and not self:equals(mount[1], "/") and findName == mountName then
            return true
        end
    end
    return false
end

function vfshost:getMountList(path)
    path = formatPathWithEndSlash(self:absolute(path))
    local mountList = {}
    for _, mount in ipairs(self.mountList) do
        if self:equals(path, vfs.path(mount[1])) and not self:equals(mount[1], "/") then
            table.insert(mountList, vfs.name(mount[1]))
        end
    end
    return mountList
end

---------------

function vfshost:pCreateFolder(path)
    local elements = vfs.elements(formatPathWithoutStartSlash(self:absolute(path)))
    local oldPath = "/"
    for _, element in ipairs(elements) do
        sc.yield()
        local folderPath = vfs.concat(oldPath, element)
        pcall(self.createFolder, self, folderPath)
        oldPath = folderPath
    end
end

function vfshost:pCreateFile(path)
    self:pCreateFolder(vfs.path(path))
    if not self:hasFile(path) then
        self:createFile(path)
    end
end

function vfshost:pWriteFile(path, data)
    self:pCreateFile(path)
    return self:writeFile(path, data)
end

function vfshost:pReadFile(path)
    local ok, result = pcall(self.readFile, self, path)
    if ok then
        return result
    end
end

function vfshost:pDeleteFile(path)
    return (pcall(self.deleteFile, self, path))
end

function vfshost:pDeleteFolder(path)
    return (pcall(self.deleteFolder, self, path))
end

function vfshost:pGetFileSize(path)
    local ok, result = pcall(self.getFileSize, self, path)
    if ok then
        return result
    end
end

function vfshost:pGetFolderSize(path)
    local ok, result = pcall(self.getFolderSize, self, path)
    if ok then
        return result
    end
end

function vfshost:pHasFile(path)
    local ok, result = pcall(self.hasFile, self, path)
    if ok then
        return result
    end
    return false
end

function vfshost:pHasFolder(path)
    local ok, result = pcall(self.hasFolder, self, path)
    if ok then
        return result
    end
    return false
end

function vfshost:pGetFileList(path)
    local ok, result = pcall(self.getFileList, self, path)
    if ok then
        return result
    end
    return {}
end

function vfshost:pGetFolderList(path)
    local ok, result = pcall(self.getFolderList, self, path)
    if ok then
        return result
    end
    return {}
end

---------------

function vfshost:recursionDelete(path, deleteContentsMountPoints)
    sc.yield()

    for _, file in ipairs(self:pGetFileList(path)) do
        sc.yield()
        self:pDeleteFile(vfs.concat(path, file))
    end

    for _, dir in ipairs(self:pGetFolderList(path)) do
        sc.yield()
        self:recursionDelete(vfs.concat(path, dir))
    end

    if deleteContentsMountPoints then
        for _, mount in ipairs(self:getMountList(path)) do
            sc.yield()
            self:recursionDelete(vfs.concat(path, mount))
        end
    end

    self:pDeleteFolder(path)
end

function vfshost:recursionCopy(path, path2, copyContentsMountPoints)
    sc.yield()
    path = self:absolute(path)
    path2 = self:absolute(path2)
    self:pCreateFolder(path2)

    for _, file in ipairs(self:pGetFileList(path)) do
        sc.yield()
        self:pWriteFile(vfs.concat(path2, file), self:readFile(vfs.concat(path, file)))
    end

    for _, dir in ipairs(self:pGetFolderList(path)) do
        sc.yield()
        local from = vfs.concat(path, dir)
        if not self:equals(from, path2) then
            self:recursionCopy(from, vfs.concat(path2, dir))
        end
    end

    if copyContentsMountPoints then
        for _, mount in ipairs(self:getMountList(path)) do
            sc.yield()
            local from = vfs.concat(path, mount)
            if not self:equals(from, path2) then
                self:recursionCopy(from, vfs.concat(path2, mount))
            end
        end
    end
end

---------------------------------------

function vfs.createHost()
    return sc.setmetatable({mountList = {}, workingDirectory = "/"}, vfshost)
end

function vfs.elements(path)
    path = formatPathWithoutEndSlash(path)

    local elements = {}
    for i, element in ipairs(strSplit(strtool, path, "/")) do
        elements[i] = element
    end
    return elements
end

function vfs.resolve(...)
    local elementsList = {...}
    local newElements = {}
    for _, elements in ipairs(elementsList) do
        for _, element in ipairs(elements) do
            if element == "." then
            elseif element == ".." then
                if newElements[#newElements] ~= "" then
                    table.remove(newElements)
                end
            elseif element == "" then
                newElements = {""}
            else
                table.insert(newElements, element)
            end
        end
    end
    if #newElements == 1 and newElements[1] == "" then
        return "/"
    end
    return table.concat(newElements, "/")
end

function vfs.concat(...)
    local paths = {...}
    for i, path in ipairs(paths) do
        paths[i] = vfs.elements(path)
    end
    return vfs.resolve(unpack(paths))
end

function vfs.safeConcat(rootpath, ...)
    rootpath = formatPathWithEndSlash(rootpath)

    local paths = {rootpath, ...}
    for i, path in ipairs(paths) do
        paths[i] = vfs.elements(path)
    end

    local resultPath = vfs.resolve(unpack(paths))
    resultPath = formatPathWithEndSlash(resultPath)
    if strtool.sub(resultPath, 1, strtool.len(rootpath)) ~= rootpath then
        return
    end

    return formatPathWithoutEndSlash(resultPath)
end

function vfs.isGlobalPath(path)
    local firstChar = strtool.sub(path, 1, 1)
    return firstChar == "/" or firstChar == "\\"
end

function vfs.path(path)
    local elements = vfs.elements(path)
    table.remove(elements)
    return vfs.resolve(elements)
end

function vfs.name(path)
    local elements = vfs.elements(path)
    return table.remove(elements)
end

function vfs.hideExtension(name)
    local newName = {}
    for i = 1, strtool.len(name) do
        local char = strtool.sub(name, i, i)
        if char == "." then
            break
        end
        table.insert(newName, char)
    end
    return table.concat(newName)
end

function vfs.getExtension(name)
    local newName = {}
    for i = strtool.len(name), 1, -1 do
        local char = strtool.sub(name, i, i)
        if char == "." then
            break
        end
        table.insert(newName, 1, char)
    end
    return table.concat(newName)
end

return vfs
end
end
function scmframework_de9383be65e693e93a16dff39b3c8470() --$CONTENT_DATA/Scripts/internal_libs/xEngine.lua
dofile("$CONTENT_DATA/Scripts/RaycastCamera.lua")
local maxBudget = 10000
local staticObjectBudget = 1
local dynamicObjectBudget = 50
local areaSize = 64

local supportedShapes = {
    ["box_1x1x1"] = sm.uuid.new("bb395d17-1b52-43d0-8d7d-3ecc09d46b07"),
    ["box_2x2x2"] = sm.uuid.new("648b1ae8-7c9e-4cb3-b527-935fd543c3f3"),
    ["box_3x3x3"] = sm.uuid.new("3b2fde74-4b3d-4e4e-aec9-e9b87755802f"),
    ["box_4x4x4"] = sm.uuid.new("97fb655e-e0ea-4359-bf7c-61d1327e70b4"),
    ["box_16x16x1"] = sm.uuid.new("3053bc20-bac7-4d69-9559-8664bfa2bbcc"),
    ["box_64x64x1"] = sm.uuid.new("8c4fb2ec-e54b-4a0a-9a5b-ea10a9dc1682"),
    ["box_16x16x4"] = sm.uuid.new("f9a43261-6b19-4beb-9476-3399e7cd9601"),
    ["sphere_1"] = sm.uuid.new("7f15869c-9d69-4f43-946c-3bd822b2820f"),
    ["sphere_2"] = sm.uuid.new("1de75f5c-42d6-45c6-876f-3d557f1b04df"),
    ["sphere_3"] = sm.uuid.new("ca3ba192-e93f-4d84-9865-b09ea4847989"),
    ["sphere_4"] = sm.uuid.new("e957c3d4-68b5-4470-999e-3254839f6539"),
    ["sphere_5"] = sm.uuid.new("c821761a-e812-4d61-bf07-18d4220de3e1"),
    ["sphere_6"] = sm.uuid.new("20f9bc86-5f4f-4d1f-aaf8-d30e526be22c"),
    ["sphere_7"] = sm.uuid.new("0aee86b9-cbf7-45f6-94a0-3b38905a6780"),
    ["sphere_8"] = sm.uuid.new("288b89f2-b0e2-4b92-9e65-0a386e9a2641"),
    ["sphere_9"] = sm.uuid.new("e985b8b5-4372-4f6c-bd40-d68c4692b175"),
    ["sphere_10"] = sm.uuid.new("5351d1bb-4094-4992-a729-1f014f84c9ba"),
    ["sphere_16"] = sm.uuid.new("2a2874ac-046f-440e-891a-fbbca4ec446e"),
    ["cylinder_1x1"] = sm.uuid.new("2b8a00e5-c633-4366-be7e-627a3df8a8b9"),
    ["cylinder_2x1"] = sm.uuid.new("a3c4e935-94cb-40dc-ae93-a3ada4d37f35"),
    ["cylinder_3x1"] = sm.uuid.new("2ec00f80-ba09-4258-ac53-e1c791e57f45"),
    ["cylinder_4x1"] = sm.uuid.new("3bec5538-1983-41be-a656-6389bc723889"),
    ["cylinder_5x1"] = sm.uuid.new("f07a77f6-27fd-44f2-b65b-ed16649203d6"),
    ["cylinder_6x1"] = sm.uuid.new("de400276-b74e-4e5a-8096-632a0110020d"),
    ["cylinder_7x1"] = sm.uuid.new("ce797b59-881b-4612-bac9-8c8f94d78b46"),
    ["cylinder_8x1"] = sm.uuid.new("653983c9-e0ec-4e2e-b662-de5999758582"),
    ["cylinder_9x1"] = sm.uuid.new("7fcc8b1e-b1f7-4a0d-aeab-e604ad0e35c0"),
    ["cylinder_10x1"] = sm.uuid.new("fc70d559-3537-4c40-8bd1-d69587d9826a"),
    ["cylinder_11x1"] = sm.uuid.new("d8be5062-c7ee-4627-a6a0-679360cef4c1"),
    ["cylinder_12x1"] = sm.uuid.new("fb29acb4-a8a3-4283-b43c-e70c900e30b0"),
    ["cylinder_13x1"] = sm.uuid.new("796c258e-863d-4aae-b77c-3b181b376a7a"),
    ["cylinder_14x1"] = sm.uuid.new("1f2eadb3-da28-4797-97ed-c570a35ab7b5"),
    ["cylinder_15x1"] = sm.uuid.new("d8ed36bb-a863-42ee-809c-9526cd521250"),
    ["cylinder_16x1"] = sm.uuid.new("6a6a9e70-9630-4391-a7ad-37c51fb8c013"),
}

local function isSupportedShape(uuid)
    for _, luuid in pairs(supportedShapes) do
        if luuid == uuid then
            return true
        end
    end
    return false
end

local function supportedShapeCheck(uuid)
    if not isSupportedShape(uuid) then
        error("shape is not supported", 3)
    end
end

local function isValidPos(pos)
    if pos.z < 0 then
        return false
    elseif pos.z > 64 then
        return false
    end
    if pos.x < -64 then
        return false
    elseif pos.x > 64 then
        return false
    end
    if pos.y < -64 then
        return false
    elseif pos.y > 64 then
        return false
    end
    return true
end

local function checkPos(pos)
    if pos.z < 0 then
        error("the Z position cannot be less than 0", 3)
    elseif pos.z > 64 then
        error("Z cannot be greater than 64", 3)
    end
    if pos.x < -64 then
        error("X cannot be less than -64", 3)
    elseif pos.x > 64 then
        error("X cannot be greater than 64", 3)
    end
    if pos.y < -64 then
        error("Y cannot be less than -64", 3)
    elseif pos.y > 64 then
        error("Y cannot be greater than 64", 3)
    end
    return pos
end

function sc_reglib_xEngine(self)
    local realself = self.realself
    local hiddenDatas = {}
    local function getHiddenData(self, force)
		if hiddenDatas[self] == nil then
	        hiddenDatas[self] = {}
		end
        if not force and hiddenDatas[self] == true then
            error("this 3D engine has been destroyed", 3)
        end
        return hiddenDatas[self]
    end

    --------------------------

    local engineCameraClass = {}

    function engineCameraClass:setPosition(position)
        checkArg(1, position, "Vec3")
        local hiddenData = getHiddenData(self)
        self.shape.worldPosition = hiddenData.parentHiddenData.position + checkPos(position)
        if self.shape.worldPosition ~= hiddenData.worldPosition then
            hiddenData.mt.raysCache = {}
            hiddenData.worldPosition = self.shape.worldPosition
        end
    end

    function engineCameraClass:setRotation(rotation)
        checkArg(1, rotation, "Quat")
        local hiddenData = getHiddenData(self)
        self.shape.worldRotation = rotation
        if self.shape.worldRotation ~= hiddenData.worldRotation then
            hiddenData.mt.raysCache = {}
            hiddenData.worldRotation = rotation
        end
    end

    function engineCameraClass:getPosition()
        local hiddenData = getHiddenData(self)
        return hiddenData.parentHiddenData.position - self.shape.worldPosition
    end

    function engineCameraClass:getRotation()
        return self.shape.worldRotation
    end

    function engineCameraClass:getDirection()
        return self.shape.worldRotation * sm.vec3.new(0, 0, 1)
    end

    function engineCameraClass:destroy()
        local hiddenData = getHiddenData(self)
        
    end

    --------------------------

    local engineShapeClass = {}

    function engineShapeClass:isStatic()
        local hiddenData = getHiddenData(self)
        return hiddenData.shape.body:isStatic()
    end

    function engineShapeClass:isDynamic()
        local hiddenData = getHiddenData(self)
        return hiddenData.shape.body:isDynamic()
    end

    function engineShapeClass:setColor(color)
        local hiddenData = getHiddenData(self)
        hiddenData.shape:setColor(sc.formatColor(color))
    end

    function engineShapeClass:getColor()
        local hiddenData = getHiddenData(self)
        return sc.advDeepcopy(hiddenData.shape:getColor())
    end

    function engineShapeClass:getPosition()
        local hiddenData = getHiddenData(self)
        return hiddenData.shape.worldPosition - hiddenData.parentHiddenData.position
    end

    function engineShapeClass:getRotation()
        local hiddenData = getHiddenData(self)
        return sc.advDeepcopy(hiddenData.shape.worldRotation)
    end

    function engineShapeClass:getVelocity()
        local hiddenData = getHiddenData(self)
        return sc.advDeepcopy(hiddenData.shape:getVelocity())
    end

    function engineShapeClass:getXAxis()
        local hiddenData = getHiddenData(self)
        return sc.advDeepcopy(hiddenData.shape:getXAxis())
    end

    function engineShapeClass:getYAxis()
        local hiddenData = getHiddenData(self)
        return sc.advDeepcopy(hiddenData.shape:getYAxis())
    end

    function engineShapeClass:getZAxis()
        local hiddenData = getHiddenData(self)
        return sc.advDeepcopy(hiddenData.shape:getZAxis())
    end

    function engineShapeClass:getUp()
        local hiddenData = getHiddenData(self)
        return sc.advDeepcopy(hiddenData.shape:getUp())
    end

    function engineShapeClass:getRight()
        local hiddenData = getHiddenData(self)
        return sc.advDeepcopy(hiddenData.shape:getRight())
    end

    function engineShapeClass:getAt()
        local hiddenData = getHiddenData(self)
        return sc.advDeepcopy(hiddenData.shape:getAt())
    end

    function engineShapeClass:destroy()
        local hiddenData = getHiddenData(self)
		local engineHiddenData = hiddenData.parentHiddenData
        engineHiddenData.budget = engineHiddenData.budget + hiddenData.budget
        for i, shape in ipairs(hiddenData.parentHiddenData.shapes) do
            if shape.id == hiddenData.shape.id then
                shape:destroyShape()
				hiddenDatas[engineHiddenData.shapesUserObjects[i]] = nil
                table.remove(engineHiddenData.shapes, i)
                table.remove(engineHiddenData.shapesObjects, i)
                table.remove(engineHiddenData.shapesUserObjects, i)
                break
            end
        end
    end

    function engineShapeClass:exists()
        return not not getHiddenData(self)
    end

    function engineShapeClass:getMass()
        local hiddenData = getHiddenData(self)
        return hiddenData.shape.mass
    end

    function engineShapeClass:applyImpulse(impulse, worldSpace, offset)
        checkArg(1, impulse, "Vec3")
        local hiddenData = getHiddenData(self)
        sm.physics.applyImpulse(hiddenData.shape, impulse, worldSpace, offset)
    end

    function engineShapeClass:applyTorque(torque, worldSpace)
        checkArg(1, torque, "Vec3")
        local hiddenData = getHiddenData(self)
        sm.physics.applyTorque(hiddenData.shape, torque, worldSpace)
    end

    --------------------------

    local engine = {}

    function engine:getMaxBudget()
        return maxBudget
    end

    function engine:getBudget()
        local hiddenData = getHiddenData(self)
        return hiddenData.budget
    end

    function engine:getAreaSize()
        return areaSize
    end

	function engine:getStaticObjectBudget()
		return staticObjectBudget
	end

	function engine:getDynamicObjectBudget()
		return dynamicObjectBudget
	end

    function engine:addShape(uuid, position, rotation, dynamic)
        checkArg(1, uuid, "Uuid")
        checkArg(2, position, "Vec3")
        checkArg(3, rotation, "Quat")
        checkArg(4, dynamic, "boolean")
        supportedShapeCheck(uuid)

        local hiddenData = getHiddenData(self)

        local budget
        if dynamic then
            budget = dynamicObjectBudget
        else
            budget = staticObjectBudget
        end

        if hiddenData.budget - budget < 0 then
            error("there is not enough budget to create an object", 2)
        end

		if isValidPos(hiddenData.position) then
			error("invalid spawn position of the object", 2)
		end

        hiddenData.budget = hiddenData.budget - budget
        if hiddenData.oldSpawnPosition and mathDist(hiddenData.oldSpawnPosition, position) < 0.2 then
            error("creating objects too close in 1 tick", 2)
        end
        hiddenData.oldSpawnPosition = position

        local engineShape = sc.setmetatable({}, engineShapeClass)
        local shapeHiddenData = getHiddenData(engineShape)
        shapeHiddenData.shape = sm.shape.createPart(uuid, hiddenData.position + checkPos(position), rotation, dynamic, true)
        shapeHiddenData.shapes = {}
        shapeHiddenData.parentHiddenData = hiddenData
        shapeHiddenData.budget = budget
		shapeHiddenData.dynamic = dynamic
		shapeHiddenData.engineShape = engineShape
        
        table.insert(hiddenData.shapes, shapeHiddenData.shape)
        table.insert(hiddenData.shapesObjects, shapeHiddenData)
        table.insert(hiddenData.shapesUserObjects, engineShape)
        return engineShape
    end

    function engine:addCamera()
        local engineCamera = sc.setmetatable({}, engineCameraClass)
        engineCamera.shape = {
            worldPosition = sm.vec3.new(0, 0, 0),
            worldRotation = sm.quat.fromEuler(sm.vec3.new(0, 0, 0))
        }
        local mt = sc.mt_hook({__index = RaycastCamera})
        mt.shape = engineCamera.shape
        RaycastCamera.server_onCreate(mt)
        engineCamera.api = mt.camApi

        local shapeHiddenData = getHiddenData(engineCamera)
        shapeHiddenData.parentHiddenData = getHiddenData(self)
        shapeHiddenData.mt = mt

        return engineCamera
    end

    function engine:destroy()
        local hiddenData = getHiddenData(self, true)
        if hiddenDatas[self] ~= true then
            realself.xEngine_instanceLimit = realself.xEngine_instanceLimit + 1
            for _, shape in ipairs(hiddenData.shapes) do
                if sm.exists(shape) then
                    shape:destroyShape()
                end
            end
            hiddenDatas[self] = true
        end
    end

    function engine:tick()
        local hiddenData = getHiddenData(self)
        local ctick = sm.game.getCurrentTick()
        if ctick == hiddenData.oldTick then
            error("engine:tick() cannot be called more than once per tick", 2)
        end
        hiddenData.oldTick = ctick
        hiddenData.oldSpawnPosition = nil

        local skippedTicks = 0
        if sc.lastComputer and sc.lastComputer.env then
            local ok, result = pcall(sc.lastComputer.env.getSkippedTicks)
            if ok and type(skippedTicks) == "number" then
                skippedTicks = result
            end
        end
        local skippedMul = math.floor(skippedTicks) + 1

        for i = #hiddenData.shapesObjects, 1, -1 do
            local shapeObject = hiddenData.shapesObjects[i]
            if shapeObject.dynamic and not isValidPos(shapeObject.shape.worldPosition - hiddenData.position) then
				hiddenData.budget = hiddenData.budget + shapeObject.budget
				shapeObject.shape:destroyShape()
				hiddenDatas[shapeObject.engineShape] = false
				table.remove(hiddenData.shapes, i)
				table.remove(hiddenData.shapesObjects, i)
				table.remove(hiddenData.shapesUserObjects, i)
            end
        end

		if hiddenData.gravity ~= 1 then
			for _, shapeObject in ipairs(hiddenData.shapesObjects) do
				if shapeObject.dynamic then
					local cof = 0.26455
					local val = cof - (hiddenData.gravity * cof)
					sm.physics.applyImpulse(shapeObject.shape, sm.vec3.new(0, 0, skippedMul * val * shapeObject.shape.mass), true)
				end
			end
		end
    end

    function engine:setGravity(gravity)
        if gravity < -3 then gravity = -3 end
        if gravity > 3 then gravity = 3 end
        local hiddenData = getHiddenData(self)
        hiddenData.gravity = gravity
    end

    function engine:getGravity(gravity)
        local hiddenData = getHiddenData(self)
        return hiddenData.gravity
    end

    function engine:list()
        local objects = {}
        local hiddenData = getHiddenData(self)
        for _, object in ipairs(hiddenData.shapesUserObjects) do
            table.insert(objects, object)
        end
        return objects
    end

    function engine:raycast(startPos, endPos)
        local hiddenData = getHiddenData(self)
        local distance = mathDist(startPos, endPos)
        local successful, raydata = sm.physics.raycast(hiddenData.position + startPos, hiddenData.position + endPos)
        if successful then
            local shape = raydata:getShape()
            if isSupportedShape(shape.uuid) then
                for i, lshape in ipairs(hiddenData.shapes) do
                    if lshape.id == shape.id then
                        return {
							object = hiddenData.shapesUserObjects[i],
							distance = raydata.fraction * distance,
							fraction = raydata.fraction,
							pointWorld = raydata.pointWorld - hiddenData.position,
							normalWorld = raydata.normalWorld
						}
                    end
                end
            end
        end
        return nil
    end

    --------------------------

    local xEngine = {
        shapes = sc.advDeepcopy(supportedShapes)
    }

    function xEngine.create()
        if realself.xEngine_instanceLimit <= 0 then
            error("you cannot create more than two engines at the same time", 2)
        end
        realself.xEngine_instanceLimit = realself.xEngine_instanceLimit - 1

        local engineObj = sc.setmetatable({}, engine)
        local hiddenData = getHiddenData(engineObj)
        hiddenData.shapes = {}
        hiddenData.shapesObjects = {}
        hiddenData.shapesUserObjects = {}
        hiddenData.position = sm.vec3.new(math.random(-2000, 2000), math.random(-2000, 2000), 5000)
        hiddenData.budget = maxBudget
        hiddenData.gravity = 1

        table.insert(self.xEnginesDestroy, function ()
            engineObj:destroy()
        end)

        return engineObj
    end

    return xEngine 
end

function xEngine_clear()
    for _, body in ipairs(sm.body.getAllBodies()) do
        for _, shape in ipairs(body:getShapes()) do
            if isSupportedShape(shape.uuid) then
                shape:destroyShape()
            end
        end
    end
end
end
function scmframework_983f999207e46e62e6c12393296605e1() --$CONTENT_DATA/Scripts/json.lua
local a={unloadable=true}local b;local c={["\\"]="\\",['"']='"',["\b"]="b",["\f"]="f",["\n"]="n",["\r"]="r",["\t"]="t"}local d={["/"]="/"}for e,f in pairs(c)do d[f]=e end;local function g(h)return"\\"..(c[h]or string.format("u%04x",h:byte()))end;local function i(j)return"null"end;local function k(j,l)local m={}l=l or{}if l[j]then error("circular reference")end;l[j]=true;if j[1]~=nil or next(j)==nil then local n=0;for e in pairs(j)do if type(e)~="number"then error("invalid table: mixed or invalid key types")end;n=n+1 end;if n~=#j then error("invalid table: sparse array")end;for o,f in ipairs(j)do table.insert(m,b(f,l))end;l[j]=nil;return"["..table.concat(m,",").."]"else for e,f in pairs(j)do if type(e)~="string"then error("invalid table: mixed or invalid key types")end;table.insert(m,b(e,l)..":"..b(f,l))end;l[j]=nil;return"{"..table.concat(m,",").."}"end end;local function p(j)return'"'..j:gsub('[%z\1-\31%z\127-\255\\"]',g)..'"'end;local function q(j)if j~=j or j<=-math.huge or j>=math.huge then error("unexpected number value '"..tostring(j).."'")end;return string.format("%.14g",j)end;local r={["nil"]=i,["table"]=k,["string"]=p,["number"]=q,["boolean"]=tostring}b=function(j,l)local s=type(j)local t=r[s]if t then return t(j,l)end;error("unexpected type '"..s.."'")end;function a.encode(j)return b(j)end;local u;local function v(...)local m={}for o=1,select("#",...)do m[select(o,...)]=true end;return m end;local w=v(" ","\t","\r","\n")local x=v(" ","\t","\r","\n","]","}",",")local y=v("\\","/",'"',"b","f","n","r","t","u")local z=v("true","false","null")local A={["true"]=true,["false"]=false,["null"]=nil}local function B(C,D,E,F)for o=D,#C do if E[C:sub(o,o)]~=F then return o end end;return#C+1 end;local function G(C,D,H)local I=1;local J=1;for o=1,D-1 do J=J+1;if C:sub(o,o)=="\n"then I=I+1;J=1 end end;error(string.format("%s at line %d col %d",H,I,J))end;local function K(n)local t=math.floor;if n<=255 then return string.char(n)elseif n<=0x7ff then return string.char(t(n/64)+192,n%64+128)elseif n<=0xffff then return string.char(t(n/4096)+224,t(n%4096/64)+128,n%64+128)elseif n<=0x10ffff then return string.char(t(n/262144)+240,t(n%262144/4096)+128,t(n%4096/64)+128,n%64+128)end;error(string.format("invalid unicode codepoint '%x'",n))end;local function L(M)local N=tonumber(M:sub(1,4),16)local O=tonumber(M:sub(7,10),16)if O then return K((N-0xd800)*0x400+O-0xdc00+0x10000)else return K(N)end end;local function P(C,o)local m=""local Q=o+1;local e=Q;while Q<=#C do local R=C:byte(Q)if R<32 then G(C,Q,"control character in string")elseif R==92 then m=m..C:sub(e,Q-1)Q=Q+1;local h=C:sub(Q,Q)if h=="u"then local S=C:match("^[dD][89aAbB]%x%x\\u%x%x%x%x",Q+1)or C:match("^%x%x%x%x",Q+1)or G(C,Q-1,"invalid unicode escape in string")m=m..L(S)Q=Q+#S else if not y[h]then G(C,Q-1,"invalid escape char '"..h.."' in string")end;m=m..d[h]end;e=Q+1 elseif R==34 then m=m..C:sub(e,Q-1)return m,Q+1 end;Q=Q+1 end;G(C,o,"expected closing quote for string")end;local function T(C,o)local R=B(C,o,x)local M=C:sub(o,R-1)local n=tonumber(M)if not n then G(C,o,"invalid number '"..M.."'")end;return n,R end;local function U(C,o)local R=B(C,o,x)local V=C:sub(o,R-1)if not z[V]then G(C,o,"invalid literal '"..V.."'")end;return A[V],R end;local function W(C,o)local m={}local n=1;o=o+1;while 1 do local R;o=B(C,o,w,true)if C:sub(o,o)=="]"then o=o+1;break end;R,o=u(C,o)m[n]=R;n=n+1;o=B(C,o,w,true)local X=C:sub(o,o)o=o+1;if X=="]"then break end;if X~=","then G(C,o,"expected ']' or ','")end end;return m,o end;local function Y(C,o)local m={}o=o+1;while 1 do local Z,j;o=B(C,o,w,true)if C:sub(o,o)=="}"then o=o+1;break end;if C:sub(o,o)~='"'then G(C,o,"expected string for key")end;Z,o=u(C,o)o=B(C,o,w,true)if C:sub(o,o)~=":"then G(C,o,"expected ':' after key")end;o=B(C,o+1,w,true)j,o=u(C,o)m[Z]=j;o=B(C,o,w,true)local X=C:sub(o,o)o=o+1;if X=="}"then break end;if X~=","then G(C,o,"expected '}' or ','")end end;return m,o end;local _={['"']=P,["0"]=T,["1"]=T,["2"]=T,["3"]=T,["4"]=T,["5"]=T,["6"]=T,["7"]=T,["8"]=T,["9"]=T,["-"]=T,["t"]=U,["f"]=U,["n"]=U,["["]=W,["{"]=Y}u=function(C,D)local X=C:sub(D,D)local t=_[X]if t then return t(C,D)end;G(C,D,"unexpected character '"..X.."'")end;function a.decode(C)if type(C)~="string"then error("expected argument of type string, got "..type(C))end;local m,D=u(C,B(C,1,w,true))D=B(C,D,w,true)if D<=#C then G(C,D,"trailing garbage")end;return m end;json=a
end
function scmframework_c661a44da68f9255b800caa2586cf147() --$CONTENT_DATA/Scripts/keyboard.lua
dofile("$CONTENT_DATA/Scripts/Config.lua")
keyboard = class()
keyboard.maxParentCount = 1
keyboard.maxChildCount = 1
keyboard.connectionInput = sm.interactable.connectionType.seated
keyboard.connectionOutput = sm.interactable.connectionType.composite
keyboard.colorNormal = sm.color.new(   0x9c1561ff)
keyboard.colorHighlight = sm.color.new(0xff30a5ff)
keyboard.poseWeightCount = 1
keyboard.maxSize = 32 * 1024
keyboard.componentType = "keyboard"

function keyboard:server_onCreate()
    local data = self.storage:load()
    if not data then
        data = {currentData = ""}
        self.storage:save(data)
    end
    self.sdata = data

    self.printMode = false
    self.soundEnable = true
    self.syntax = false

    sc.keyboardDatas[self.interactable.id] = {
        clear = function ()
            self.writeData = ""
        end,
        read = function ()
            return self.sdata.currentData
        end,
        write = function (text)
            checkArg(1, text, "string")

            if #text > keyboard.maxSize then
                error("a string larger than 32 kb", 2)
            else
                self.writeData = text
                self.sdata.currentData = text
            end
            return true
        end,
        isEnter = function ()
            return not not self.btns.enter
        end,
        isEsc = function ()
            return not not self.btns.esc
        end,
        resetButtons = function ()
            self.btns = {}
        end,
        setPrintMode = function (state)
            checkArg(1, state, "boolean")
            if state ~= self.printMode then
                self.printMode = state
                self.flushPrintMode = true
            end
        end,
        isPrintMode = function (state)
            return self.printMode
        end,
        setSoundEnable = function(state)
            checkArg(1, state, "boolean")
            if state ~= self.soundEnable then
                self.soundEnable = state
                self.flushSoundEnable = true
            end
        end,
        isSoundEnable = function (state)
            return self.soundEnable
        end,
        setSyntax = function(syntax)
            checkArg(1, syntax, "boolean")
            self.syntax = syntax
            self.flushSyntaxEnable = true
        end,
        isSyntax = function()
            return self.syntax
        end
    }
    self.btns = {}

    self.network:sendToClients("cl_writeData", self.sdata.currentData)
end

function keyboard:server_onFixedUpdate()
    local ctick = sm.game.getCurrentTick()
	if ctick % sc.restrictions.screenRate == 0 then self.allow_update = true end

    if self.writeData and self.allow_update then
        self:sv_writeData(self.writeData)
        self.writeData = nil
        self.allow_update = nil
    end

    if self.flushPrintMode then
        self.network:sendToClients("cl_setPrintMode", self.printMode)
        self.flushPrintMode = nil
    end

    if self.flushSoundEnable then
        self.network:sendToClients("cl_setSoundEnable", self.soundEnable)
        self.flushSoundEnable = nil
    end

    if self.flushSyntaxEnable then
        self.network:sendToClients("cl_setSyntaxEnable", self.syntax)
        self.flushSyntaxEnable = nil
    end
end

function keyboard:server_onDestroy()
    sc.keyboardDatas[self.interactable.id] = nil
end



function keyboard:sv_writeData(data, caller)
    self.sdata.currentData = data
    self.storage:save(self.sdata)

    for _, player in ipairs(sm.player.getAllPlayers()) do
        if not caller or caller.id ~= player.id then
            self.network:sendToClient(player, "cl_writeData", data)
        end
    end

    if caller then
        for _, player in ipairs(sm.player.getAllPlayers()) do
            if caller.id ~= player.id then
                self.network:sendToClient(player, "cl_sound_1")
            end
        end
    end
end

function keyboard:sv_pressButton(btn, caller)
    self.btns[btn] = true

    for _, player in ipairs(sm.player.getAllPlayers()) do
        if  caller.id ~= player.id then
            self.network:sendToClient(player, "cl_sound_2")
        end
    end
end

function keyboard:sv_getData(_, caller)
    self.network:sendToClient(caller, "cl_writeData", self.sdata.currentData)
    self.network:sendToClient(caller, "cl_setPrintMode", self.printMode)
    self.network:sendToClient(caller, "cl_setSoundEnable", self.soundEnable)
    self.network:sendToClient(caller, "cl_setSyntaxEnable", self.syntax)
end

-------------------------------------------------------

function keyboard:cl_createGui()
    if self.gui then
        self.gui:close()
        self.gui:destroy()
    end

    self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/keyboard.layout")
    self.gui:setButtonCallback("enter", "cl_pressButton")
    self.gui:setButtonCallback("esc", "cl_pressButton")
    self.gui:setTextChangedCallback("text", "cl_updateData")
end

function keyboard:cl_createGui_printMode()
    if self.gui then
        self.gui:close()
        self.gui:destroy()
    end
    
    self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/keyboardPrintMode.layout")
    self.gui:setButtonCallback("exit", "cl_closeGui")
    self.gui:setTextChangedCallback("text", "cl_updateData")
end

function keyboard:cl_closeGui()
    self.gui:close()
end

function keyboard:client_onCreate()
    self:cl_createGui()
    self.network:sendToServer("sv_getData")
end

function keyboard:client_onFixedUpdate()
    --self.interactable:setUvFrameIndex((self.lastdata and #self.lastdata ~= 0) and 6 or 0)
    --self.interactable:setUvFrameIndex(self.changedText and 6 or 0)
    self.interactable:setUvFrameIndex(6)
    self.changedText = nil

    if self.cl_printMode and self.gui:isActive() then
        self.gui:setFocus("text")
    end

    if self.cl_syntax then
        if localStorage.current.palette ~= self.palette then
            self.needUpdateSyntax = true
            self.palette = localStorage.current.palette
        end
    end
end

function keyboard:client_onDestroy()
    self.gui:close()
    self.gui:destroy()
end

function keyboard:client_onInteract(_, state)
    if state then
        if self.needUpdateSyntax then
            self.gui:setText("text", syntax_make(formatBeforeGui(self.lastdata)))
            self.needUpdateSyntax = nil
        end
        self.palette = localStorage.current.palette
        self.gui:open()
    end
end



function keyboard:cl_updateData(_, data)
    self:cl_sound_1()
    data = formatAfterGui(data)
    if #data > keyboard.maxSize then
        if self.cl_syntax then
            self.gui:setText("text", syntax_make(formatBeforeGui(self.lastdata)))
        else
            self.gui:setText("text", formatBeforeGui(self.lastdata))
        end
    else
        self.network:sendToServer("sv_writeData", data)
        if self.cl_syntax then
            if (#data > #self.lastdata and data:sub(1, #self.lastdata) == self.lastdata) or
            (#data < #self.lastdata and self.lastdata:sub(1, #data) == data) then
                self.gui:setText("text", syntax_make(formatBeforeGui(data)))
                self.needUpdateSyntax = nil
            else
                self.needUpdateSyntax = true
            end
        end
        self.lastdata = data
    end
end

function keyboard:cl_pressButton(name)
    self:cl_sound_2()

    self.network:sendToServer("sv_pressButton", name)
end

function keyboard:cl_setPrintMode(printMode)
    self.cl_printMode = printMode
    if printMode then
        self:cl_createGui_printMode()
    else
        self:cl_createGui()
    end
    self.gui:setText("text", formatBeforeGui(self.lastdata))
end

function keyboard:cl_setSoundEnable(state)
    self.cl_soundEnable = state
end

function keyboard:cl_setSyntaxEnable(syntax)
    self.cl_syntax = syntax
end




function keyboard:cl_writeData(data)
    self.lastdata = data
    self.gui:setText("text", formatBeforeGui(data))
end


function keyboard:cl_sound_1()
    self.changedText = true

    if not self.cl_soundEnable then return end

    if self.data and self.data.scifi then
        sm.audio.play("Sensor on", self.shape.worldPosition)
    else
        sm.audio.play("Button off", self.shape.worldPosition)
    end
end

function keyboard:cl_sound_2()
    self.changedText = true

    if not self.cl_soundEnable then return end

    if self.data and self.data.scifi then
        sm.audio.play("Sensor off", self.shape.worldPosition)
    else
        sm.effect.playEffect("keyboard", self.shape.worldPosition)
    end
end
end
function scmframework_99fdb572ee9b01c66413a6beefe61573() --$CONTENT_DATA/Scripts/led.lua
dofile("$CONTENT_DATA/Scripts/Config.lua")
led = class()
led.maxParentCount = 1
led.maxChildCount = -1
led.connectionInput = sm.interactable.connectionType.composite + sm.interactable.connectionType.loopConnection
led.connectionOutput = sm.interactable.connectionType.loopConnection
led.colorNormal = sm.color.new("#d4d4d4")
led.colorHighlight = sm.color.new("#ffffff")
led.componentType = "led"
led.scaleAdd = 0.001
led.effectScale = sm.vec3.new(0.25 + led.scaleAdd, 0.25 + led.scaleAdd, 0.25 + led.scaleAdd)

ledsDatas = ledsDatas or {}

local black = sm.color.new(0, 0, 0)
local ledKey = {}

function led:server_onCreate()
    self.currentColor = sm.color.new(0, 0, 0)
    self.glow = 1

    self.interactable.publicData = {
        sc_component = {
            type = led.componentType,
            api = {
                setColor = function (index, color)
                    color = sc.formatColor(color, true)

                    if index <= 0 then
                        self.currentColor = color
                        return
                    end

                    index = index - 1
                    for _, child in ipairs(self.lastChilds or self.interactable:getChildren()) do
                        if ledsDatas[child.id] then
                            ledsDatas[child.id].setColor(index, color)
                        end
                    end
                end,
                setGlow = function (index, multiplier)
                    checkArg(1, multiplier, "number")

                    if index <= 0 then
                        if multiplier < 0 or multiplier > 1 then
                            error("the range should be from 0 to 1", 2)
                        end
                        if multiplier ~= self.glow then
                            self.glow = multiplier
                        end
                        return
                    end

                    index = index - 1
                    for _, child in ipairs(self.lastChilds or self.interactable:getChildren()) do
                        if ledsDatas[child.id] then
                            ledsDatas[child.id].setGlow(index, multiplier)
                        end
                    end
                end,
                getStripLength = function(lLedKey, firstLed)
                    if lLedKey ~= ledKey then
                        firstLed = nil
                    elseif firstLed == self.interactable.id then
                        error("a cycle has been found in the connection of LEDs")
                    end

                    local len = 0
                    for _, child in ipairs(self.lastChilds or self.interactable:getChildren()) do
                        if ledsDatas[child.id] then
                            local llen = ledsDatas[child.id].getStripLength(ledKey, firstLed or self.interactable.id)
                            if llen > len then
                                len = llen
                            end
                        end
                    end
                    return len + 1
                end
            }
        }
    }
    self.interactable.publicData.sc_component.api.getStripLenght = self.interactable.publicData.sc_component.api.getStripLength --legacy
    ledsDatas[self.interactable.id] = self.interactable.publicData.sc_component.api

    self.network:sendToClients("cl_setColor", self:makeColor())
    if self.shape.color ~= black then
        self.shape:setColor(black)
    end
end

function led:server_onFixedUpdate()
	if sc.needScreenSend() then self.allow_update = true end
    
    if sm.game.getCurrentTick() % 20 == 0 then
        self.lastChilds = self.interactable:getChildren()
    end

    if self.allow_update and (self.currentColor ~= self._currentColor or self.glow ~= self._glow) then
		self.network:sendToClients("cl_setColor", self:makeColor())

		self._currentColor = sm.color.new(self.currentColor.r, self.currentColor.g, self.currentColor.b, self.currentColor.a)
        self._glow = self.glow
        self.allow_update = nil
    end
end

function led:server_onDestroy()
    ledsDatas[self.interactable.id] = nil
end

function led:sv_dataRequest(_, caller)
    self.network:sendToClient(caller, "cl_setColor", self:makeColor())
end

function led:makeColor()
    return sm.color.new(self.currentColor.r, self.currentColor.g, self.currentColor.b, self.glow)
end

------------------------------------------------

function led:client_onCreate()
    self.network:sendToServer("sv_dataRequest")

    self.effect = sm.effect.createEffect(canvasAPI.getEffectName(), self.interactable)
    self.effect:setParameter("uuid", self.shape.uuid)
    self.effect:setScale(led.effectScale)
    self.effect:start()
end

function led:cl_setColor(color)
    self.effect:setParameter("color", color)
end
end
function scmframework_16bdb3614252ba67e01214a56b176e50() --$CONTENT_DATA/Scripts/load_code.lua
local pcall, xpcall, unpack, error, pairs, type = pcall, xpcall, unpack, error, pairs, type

function addServiceCode(self, code, env, serviceTable)
	local computer = self
	local yieldName = self.yieldName
	--local yieldArg = "null"

	local yield
	if sm.isServerMode() then
		yield = self.sv_yield
	else
		yield = self.cl_yield
	end
	
	local function local_yield(arg, locals)
		yield(self)
	end

	if env then
		local setmetatable = sc.getApi("setmetatable")
		local getmetatable = sc.getApi("getmetatable")
		if setmetatable and getmetatable and pcall(setmetatable, {}, {}) and pcall(getmetatable, {}) then
			setmetatable(env, nil)
			env[yieldName] = nil
			setmetatable(env,
				{
					__index = {
						[yieldName] = local_yield
					},
					__newindex = function (self, key, value)
						if key == yieldName then
							error("failed to rewrite a mod-protected function", 2)
						end

						local mt = getmetatable(self)
						setmetatable(self, nil)
						self[key] = value
						setmetatable(self, mt)
					end
				}
			)
		else
			env[yieldName] = local_yield
		end
	end

	if serviceTable then
		serviceTable.yield = local_yield
		--serviceTable.yieldArg = yieldArg
	end

	--------------------------------

	local patterns = {
		--[[
		{ "if([ %(])(.-)([ %)])then([ \n])", "if%1%2%3then%4__internal_yield() " },
		{ "elseif([ %(])(.-)([ %)])then([ \n])", "elseif%1%2%3then%4__internal_yield() " },
		{ "([ \n])else([ \n])", "%1else%2__internal_yield() " },--]]
		{"([%);\n ])do([ \n%(])", "%1do%2 " .. yieldName .. "() "},
		{"([%);\n ])repeat([ \n%(])", "%1repeat%2 " .. yieldName .. "() "},
		{"([%);\n ])goto([ \n%(])", " " .. yieldName .. "() %1goto%2"},
		{"([%);\n ])until([ \n%(])", " " .. yieldName .. "() %until%2"},
		--{"([%);\n ])?)([ \n%(])", "%1?)%2__internal_yield() "} --пожалуй лишнее
	}

	local function gsub(s)
		for i = 1, #patterns, 1 do
			s = s:gsub(patterns[i][1], patterns[i][2])
		end
		return s
	end

	local function process(code)
		local wrapped = ""
		local in_str = false

		while #code > 0 do
			if not (code:find('"', nil, true) or code:find("'", nil, true) or code:find("[", nil, true)) then
				wrapped = wrapped .. gsub(code)
				break
			end

			local chunk, quote = code:match('(.-)([%["\'])')
			code = code:sub(#chunk + 2)

			if quote == '"' or quote == "'" then
				if in_str == quote then
					in_str = false
					wrapped = wrapped .. chunk .. quote
				elseif not in_str then
					in_str = quote
					wrapped = wrapped .. gsub(chunk) .. quote
				else
					wrapped = wrapped .. gsub(chunk) .. quote
				end
			elseif quote == "[" then
				local prefix = "%]"
				if code:sub(1, 1) == "[" then
					prefix = "%]%]"
					code = code:sub(2)
					wrapped = wrapped .. gsub(chunk) .. quote .. "["
				elseif code:sub(1, 1) == "=" then
					local pch = code:find("(=-%[)")
					if not pch then -- syntax error
						return wrapped .. chunk .. quote .. code
					end
					local e = code:sub(1, pch)
					prefix = prefix .. e .. "%]"
					code = code:sub(pch + #e + 1)
					wrapped = wrapped .. gsub(chunk) .. "[" .. e .. "["
				else
					wrapped = wrapped .. gsub(chunk) .. quote
				end

				if #prefix > 2 then
					local strend = code:match(".-" .. prefix)
					code = code:sub(#strend + 1)
					wrapped = wrapped .. strend
				end
			end
		end

		return wrapped
	end

	--------------------------------

	if sc.restrictions.cpu < 0 then
		return code, env
	end

	local newCode = {}
	local newCodeI = 1
	for i = 1, #code do
		local char = code:sub(i, i)
		if char ~= "\r" then
			if char == "\t" then
				newCode[newCodeI] = " "
			else
				newCode[newCodeI] = char
			end
			newCodeI = newCodeI + 1
		end
	end
	local code, err = process(table.concat(newCode))
	if code then
		return yieldName .. "() do " .. code .. " \n end " .. yieldName .. "() ", env
	else
		return nil, err or "unknown error"
	end
end


local function createAdditionalInfo(names, values)
	local str = "  -  ("
	for i, lstr in ipairs(names) do
		if type(values[i]) == "string" then
			str = str .. lstr .. "-\"" .. tostring(values[i] or "unknown") .. "\""
		else
			str = str .. lstr .. "-'" .. tostring(values[i] or "unknown") .. "'"
		end
		if i ~= #names then
			str = str .. ", "
		end
	end
	return str .. ")"
end

function checkVMname()
	local vm = sc.restrictions.vm
	if vm == "scrapVM" and _G.luavm then
		return "scrapVM"
	elseif vm == "betterAPI" and better then
		return "betterAPI"
	elseif vm == "luaInLua" and ll_Scanner and ll_Parser and ll_Interpreter then
		return "luaInLua"
	elseif vm == "dlm" and dlm and dlm.loadstring then
		return "dlm"
	elseif vm == "hsandbox" and _HENV and _HENV.load then
		return "hsandbox"
	elseif vm == "advancedExecuter" and sm.advancedExecuter then
		return "advancedExecuter"
	elseif FiOne_lua then
		return "FiOne_lua"
	end
end

function shortTraceback(...)
	local tbl = {...}
	if not tbl[1] then
		tbl[2] = tostring(tbl[2])
		if ScriptableComputer and ScriptableComputer.shortTraceback then
			local lines = strSplit(string, tbl[2], "\n", true)
			for i = 1, ScriptableComputer.shortTraceback do
				table.remove(lines, #lines)
			end
			tbl[2] = table.concat(lines, "\n")
		end
	end
	return unpack(tbl)
end

function smartCall(nativePart, func, ...)
	if nativePart ~= func then
		local self, tunnel
		pcall(function ()
			self, tunnel = nativePart[2], nativePart[1]
		end)

		if self then
			ll_Interpreter.internalData[self.env[self.yieldName]] = true --а нехер перезаписывать __internal_yield, крашеры ебаные
			local result
			if sc.traceback then
				result = {shortTraceback(xpcall(func, sc.traceback, ...))}
			else
				result = {pcall(func, ...)}
			end
			ll_Interpreter.internalData[self.env[self.yieldName]] = nil

			if result[1] then
				return unpack(result)
			else
				local str = ll_shorterr(result[2])
				if tunnel.lastEval then
					str = str .. createAdditionalInfo({"line", "eval", "name"}, {tunnel.lastEval.line, tunnel.lastEval.type, tunnel.lastEval.chunkname})
				end
				return nil, str
			end
		end
	end

	if sc.traceback then
		return shortTraceback(xpcall(func, sc.traceback, ...))
	else
		return pcall(func, ...)
	end
end

function load_code(self, chunk, chunkname, mode, env, serviceTable)
	checkArg(1, self,		 "table", "nil")
	checkArg(2, chunk,		"string")
	checkArg(3, chunkname,	"string", "nil")
	checkArg(4, mode,		 "string", "nil")
	checkArg(5, env,		  "table",  "nil")
	checkArg(6, serviceTable, "table",  "nil")

	mode = mode or "bt"
	env = env or _G

	local vm = sc.restrictions.vm
	if vm == "fullLuaEnv" and a and a.load then
		return a.load(chunk, chunkname, mode, env)
	elseif vm == "scrapVM" and _G.luavm then
		if self and not self.luastate then
			self.luastate = {}
		end

		local code, err = _G.luavm.custom_loadstring(self and self.luastate or {}, chunk, env)
		if code then
			return code --я хз че там в втором аргументе в данный момент
		else
			return code, err
		end
	elseif vm == "betterAPI" and better then
		return better.loadstring(chunk, chunkname, env)
	elseif vm == "dlm" and dlm and dlm.loadstring then
		return dlm.loadstring(chunk, chunkname, env)
	elseif vm == "hsandbox" and _HENV and _HENV.load then
		return _HENV.load(chunk, chunkname, mode, env)
	elseif vm == "luaInLua" and ll_Scanner and ll_Parser and ll_Interpreter then
		if chunkname and chunkname:sub(1, 1) == "=" then
			chunkname = chunkname:sub(2, #chunkname)
		end

		local tunnel = {}
		local function getScriptTree(script)
			local ran, tokens = pcall(ll_Scanner.scan, ll_Scanner, script)
			if ran then
				local ran, tree = pcall(ll_Parser.parse, ll_Parser, tokens, chunkname, tunnel, serviceTable)
				return ran, tree
			else
				return ran, tokens
			end
		end
		
		local newchunk, getargsfunc = ll_fix(chunk)
		local ran, tree = getScriptTree(newchunk)
		if ran then
			local enclosedEnv = ll_Interpreter:encloseEnvironment(env)

			local function resultFunction(...)
				local args = {...}
				env[getargsfunc] = function ()
					return unpack(args)
				end
				
				if self then
					ll_Interpreter.internalData[self.env[self.yieldName]] = true --а нехер перезаписывать __internal_yield, крашеры ебаные
				end
				local result = {pcall(ll_Interpreter.evaluate, ll_Interpreter, tree, enclosedEnv)}
				if self then
					ll_Interpreter.internalData[self.env[self.yieldName]] = nil
				end

				if result[1] then
					return unpack(result, 2)
				else
					local str = ll_shorterr(result[2])
					if tunnel.lastEval then
						str = str .. createAdditionalInfo({"line", "eval", "name"}, {tunnel.lastEval.line, tunnel.lastEval.type, tunnel.lastEval.chunkname})
					end
					error(str, 2)
				end
			end

			return mt_hook({
				__call = function(_, ...)
					local result = {pcall(resultFunction, ...)}
					if not result[1] then
						error(result[2], 2)
					else
						return unpack(result, 2)
					end
				end,
				__index = function(_, key)
					if key == 1 then
						return tunnel
					elseif key == 2 then
						return self
					elseif key == 3 then
						return resultFunction
					end
				end
			})
		else
			return nil, ll_shorterr(tree)
		end
	elseif vm == "advancedExecuter" and sm.advancedExecuter then
		return sm.advancedExecuter.loadstring(chunk, chunkname, mode, env)
	elseif FiOne_lua then
		if chunkname and chunkname:sub(1, 1) == "=" then
			chunkname = chunkname:sub(2, #chunkname)
		end
		local ok, result = pcall(FiOne_lua.load, self, chunk, chunkname, env)
		if ok then
			return result
		else
			return nil, result
		end
	else
		return nil, 'failed to load the code, try changing "vm" in "PermissionTool"'
	end
end

function safe_load_code(self, chunk, chunkname, mode, env)
	checkArg(1, self,	  "table")
	checkArg(2, chunk,	 "string")
	checkArg(3, chunkname, "string", "nil")
	checkArg(4, mode,	  "string", "nil")
	checkArg(5, env,	   "table",  "nil")

	if sc.shutdownFlag then
		return nil, "CRITICAL ISSUE IN SCOMPUTERS"
	end

	local codelen = #chunk
	if codelen > sc.maxcodelen then
		return nil, "the code len " .. math.round(codelen) .. " bytes, the maximum code len " .. sc.maxcodelen .. " bytes"
	end

	env = env or {}
	mode = mode or "bt"

	if mode == "bt" then
		mode = "t"
	elseif mode == "t" then
		mode = "t"
	elseif mode == "b" then
		return nil, "bytecode is unsupported"
	else
		return nil, "this load mode is unsupported"
	end

	local preloadOk, preloadErr = load_code(self, chunk, chunkname, mode, {}) --syntax errors check
	if not preloadOk then
		return nil, preloadErr
	end

	local serviceTable = {}
	chunk, env = addServiceCode(self, chunk, env, serviceTable) --env may be a error
	if not chunk then
		return nil, env
	end
	
	return load_code(self, chunk, chunkname, mode, env, serviceTable)
end
end
function scmframework_b8fbc5851c276e1489614140de695016() --$CONTENT_DATA/Scripts/localStorage.lua
localStorage = {}
localStorage.path = "$CONTENT_DATA/USER/localStorage.json"
localStorage.paletteCount = 5
localStorage.fontScaleCount = 4
localStorage.emptyPalette = 5

if sm.json.fileExists(localStorage.path) then
    localStorage.current = sm.json.open(localStorage.path)
end

if not localStorage.current then
    localStorage.current = {palette = 0, fontScale = 1}
end

function localStorage.save()
    sm.json.save(localStorage.current, localStorage.path)
end
end
function scmframework_8efa3578e99229999f2692f592aab585() --$CONTENT_DATA/Scripts/md5.lua
md5 = {
    _VERSION     = "md5.lua 1.1.0",
    _DESCRIPTION = "MD5 computation in Lua (5.1-3, LuaJIT)",
    _URL         = "https://github.com/kikito/md5.lua",
    _LICENSE     = [[
      MIT LICENSE
  
      Copyright (c) 2013 Enrique García Cota + Adam Baldwin + hanzao + Equi 4 Software
  
      Permission is hereby granted, free of charge, to any person obtaining a
      copy of this software and associated documentation files (the
      "Software"), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:
  
      The above copyright notice and this permission notice shall be included
      in all copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    ]]
  }
  
  -- bit lib implementions
  
  local char, byte, format, rep, sub =
    string.char, string.byte, string.format, string.rep, string.sub
  local bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift
  
  local ok, bit = pcall(require, 'bit')
  local ok_ffi, ffi = pcall(require, 'ffi')
  if ok then
    bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift = bit.bor, bit.band, bit.bnot, bit.bxor, bit.rshift, bit.lshift
  else
    ok, bit = pcall(require, 'bit32')
  
    if ok then
  
      bit_not = bit.bnot
  
      local tobit = function(n)
        return n <= 0x7fffffff and n or -(bit_not(n) + 1)
      end
  
      local normalize = function(f)
        return function(a,b) return tobit(f(tobit(a), tobit(b))) end
      end
  
      bit_or, bit_and, bit_xor = normalize(bit.bor), normalize(bit.band), normalize(bit.bxor)
      bit_rshift, bit_lshift = normalize(bit.rshift), normalize(bit.lshift)
  
    else
  
      local function tbl2number(tbl)
        local result = 0
        local power = 1
        for i = 1, #tbl do
          result = result + tbl[i] * power
          power = power * 2
        end
        return result
      end
  
      local function expand(t1, t2)
        local big, small = t1, t2
        if(#big < #small) then
          big, small = small, big
        end
        -- expand small
        for i = #small + 1, #big do
          small[i] = 0
        end
      end
  
      local to_bits -- needs to be declared before bit_not
  
      bit_not = function(n)
        local tbl = to_bits(n)
        local size = math.max(#tbl, 32)
        for i = 1, size do
          if(tbl[i] == 1) then
            tbl[i] = 0
          else
            tbl[i] = 1
          end
        end
        return tbl2number(tbl)
      end
  
      -- defined as local above
      to_bits = function (n)
        if(n < 0) then
          -- negative
          return to_bits(bit_not(math.abs(n)) + 1)
        end
        -- to bits table
        local tbl = {}
        local cnt = 1
        local last
        while n > 0 do
          last      = n % 2
          tbl[cnt]  = last
          n         = (n-last)/2
          cnt       = cnt + 1
        end
  
        return tbl
      end
  
      bit_or = function(m, n)
        local tbl_m = to_bits(m)
        local tbl_n = to_bits(n)
        expand(tbl_m, tbl_n)
  
        local tbl = {}
        for i = 1, #tbl_m do
          if(tbl_m[i]== 0 and tbl_n[i] == 0) then
            tbl[i] = 0
          else
            tbl[i] = 1
          end
        end
  
        return tbl2number(tbl)
      end
  
      bit_and = function(m, n)
        local tbl_m = to_bits(m)
        local tbl_n = to_bits(n)
        expand(tbl_m, tbl_n)
  
        local tbl = {}
        for i = 1, #tbl_m do
          if(tbl_m[i]== 0 or tbl_n[i] == 0) then
            tbl[i] = 0
          else
            tbl[i] = 1
          end
        end
  
        return tbl2number(tbl)
      end
  
      bit_xor = function(m, n)
        local tbl_m = to_bits(m)
        local tbl_n = to_bits(n)
        expand(tbl_m, tbl_n)
  
        local tbl = {}
        for i = 1, #tbl_m do
          if(tbl_m[i] ~= tbl_n[i]) then
            tbl[i] = 1
          else
            tbl[i] = 0
          end
        end
  
        return tbl2number(tbl)
      end
  
      bit_rshift = function(n, bits)
        local high_bit = 0
        if(n < 0) then
          -- negative
          n = bit_not(math.abs(n)) + 1
          high_bit = 0x80000000
        end
  
        local floor = math.floor
  
        for i=1, bits do
          n = n/2
          n = bit_or(floor(n), high_bit)
        end
        return floor(n)
      end
  
      bit_lshift = function(n, bits)
        if(n < 0) then
          -- negative
          n = bit_not(math.abs(n)) + 1
        end
  
        for i=1, bits do
          n = n*2
        end
        return bit_and(n, 0xFFFFFFFF)
      end
    end
  end
  
  -- convert little-endian 32-bit int to a 4-char string
  local lei2str
  -- function is defined this way to allow full jit compilation (removing UCLO instruction in LuaJIT)
  if ok_ffi then
    local ct_IntType = ffi.typeof("int[1]")
    lei2str = function(i) return ffi.string(ct_IntType(i), 4) end
  else
    lei2str = function (i)
      local f=function (s) return char( bit_and( bit_rshift(i, s), 255)) end
      return f(0)..f(8)..f(16)..f(24)
    end
  end
  
  
  
  -- convert raw string to big-endian int
  local function str2bei(s)
    local v=0
    for i=1, #s do
      v = v * 256 + byte(s, i)
    end
    return v
  end
  
  -- convert raw string to little-endian int
  local str2lei
  
  if ok_ffi then
    local ct_constcharptr = ffi.typeof("const char*")
    local ct_constintptr = ffi.typeof("const int*")
    str2lei = function(s)
      local int = ct_constcharptr(s)
      return ffi.cast(ct_constintptr, int)[0]
    end
  else
    str2lei = function(s)
      local v=0
      for i = #s,1,-1 do
        v = v*256 + byte(s, i)
      end
      return v
      end
  end
  
  
  -- cut up a string in little-endian ints of given size
  local function cut_le_str(s)
    return {
      str2lei(sub(s, 1, 4)),
      str2lei(sub(s, 5, 8)),
      str2lei(sub(s, 9, 12)),
      str2lei(sub(s, 13, 16)),
      str2lei(sub(s, 17, 20)),
      str2lei(sub(s, 21, 24)),
      str2lei(sub(s, 25, 28)),
      str2lei(sub(s, 29, 32)),
      str2lei(sub(s, 33, 36)),
      str2lei(sub(s, 37, 40)),
      str2lei(sub(s, 41, 44)),
      str2lei(sub(s, 45, 48)),
      str2lei(sub(s, 49, 52)),
      str2lei(sub(s, 53, 56)),
      str2lei(sub(s, 57, 60)),
      str2lei(sub(s, 61, 64)),
    }
  end
  
  -- An MD5 mplementation in Lua, requires bitlib (hacked to use LuaBit from above, ugh)
  -- 10/02/2001 jcw@equi4.com
  
  local CONSTS = {
    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
    0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
    0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
    0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
    0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
    0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
    0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
    0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
    0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
  }
  
  local f=function (x,y,z) return bit_or(bit_and(x,y),bit_and(-x-1,z)) end
  local g=function (x,y,z) return bit_or(bit_and(x,z),bit_and(y,-z-1)) end
  local h=function (x,y,z) return bit_xor(x,bit_xor(y,z)) end
  local i=function (x,y,z) return bit_xor(y,bit_or(x,-z-1)) end
  local z=function (ff,a,b,c,d,x,s,ac)
    a=bit_and(a+ff(b,c,d)+x+ac,0xFFFFFFFF)
    -- be *very* careful that left shift does not cause rounding!
    return bit_or(bit_lshift(bit_and(a,bit_rshift(0xFFFFFFFF,s)),s),bit_rshift(a,32-s))+b
  end
  
  local function transform(A,B,C,D,X)
    local a,b,c,d=A,B,C,D
    local t=CONSTS
  
    a=z(f,a,b,c,d,X[ 0], 7,t[ 1])
    d=z(f,d,a,b,c,X[ 1],12,t[ 2])
    c=z(f,c,d,a,b,X[ 2],17,t[ 3])
    b=z(f,b,c,d,a,X[ 3],22,t[ 4])
    a=z(f,a,b,c,d,X[ 4], 7,t[ 5])
    d=z(f,d,a,b,c,X[ 5],12,t[ 6])
    c=z(f,c,d,a,b,X[ 6],17,t[ 7])
    b=z(f,b,c,d,a,X[ 7],22,t[ 8])
    a=z(f,a,b,c,d,X[ 8], 7,t[ 9])
    d=z(f,d,a,b,c,X[ 9],12,t[10])
    c=z(f,c,d,a,b,X[10],17,t[11])
    b=z(f,b,c,d,a,X[11],22,t[12])
    a=z(f,a,b,c,d,X[12], 7,t[13])
    d=z(f,d,a,b,c,X[13],12,t[14])
    c=z(f,c,d,a,b,X[14],17,t[15])
    b=z(f,b,c,d,a,X[15],22,t[16])
  
    a=z(g,a,b,c,d,X[ 1], 5,t[17])
    d=z(g,d,a,b,c,X[ 6], 9,t[18])
    c=z(g,c,d,a,b,X[11],14,t[19])
    b=z(g,b,c,d,a,X[ 0],20,t[20])
    a=z(g,a,b,c,d,X[ 5], 5,t[21])
    d=z(g,d,a,b,c,X[10], 9,t[22])
    c=z(g,c,d,a,b,X[15],14,t[23])
    b=z(g,b,c,d,a,X[ 4],20,t[24])
    a=z(g,a,b,c,d,X[ 9], 5,t[25])
    d=z(g,d,a,b,c,X[14], 9,t[26])
    c=z(g,c,d,a,b,X[ 3],14,t[27])
    b=z(g,b,c,d,a,X[ 8],20,t[28])
    a=z(g,a,b,c,d,X[13], 5,t[29])
    d=z(g,d,a,b,c,X[ 2], 9,t[30])
    c=z(g,c,d,a,b,X[ 7],14,t[31])
    b=z(g,b,c,d,a,X[12],20,t[32])
  
    a=z(h,a,b,c,d,X[ 5], 4,t[33])
    d=z(h,d,a,b,c,X[ 8],11,t[34])
    c=z(h,c,d,a,b,X[11],16,t[35])
    b=z(h,b,c,d,a,X[14],23,t[36])
    a=z(h,a,b,c,d,X[ 1], 4,t[37])
    d=z(h,d,a,b,c,X[ 4],11,t[38])
    c=z(h,c,d,a,b,X[ 7],16,t[39])
    b=z(h,b,c,d,a,X[10],23,t[40])
    a=z(h,a,b,c,d,X[13], 4,t[41])
    d=z(h,d,a,b,c,X[ 0],11,t[42])
    c=z(h,c,d,a,b,X[ 3],16,t[43])
    b=z(h,b,c,d,a,X[ 6],23,t[44])
    a=z(h,a,b,c,d,X[ 9], 4,t[45])
    d=z(h,d,a,b,c,X[12],11,t[46])
    c=z(h,c,d,a,b,X[15],16,t[47])
    b=z(h,b,c,d,a,X[ 2],23,t[48])
  
    a=z(i,a,b,c,d,X[ 0], 6,t[49])
    d=z(i,d,a,b,c,X[ 7],10,t[50])
    c=z(i,c,d,a,b,X[14],15,t[51])
    b=z(i,b,c,d,a,X[ 5],21,t[52])
    a=z(i,a,b,c,d,X[12], 6,t[53])
    d=z(i,d,a,b,c,X[ 3],10,t[54])
    c=z(i,c,d,a,b,X[10],15,t[55])
    b=z(i,b,c,d,a,X[ 1],21,t[56])
    a=z(i,a,b,c,d,X[ 8], 6,t[57])
    d=z(i,d,a,b,c,X[15],10,t[58])
    c=z(i,c,d,a,b,X[ 6],15,t[59])
    b=z(i,b,c,d,a,X[13],21,t[60])
    a=z(i,a,b,c,d,X[ 4], 6,t[61])
    d=z(i,d,a,b,c,X[11],10,t[62])
    c=z(i,c,d,a,b,X[ 2],15,t[63])
    b=z(i,b,c,d,a,X[ 9],21,t[64])
  
    return bit_and(A+a,0xFFFFFFFF),bit_and(B+b,0xFFFFFFFF),
           bit_and(C+c,0xFFFFFFFF),bit_and(D+d,0xFFFFFFFF)
  end
  
  ----------------------------------------------------------------
  
  local function md5_update(self, s, needYield)
    local function yield()
      if needYield then
          sc.smartYield()
      end
  end

    self.pos = self.pos + #s
    s = self.buf .. s
    for ii = 1, #s - 63, 64 do
      yield()
      local X = cut_le_str(sub(s,ii,ii+63))
      assert(#X == 16)
      X[0] = table.remove(X,1) -- zero based!
      self.a,self.b,self.c,self.d = transform(self.a,self.b,self.c,self.d,X)
    end
    self.buf = sub(s, math.floor(#s/64)*64 + 1, #s)
    return self
  end
  
  local function md5_finish(self)
    local msgLen = self.pos
    local padLen = 56 - msgLen % 64
  
    if msgLen % 64 > 56 then padLen = padLen + 64 end
  
    if padLen == 0 then padLen = 64 end
  
    local s = char(128) .. rep(char(0),padLen-1) .. lei2str(bit_and(8*msgLen, 0xFFFFFFFF)) .. lei2str(math.floor(msgLen/0x20000000))
    md5_update(self, s)
  
    assert(self.pos % 64 == 0)
    return lei2str(self.a) .. lei2str(self.b) .. lei2str(self.c) .. lei2str(self.d)
  end
  
  ----------------------------------------------------------------
  
  function md5.new()
    return { a = CONSTS[65], b = CONSTS[66], c = CONSTS[67], d = CONSTS[68],
             pos = 0,
             buf = '',
             update = md5_update,
             finish = md5_finish }
  end
  
  function md5.tohex(s)
    return format("%08x%08x%08x%08x", str2bei(sub(s, 1, 4)), str2bei(sub(s, 5, 8)), str2bei(sub(s, 9, 12)), str2bei(sub(s, 13, 16)))
  end
  
  function md5.sum(s, needYield)
    return md5.new():update(s, needYield):finish()
  end
  
  function md5.sumhexa(s, needYield)
    return md5.tohex(md5.sum(s, needYield))
  end
end
function scmframework_c1af978b46ebf823b24684a1069bb221() --$CONTENT_DATA/Scripts/methods.lua
local math_sqrt = math.sqrt
local math_min = math.min
local math_max = math.max
local math_floor = math.floor
local string_format = string.format
local math_ceil = math.ceil
local string_byte = string.byte
local type = type
local tostring = tostring
local pairs = pairs
local math_random = math.random
local table_insert = table.insert
local table_remove = table.remove
local table_concat = table.concat
local ipairs = ipairs
local pairs = pairs
local sm_color_new = sm.color.new

function colorCombineRaw(v, color1, color2)
    return color1.r + v * (color2.r - color1.r), color1.g + v * (color2.g - color1.g), color1.b + v * (color2.b - color1.b)
end

function colorCombine(v, color1, color2)
    return sm_color_new(colorCombineRaw(v, color1, color2))
end

function colorCombineAdd(color, v, addColor)
	color.r = color.r + (v * (addColor.r - color.r))
	color.g = color.g + (v * (addColor.g - color.g))
	color.b = color.b + (v * (addColor.b - color.b))
end

function colorCombineToNumber(v, color1, color2)
    return (math_floor((color1.r + v * (color2.r - color1.r)) * 256) * 256 * 256) + (math_floor((color1.g + v * (color2.g - color1.g)) * 256) * 256) + math_floor((color1.b + v * (color2.b - color1.b)) * 256)
end

function colorCombineToString(v, color1, color2)
    return numberToColorpart(math_floor(color1.r + v * (color2.r - color1.r))) .. numberToColorpart(math_floor(color1.g + v * (color2.g - color1.g))) .. numberToColorpart(math_floor(color1.b + v * (color2.b - color1.b))) .. "ff"
end

function tableShuffle(array)
    local n = #array
    for i = n, 2, -1 do
        local j = math.random(i)
        array[i], array[j] = array[j], array[i]
    end
end

function doesRayIntersectSphere(P0, P1, C, r)
    local D = {x = P1.x - P0.x, y = P1.y - P0.y, z = P1.z - P0.z}
    local Lx = P0.x - C.x
    local Ly = P0.y - C.y
    local Lz = P0.z - C.z

    local a = D.x^2 + D.y^2 + D.z^2
    local b = 2 * (Lx * D.x + Ly * D.y + Lz * D.z)
    local c = Lx^2 + Ly^2 + Lz^2 - r^2

    local discriminant = b^2 - 4 * a * c

    if discriminant < 0 then
        return false
    end

    return true
end

function multiColorCombine(colors)
	local r, g, b = 0, 0, 0
	local sum = 0
	for _, color in ipairs(colors) do
		r = r + color.r
		g = g + color.g
		b = b + color.b
		sum = sum + 1
	end
    return sm.color.new(r / sum, g / sum, b / sum)
end

function mt_hook(mt)
	local empty_class = class(mt)
    empty_class.__index = mt.__index
    return empty_class()
end

local maxrep = 1024 * 1024
local orep = string.rep
function customRep(s, n, sep)
    checkArg(1, s, "string")
    checkArg(2, n, "number")
    checkArg(3, sep, "string", "nil")

    if n <= 0 then
        return ""
    end

    local allocations = n * #s
    if sep then
        local seplen = #sep
        allocations = allocations + ((n * seplen) - seplen)
    end
    if allocations > maxrep then
        error("the maximum amount of allocations via string.rep is 1024kb", 2)
    end

    local result = {pcall(orep, s, n, sep)}
    if result[1] then
        return result[2]
    else
        error(tostring(result[2]), 2)
    end
end

function isTweaksAvailable()
	return not not sc.getApi("getmetatable")
end

function tweaks()
	local getmetatable = sc.getApi("getmetatable")
	if getmetatable then
		local string_mt = getmetatable("")
		string_mt.__index.rep = customRep
	end
end

function unTweaks()
	local getmetatable = sc.getApi("getmetatable")
	if getmetatable then
		local string_mt = getmetatable("")
		string_mt.__index.rep = orep
	end
end

local jsonEncodeInputCheck
function jsonEncodeInputCheck(tbl, level, itemsCount)
	itemsCount = itemsCount or 0

	if level >= 8 then
		error("too many nested tables. max 8", level + 3)
	end

	local isStringKey = false
	local isNumberKey = false
	for key, value in pairs(tbl) do
		local keytype = type(key)
		local valuetype = type(value)

		------ check count
		if itemsCount > 256 then
			error("your table cannot contain more than 256 items", level + 3)
		end
		itemsCount = itemsCount + 1

		------ key check
		if keytype == "string" then
			isStringKey = true
		elseif keytype == "number" then
			isNumberKey = true
		else
			error("keys in json can only be string or number", level + 3)
		end
		if isStringKey and isNumberKey then
			error("keys in json cannot be both string and number in the same subtable", level + 3)
		end
		
		------ value check
		if
		valuetype ~= "nil" and
		valuetype ~= "boolean" and
		valuetype ~= "table" and
		valuetype ~= "number" and
		valuetype ~= "string" and
		valuetype ~= "table" then
			error("unsupported type \"" .. valuetype .. "\" in json", level + 3)
		end
		
		if valuetype == "table" then
			itemsCount = jsonEncodeInputCheck(value, level + 1, itemsCount)
		end
	end
	
	return itemsCount
end
_G.jsonEncodeInputCheck = jsonEncodeInputCheck

function NormalizeQuaternion(quaternion)
    local magnitude = math_sqrt(quaternion.x^2 + quaternion.y^2 + quaternion.z^2 + quaternion.w^2)
    if magnitude ~= 0 then
        quaternion.x = quaternion.x / magnitude
        quaternion.y = quaternion.y / magnitude
        quaternion.z = quaternion.z / magnitude
        quaternion.w = quaternion.w / magnitude
    end
    return quaternion
end

function map(value, low, high, low_2, high_2)
    return low_2 + (high_2 - low_2) * ((value - low) / (high - low))
end

function constrain(value, min, max)
    return math_min(math_max(value, min), max)
end

local constrain, map = constrain, map
function mapClip(value, low, high, low_2, high_2)
    return constrain(map(value, low, high, low_2, high_2), low_2, high_2)
end

function mathDist(pos1, pos2)
    return math_sqrt(((pos1.x - pos2.x) ^ 2) + ((pos1.y - pos2.y) ^ 2) + ((pos1.z - pos2.z) ^ 2))
end

function round(number, numbers)
    numbers = numbers or 3
    return tonumber(string_format("%." .. tostring(math_floor(numbers)) .. "f", number))
end

function mathRound(number)
    return math.floor(number + 0.5)
end

function isNan(number)
    return number ~= number
end

function probability(probabilityNum)
    return math_random() > ((99 - probabilityNum) / 99)
end

function require(name)
	return dofile(name .. ".lua")
end

local tcCache = {}
local function tableChecksum(input, blkey)
	local value, input_type = 5132, type(input)
	if input_type == "table" then
		local ldop = 0
		for k, v in pairs(input) do
			if not blkey or k ~= blkey then
				value = value + (tableChecksum(k) * tableChecksum(v)) + ldop
				ldop = ldop + math_ceil(value / 48891)
			end
		end
		value = value + ldop
	elseif input_type == "number" then
		value = (input + 17) * 2
	elseif input_type == "Vec3" then
		value = value + (input.x * 3)
		value = value - (input.y * 14)
		value = value - (input.z * 7)
	elseif input_type == "Color" then
		value = value + (input.r * 2)
		value = value - (input.g * 4)
		value = value + (input.b * 8)
	elseif input_type == "boolean" then
		if input then
			value = value + 8231
		else
			value = value - 3265
		end
	elseif input_type == "nil" then
		value = value - 984
	else
		local strInput = tostring(input)
		if tcCache[strInput] then
			return tcCache[strInput]
		end

		for i = 1, #strInput do
			value = value + ((string_byte(strInput, i) + i) * i)
		end

		tcCache[strInput] = value
	end
	
	return value
end
_G.tableChecksum = tableChecksum
_G.tcCache = tcCache

function tableEquals(tbl1, tbl2)
	if #tbl1 ~= #tbl2 then
		return false
	end
	return tableChecksum(tbl1) == tableChecksum(tbl2)
end

local sm_quat_new = sm.quat.new
local math_sin = math.sin
local math_cos = math.cos

local function doQuat(x, y, z, w)
    local sin = math_sin(w / 2)
    return sm_quat_new(sin * x, sin * y, sin * z, math_cos(w / 2))
end

function fromEuler(x, y, z) --custom implementation
	return doQuat(1, 0, 0, x) * doQuat(0, 1, 0, y) * doQuat(0, 0, 1, z)
end

function fromEulerVec(vec) --custom implementation
	local x, y, z = vec.x, vec.y, vec.z
	return doQuat(1, 0, 0, x) * doQuat(0, 1, 0, y) * doQuat(0, 0, 1, z)
end

local sqrt = math.sqrt
local atan2 = math.atan2
local asin = math.asin
local pi = math.pi

--[[
function toEuler(q)
    local angles = sm.vec3.new(0, 0, 0)

    -- roll (x-axis rotation)
    local sinr_cosp = 2 * (q.w * q.x + q.y * q.z)
    local cosr_cosp = 1 - 2 * (q.x * q.x + q.y * q.y)
    angles.x = atan2(sinr_cosp, cosr_cosp)

    -- pitch (y-axis rotation)
    local sinp = sqrt(1 + 2 * (q.w * q.y - q.x * q.z))
    local cosp = sqrt(1 - 2 * (q.w * q.y - q.x * q.z))
    angles.y = 2 * atan2(sinp, cosp) - pi / 2

    -- yaw (z-axis rotation)
    local siny_cosp = 2 * (q.w * q.z + q.x * q.y)
    local cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z)
    angles.z = atan2(siny_cosp, cosy_cosp)

    return angles
end
]]

--[[
function toEuler(quat)
	local x, y, z, w = quat.x, quat.y, quat.z, quat.w
	local rollDegrees = atan2(2*(w*x + y*z), 1 - 2*(x*x + y*y))
	local pitchDegrees = asin(2*(w*y - z*x))
	local yawDegrees = atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z))
	return sm.vec3.new(rollDegrees, pitchDegrees, yawDegrees)
end
]]

function toEuler(quat)
	local x, y, z, w = quat.x, quat.y, quat.z, quat.w
	local ex = atan2(2 * (w * x + y * z), 1 - 2 * (x^2 + y^2))
	local ey = asin(2 * (w * y - z * x))
	local ez = atan2(2 * (w * z + x * y), 1 - 2 * (y^2 + z^2))
	if ex ~= ex then ex = 0 end --is nan check
	if ey ~= ey then ey = 0 end --is nan check
	if ez ~= ez then ez = 0 end --is nan check
	return sm.vec3.new(ex, ey, ez)
end

-------------------------------------------------------

function splitByMaxSize(str, max)
    max = math_floor(max + 0.5)
    if max <= 0 then
        max = 1
    end

    local strs = {}
    while #str > 0 do
		sc.yield()

        table_insert(strs, str:sub(1, max))
        str = str:sub(#strs[#strs] + 1)
    end
    return strs
end

function splitByMaxSizeWithTool(tool, str, max)
    max = math.floor(max + 0.5)
    if max <= 0 then
        max = 1
    end

    local strs = {}
    while true do
        local strlen = tool.len(str)
        if strlen == 0 then
            break
        end
        
        sc.yield()
        table.insert(strs, tool.sub(str, 1, max))
        str = tool.sub(str, tool.len(strs[#strs]) + 1, strlen)
    end
    return strs
end

function paths_path(str)
	local strs = FileSystem.strSplit(string, str, {"/"})
	if str:sub(1, 1) == "/" then
		table_remove(strs, 1)
	end
	if strs[#strs] == "" then
		table_remove(strs)
	end
	table_remove(strs)
	return table_concat(strs, "/")
end

function checkArg(n, have, ...)
	have = type(have)
	local tbl = {...}
	for _, t in ipairs(tbl) do
		if have == t then
			return
		end
	end
	error(string_format("bad argument #%d (%s expected, got %s)", n, table_concat(tbl, " or "), have), 3)
end

local orig_backslash = "\\"
local magic_backslash = "¦"
function formatBeforeGui(text)
	text = text:gsub("#", "##"):gsub(orig_backslash .. "n", magic_backslash .. "n")
	return text
end
function formatAfterGui(text)
	text = text:gsub(magic_backslash .. "n", orig_backslash .. "n")
	return text
end

ftgui = formatBeforeGui

function makeErrorColor(msg)
	local lines = strSplit(string, msg, "\n", true)
	for i, v in ipairs(lines) do
		if i == 1 then
			lines[i] = "#ffffff" .. v
		else
			lines[i] = "#00ff62" .. v
		end
	end
	return table.concat(lines, "\n")
end

function strSplit(tool, str, seps, noYield)
    if type(seps) ~= "table" then
        seps = {seps}
    end
    
    local seplens = {}
    for i, sep in ipairs(seps) do
        --seps[i] = tostring(sep)
        seplens[i] = tool.len(sep)
    end

    local parts = {{}}
    local index = 1
    local strlen = tool.len(str)
    while index <= strlen do
		if not noYield then
			sc.yield()
		end

        while true do
            if not noYield then
                sc.yield()
            end

            local finded = false
            for i, sep in ipairs(seps) do
                if not noYield then
                    sc.yield()
                end
                
                if sep ~= "" and tool.sub(str, index, index + (seplens[i] - 1)) == sep then
                    table.insert(parts, {})
                    index = index + seplens[i]
                    finded = true
                    break
                end
            end
            if not finded then
                break
            end
        end

        table.insert(parts[#parts], tool.sub(str, index, index))
        index = index + 1
    end

    for i, part in ipairs(parts) do
        parts[i] = table.concat(part)
    end

    return parts
end

function strSplitNoYield(tool, str, seps)
    return strSplit(tool, str, seps, true)
end

function createPID(kp, ki, kd, dt)
	kp = kp or 1
	ki = ki or 0
	kd = kd or 0
	dt = dt or 40

	local I = 0
	local prevErr = 0
	return function (target, input)
		local err = target - input
		I = I + (err * dt)
		local D = (err - prevErr) / dt
		prevErr = err
		return (err * kp) + (I * ki) + (D * kd)
	end
end

function freezeDetector(name, callback, ...)
	local clock = os.clock()
	local result = {callback(...)}
	local delta = os.clock() - clock
    if delta > 0.05 then
        print("freezeDetector", name, sm.game.getCurrentTick() % (40 * 5), delta)
    end
	return unpack(result)
end

local findTags = {":", "\"]:"}
function parseErrorLine(msg, computerTag)
	local line
	for _, tag in ipairs(findTags) do
		local strs = strSplitNoYield(string, msg, computerTag .. tag)
		for i, v in ipairs(strs) do
			v = strSplitNoYield(string, v, ":")[1] or v
			line = tonumber(v) or line
		end
		if line then
			break
		end
	end
	return line
end
end
function scmframework_810461f87c343fd9e4c95fb84cc6a6da() --$CONTENT_DATA/Scripts/Networking/Antennas/Antenna.lua
dofile "$MOD_DATA/Scripts/Config.lua"

Antenna = class(nil)
Antenna.maxParentCount = -1
Antenna.maxChildCount = -1
Antenna.connectionInput = sm.interactable.connectionType.networking + sm.interactable.connectionType.composite
Antenna.connectionOutput = sm.interactable.connectionType.networkCamera
Antenna.colorNormal = sm.color.new(0xedc84cff)
Antenna.colorHighlight = sm.color.new(0xebcf71ff)

function Antenna.writeToBuffer(self, packets, buffer)
	local insert = table.insert
	--local id = self.super.interactable:getId()

	--local copy = sc.networking.packetCopyPath

	for i, packet in ipairs(packets) do
		--local transmitters = packet.transmitters

		--if transmitters[id] == nil then
		--	transmitters[id] = true

		--	packet = copy(packet)
		--	insert(packet.transmitterPath, id)

			insert(buffer, packet)
		--end
	end
end

function Antenna:selfID()
	if self.interactable then
		return self.interactable.id
	else
		return self.tool.id
	end
end

function Antenna.receivePackets(self, packets) --вызываеться с отправляюшей антенны
	if self.activeState then
		self:writeToBuffer(packets, self.receivePacketBuffer)
	end
end

function Antenna.setChannel(self, c)
	if c >= 0 and c < 32 and c % 1 == 0 then
		self.channel = c
	else
		error("channel value is integer in [0; 31]")
	end
end

function Antenna.sendPackets(self) --отправка пакетов по ралиоканалу
	if self.activeState then
		local thisPos = self.shape:getWorldPosition()
		local distSq = self.radius and (self.radius * self.radius)
		local packets = self.sendPacketBuffer

		local recvPacks = Antenna.receivePackets

		for k, v in pairs(sc.antennasRefs) do
			if v.channel == self.channel and v ~= self then
				local shape = v.shape
				local pos = shape:getWorldPosition()

				local delta = pos - thisPos

				if not distSq or delta:length2() <= distSq then --если она в радиусе действия или у нашей антены нет радиуса
					recvPacks(v, packets) --вызываем метод приема у целевой антены
				end
			end
		end

		self:doBlick()
	end

	self.sendPacketBuffer = {}
end

function Antenna:findTargets()
	local tbl = {}

	if self.activeState then
		local thisPos = self.shape:getWorldPosition()
		local distSq = self.radius and (self.radius * self.radius)
		local packets = self.sendPacketBuffer

		for k, v in pairs(sc.antennasRefs) do
			if v.channel == self.channel and v ~= self then
				local shape = v.shape
				local pos = shape:getWorldPosition()

				local delta = pos - thisPos

				if not distSq or delta:length2() <= distSq then --если она в радиусе действия или у нашей антены нет радиуса
					table.insert(tbl, v)
				end
			end
		end
	end

	return tbl
end

function Antenna.transmitPackets(self)
	if self.activeState and self.interactable then
		local parents = self.interactable:getParents(sm.interactable.connectionType.networking) or {}

		for index, parent in ipairs(parents) do
			local script = sc.networking[parent:getId()]
			if script then
				script:propagatePackets(self.receivePacketBuffer)
			end
		end

		self:doBlick()
	end

	self.receivePacketBuffer = {}
end

function Antenna.propagatePackets(self, packets)
	self:writeToBuffer(packets, self.sendPacketBuffer)
end

function Antenna.server_onCreate(self)
	local id = self:selfID()

	self.data = self.data or {}

	self.radius = self.data.radius
	self.sendPacketBuffer = {}
	self.receivePacketBuffer = {}
	self.activeState = true
	
	local data = self.storage:load()
	if data ~= nil then
		self.channel = data.channel or 0
	else
		self.channel = 0
	end

	sc.antennasRefs[id] = self
	sc.networking[id] = self
	sc.antennasApis[id] = {
		getRadius = function ()
			return self.radius or math.huge
		end,
		getChannel = function ()
			return self.temp_setchannel or self.channel
		end,
		setChannel = function (c)
			if c >= 0 and c < 32 and c % 1 == 0 then
				self.temp_setchannel = c
			else
				error("channel value is integer in [0; 31]")
			end
		end,
		setActive = function (state)
			checkArg(1, state, "boolean")
			self.activeState = state
		end,
		isActive = function ()
			return self.activeState
		end
	}

	if self.radius and self.radius <= 4 and self.data.screen then
		self.network:sendToClients("cl_blink", true)
	end
end

function Antenna.server_onDestroy(self)
	local id = self:selfID()
	sc.antennasRefs[id] = nil
	sc.networking[id] = nil
	sc.antennasApis[id] = nil
end

function Antenna:doBlick()
	local ctick = sm.game.getCurrentTick()
	if (not self.lastSendBlinkTime or ctick - self.lastSendBlinkTime > 20) and self.data.screen then
		self.network:sendToClients("cl_blink")
		self.lastSendBlinkTime = ctick
	end
end

function Antenna.server_onFixedUpdate(self)
	if #self.sendPacketBuffer > 0 then
		self:sendPackets()
	end

	if #self.receivePacketBuffer > 0 then
		self:transmitPackets()
	end
	
	if self.temp_setchannel then
		self:server_changeChannel(self.temp_setchannel)
		self.temp_setchannel = nil
	end

	if self.sendBlick then
		self:doBlick()
		self.sendBlick = nil
	end

	if (self.channel ~= self.old_channel or self.activeState ~= self.old_activeState) and sc.needSaveData() then
		self:sv_save()
		self.old_channel = self.channel
		self.old_activeState = self.activeState
	end
end

function Antenna:sv_save()
	self.storage:save({
		channel = self.channel
	})
end

function Antenna.server_changeChannel(self, channel)
	self:setChannel(channel)
	self.network:sendToClients("client_changeChannel", channel)
end


function Antenna.server_requireChannel(self, data, client)
	self.network:sendToClient(client, "client_changeChannel", self.channel)
	if self.radius and self.radius <= 4 and self.data.screen then
		self.network:sendToClients("cl_blink", true)
	end
end


function Antenna.client_onCreate(self)
	self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/Antenna.layout", false, { backgroundAlpha = 0.5 })
	self.gui:setTextChangedCallback("Channel", "client_onChannelChanged")
	self.gui:setButtonCallback("Save", "client_onSave")

	self.channelToSend = 0
	self.serverChannel = 0

	self.network:sendToServer("server_requireChannel")
end

function Antenna.client_onDestroy(self)
	self.gui:destroy()
end

function Antenna.client_onInteract(self, char, state)
	if state then
		self:client_guiOpen()
	end
end

function Antenna.client_changeChannel(self, channel)
	self.serverChannel = channel
end

function Antenna.client_onChannelChanged(self, widget, data)
	if data:match("%d*") == data then
		local channel = tonumber(data)
		if channel >= 0 and channel <= 31 then
			self.channelToSend = channel
			self:client_guiError(nil)
		else
			self:client_guiError("integer not in [0; 31]")
		end
	else
		self:client_guiError("bad integer")
	end
end

function Antenna.client_onSave(self)
	self.network:sendToServer("server_changeChannel", self.channelToSend)
	self:client_guiClose()
end

function Antenna.client_guiOpen(self)
	self.channelToSend = self.serverChannel
	self.gui:setText("Channel", tostring(self.serverChannel))
	self:client_guiError(nil)
	self.gui:open()
end

function Antenna.client_guiError(self, text)
	if text ~= nil then
		self.gui:setVisible("Save", false)
		self.gui:setText("Error", text)
	else
		self.gui:setVisible("Save", true)
		self.gui:setText("Error", "")
	end
end

function Antenna.client_guiClose(self)
	self.gui:close()
end

function Antenna:client_onFixedUpdate()
	if self.interactable and self.blink_time then
		self.blink_time = self.blink_time - 1
		if self.blink_time <= 0 then
			self.interactable:setUvFrameIndex(self.isNfc and 1 or 0)
			self.blink_time = nil
		end
	end
end

function Antenna:cl_blink(data)
	if self.interactable then
		if data then
			self.isNfc = data
			self.interactable:setUvFrameIndex(1)
		else
			self.interactable:setUvFrameIndex(self.isNfc and 7 or 6)
			self.blink_time = 7
		end
	end
end
end
function scmframework_e9f5adbec88b956a58a71f91e123840e() --$CONTENT_DATA/Scripts/Networking/CameraTunnel.lua
dofile("$CONTENT_DATA/Scripts/RaycastCamera.lua")
dofile("$CONTENT_DATA/Scripts/Networking/Antennas/Antenna.lua")
CameraTunnel = class()
CameraTunnel.maxParentCount = 1
CameraTunnel.maxChildCount = 2 --simultaneous connection of the antenna and the computer is allowed (for changing channels)
CameraTunnel.connectionInput = sm.interactable.connectionType.networking + sm.interactable.connectionType.networkCamera
CameraTunnel.connectionOutput = sm.interactable.connectionType.networking + sm.interactable.connectionType.composite
CameraTunnel.colorNormal = sm.color.new("#b3e000")
CameraTunnel.colorHighlight = sm.color.new("#e6e808")
CameraTunnel.componentType = "camera"
CameraTunnel.poseWeightCount = 1
cameraTunnels = cameraTunnels or {}
cameraTunnelSelfs = cameraTunnelSelfs or {}

function CameraTunnel:server_onCreate()
    self.sdata = self.storage:load() or {channel = 0}
    self.active = false
    cameraTunnelSelfs[self.interactable.id] = self

    self.camApi = nil
    self.staticCamApi = {}
    for methodName in pairs(RaycastCamera.createData(self, true)) do
        self.staticCamApi[methodName] = function(...)
            if not self.camApi then
                error("there is no connection to the camera", 2)
            end
            self.needSendBlick = true
            
            --for a proper stack traceback
            local result = {pcall(self.camApi[methodName], ...)}
            if result[1] then
                return unpack(result, 2)
            else
                error(result[2], 2)
            end
        end
    end

    self.staticCamApi["isCameraAvailable"] = function ()
        return not not self.camApi
    end

    self.staticCamApi["setCameraChannel"] = function (channel)
        checkArg(1, channel, "number")
        if channel >= 0 and channel <= 31 and channel % 1 == 0 then
            self.sdata.channel = channel
            self.channelChanged = true    
        else
            error("integer not in [0; 31]", 2)
        end
    end

    self.staticCamApi["getCameraChannel"] = function ()
        return self.sdata.channel
    end

    self.staticCamApi["isChannelBusy"] = function (channel)
        local parent = self.interactable:getSingleParent()
        local child = self.interactable:getChildren()[1]
        local antenna, camera
        if parent and child then
            if sc.antennasRefs[parent.id] then
                antenna = sc.antennasRefs[parent.id]
            elseif sc.camerasRefs[parent.id] then
                camera = sc.camerasRefs[parent.id]
                if sc.antennasRefs[child.id] then
                    antenna = sc.antennasRefs[child.id]
                end
            end
        end

        if antenna then
            for _, targetAntenna in ipairs(antenna:findTargets()) do
                if targetAntenna.activeState then
                    for _, tunnel in ipairs(targetAntenna.interactable:getParents()) do
                        local tunnelSelf = cameraTunnelSelfs[tunnel.id]
                        if tunnelSelf and
                            tunnel.shape.uuid == self.shape.uuid and
                            tunnel.shape.id ~= self.shape.id and
                            tunnelSelf.sdata.channel == channel and
                            tunnelSelf.transmitterMode then
                            return true
                        end
                    end
                end
            end
        end
        return false
    end

    self.interactable.publicData = {
        sc_component = {
            type = CameraTunnel.componentType,
            api = self.staticCamApi
        }
    }
end

function CameraTunnel:server_onFixedUpdate()
    if self.channelChanged then
        self.storage:save(self.sdata)
        self:sv_dataRequest()
        self.channelChanged = nil
    end

    local parent = self.interactable:getSingleParent()
    local child = self.interactable:getChildren()[1]
    
    local antenna, camera
    if parent and child then
        if sc.antennasRefs[parent.id] then
            antenna = sc.antennasRefs[parent.id]
        elseif sc.camerasRefs[parent.id] then
            camera = sc.camerasRefs[parent.id]
            if sc.antennasRefs[child.id] then
                antenna = sc.antennasRefs[child.id]
            end
        end
    end

    self.camApi = nil
    self.transmitterMode = false
    local camApiTransmitted = false
    if antenna and camera then
        self.transmitterMode = true
        for _, targetAntenna in ipairs(antenna:findTargets()) do
            if targetAntenna.activeState then
                for _, tunnel in ipairs(targetAntenna.interactable:getChildren()) do
                    local tunnelSelf = cameraTunnelSelfs[tunnel.id]
                    if tunnelSelf and tunnel.shape.uuid == self.shape.uuid and tunnelSelf.sdata.channel == self.sdata.channel then
                        camApiTransmitted = true
                        cameraTunnels[tunnel.id] = {camera, antenna}
                    end
                end
            end
        end
    elseif antenna then
        local tunnel = cameraTunnels[self.interactable.id]
        if tunnel then
            if self.needSendBlick then
                antenna.sendBlick = true
                tunnel[2].sendBlick = true
            end

            self.camApi = tunnel[1].camApi
            cameraTunnels[self.interactable.id] = nil
        end
    end
    self.needSendBlick = nil

    self.active = self.camApi or camApiTransmitted
    if self.active ~= self.oldActive then
        self.oldActive = self.active
        self:sv_dataRequest()
    end
end

function CameraTunnel:sv_changeChannel(channel)
    self.sdata.channel = channel
    self.storage:save(self.sdata)
    self:sv_dataRequest()
end

function CameraTunnel:sv_dataRequest(_, caller)
    local cldata = {channel = self.sdata.channel, active = self.active}
    if caller then
        self.network:sendToClient(caller, "cl_updateLocalData", cldata)
    else
        self.network:sendToClients("cl_updateLocalData", cldata)
    end
end

function CameraTunnel:server_onDestroy()
    cameraTunnelSelfs[self.interactable.id] = nil
end

-------------------------------------------------------

function CameraTunnel:client_onCreate()
    self.network:sendToServer("sv_dataRequest")

    self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/Antenna.layout", false, { backgroundAlpha = 0.5 })
	self.gui:setTextChangedCallback("Channel", "cl_onChannelChanged")
	self.gui:setButtonCallback("Save", "cl_onSave")
    self.gui:setText("Title", "Camera Tunnel")
end

function CameraTunnel:cl_onChannelChanged(widget, data)
	if data:match("%d*") == data then
		local channel = tonumber(data)
		if channel >= 0 and channel <= 31 then
			self.channelToSend = channel
			self:cl_guiError(nil)
		else
			self:cl_guiError("integer not in [0; 31]")
		end
	else
		self:cl_guiError("bad integer")
	end
end

function CameraTunnel:cl_guiError(text)
	if text ~= nil then
		self.gui:setVisible("Save", false)
		self.gui:setText("Error", text)
	else
		self.gui:setVisible("Save", true)
		self.gui:setText("Error", "")
	end
end

function CameraTunnel:cl_onSave()
    self.cldata.channel = self.channelToSend
	self.network:sendToServer("sv_changeChannel", self.channelToSend)
	self.gui:close()
end

function CameraTunnel:client_onInteract(_, state)
    if state then
        self.gui:setText("Channel", tostring(self.cldata.channel))
        self.gui:open()
    end
end

function CameraTunnel:cl_updateLocalData(cldata)
    self.cldata = cldata
    self.channelToSend = self.cldata.channel
    self.interactable:setPoseWeight(0, cldata.active and 1 or 0)
    self.interactable:setUvFrameIndex(cldata.active and 6 or 0)
end
end
function scmframework_3b93cb758f50c0955d7142cb4b3d89e2() --$CONTENT_DATA/Scripts/Networking/NetworkPort.lua
dofile "$MOD_DATA/Scripts/Config.lua"

NetworkPort = class(nil)

NetworkPort.maxParentCount = -1
NetworkPort.maxChildCount = -1
NetworkPort.connectionInput = sm.interactable.connectionType.composite + sm.interactable.connectionType.networking
NetworkPort.connectionOutput = sm.interactable.connectionType.networking
NetworkPort.colorNormal = sm.color.new(0xedc84cff)
NetworkPort.colorHighlight = sm.color.new(0xebcf71ff)

NetworkPort.MAX_STORED_PACKETS = 128

-- CLIENT --

--[[
function NetworkPort.getParentCount(self, connectionType)
    return #
end

function NetworkPort.getChildCount(self, connectionType)
    return #self.interactable:getChildren(connectionType)
end

function NetworkPort.getNetworkConnectionsCount(self)
    return self:getChildCount() + self:getParentCount(sm.interactable.connectionType.networking)
end

function NetworkPort.client_getAvailableChildConnectionCount(self, connectionType)
    return 1 - self:getNetworkConnectionsCount()
end


]]

function NetworkPort.client_getAvailableParentConnectionCount(self, connectionType)
    local checks = sm.interactable.connectionType.composite
    if bit.band(connectionType, checks) ~= 0 then
        return 1 - #self.interactable:getParents(checks)
    end
    return 1
end



-- SERVER --

function NetworkPort:getUniqueId()
    return self.interactable:getId()
end

function NetworkPort.createData(self)
    return {
        getMaxPacketsCount = function () return NetworkPort.MAX_STORED_PACKETS end,
        getPacketsCount = function () 
            return #self.packets
        end,
        nextPacket = function () 
            local packet = table.remove(self.packets, 1)
            if not packet then return nil, nil end
            return packet.data, packet.source
        end,
        send = function (packet)
            checkArg(1, packet, "string")
            self:server_putPacket(packet)
        end,
        sendTo = function (id, packet)
            checkArg(1, id, "number")
            checkArg(2, packet, "string")
            self:server_putPacket(packet, id)
        end,
        clear = function ()
            self.packets = {}
        end,
        getUniqueId = function ()
            return self:getUniqueId()
        end,

        sendTable = function (tbl)
            checkArg(1, tbl, "table")
            jsonEncodeInputCheck(tbl, 0)
            self:server_putPacket(sm.json.writeJsonString(tbl))
        end,
        sendTableTo = function (id, tbl)
            checkArg(1, id, "number")
            checkArg(2, tbl, "table")
            jsonEncodeInputCheck(tbl, 0)
            self:server_putPacket(sm.json.writeJsonString(tbl), id)
        end,
        nextTable = function () 
            local packet = table.remove(self.packets, 1)
            if not packet then return nil, nil end
            local okay, tbl = pcall(sm.json.parseJsonString, packet.data)
            if okay then
                return tbl, packet.source
            end
        end,
    }
end

-- interface method
function NetworkPort.propagatePackets(self, packets) --получение
    self.reciveBlick = true

    local packs = self.packets
    local id = self:getUniqueId()

    local max = NetworkPort.MAX_STORED_PACKETS
    local insert = table.insert

    local dcopy = sc.deepcopy

    for i, packet in ipairs(packets) do
        if not packet.id or packet.id == id then
            if #packs <= max then
                insert(packs, dcopy(packet))
            else
                break
            end
        end
    end
end

function NetworkPort.server_putPacket(self, packet, id) --помешения на отправку из компа
    assert(type(packet) == "string", "network data must be string")
    if #self.packetsToSend < NetworkPort.MAX_STORED_PACKETS then
        table.insert(self.packetsToSend, {
            data = packet,
            id = id,
            source = self:getUniqueId()
        })
    else
        error("packet buffer overflow")
    end
end

function NetworkPort.server_sendPackets(self) --отправка
    local childs = self.interactable:getChildren(sm.interactable.connectionType.networking) or {}
    local parents = self.interactable:getParents(sm.interactable.connectionType.networking) or {}

    for index, child in ipairs(childs) do
        local script = sc.networking[child:getId()]
        if script then
            script:propagatePackets(self.packetsToSend)
        end
    end
    for index, parent in ipairs(parents) do
        local script = sc.networking[parent:getId()]
        if script then
            script:propagatePackets(self.packetsToSend)
        end
    end

    self.packetsToSend = {}
end

function NetworkPort.server_onCreate(self)
    self.packets = {}
    self.packetsToSend = {}

    local id = self.interactable:getId()

    sc.networkPortsDatas[id] = self:createData()
    sc.networking[id] = self
end

function NetworkPort.server_onDestroy(self)
    local id = self.interactable:getId()

    sc.networkPortsDatas[id] = nil
    sc.networking[id] = nil
end

function NetworkPort.server_onFixedUpdate(self, dt)
    local ctick = sm.game.getCurrentTick()
    
    if #self.packetsToSend > 0 then
        self:server_sendPackets()

        if not self.lastSendBlinkTime1 or ctick - self.lastSendBlinkTime1 > 20 then
            self.network:sendToClients("cl_blink", 1)
            self.lastSendBlinkTime1 = ctick
        end
    end

    if self.reciveBlick then
        if not self.lastSendBlinkTime2 or ctick - self.lastSendBlinkTime2 > 20 then
            self.network:sendToClients("cl_blink", 2)
            self.lastSendBlinkTime2 = ctick
        end

		self.reciveBlick = false
    end
end

------------------------

NetworkPort.ledShape = sm.uuid.new("64d41b06-9b71-4e19-9f87-1e7e63845e59")

NetworkPort.sendOn = sm.color.new("#00ed76")
NetworkPort.sendOn.a = 1
NetworkPort.reciveOn = sm.color.new("#edb100")
NetworkPort.reciveOn.a = 1

NetworkPort.sendOff = NetworkPort.sendOn * 0.5
NetworkPort.sendOff.a = 0
NetworkPort.reciveOff = NetworkPort.reciveOn * 0.5
NetworkPort.reciveOff.a = 0

NetworkPort.ledScale = sm.vec3.new(0.06, 0.04, 0)
NetworkPort.sendLedOffset = sm.vec3.new(-0.076, 0.1, 0.12)
NetworkPort.reciveLedOffset = sm.vec3.new(0.076, 0.1, 0.12)

function NetworkPort:client_onCreate()
    self.sendLed = sm.effect.createEffect("ShapeRenderable", self.interactable)
    self.reciveLed = sm.effect.createEffect("ShapeRenderable", self.interactable)

    self.sendLed:setParameter("uuid", NetworkPort.ledShape)
    self.reciveLed:setParameter("uuid", NetworkPort.ledShape)

    self.sendLed:setParameter("color", NetworkPort.sendOff)
    self.reciveLed:setParameter("color", NetworkPort.reciveOff)

    self.sendLed:setScale(NetworkPort.ledScale)
    self.reciveLed:setScale(NetworkPort.ledScale)

    self.sendLed:setOffsetPosition(NetworkPort.sendLedOffset)
    self.reciveLed:setOffsetPosition(NetworkPort.reciveLedOffset)

    self.sendLed:start()
    self.reciveLed:start()
end

function NetworkPort:client_onFixedUpdate()
	if self.blink_time1 then
		self.blink_time1 = self.blink_time1 - 1
		if self.blink_time1 <= 0 then
			self.sendLed:setParameter("color", NetworkPort.sendOff)
			self.blink_time1 = nil
		end
	end

	if self.blink_time2 then
		self.blink_time2 = self.blink_time2 - 1
		if self.blink_time2 <= 0 then
			self.reciveLed:setParameter("color", NetworkPort.reciveOff)
			self.blink_time2 = nil
		end
	end
end

function NetworkPort:cl_blink(btype)
    if self.interactable then
        if btype == 1 then
            self.blink_time1 = 7
            self.sendLed:setParameter("color", NetworkPort.sendOn)
        elseif btype == 2 then
            self.blink_time2 = 7
            self.reciveLed:setParameter("color", NetworkPort.reciveOn)
        end
    end
end
end
function scmframework_40886caf014bcc9ca9b0f8abfe422861() --$CONTENT_DATA/Scripts/paintGun.lua
paintGun = class()
paintGun.maxParentCount = 1
paintGun.maxChildCount = 0
paintGun.connectionInput = sm.interactable.connectionType.composite
paintGun.connectionOutput = sm.interactable.connectionType.none
paintGun.colorNormal = sm.color.new("#aa0000")
paintGun.colorHighlight = sm.color.new("#ff0303")
paintGun.componentType = "paint"

local blockSize = sm.vec3.new(1, 1, 1)
local floor = math.floor
local oneSize = sm.vec3.new(0.25, 0.25, 0.25)

function paintGun:server_onCreate()
    self.interactable.publicData = {
        sc_component = {
            type = paintGun.componentType,
            api = {
                shot = function(color)
                    self.shot = sc.formatColor(color)
                end,
                scan = function ()
                    local ok, raydata = sm.physics.raycast(self.shape.worldPosition, self.shape.worldPosition + (self.shape.worldRotation * sm.vec3.new(0, 0, 4)))
                    if ok then
                        local shape = raydata:getShape()
                        local character = raydata:getCharacter()
                        local joint = raydata:getJoint()
                        local harvestable = raydata:getHarvestable()

                        if shape then
                            return shape.color, raydata.fraction * 4
                        elseif character then
                            return character.color, raydata.fraction * 4
                        elseif joint then
                            return joint.color, raydata.fraction * 4
                        elseif harvestable then
                            if sc.treesPainted[harvestable.id] then
                                return sc.treesPainted[harvestable.id][2] or sm.color.new(0, 0, 0), raydata.fraction * 4
                            else
                                return sm.color.new(0, 0, 0), raydata.fraction * 4
                            end
                        end
                    end
                end
            }
        }
    }
end

function paintGun:server_onFixedUpdate()
    if self.shot then
        local data = {}

        local ok, raydata = sm.physics.raycast(self.shape.worldPosition, self.shape.worldPosition + (self.shape.worldRotation * sm.vec3.new(0, 0, 4)))
        if ok then
            data.pos = raydata.pointWorld
            local shape = raydata:getShape()
            local character = raydata:getCharacter()
            local joint = raydata:getJoint()
            local harvestable = raydata:getHarvestable()

            if shape then
                if shape.color ~= self.shot then
                    if shape.isBlock and shape:getBoundingBox() ~= oneSize then
                        local uuid = shape.uuid
                        local pos = raydata.pointLocal + (shape:transformRotation(self.shape.worldRotation) * sm.vec3.new(0, 0, 0.1))

                        local lpos = pos * 4
                        lpos.x = floor(lpos.x)
                        lpos.y = floor(lpos.y)
                        lpos.z = floor(lpos.z)

                        shape:destroyBlock(lpos)
                        local block = shape.body:createBlock(uuid, blockSize, lpos)
                        block.color = self.shot
                    else
                        shape.color = self.shot
                    end
                end
            elseif character then
                character.color = self.shot
            elseif joint then
                joint.color = self.shot
            elseif harvestable then
                sc.treesPainted[harvestable.id] = {harvestable, self.shot}
                sm.storage.save("sc_treesPainted", sc.treesPainted)
                data[1] = harvestable
                data[2] = self.shot
            end
        end

        self.network:sendToClients("cl_shot", data)
        self.shot = nil
        self.allow_update = nil
    end
end



function paintGun:cl_shot(data)
    if type(data[1]) == "Harvestable" then
        data[1]:setColor(data[2])
    end
    if data.pos then
        sm.effect.playEffect("PaintTool - Paint", data.pos)
    else
        sm.effect.playEffect("PaintTool - Paint", self.shape.worldPosition)
    end
    --sm.effect.playEffect("Steam - quench", self.shape.worldPosition, (self.shape.worldRotation * sm.vec3.new(0, 0, 3)))
end
end
function scmframework_6a44882dcfd6ed66c89bb131c3dc87c4() --$CONTENT_DATA/Scripts/pistonController.lua
pistonController = class()
pistonController.maxParentCount = 1
pistonController.maxChildCount = -1
pistonController.connectionInput = sm.interactable.connectionType.composite
pistonController.connectionOutput = sm.interactable.connectionType.piston
pistonController.colorNormal = sm.color.new(0x8c6208ff)
pistonController.colorHighlight = sm.color.new(0xe39a01ff)
pistonController.componentType = "pistonController" --absences can cause problems

pistonController.defaultVelocity = 3
pistonController.defaultLengthLimit = 15
pistonController.defaultSpeedLimit = 10
pistonController.defaultForceLimit = 100000

pistonController.pistonsRestrictions = {
    ["8c741785-5eae-4c48-9f99-d62bf522a83f"] = {
        length = 7
    },
    ["31f14f52-f4d8-4b9f-9d6e-7412497c9284"] = {
        length = 9
    },
    ["46396518-8c29-4da9-81bb-a020f4baf5b2"] = {
        length = 11
    },
    ["7324219e-2b19-4098-baa3-9876984ead08"] = {
        length = 13
    },
    ["2f004fdf-bfb0-46f3-a7ac-7711100bee0c"] = {
        length = 15
    },
    ["6b919779-1aa4-4d1a-9186-513d0965dc98"] = {
        length = 255,
        speed = 50,
        force = 10000000
    }
}

function pistonController:server_onCreate()
    self.sdata = self.storage:load() or {label = ""}
    self:sv_setData(self.sdata)

    self.interactable.publicData = {
        sc_component = {
            type = pistonController.componentType,
            api = {
                setLength = function(index, length)
                    checkArg(1, index, "number")
                    checkArg(2, length, "number")
                    self.pistonsLength[index] = length
                end,
                getLength = function(index)
                    checkArg(1, index, "number")
                    return self.pistonsLength[index] or 0
                end,

                setVelocity = function(index, velocity)
                    checkArg(1, index, "number")
                    checkArg(2, velocity, "number")
                    self.pistonsVelocity[index] = velocity
                end,
                getVelocity = function(index)
                    checkArg(1, index, "number")
                    return self.pistonsVelocity[index] or pistonController.defaultVelocity
                end,

                setForce = function(index, force)
                    checkArg(1, index, "number")
                    checkArg(2, force, "number")
                    self.pistonsForce[index] = force
                end,
                getForce = function(index)
                    checkArg(1, index, "number")
                    return self.pistonsForce[index] or pistonController.defaultForceLimit
                end,
                

                getPistonsCount = function()
                    return self.pistonsCount
                end,
                isPistonAvailable = function(index)
                    checkArg(1, index, "number")
                    return not not self.pistonsAvailable[index]
                end,
                getMaxVelocity = function(index)
                    checkArg(1, index, "number")
                    local restrictions = self.pistonsAvailable[index]
                    if restrictions then
                        return restrictions.speed or pistonController.defaultSpeedLimit
                    end
                end,
                getMaxLength = function(index)
                    checkArg(1, index, "number")
                    local restrictions = self.pistonsAvailable[index]
                    if restrictions then
                        return restrictions.length or pistonController.defaultLengthLimit
                    end
                end,
                getMaxForce = function(index)
                    checkArg(1, index, "number")
                    local restrictions = self.pistonsAvailable[index]
                    if restrictions then
                        return restrictions.force or pistonController.defaultForceLimit
                    end
                end
            },
            label = function()
                return self.sdata.label
            end
        }
    }
    
    self.pistonsCount = 0
    self.pistonsLength = {}
    self.pistonsVelocity = {}
    self.pistonsAvailable = {}
    self.pistonsForce = {}
    self:sv_update()
end

function pistonController:server_onFixedUpdate()
    self:sv_update()
end

function pistonController:sv_update()
    self.pistonsAvailable = {}
    self.pistonsCount = 0
    for k, v in pairs(self.interactable:getPistons()) do
        local index = k - 1
        local restrictions = pistonController.pistonsRestrictions[tostring(v.uuid)]
        v:setTargetLength(
            math.max(math.min(restrictions.length or pistonController.defaultLengthLimit, self.pistonsLength[index] or 0), 0),
            math.max(math.min(restrictions.speed or pistonController.defaultSpeedLimit, self.pistonsVelocity[index] or pistonController.defaultVelocity), 0),
            math.max(math.min(restrictions.force or pistonController.defaultForceLimit, self.pistonsForce[index] or pistonController.defaultForceLimit), 0)
        )

        self.pistonsAvailable[index] = restrictions
        self.pistonsCount = self.pistonsCount + 1
    end
end

function pistonController:sv_setData(data)
	data.label = tostring(data.label or "")
    self.sdata = data
    self.network:sendToClients("cl_setData", self.sdata)
    self.storage:save(self.sdata)
end

function pistonController:sv_dataRequest(_, player)
    self.network:sendToClient(player, "cl_setData", self.sdata)
end

-------------------------------------------------------------------

function pistonController:client_onCreate()
	self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/MotorLabel.layout", false, { backgroundAlpha = 0 })
	self.gui:setTextChangedCallback("Label", "cl_onLabelChanged")
	self.gui:setButtonCallback("Save", "cl_onLabelChange")
    self.gui:setText("Title", "PistonController Label")

    self.network:sendToServer("sv_dataRequest")
end

function pistonController:cl_onLabelChanged(_, data)
	if #data <= 32 then
		self.cl_temp_label = data
        self:cl_guiError(nil)
	else
		self:cl_guiError("label is too long")
	end
end

function pistonController:cl_setData(data)
    self.csdata = data
end

function pistonController:cl_guiError(text)
	if text ~= nil then
		self.gui:setVisible("Save", false)
        self.gui:setVisible("Error", true)
		self.gui:setText("Error", text)
	else
		self.gui:setVisible("Save", true)
        self.gui:setVisible("Error", false)
		self.gui:setText("Error", "")
	end
end

function pistonController:cl_onLabelChange()
    self.csdata.label = self.cl_temp_label
    self.network:sendToServer("sv_setData", self.csdata)
	self.gui:close()
end

function pistonController:client_onInteract(_, state)
	if state and self.csdata then
        self.cl_temp_label = self.csdata.label
        self.gui:setText("Label", tostring(self.cl_temp_label))
	    self:cl_guiError(nil)
		self.gui:open()
	end
end
end
function scmframework_5f010a59b73cf3b5e696b86dadf5bc34() --$CONTENT_DATA/Scripts/radarDetector.lua
radarDetector = class()
radarDetector.maxParentCount = 1
radarDetector.maxChildCount = 0
radarDetector.connectionInput = sm.interactable.connectionType.composite
radarDetector.connectionOutput = sm.interactable.connectionType.none
radarDetector.colorNormal = sm.color.new("#134da9")
radarDetector.colorHighlight = sm.color.new("#3080ff")
radarDetector.componentType = "radarDetector"

function radarDetector:server_onCreate()
    self.interactable.publicData = {
        sc_component = {
            type = radarDetector.componentType,
            api = {
                getRadars = function()
                    local tick = sm.game.getCurrentTick()
                    if tick == self.old_tick and not sc.restrictions.disableCallLimit then
                        error("getRadars can only be used 1 time per tick on one radar", 2)
                    end
                    self.old_tick = tick

                    local radars = {}
                    for _, data in pairs(sc.radarDetectedBodies[self.shape:getBody().id] or {}) do
                        if tick < data[1] and not data[3][self.interactable.id] then
                            local direction = data[2] - self.shape.worldPosition
                            local f_at = sm.quat.getUp(self.shape.worldRotation)
                            local f_up = sm.quat.getAt(self.shape.worldRotation)
                            table.insert(radars, (sm.quat.lookRotation(f_at, f_up) * direction):normalize())
                            --table.insert(radars, (self.shape:transformDirection(direction)):normalize())
                            data[3][self.interactable.id] = true
                        end
                    end
                    return radars
                end
            }
        }
    }
end


end
function scmframework_55377b67e83bab57c3d289b0b4d22650() --$CONTENT_DATA/Scripts/Radars/BigRadar.lua
dofile '$CONTENT_DATA/Scripts/Radars/RadarBase.lua'

BigRadar = class(nil)

BigRadar.maxParentCount = 1
BigRadar.maxChildCount = 0
BigRadar.connectionInput = sm.interactable.connectionType.composite
BigRadar.colorNormal = sm.color.new(0x7b139eff)
BigRadar.colorHighlight = sm.color.new(0xb81cedff)
BigRadar.componentType = "radar"


function BigRadar.server_onCreate(self)
	self.radar = sc.radar.createRadar(self, 512, 512, math.pi / 6, math.pi / 6, 0.5)
	sc.radar.server_onCreate(self.radar)
end

function BigRadar.server_onFixedUpdate(self)
	sc.creativeCheck(self, self.data and self.data.creative)
	sc.radar.server_onTick(self.radar)
end

function BigRadar.server_onDestroy(self)
	sc.radar.server_onDestroy(self.radar)
end
end
function scmframework_0cf078eaa29c0703826a0b14ccb1f0fc() --$CONTENT_DATA/Scripts/Radars/ExtraBigRadar.lua
dofile '$CONTENT_DATA/Scripts/Radars/RadarBase.lua'

ExtraBigRadar = class(nil)

ExtraBigRadar.maxParentCount = 1
ExtraBigRadar.maxChildCount = 0
ExtraBigRadar.connectionInput = sm.interactable.connectionType.composite
ExtraBigRadar.colorNormal = sm.color.new(0x7b139eff)
ExtraBigRadar.colorHighlight = sm.color.new(0xb81cedff)
ExtraBigRadar.componentType = "radar"


function ExtraBigRadar.server_onCreate(self)
	self.radar = sc.radar.createRadar(self, 2048, 2048, math.pi / 6, math.pi / 6, 0.05)
	sc.radar.server_onCreate(self.radar)
end

function ExtraBigRadar.server_onFixedUpdate(self)
	sc.creativeCheck(self, self.data and self.data.creative)
	sc.radar.server_onTick(self.radar)
end

function ExtraBigRadar.server_onDestroy(self)
	sc.radar.server_onDestroy(self.radar)
end
end
function scmframework_b949564a9f96fb1dc997834b5383285d() --$CONTENT_DATA/Scripts/Radars/Radar.lua
dofile '$CONTENT_DATA/Scripts/Radars/RadarBase.lua'

Radar = class(nil)

Radar.maxParentCount = 1
Radar.maxChildCount = 0
Radar.connectionInput = sm.interactable.connectionType.composite
Radar.colorNormal = sm.color.new(0x7b139eff)
Radar.colorHighlight = sm.color.new(0xb81cedff)
Radar.componentType = "radar"


function Radar.server_onCreate(self)
	self.radar = sc.radar.createRadar(self, 128, 128, math.pi / 6, math.pi / 6, 1.5)
	sc.radar.server_onCreate(self.radar)
end

function Radar.server_onFixedUpdate(self)
	sc.creativeCheck(self, self.data and self.data.creative)
	sc.radar.server_onTick(self.radar)
end

function Radar.server_onDestroy(self)
	sc.radar.server_onDestroy(self.radar)
end
end
function scmframework_4344ba79a674f18b8460b93073e49c41() --$CONTENT_DATA/Scripts/Radars/RadarBase.lua
dofile "$CONTENT_DATA/Scripts/Config.lua"

sc.radar = {}

clamp = sm.util.clamp

function radar_needRaycast(direction, halfHcos, halfVcos) -- self pos is (0, 0, 0)
	-- forward direction is (-1, 0, 0)
	-- up direction is (0, 1, 0)
	local dX = direction.x
	local dZ = direction.z

	local xzLen = math.sqrt(dX * dX + dZ * dZ)

	local hdot = clamp(-dX / xzLen, -1, 1) -- clamp because if > 1 acos is nan
	local vdot = clamp((dX*dX + dZ*dZ) / xzLen, -1, 1) -- vec(dX, 0, dZ).normalized().dot( vec(dX, dY, dZ) )

	return hdot >= halfHcos and vdot >= halfVcos
end

function radar_getAngles(direction)
	local dX = direction.x
	local dZ = direction.z

	local xzLen = math.sqrt(dX * dX + dZ * dZ)

	local hdot = clamp(-dX / xzLen, -1, 1)
	local vdot = clamp((dX*dX + dZ*dZ) / xzLen, -1, 1)

	local acos = math.acos

	return acos(hdot) * (direction.z <= 0 and 1 or -1), acos(vdot) * (direction.y >= 0 and 1 or -1)
end

function sc.radar.createRadar(scriptableObject, hResol, vResol, hFov, vFov, minDetectionMassRatio)
	return {
		hResol = hResol,
		vResol = vResol,
		hFov = hFov,
		vFov = vFov,
		angle = 0,
        vAngle = 0,
		scriptableObject = scriptableObject,
		minDetectionMassRatio = minDetectionMassRatio
	}
end

function sc.radar.createData(self)
	return {
		getTargets = function () --> {hangle, vangle, distance}
			local tick = sm.game.getCurrentTick()
			if tick == self.old_tick and not sc.restrictions.disableCallLimit then
				error("getTargets can only be used 1 time per tick on one radar", 2)
			end
			self.old_tick = tick

			return sc.radar.server_makeCasts(self)
		end,

		setAngle = function (a) 
			if type(a) == "number" then
				self.angle = a
			else
				error("Type must be number", 2)
			end
		end,
		getAngle = function () return self.angle end,

        setVAngle = function (a) 
			if type(a) == "number" then
				self.vAngle = a
			else
				error("Type must be number", 2)
			end
		end,
		getVAngle = function () return self.vAngle end,

		setHFov = function (a)
			if type(a) == "number" then
				local pi = math.pi

				if a >= -pi and a <= pi then
					self.hFov = a
				else
					error("Angle must be in [0, pi]", 2)
				end
			else
				error("Type must be number", 2)
			end
		end,
		getHFov = function () return self.hFov end,

		setVFov = function (a)
			if type(a) == "number" then
				local pi = math.pi

				if a >= -pi and a <= pi then
					self.vFov = a
				else
					error("Angle must be in [0, pi]", 2)
				end
			else
				error("Type must be number", 2)
			end
		end,
		getVFov = function () return self.vFov end,
	}
end

local function checkChaffCollision(pos1, pos2)
    for _, chaffObjects in ipairs(sc.sv_chaff_objects) do
        if doesRayIntersectSphere(pos1, pos2, chaffObjects.position, sc.chaff_real_size) then
            return true
        end
    end
end

local zero = sm.vec3.zero()
function sc.radar.server_makeCasts(self) --> table[hResol, vResol]
	local hFov = self.hFov
	local vFov = self.vFov
	local hResol = self.hResol
	local vResol = self.vResol
	local angle = self.angle
    local vAngle = self.vAngle

	local minDetectionMassRatio = self.minDetectionMassRatio

	local quatOffset = sm.quat.angleAxis(angle, sm.vec3.new(0, 1, 0))
    local vQuatOffset = sm.quat.angleAxis(vAngle, sm.vec3.new(0, 0, 1))

	local shape = self.scriptableObject.shape
	local sbody = shape.body
	local sbodyId = sbody:getId()

	local sgpos = shape:getWorldPosition()

	local hAngleStep = hFov / hResol
	local vAngleStep = vFov / vResol

	local halfHcos = math.cos(hFov / 2)
	local halfVcos = math.cos(vFov / 2)
	
	local raycast = sm.physics.raycast

	local points = {} -- pointData = { id, x, y, distance, force }

	--local insert = table.insert
	local floor = math.floor
	local insert = table.insert
	local fmod = math.fmod
	local pi = math.pi

	local random = math.random

	local genNoise
	if self.scriptableObject.unrestricted then
		genNoise = function (a)
			return 0
		end
	else
		genNoise = function (a)
			return random() * a - a / 2
		end
	end

    local ctick = sm.game.getCurrentTick()
	local bodies = sm.body.getAllBodies()
	for i = 1, #bodies do
		local body = bodies[i]

		local id = body:getId()

		if id ~= sbodyId then
			local gpos
			if body:isStatic() then
				gpos = body:getShapes()[1].worldPosition
			else
				gpos = body:getCenterOfMassPosition()
			end

			local lpos = vQuatOffset * quatOffset * shape:transformPoint(gpos)
			local dir = lpos:normalize()

			local len = (sgpos - gpos):length()

			local massRatio = body:getMass() / len

			if massRatio >= minDetectionMassRatio and radar_needRaycast(dir, halfHcos, halfVcos) and not checkChaffCollision(sgpos, gpos) then
                local valid, data = raycast(sgpos, gpos, sbody)
                local b = data:getBody()

                if valid and b and b:getId() == body:getId() then
                    local hangle, vangle = radar_getAngles(dir)

                    local hcoord = floor( hangle / hAngleStep + 0.5 )
                    local vcoord = floor( vangle / vAngleStep + 0.5 )
                    local pos = hcoord + vcoord * vResol

                    if not sc.radarDetectedBodies[b.id] then sc.radarDetectedBodies[b.id] = {} end
                    sc.radarDetectedBodies[b.id][self] = {ctick + 40, sgpos, {}}

                    local d = points[pos]
                    if d == nil then
                        points[pos] = {
                            x = hcoord,
                            y = vcoord,

                            distance = len,
                            force = massRatio / minDetectionMassRatio,
                            id = id,
                            type = "body"
                        }
                    else
                        if d.distance > len then
                            d.distance = len
                            d.id = id
                            d.force = massRatio / minDetectionMassRatio
                        end
                    end
                end
			end
		end
	end

	local characters = {}
	for index, value in ipairs(sm.player.getAllPlayers()) do
		table.insert(characters, value.character)
	end
	for index, value in ipairs(sm.unit.getAllUnits()) do
		table.insert(characters, value.character)
	end

	for i = 1, #characters do
		local character = characters[i]

		local id = character:getId()

		local gpos = character:getWorldPosition()

		local lpos = vQuatOffset * quatOffset * shape:transformPoint(gpos)
		local dir = lpos:normalize()

		local len = (sgpos - gpos):length()
		local massRatio = character:getMass() / len

		if massRatio >= minDetectionMassRatio and radar_needRaycast(dir, halfHcos, halfVcos) and not checkChaffCollision(sgpos, gpos) then
			local valid, data = raycast(sgpos, gpos, sbody)
			local p = data:getCharacter()

			if valid and p and p:getId() == character:getId() then
				local hangle, vangle = radar_getAngles(dir)

				local hcoord = floor( hangle / hAngleStep + 0.5 )
				local vcoord = floor( vangle / vAngleStep + 0.5 )
				local pos = hcoord + vcoord * vResol

				local d = points[pos]

				if d == nil then
					points[pos] = {
						x = hcoord,
						y = vcoord,

						distance = len,
						force = massRatio / minDetectionMassRatio,
						id = id,
						type = "character"
					}
				else
					if d.distance > len then
						d.distance = len
						d.id = id
						d.force = massRatio / minDetectionMassRatio
					end
				end
			end
		end
	end

    for i = 1, #sc.sv_chaff_objects do
		local chaffObject = sc.sv_chaff_objects[i]
		local id = chaffObject.id
		local gpos = chaffObject.position

		local lpos = vQuatOffset * quatOffset * shape:transformPoint(gpos)
		local dir = lpos:normalize()

		local len = (sgpos - gpos):length()
		local massRatio = chaffObject.mass / len

		if massRatio >= minDetectionMassRatio and radar_needRaycast(dir, halfHcos, halfVcos) then
			if not raycast(sgpos, gpos, sbody) then
				local hangle, vangle = radar_getAngles(dir)

				local hcoord = floor( hangle / hAngleStep + 0.5 )
				local vcoord = floor( vangle / vAngleStep + 0.5 )
				local pos = hcoord + vcoord * vResol

				local d = points[pos]

				if d == nil then
					points[pos] = {
						x = hcoord,
						y = vcoord,

						distance = len,
						force = massRatio / minDetectionMassRatio,
						id = id,
						type = "body"
					}
				else
					if d.distance > len then
						d.distance = len
						d.id = id
						d.force = massRatio / minDetectionMassRatio
					end
				end
			end
		end
	end

	local result = {} -- [{ id, hangle, vangle, dist, force }]
	local pi2 = pi * 2
	local error = (1 / hResol + 1 / vResol) / 2

	for k, v in pairs(points) do
		local hangle = v.x * hAngleStep + angle + genNoise(hAngleStep)
		hangle = fmod(hangle + pi, pi2) - pi

		local vangle = v.y * vAngleStep + genNoise(vAngleStep)
		vangle = fmod(vangle + pi, pi2) - pi
		
		local distance = v.distance
		distance = distance + genNoise(error * distance)

		local force = v.force
		force = force + genNoise(error * force)

		insert(result, {
			v.id,
			hangle,
			vangle,
			distance,
			force,
			v.type,

            id = v.id,
            hangle = hangle,
            vangle = vangle,
            distance = distance,
            force = force,
            type = v.type
		})
	end

    tableShuffle(result)

	return result
end

function sc.radar.server_onTick(self)
	
end

function sc.radar.server_onCreate(self)
	sc.radarsDatas[self.scriptableObject.interactable:getId()] = sc.radar.createData(self)
end

function sc.radar.server_onDestroy(self)
	sc.radarsDatas[self.scriptableObject.interactable:getId()] = nil
end
end
function scmframework_48be20ed1737479c1e9c56a182387d2f() --$CONTENT_DATA/Scripts/Radars/SmallRadar.lua
dofile '$CONTENT_DATA/Scripts/Radars/RadarBase.lua'

SmallRadar = class(nil)

SmallRadar.maxParentCount = 1
SmallRadar.maxChildCount = 0
SmallRadar.connectionInput = sm.interactable.connectionType.composite
SmallRadar.colorNormal = sm.color.new(0x7b139eff)
SmallRadar.colorHighlight = sm.color.new(0xb81cedff)
SmallRadar.componentType = "radar"


function SmallRadar.server_onCreate(self)
	self.radar = sc.radar.createRadar(self, 32, 32, math.pi / 6, math.pi / 6, 3.5)
	sc.radar.server_onCreate(self.radar)
end

function SmallRadar.server_onFixedUpdate(self)
	sc.creativeCheck(self, self.data and self.data.creative)
	sc.radar.server_onTick(self.radar)
end

function SmallRadar.server_onDestroy(self)
	sc.radar.server_onDestroy(self.radar)
end
end
function scmframework_4526da4de05c8e80a17c68d30449da66() --$CONTENT_DATA/Scripts/Radars/UnrestrictedRadar.lua
dofile '$CONTENT_DATA/Scripts/Radars/RadarBase.lua'

UnrestrictedRadar = class(nil)

UnrestrictedRadar.maxParentCount = 1
UnrestrictedRadar.maxChildCount = 0
UnrestrictedRadar.connectionInput = sm.interactable.connectionType.composite
UnrestrictedRadar.colorNormal = sm.color.new(0x7b139eff)
UnrestrictedRadar.colorHighlight = sm.color.new(0xb81cedff)
UnrestrictedRadar.componentType = "radar"


function UnrestrictedRadar.server_onCreate(self)
	self.unrestricted = true
	self.radar = sc.radar.createRadar(self, 2048, 2048, math.pi / 6, math.pi / 6, 0)
	sc.radar.server_onCreate(self.radar)
end

function UnrestrictedRadar.server_onFixedUpdate(self)
	sc.creativeCheck(self, true)
	sc.radar.server_onTick(self.radar)
end

function UnrestrictedRadar.server_onDestroy(self)
	sc.radar.server_onDestroy(self.radar)
end
end
function scmframework_98da336c793e414411082ba7520d7245() --$CONTENT_DATA/Scripts/RaycastCamera.lua
dofile '$CONTENT_DATA/Scripts/Config.lua'

RaycastCamera = class(nil)

RaycastCamera.maxParentCount = 0
RaycastCamera.maxChildCount = 1
RaycastCamera.connectionOutput = sm.interactable.connectionType.composite + sm.interactable.connectionType.networkCamera
RaycastCamera.colorNormal = sm.color.new(0x139d9eff)
RaycastCamera.colorHighlight = sm.color.new(0x1adbddff)
RaycastCamera.componentType = "camera"
RaycastCamera.poseWeightCount = 1

local rc_raycast = sm.physics.raycast
local rc_multicast = sm.physics.multicast
local rc_insert = table.insert
local rc_remove = table.remove
local rc_vec3_new = sm.vec3.new
local rc_floor = math.floor
local rc_color_new = sm.color.new
local sm_exists = sm.exists

local constrain = constrain
local floor = math.floor
local abs = math.abs
local min = math.min
local max = math.max
local shadowVec = sm.vec3.new(0, 0, 0.8)
local mathDist = mathDist

local vec3_new = rc_vec3_new
local floor = rc_floor
local insert = rc_insert

local formatColor = sc.formatColor
local formatColorStr = sc.formatColorStr
local formatColorToSmallNumber = canvasAPI.formatColorToSmallNumber
local tostring = tostring
local mapClip = mapClip
local map = map
local dot = sm.vec3.dot
local multiColorCombine = multiColorCombine
local colorCombine = colorCombine
local colorCombineToNumber = colorCombineToNumber
local colorCombineToString = colorCombineToString
local colorCombineAdd = colorCombineAdd

local zero = sm.vec3.zero()
local normalize = sm.vec3.normalize
local function cNormalize(vec)
    if vec ~= zero then
        return normalize(vec)
    end
    return vec
end

local rad_0 = math.rad(0)
local rad_1 = math.rad(1)
local rad_45 = math.rad(45)
local rad_60 = math.rad(60)
local rad_90 = math.rad(90)
local rad_82_5 = math.rad(82.5)
local rad_165 = math.rad(165)

local defaultRayColor = rc_color_new("#80A520")
local liftColor = rc_color_new("#ebb700")
local assetColor = rc_color_new("#808080")
local sunColor = rc_color_new("#EEF4DE")

local waterColor = rc_color_new("41ADC5")
local chemicalColor = rc_color_new("FF659A")
local oilColor = rc_color_new("0B2028")

local sunColorSmallNumber = formatColorToSmallNumber(sunColor)

local skyStates = {
    {color = rc_color_new("#000008")},
    {color = rc_color_new("#182c43")},
    {color = rc_color_new("#6099bb")},
    {color = rc_color_new("#6ab4c8"), dir = sm.vec3.new(-0.227422, -0.674264, 0.7026)},
    {color = rc_color_new("#73c4cc"), dir = sm.vec3.new(-0.227422, -0.674264, 0.7026)},
    {color = rc_color_new("#7bc9cb"), dir = sm.vec3.new(-0.227422, -0.674264, 0.7026)}, --day
    {color = rc_color_new("#93b394"), dir = sm.vec3.new(-0.227422, -0.674264, 0.7026)},
    {color = rc_color_new("#c48933"), dir = sm.vec3.new(-0.227422, -0.674264, 0.7026)},
    {color = rc_color_new("#c88322")},
    {color = rc_color_new("#643037")},
    {color = rc_color_new("#31073d")},
    {color = rc_color_new("#000008")},
}

local materialColors = {
    Rock = rc_color_new("#808080"),
    Sand = rc_color_new("#FFBA5F"),
    Dirt = rc_color_new("#7E6135")
}

local assetMaterialColors = {
    Sand = rc_color_new("#883c00"),
    Dirt = rc_color_new("#883c00"),
    Grass = rc_color_new("#883c00"),
    Rock = rc_color_new("#656565")
}

local defaultCameraSettings = {
    lampLighting = true,
    shadows = true,
    smoothingTerrain = true,
    simpleShadows = true,
    sun = true,
    fog = true,
    reduceAccuracy = true,

    shadowMultiplier = 0.6,
    sunPercentage = 1 - (0.003 * 2),
    simpleShadowMin = 0.3,
    simpleShadowMax = 1
}

local fastCameraSettings = {
    lampLighting = false,
    shadows = false,
    smoothingTerrain = false
}

for k, v in pairs(defaultCameraSettings) do
    if fastCameraSettings[k] == nil then
        fastCameraSettings[k] = v
    end
end

local lamps = {
    ["27c00cfb-4e7f-45fc-a037-f9a941464ce6"] = {dist = 3},
    ["e91b0bf2-dafa-439e-a503-286e91461bb0"] = {dist = 3},
    ["1e2485d7-f600-406e-b348-9f0b7c1f5077"] = {dist = 3},
    ["7b2c96af-a4a1-420e-9370-ea5b58f23a7e"] = {dist = 3},
    ["5e3dff9b-2450-44ae-ad46-d2f6b5148cbf"] = {dist = 3},
    ["16ba2d22-7b96-4c5e-9eb7-f6422ed80ad4"] = {dist = 3},
    ["85339a1d-e67f-4c63-94fd-4a1cf8c25810"] = {dist = 3},
    ["abaef792-741e-4c6b-8e79-02461a37b035"] = {dist = 3},
    ["cc454365-7262-4953-a190-4bead4f4a260"] = {dist = 3},
    ["ba79e3c0-914f-46ff-874b-243df5589e3c"] = {dist = 3},
    ["da6e54df-a223-4a0e-b42f-ddeddd33f5b3"] = {dist = 3},
    ["ebefa387-fe4a-4839-bdd9-b6b4da39368f"] = {dist = 3},
    ["47062936-5d28-43ec-81b5-8fdb619e97e4"] = {dist = 3},
    ["ed27f5e2-cac5-4a32-a5d9-49f116acc6af"] = {dist = 3},
    ["695d66c8-b937-472d-8bc2-f3d72dd92879"] = {dist = 3}
}

local glassBlocks = {
    ["5f41af56-df4c-4837-9b3c-10781335757f"] = 0.15,
    ["749f69e0-56c9-488c-adf6-66c58531818f"] = 0.2,
    ["f406bf6e-9fd5-4aa0-97c1-0b3c2118198e"] = 0.3,
    ["b5ee5539-75a2-4fef-873b-ef7c9398b3f5"] = 0.4
}

--[[
local function drawAdvanced(posx, posy, raydata, skyColor, width, time, lampsData, skyState)
    local localSky = skyColor
    if skyState.dir and dot(skyState.dir, (raydata.rawray.directionWorld):normalize()) > 0.993 then
        localSky = sunColor
    end
    if not raydata.type or raydata.type == "limiter" then
        return localSky
    end
    
    local shadowMul = 1
    local sunShadowMul = 1
    local globalSunMul = max(1 - (abs(time - 0.5) * 2), 0.3)
    if raydata.normalWorld then
        shadowMul = max((shadowVec:dot(raydata.normalWorld) + 1) / 2, 0.2)
    end
    if raydata.overlapSunbeam then
        sunShadowMul = 0.6
    end
    local color = (raydata.color or defaultRayColor) * shadowMul * sunShadowMul
    local lampsColorAdded = false
    if lampsData then
        local lamp, dist
        for i = 1, #lampsData do
            lamp = lampsData[i]
            dist = mathDist(raydata.rawray.pointWorld, lamp[1].worldPosition)
            if dist <= lamp[2].dist * extendedLampLight then
                --color = colorCombine(constrain((dist / lamp[2].dist) * ((i2 * 0.35) + 1), 0.6, 1), lamp[1].color, color)
                color = color * lamp[1].color * constrain(map(dist / lamp[2].dist, 0, 1, 4, 1), globalSunMul, 4)
                lampsColorAdded = true
            end
        end
    end
    if not lampsColorAdded then
        color = color * globalSunMul
    end
    return colorCombine(
        raydata.fraction,
        color,
        localSky
    )
end
]]

local function downscaleResolution(resolutionX, resolutionY, step, downscale)
    resolutionX = floor(resolutionX / downscale)
    resolutionY = floor(resolutionY / downscale)
    if resolutionX < 1 then resolutionX = 1 end
    if resolutionY < 1 then resolutionY = 1 end
    local maxStep = resolutionX * resolutionY
    if step > maxStep then step = maxStep end
    return resolutionX, resolutionY, step
end

local function preprocessAdvancedSettings(self, advancedSettings)
    if advancedSettings ~= defaultCameraSettings and advancedSettings ~= fastCameraSettings then
        advancedSettings.constColor = advancedSettings.constColor and formatColor(advancedSettings.constColor)

        advancedSettings.skyColorColor = advancedSettings.constSkyColor and formatColor(advancedSettings.constSkyColor)
        advancedSettings.constTerrainColor = advancedSettings.constTerrainColor and formatColor(advancedSettings.constTerrainColor)
        advancedSettings.constHarvestableColor = advancedSettings.constHarvestableColor and formatColor(advancedSettings.constHarvestableColor)
        advancedSettings.constAssetsColor = advancedSettings.constAssetsColor and formatColor(advancedSettings.constAssetsColor)

        advancedSettings.constShapeColor = advancedSettings.constShapeColor and formatColor(advancedSettings.constShapeColor)
        advancedSettings.customLiftColor = advancedSettings.customLiftColor and formatColor(advancedSettings.customLiftColor)
        advancedSettings.constCharacterColor = advancedSettings.constCharacterColor and formatColor(advancedSettings.constCharacterColor)
        advancedSettings.constJointColor = advancedSettings.constJointColor and formatColor(advancedSettings.constJointColor)

        advancedSettings.customWaterColor = advancedSettings.customWaterColor and formatColor(advancedSettings.customWaterColor)
        advancedSettings.customChemicalColor = advancedSettings.customChemicalColor and formatColor(advancedSettings.customChemicalColor)
        advancedSettings.customOilColor = advancedSettings.customOilColor and formatColor(advancedSettings.customOilColor)

        advancedSettings.customTerrainColor_dirt = advancedSettings.customTerrainColor_dirt and formatColor(advancedSettings.customTerrainColor_dirt)
        advancedSettings.customTerrainColor_grass = advancedSettings.customTerrainColor_grass and formatColor(advancedSettings.customTerrainColor_grass)
        advancedSettings.customTerrainColor_sand = advancedSettings.customTerrainColor_sand and formatColor(advancedSettings.customTerrainColor_sand)
        advancedSettings.customTerrainColor_stone = advancedSettings.customTerrainColor_stone and formatColor(advancedSettings.customTerrainColor_stone)

        if advancedSettings.customTerrainColor_dirt or advancedSettings.customTerrainColor_grass or advancedSettings.customTerrainColor_sand or advancedSettings.customTerrainColor_stone then
            if advancedSettings.customTerrainColor_dirt ~= self._old_dirt or
            advancedSettings.customTerrainColor_grass ~= self._old_grass or
            advancedSettings.customTerrainColor_sand ~= self._old_sand or
            advancedSettings.customTerrainColor_stone ~= self._old_stone then
                self.customTerrainColors = {
                    Rock = advancedSettings.customTerrainColor_stone or materialColors.Rock,
                    Sand = advancedSettings.customTerrainColor_sand or materialColors.Sand,
                    Dirt = advancedSettings.customTerrainColor_dirt or materialColors.Dirt
                }
                self.customDefaultColor = advancedSettings.customTerrainColor_grass
                self.customSmoothedCache = {}
                self._old_dirt = advancedSettings.customTerrainColor_dirt
                self._old_grass = advancedSettings.customTerrainColor_grass
                self._old_sand = advancedSettings.customTerrainColor_sand
                self._old_stone = advancedSettings.customTerrainColor_stone
            end
        else
            self.customTerrainColors = nil
            self.customDefaultColor = nil
            self.customSmoothedCache = nil
            self._old_dirt = nil
            self._old_grass = nil
            self._old_sand = nil
            self._old_stone = nil
        end
    end
end

local function getVecHash(vec, mul)
    mul = mul or 1
    return floor(vec.x * mul) + (floor(vec.y * mul) * 3000) + (floor(vec.z * mul) * 3000 * 3000)
    --return "" .. floor(vec.x * mul) .. "" .. floor(vec.y * mul) .. "" .. floor(vec.z * mul) 
end

local function fDrawPixel(drawPixel, fillRect, width, height, downscale, offsetX, offsetY, x, y, color)
    local changed = false
    if downscale > 1 then
        x = offsetX + x * downscale
        y = offsetY + y * downscale
        if fillRect then
            --[[
            local sizeX, sizeY = downscale, downscale
            local maxSizeX, maxSizeY = width - x, height - y
            if sizeX > maxSizeX then sizeX = maxSizeX end
            if sizeY > maxSizeY then sizeY = maxSizeY end
            fillRect(x, y, sizeX, sizeY, color)
            ]]
            fillRect(x, y, downscale, downscale, color)
            changed = true
        else
            if downscale > 256 then downscale = 256 end
            local downscaleM = downscale - 1
            for ix = 0, downscaleM do
                for iy = 0, downscaleM do
                    local px, py = x + ix, y + iy
                    if px < width and py < height and drawPixel(px, py, color) then
                        changed = true
                    end
                end
            end
        end
    else
        changed = drawPixel(offsetX + x, offsetY + y, color)
    end
    return changed
end

local function ffDrawPixel(drawPixel, fillRect, width, height, downscale, offsetX, offsetY, x, y, color)
    return fDrawPixel(drawPixel, fillRect, width, height, downscale, offsetX, offsetY, x, y, formatColorToSmallNumber(color))
end

local function cDrawPixel(display, downscale, offsetX, offsetY, x, y, color)
    fDrawPixel(display.drawPixel, display.fillRect, display.getWidth(), display.getHeight(), downscale, offsetX, offsetY, x, y, color)
end

local physics_getGroundMaterial = sm.physics.getGroundMaterial

local groundCache = {}
local assetsCache = {}

local function cached_getGroundMaterial(point, cache, gridSize)
    local vechash = getVecHash(point, gridSize)
    cache = cache or groundCache
    if cache[vechash] then
        return cache[vechash]
    end
    local color = physics_getGroundMaterial(point)
    cache[vechash] = color
    return color
end

local function cached_getGroundColor(point, colors, cache, gridSize)
    local material = cached_getGroundMaterial(point, cache, gridSize)
    if not material then
        return
    end
    colors = colors or materialColors
    return colors[material]
end

local groundSmoothedPointCache = {}
local groundSmoothedCache = {}
local function cached_smoothed_getGroundColor(point, defaultColor, colors, smoothedPointCache, smoothedCache)
    local vechash = getVecHash(point, 4)
    smoothedCache = smoothedCache or groundSmoothedCache
    if smoothedCache[vechash] then
        return smoothedCache[vechash]
    end

    smoothedPointCache = smoothedPointCache or groundSmoothedPointCache

    local r, g, b = 0, 0, 0
    local sum = 0
    local lcol
    local dx = point.x
    local dy = point.y
    for ix = -0.75, 0.75, 0.25 do
        point.x = dx + ix
        for iy = -0.75, 0.75, 0.25 do
            point.y = dy + iy
            lcol = cached_getGroundColor(point, colors, smoothedPointCache, 4) or defaultColor
            if lcol then
                r = r + lcol.r
                g = g + lcol.g
                b = b + lcol.b
                sum = sum + 1
            end
        end
    end
    point.x = dx
    point.y = dy

    if sum == 0 then
        return
    end

    local color = rc_color_new(r / sum, g / sum, b / sum)
    smoothedCache[vechash] = color
    return color
end



local areaPosCache = {}
local function getRayColor(self, rawray, advancedSettings)
    local rtype = rawray.type

    --[[
    local shape = rawray:getShape()
    if shape then
        return shape.color
    else
        local character = rawray:getCharacter()
        if character then
            return character.color
        else
            local harvestable = rawray:getHarvestable()
            if harvestable then
                return harvestable:getColor()
            else
                local joint = rawray:getJoint()
                if joint then
                    return joint.color
                elseif rtype == "lift" then
                    return liftColor
                elseif rtype == "terrainAsset" then
                    return customFastGetGroundColor(rawray, assetMaterialColors, assetColor)
                elseif rtype == "areaTrigger" then
                    local triggerData = rawray:getAreaTrigger():getUserData()
                    if triggerData then
                        if triggerData.water then
                            return waterColor
                        elseif triggerData.chemical then
                            return chemicalColor
                        elseif triggerData.oil then
                            return oilColor
                        end
                    end
                elseif fastmode then
                    return customFastGetGroundColor(rawray)
                else
                    return customGetGroundColor(rawray)
                end
            end
        end
    end
    ]]

    local color = advancedSettings.constColor
    if color then
        return color
    end

    if rtype == "terrainAsset" then
        if advancedSettings.smoothingTerrain then
            color = advancedSettings.constAssetsColor or cached_smoothed_getGroundColor(rawray.pointWorld, defaultRayColor, assetMaterialColors, assetsCache) or assetColor
        else
            color = advancedSettings.constAssetsColor or cached_getGroundColor(rawray.pointWorld, assetMaterialColors, assetsCache) or assetColor
        end
        --color = assetMaterialColors[getGroundMaterial(rawray.pointWorld)] or assetColor
    elseif rtype == "body" then
        color = advancedSettings.constShapeColor or rawray:getShape().color
    elseif rtype == "character" then
        color = advancedSettings.constCharacterColor or rawray:getCharacter().color
    elseif rtype == "harvestable" then
        color = advancedSettings.constHarvestableColor or rawray:getHarvestable():getColor()
    elseif rtype == "lift" then
        color = advancedSettings.customLiftColor or liftColor
    elseif rtype == "joint" then
        color = advancedSettings.constJointColor or rawray:getJoint().color
    else
        if rtype == "areaTrigger" then
            local vechash = getVecHash(rawray.pointWorld)
            if areaPosCache[vechash] then
                color = areaPosCache[vechash]
            end

            if not color then
                areaPosCache[vechash] = true
                local areaTrigger = rawray:getAreaTrigger()
                if sm_exists(areaTrigger) then
                    local triggerData = areaTrigger:getUserData()
                    if triggerData then
                        if triggerData.water then
                            color = 1
                        elseif triggerData.chemical then
                            color = 2
                        elseif triggerData.oil then
                            color = 3
                        end
                    end

                    areaPosCache[vechash] = color
                end
            end

            if color == true then
                color = nil
            elseif color == 1 then
                color = advancedSettings.customWaterColor or waterColor
            elseif color == 2 then
                color = advancedSettings.customChemicalColor or chemicalColor
            elseif color == 3 then
                color = advancedSettings.customOilColor or oilColor
            end
        end
        
        color = color or advancedSettings.constTerrainColor
        if not color then
            if advancedSettings.smoothingTerrain then
                color = cached_smoothed_getGroundColor(rawray.pointWorld, self.customDefaultColor or defaultRayColor, self.customTerrainColors, nil, self.customSmoothedCache)
            else
                color = cached_getGroundColor(rawray.pointWorld, self.customTerrainColors)
            end
        end
    end

    if not color then
        color = self.customDefaultColor or defaultRayColor
    end

    return color
end

local function getGlobalSunMul(self, advancedSettings)
    return max(1 - (abs((advancedSettings.constDayLightValue or self.time or 0) - 0.5) * 2), 0.3)
end

local function drawAdvanced(self, x, y, res, skyState, lampsData, sunres, advancedSettings, globalSunMul, distance)
    local collision, rawray = res[1], res[2]

    if not collision or rawray.type == "limiter" then
        if advancedSettings.sun and skyState.dir and dot(skyState.dir, cNormalize(rawray.directionWorld)) > advancedSettings.sunPercentage then
            return advancedSettings.customSunColor or sunColorSmallNumber
        else
            return advancedSettings.constSkyColor or skyState.colorNumber
        end
    end
    
    -- FUCKING LAGS
    local color = getRayColor(self, rawray, advancedSettings)

    -- FUCKING LAGS
    if rawray.type ~= "character" then
        local shadowMul = 0.95
        if advancedSettings.simpleShadows then
            shadowMul = map(dot(skyState.dir or shadowVec, rawray.normalWorld), -1, 1, advancedSettings.simpleShadowMin, advancedSettings.simpleShadowMax)
            if advancedSettings.reduceAccuracy then
                shadowMul = floor(shadowMul * 16) / 16
            end
        end
        if sunres and sunres[1] then
            if sunres[2].type ~= "limiter" then
                --[[
                if sunresType == "body" then
                    local shape = sunres[2]:getShape()
                    local glassMul = glassBlocks[tostring(shape.uuid)]
                    if glassMul then
                        colorCombineAdd(color, glassMul, shape.color)
                    else
                        color.r = color.r * 0.6
                        color.g = color.g * 0.6
                        color.b = color.b * 0.6
                    end
                else
                ]]
                shadowMul = shadowMul * advancedSettings.shadowMultiplier
                --end
            end
        end
        local minLampDist = 1
        if lampsData then
            for i = 1, #lampsData do
                local lamp = lampsData[i]
                local dist = mathDist(rawray.pointWorld, lamp[1].worldPosition)
                if dist <= lamp[2].dist then
                    local lampDist = dist / lamp[2].dist
                    color = colorCombine(lampDist, lamp[1].color, color)
                    if lampDist < minLampDist then
                        minLampDist = lampDist
                    end
                end
            end
        end
        shadowMul = shadowMul * (((globalSunMul - 1) * minLampDist) + 1)
        color = color * shadowMul
    else
        color = color * globalSunMul
    end

    -- FUCKING LAGS
    if not advancedSettings.fog or rawray.fraction <= 0.025 then
        return formatColorToSmallNumber(color)
    end
    if advancedSettings.reduceAccuracy then
        return colorCombineToNumber(floor(rawray.fraction * 16) / 16, color, advancedSettings.skyColorColor or skyState.color)
    else
        return colorCombineToNumber(rawray.fraction, color, advancedSettings.skyColorColor or skyState.color)
    end
end

local clientCameras = {}

local dcwf_def_noCollideColor = "000000"
local dcwf_def_terrainColor = "666666"
local dcwf_def_unitsColor = "ffffff"

local dc_def_noCollideColor = "45c2de"
local dc_def_terrainColor = "666666"
local dc_def_unitsColor = "ffffff"

local dd_def_baseColor = "666666"
local dd_def_noCollideColor = "000000"
local dd_def_unitsColor = "ffffff"

local redMul = 256 * 256 * 256
local greenMul = 256 * 256
local blueMul = 256

local function ifCheckNeedActivate(offsetX, offsetY, width, height, rx, ry)
    return offsetX < 0 or offsetY < 0 or offsetX + width > rx or offsetY + height > ry
end

local rawPushID = 6723
canvasAPI.dataSizes[rawPushID] = 17
canvasAPI.userCalls[rawPushID] = function(newBuffer, rotation, _, _, rx, ry, stack, offset, _, bufferRangeUpdate, setDot, checkSetDot, rasterize_fill)
    local nextPixel = stack[offset]
    local offsetX, offsetY, width, height = stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4]
    if ifCheckNeedActivate(offsetX, offsetY, width, height, rx, ry) then
        setDot = checkSetDot
    end
    local step = stack[offset+5]
    local distance = stack[offset+6]
    local fovX = stack[offset+7]
    local fovY = stack[offset+8]
    local downscale = stack[offset+9]
    local actionNum = stack[offset+11]
    local interactableId = stack[offset+12]
    local col1 = stack[offset+13]
    local col2 = stack[offset+14]
    local col3 = stack[offset+15]

    local fwidth, fheight = width, height
    width, height, step = downscaleResolution(width, height, step, downscale)
    local stepM = step - 1

    local clientSelf = clientCameras[interactableId]
    local results = clientSelf:rays(width, height, nextPixel, stepM, distance, fovX, fovY, downscale)
    local tCol = 0
    local res, pixel
    local x, y
    local data, shape, character
    local idx, changed = 0, false

    --[[
    local function fillRect(x, y, sizeX, sizeY, color)
        insert(stack, 2)
        insert(stack, x)
        insert(stack, y)
        insert(stack, sizeX)
        insert(stack, sizeY)
        insert(stack, color)
    end
    ]]

    if actionNum == 0 then
        for i = 0, stepM do
            res = results[i+1]
            pixel = nextPixel + i
            x = floor(pixel / height) % width
            y = pixel % height

            if res and res[1] then
                data = res[2]
                shape = data:getShape()
                character = data:getCharacter()
                if character then
                    if ffDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, col3 * (1 - data.fraction)) then
                        changed = true
                    end
                elseif shape then
                    if ffDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, shape.color * (1 - data.fraction)) then
                        changed = true
                    end
                elseif data.type ~= "limiter" then
                    if ffDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, col2 * (1 - data.fraction)) then
                        changed = true
                    end
                elseif fDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, col1) then
                    changed = true
                end
            elseif fDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, col1) then
                changed = true
            end
        end
    elseif actionNum == 1 then
        for i = 0, stepM do
            res = results[i+1]
            pixel = nextPixel + i
            x = floor(pixel / height) % width
            y = pixel % height

            if res and res[1] then
                data = res[2]
                shape = data:getShape()
                character = data:getCharacter()

                if character then
                    if fDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, col3) then
                        changed = true
                    end
                elseif shape then
                    if ffDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, shape.color) then
                        changed = true
                    end
                elseif data.type ~= "limiter" then
                    if fDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, col2) then
                        changed = true
                    end
                elseif fDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, col1) then
                    changed = true
                end
            elseif fDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, col1) then
                changed = true
            end
        end
    elseif actionNum == 2 then
        for i = 0, stepM do
            res = results[i+1]
            pixel = nextPixel + i
            x = floor(pixel / height) % width
            y = pixel % height

            if res and res[1] then
                data = res[2]
                character = data:getCharacter()
                if character then
                    if ffDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, col3 * (1 - data.fraction)) then
                        changed = true
                    end
                elseif data.type ~= "limiter" then
                    if ffDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, col1 * (1 - data.fraction)) then
                        changed = true
                    end
                elseif fDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, col2) then
                    changed = true
                end
            elseif fDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, col2) then
                changed = true
            end
        end
    end

    --clientSelf:cl_saveLastInfo(results, nextPixel)
    return changed
end

local rawPushID2 = 6724
canvasAPI.dataSizes[rawPushID2] = 14
canvasAPI.userCalls[rawPushID2] = function(newBuffer, rotation, _, _, rx, ry, stack, offset, _, bufferRangeUpdate, setDot, checkSetDot, rasterize_fill)
    local nextPixel = stack[offset]
    local offsetX, offsetY, width, height = stack[offset+1], stack[offset+2], stack[offset+3], stack[offset+4]
    if ifCheckNeedActivate(offsetX, offsetY, width, height, rx, ry) then
        setDot = checkSetDot
    end
    local step = stack[offset+5]
    local distance = stack[offset+6]
    local fovX = stack[offset+7]
    local fovY = stack[offset+8]
    local downscale = stack[offset+9]

    local fwidth, fheight = width, height
    width, height, step = downscaleResolution(width, height, step, downscale)
    local stepM = step - 1

    local interactableId = stack[offset+11]
    local rawAdvancedSettings = stack[offset+12]
    
    local clientSelf = clientCameras[interactableId]
    local advancedSettings
    if type(rawAdvancedSettings) == "string" then
        advancedSettings = sm.json.parseJsonString(rawAdvancedSettings)
        preprocessAdvancedSettings(clientSelf, advancedSettings)
    elseif rawAdvancedSettings then
        advancedSettings = fastCameraSettings
    else
        advancedSettings = defaultCameraSettings
    end
    local results = clientSelf:rays(width, height, nextPixel, stepM, distance, fovX, fovY, downscale)
    local sunRays, lampsData
    if advancedSettings.shadows then
        sunRays = clientSelf:sunRays(width, height, nextPixel, distance, results, advancedSettings)
    end
    if advancedSettings.lampLighting then
        lampsData = clientSelf:getLampsData(distance)
    end
    local skyState = clientSelf:getSkyState(advancedSettings)
    local res, sunres, pixel
    local x, y
    local idx, changed = 0, false
    local raydata
    local globalSunMul = getGlobalSunMul(clientSelf, advancedSettings)

    --[[
    local function fillRect(x, y, sizeX, sizeY, color)
        insert(stack, 2)
        insert(stack, x)
        insert(stack, y)
        insert(stack, sizeX)
        insert(stack, sizeY)
        insert(stack, formatColorToSmallNumber(color))
    end
    ]]

    for i = 0, stepM do
        res = results[i+1]
        sunres = sunRays and sunRays[i+1]
        pixel = nextPixel + i
        x = floor(pixel / height) % width
        y = pixel % height

        if fDrawPixel(setDot, rasterize_fill, fwidth, fheight, downscale, offsetX, offsetY, x, y, drawAdvanced(clientSelf, x, y, res, skyState, lampsData, sunres, advancedSettings, globalSunMul, distance)) then
            changed = true
        end
    end

    --clientSelf:cl_saveLastInfo(results, nextPixel)
    return changed
end

--[[
local clientHostcall = {}
local hostcallId = 0

local rawPushID3 = 6725
canvasAPI.dataSizes[rawPushID3] = 2
canvasAPI.userCalls[rawPushID3] = function(newBuffer, rotation, rSizeX, rSizeY, rx, ry, stack, offset, _, bufferRangeUpdate, setDot, checkSetDot)
    local id = stack[offset]
    if id then
        clientHostcall[id](stack, offset, rSizeX, rSizeY)
        clientHostcall[id] = nil
    end
end

local function pushClientHostcall(self, display, backend, func)
    if not backend.internalApi then return end

    if not display or display.getAudience() > 0 then
        clientHostcall[hostcallId] = func
        backend.internalApi.rawPush({rawPushID3, hostcallId})
        hostcallId = hostcallId + 1
    end

    self.iterator = self.iterator + 1
end
]]

local function getViewportWH(self, width, height)
    if self.viewport_x then
        return self.viewport_x, self.viewport_y, self.viewport_sizeX, self.viewport_sizeY
    else
        return 0, 0, width, height
    end
end

local function getViewport(self, display)
    return getViewportWH(self, display.getWidth(), display.getHeight())
end

local function checkNextPixel(self, resolutionX, resolutionY)
    if self.nextPixel ~= self.nextPixel then self.nextPixel = 0 end --is nan check
    self.nextPixel = self.nextPixel % (resolutionX * resolutionY)
end

local function pushClientRender(self, display, localRawPush, backend, ...)
    if not backend.internalApi then return end

    local width = backend.api.getWidth()
    local height = backend.api.getHeight()
    local step
    width, height, step = downscaleResolution(width, height, self.step, self.downscale)
    checkNextPixel(self, width, height)

    local x, y, sizeX, sizeY = getViewport(self, display)
    backend.internalApi.rawPush({
        localRawPush,
        self.nextPixel,
        x, y, sizeX, sizeY,
        step,
        self.distance,
        self.fovX,
        self.fovY,
        self.downscale,
        self.iterator,
        ...
    })

    self.nextPixel = (self.nextPixel + step) % (width * height)
    self.iterator = self.iterator + 1
end

local function needOnClient()
    return true
    --return #sm.player.getAllPlayers() > 1
end

local function getCurrentRotation(self)
    local currentRotation = self.netdata and self.netdata.currentRotation or 0
    if self.netdata and self.netdata.rotateSync then
        currentRotation = currentRotation + toEuler(self.shape.worldRotation).z
    end
    currentRotation = -currentRotation
    return currentRotation
end

function RaycastCamera:createData(forceMinimap) --forceMinimap is used from CameraTunnel.lua to get an up-to-date list of minimap methods
    self.iterator = 0
    self.downscale = 1
    local api
    local _detectable
    api = {
        fork = function(cloneSettings)
            local newapi = sc.copy(api)
            local nextPixel = 0
            local viewport_x, viewport_y, viewport_sizeX, viewport_sizeY
            local fovX, fovY = rad_60, rad_60
            local downscale = 1
            local distance = 1024
            local step = 256
            local detectable

            local function hookDrawerFunction(name)
                newapi[name] = function(...)
                    local old_viewport_x, old_viewport_y, old_viewport_sizeX, old_viewport_sizeY = api.getViewport()
                    local old_fovX, old_fovY = api.getFovX(), api.getFovY()
                    local old_nextPixel = api.getNextPixel()
                    local old_downscale = api.getDownScale()
                    local old_distance = api.getDistance()
                    local old_step = api.getStep()
                    local old_detectable = api.getDetectableObjects()
                    
                    api.setViewport(viewport_x, viewport_y, viewport_sizeX, viewport_sizeY)
                    api.setNextPixel(nextPixel)

                    if cloneSettings then
                        api.setNonSquareFov(fovX, fovY)
                        api.setDownScale(downscale)
                        api.setDistance(distance)
                        api.setStep(step)
                        api.setDetectableObjects(detectable)
                    end

                    api[name](...)
                    nextPixel = api.getNextPixel()
                    
                    api.setViewport(old_viewport_x, old_viewport_y, old_viewport_sizeX, old_viewport_sizeY)
                    api.setNonSquareFov(old_fovX, old_fovY)
                    api.setNextPixel(old_nextPixel)
                    api.setDownScale(old_downscale)
                    api.setDistance(old_distance)
                    api.setStep(old_step)
                    api.setDetectableObjects(old_detectable)
                end
            end

            hookDrawerFunction("drawColorWithDepth")
            hookDrawerFunction("drawColor")
            hookDrawerFunction("drawDepth")
            hookDrawerFunction("drawCustom")
            hookDrawerFunction("drawAdvanced")
            hookDrawerFunction("drawOverlay")

            function newapi.setViewport(x, y, sizeX, sizeY)
                if x then
                    checkArg(1, x, "number")
                    checkArg(2, y, "number")
                    checkArg(3, sizeX, "number")
                    checkArg(4, sizeY, "number")
                    nextPixel = nextPixel % (sizeX * sizeY)
                    viewport_x = floor(x)
                    viewport_y = floor(y)
                    viewport_sizeX = floor(sizeX)
                    viewport_sizeY = floor(sizeY)
                else
                    checkArg(1, x, "nil")
                    checkArg(2, y, "nil")
                    checkArg(3, sizeX, "nil")
                    checkArg(4, sizeY, "nil")
                    viewport_x = nil
                    viewport_y = nil
                    viewport_sizeX = nil
                    viewport_sizeY = nil
                end
            end

            function newapi.getViewport()
                return viewport_x, viewport_y, viewport_sizeX, viewport_sizeY
            end

            function newapi.setNextPixel(_nextPixel)
                checkArg(1, _nextPixel, "number")
                nextPixel = _nextPixel
            end
            function newapi.getNextPixel() return nextPixel end
            function newapi.resetCounter() nextPixel = 0 end

            if cloneSettings then
                function newapi.setFov(fov)
                    checkArg(1, fov, "number")
                    newapi.setNonSquareFov(fov, fov)
                end
    
                function newapi.setNonSquareFov(fovX, fovY)
                    checkArg(1, fovX, "number")
                    checkArg(2, fovY, "number")
                    
                    if fovX < rad_1 then
                        fovX = rad_1
                    elseif fovX > rad_165 then
                        fovX = rad_165
                    end
    
                    if fovY < rad_1 then
                        fovY = rad_1
                    elseif fovY > rad_165 then
                        fovY = rad_165
                    end
                end
                
                function newapi.getFov() return math.max(fovX, fovY) end
                function newapi.getFovX() return fovX end
                function newapi.getFovY() return fovY end
                
                function newapi.setDownScale(_downscale)
                    _downscale = floor(_downscale)
                    if _downscale < 1 then _downscale = 1 end
                    if _downscale ~= downscale then
                        downscale = _downscale
                    end
                end

                function newapi.getDownScale()
                    return downscale
                end

                function newapi.setStep(_step)
                    if type(_step) == "number" and _step % 1 == 0 and _step > 0 and _step <= 4096 then
                        step = _step
                    else
                        error("integer must be in [1; 4096]")
                    end
                end
                function newapi.getStep() return step end

                function newapi.setDistance(_distance) 
                    if type(_distance) == "number" and _distance >= 0 then
                        if distance > 2048 then
                            distance = 2048
                        end
                        distance = _distance
                    else
                        error("number must be (0; 2048)")
                    end
                end
                function newapi.getDistance() return distance end

                function newapi.resetDetectableObjects()
                    newapi.setDetectableObjects({
                        liquids = true,
                        dynamicBody = true,
                        staticBody = true,
                        characters = true,
                        joints = true,
                        terrain = true,
                        assets = true,
                        harvestable = true
                    })
                end

                function newapi.setDetectableObjects(_detectable)
                    checkArg(1, _detectable, "table")
                    detectable = _detectable
                end

                function newapi.getDetectableObjects()
                    return detectable
                end

                newapi.resetDetectableObjects()
            end

            return newapi
        end,
        setViewport = function(x, y, sizeX, sizeY)
            if x then
                checkArg(1, x, "number")
                checkArg(2, y, "number")
                checkArg(3, sizeX, "number")
                checkArg(4, sizeY, "number")
                self.nextPixel = self.nextPixel % (sizeX * sizeY)
                self.viewport_x = floor(x)
                self.viewport_y = floor(y)
                self.viewport_sizeX = floor(sizeX)
                self.viewport_sizeY = floor(sizeY)
            else
                checkArg(1, x, "nil")
                checkArg(2, y, "nil")
                checkArg(3, sizeX, "nil")
                checkArg(4, sizeY, "nil")
                self.viewport_x = nil
                self.viewport_y = nil
                self.viewport_sizeX = nil
                self.viewport_sizeY = nil
            end
        end,
        getViewport = function()
            return self.viewport_x, self.viewport_y, self.viewport_sizeX, self.viewport_sizeY
        end,
        setDownScale = function(downscale)
            downscale = floor(downscale)
            if downscale < 1 then downscale = 1 end
            if downscale ~= self.downscale then
                self.downscale = downscale
            end
        end,
        getDownScale = function()
            return self.downscale
        end,
        drawColorWithDepth = function (display, noCollideColor, terrainColor, unitsColor)
            self.lightTick = sm.game.getCurrentTick()
            local backend = sc.componentsBackend[display]
            if self.interactable and backend and needOnClient() then
                pushClientRender(self, display, rawPushID, backend,
                    0,
                    self.interactable.id,
                    formatColorToSmallNumber(noCollideColor or dcwf_def_noCollideColor),
                    formatColor(terrainColor or dcwf_def_terrainColor),
                    formatColor(unitsColor or dcwf_def_unitsColor)
                )
            else
                self:sv_drawColorWithDepth(display, noCollideColor, terrainColor, unitsColor)
            end
        end,
        drawColor = function (display, noCollideColor, terrainColor, unitsColor)
            self.lightTick = sm.game.getCurrentTick()
            local backend = sc.componentsBackend[display]
            if self.interactable and backend and needOnClient() then
                pushClientRender(self, display, rawPushID, backend,
                    1,
                    self.interactable.id,
                    formatColorToSmallNumber(noCollideColor or dc_def_noCollideColor),
                    formatColorToSmallNumber(terrainColor or dc_def_terrainColor),
                    formatColorToSmallNumber(unitsColor or dc_def_unitsColor)
                )
            else
                self:sv_drawColor(display, noCollideColor, terrainColor, unitsColor)
            end
        end,
        drawDepth = function (display, baseColor, noCollideColor, unitsColor)
            self.lightTick = sm.game.getCurrentTick()
            local backend = sc.componentsBackend[display]
            if self.interactable and backend and needOnClient() then
                pushClientRender(self, display, rawPushID, backend,
                    2,
                    self.interactable.id,
                    formatColor(baseColor or dd_def_baseColor),
                    formatColorToSmallNumber(noCollideColor or dd_def_noCollideColor),
                    formatColor(unitsColor or dd_def_unitsColor)
                )
            else
                self:sv_drawDepth(display, baseColor, noCollideColor, unitsColor)
            end
        end,
        drawCustom = function (display, drawer, ...)
            self.lightTick = sm.game.getCurrentTick()
            self:sv_drawCustom(false, display, drawer, ...)
        end,
        drawAdvanced = function (display, advancedSettings)
            self.lightTick = sm.game.getCurrentTick()
            local backend = sc.componentsBackend[display]
            local newAdvancedSettings
            if type(advancedSettings) == "table" then
                newAdvancedSettings = {}
                for k, v in pairs(defaultCameraSettings) do
                    newAdvancedSettings[k] = v
                end
                for k, v in pairs(advancedSettings) do
                    local ttype = type(v)
                    if ttype == "string" or ttype == "Color" then
                        newAdvancedSettings[k] = formatColorToSmallNumber(v)
                    else
                        newAdvancedSettings[k] = v
                    end
                end
                if advancedSettings.sunPercentage then
                    newAdvancedSettings.sunPercentage = 1 - (advancedSettings.sunPercentage * 2)
                end
            end
            if self.interactable and backend and needOnClient() then
                if newAdvancedSettings then
                    jsonEncodeInputCheck(newAdvancedSettings, 0)
                    pushClientRender(self, display, rawPushID2, backend,
                        self.interactable.id,
                        sm.json.writeJsonString(newAdvancedSettings)
                    )
                else
                    pushClientRender(self, display, rawPushID2, backend,
                        self.interactable.id,
                        not not advancedSettings
                    )
                end
            else
                if not newAdvancedSettings then
                    if advancedSettings then
                        newAdvancedSettings = fastCameraSettings
                    else
                        newAdvancedSettings = defaultCameraSettings
                    end
                end
                self:sv_drawAdvanced(display, newAdvancedSettings)
            end
        end,
        drawOverlay = function(display, mainDrawFunction, mainArgs, overlayDrawer, overlayArgs)
            --[[
            checkDisplayRes(display)
            self.lightTick = sm.game.getCurrentTick()
            mainDrawFunction(display, unpack(mainArgs))
            local backend = sc.componentsBackend[display]
            if self.interactable and backend and needOnClient() then
                pushClientHostcall(self, display, backend, function (stack, stackIndex, rSizeX, rSizeY)
                    self:sv_drawCustom(true, function(x, y, color)
                        rc_insert(stack, 16)
                        rc_insert(stack, x + (y * rSizeX))
                        rc_insert(stack, formatColorToSmallNumber(color))
                    end, display, overlayDrawer, unpack(overlayArgs))
                end)
            else
                self:sv_drawCustom(true, nil, display, overlayDrawer, unpack(overlayArgs))
            end
            ]]

            self.lightTick = sm.game.getCurrentTick()

            local serverSideRenderHook = {
                getWidth = function()
                    return display.getWidth()
                end,
                getHeight = function()
                    return display.getHeight()
                end,
                drawPixel = function(...)
                    return display.drawPixel(...)
                end
            }

            mainDrawFunction(serverSideRenderHook, unpack(mainArgs))
            self:sv_drawCustom(true, serverSideRenderHook, overlayDrawer, unpack(overlayArgs))
        end,
        rawRay = function (x, y, maxdist)
            self.lightTick = sm.game.getCurrentTick()
            return self:rawRay(x, y, maxdist)
        end,
        getSkyColor = function (constDayLightValue)
            return self:getSkyColor({constDayLightValue = constDayLightValue})
        end,
        getDayLightValue = function()
            return self.time or 0
        end,
        getGlobalSunMul = function(constDayLightValue)
            return getGlobalSunMul(self, {constDayLightValue = constDayLightValue})
        end,
        
        setStep = function (step)
            if type(step) == "number" and step % 1 == 0 and step > 0 and step <= 4096 then
                self.step = step
            else
                error("integer must be in [1; 4096]")
            end
        end,
        getStep = function () return self.step end,
        setDistance = function (dist) 
            if type(dist) == "number" and dist >= 0 then
                if self.distance > 2048 then
                    self.distance = 2048
                end
                self.distance = dist
            else
                error("number must be (0; 2048)")
            end
        end,
        getDistance = function () return self.distance end,
        setFov = function (fov)
            checkArg(1, fov, "number")
            api.setNonSquareFov(fov, fov)
        end,
        setNonSquareFov = function(fovX, fovY)
            checkArg(1, fovX, "number")
            checkArg(2, fovY, "number")
            if fovX < rad_1 then
                fovX = rad_1
            elseif fovX > rad_165 then
                fovX = rad_165
            end
            if fovY < rad_1 then
                fovY = rad_1
            elseif fovY > rad_165 then
                fovY = rad_165
            end

            self.fovX = fovX
            self.fovY = fovY

            if fovX ~= self.netdata.fovX or fovY ~= self.netdata.fovY then
                self.netdata.fovX = fovX
                self.netdata.fovY = fovY
                self.netdataSend = true
            end
        end,
        getFov = function () return math.max(self.fovX, self.fovY) end,
        getFovX = function () return self.fovX end,
        getFovY = function () return self.fovY end,
        setNextPixel = function (nextPixel)
            checkArg(1, nextPixel, "number")
            self.nextPixel = nextPixel
        end,
        getNextPixel = function () return self.nextPixel end,
        resetCounter = function () self.nextPixel = 0 end,

        resetDetectableObjects = function()
            api.setDetectableObjects({
                liquids = true,
                dynamicBody = true,
                staticBody = true,
                characters = true,
                joints = true,
                terrain = true,
                assets = true,
                harvestable = true
            })
        end,
        setDetectableObjects = function(detectable)
            checkArg(1, detectable, "table")
            _detectable = detectable
            self.netdata.ray_mask = 0
            if detectable.liquids then
                self.netdata.ray_mask = self.netdata.ray_mask + sm.physics.filter.areaTrigger
            end
            if detectable.dynamicBody then
                self.netdata.ray_mask = self.netdata.ray_mask + sm.physics.filter.dynamicBody
            end
            if detectable.staticBody then
                self.netdata.ray_mask = self.netdata.ray_mask + sm.physics.filter.staticBody
            end
            if detectable.characters then
                self.netdata.ray_mask = self.netdata.ray_mask + sm.physics.filter.character
            end
            if detectable.joints then
                self.netdata.ray_mask = self.netdata.ray_mask + sm.physics.filter.joints
            end
            if detectable.terrain then
                self.netdata.ray_mask = self.netdata.ray_mask + sm.physics.filter.terrainSurface
            end
            if detectable.assets then
                self.netdata.ray_mask = self.netdata.ray_mask + sm.physics.filter.terrainAsset
            end
            if detectable.harvestable then
                self.netdata.ray_mask = self.netdata.ray_mask + sm.physics.filter.harvestable
            end
            if self.netdata.ray_mask ~= self._ray_mask then
                self.netdataSend = true
                self._ray_mask = self.netdata.ray_mask
            end
        end,
        getDetectableObjects = function()
            return _detectable
        end
    }

    --[[
    local drawAdvanced = api.drawAdvanced
    function api.drawAdvanced(...)
        return freezeDetector("drawAdvanced", drawAdvanced, ...) 
    end
    ]]

    self.netdata = self.netdata or {}
    self.netdata.currentRotation = 0
    self.netdata.fovX = rad_60
    self.netdata.fovY = rad_60
    self.netdataSend = true

    function api.setImageRotation(currentRotation)
        checkArg(1, currentRotation, "number")
        if self.netdata.currentRotation ~= currentRotation then
            self.netdata.currentRotation = currentRotation
            self.netdataSend = true
        end
    end

    function api.getImageRotation()
        return self.netdata.currentRotation
    end

    if (self.data and self.data.minimap) or forceMinimap then
        self.netdata.currentHeight = 100
        self.netdata.isometricRender = false
        self.netdata.rotateSync = true
        self.netdata.worldMode = true
        self.netdata.isometricSizeX = 1
        self.netdata.isometricSizeY = 1
        self.netdata.offsetX = 0
        self.netdata.offsetY = 0

        function api.setMinimapHeight(currentHeight)
            checkArg(1, currentHeight, "number")
            if self.netdata.currentHeight ~= currentHeight then
                self.netdata.currentHeight = currentHeight
                self.netdataSend = true
            end
        end

        function api.getMinimapHeight()
            return self.netdata.currentHeight
        end

        function api.setMinimapRotation(currentRotation, rotateSync)
            checkArg(1, currentRotation, "number")
            api.setImageRotation(currentRotation)
            rotateSync = not not rotateSync
            if self.netdata.rotateSync ~= rotateSync then
                self.netdata.rotateSync = rotateSync
                self.netdataSend = true
            end
        end

        function api.getMinimapRotation()
            return self.netdata.currentRotation, self.netdata.rotateSync
        end

        function api.setIsometricRender(isometricRender)
            checkArg(1, isometricRender, "boolean")
            if self.netdata.isometricRender ~= isometricRender then
                self.netdata.isometricRender = isometricRender
                self.netdataSend = true
            end
        end

        function api.isIsometricRender()
            return self.netdata.isometricRender
        end

        function api.setIsometricSize(isometricSizeX, isometricSizeY)
            checkArg(1, isometricSizeX, "number")
            checkArg(2, isometricSizeY, "number")
            if self.netdata.isometricSizeX ~= isometricSizeX or self.netdata.isometricSizeY ~= isometricSizeY then
                self.netdata.isometricSizeX = isometricSizeX
                self.netdata.isometricSizeY = isometricSizeY
                self.netdataSend = true
            end
        end

        function api.getIsometricSize()
            return self.netdata.isometricSizeX, self.netdata.isometricSizeY
        end

        function api.setMinimapOffset(offsetX, offsetY)
            checkArg(1, offsetX, "number")
            checkArg(2, offsetY, "number")
            if self.netdata.offsetX ~= offsetX or self.netdata.offsetY ~= offsetY then
                self.netdata.offsetX = offsetX
                self.netdata.offsetY = offsetY
                self.netdataSend = true
            end
        end

        function api.getMinimapOffset()
            return self.netdata.offsetX, self.netdata.offsetY
        end

        function api.getWaypoints(width, height)
            checkArg(1, width, "number")
            checkArg(2, height, "number")
            return self:sv_getWaypoints(width, height)
        end

        function api.drawWaypoints(display, drawer)
            self:sv_drawWaypoints(display, self:sv_getWaypoints(display.getWidth(), display.getHeight()), drawer)
        end

        function api.getRealRotation()
            return getCurrentRotation(self)
        end

        function api.setWorldMode(worldMode)
            checkArg(1, worldMode, "boolean")
            if self.netdata.worldMode ~= worldMode then
                self.netdata.worldMode = worldMode
                self.netdataSend = true
            end
        end

        function api.isWorldMode()
            return self.netdata.worldMode
        end
    end

    api.resetDetectableObjects()

    return api
end

local function rotateVector(x, y, angle)
    local x_new = x * math.cos(angle) - y * math.sin(angle)
    local y_new = x * math.sin(angle) + y * math.cos(angle)
    return x_new, y_new
end

local function calculateCaptureArea(fovRadians, height)
    local halfFOV = fovRadians / 2
    return height * math.tan(halfFOV)
end

function RaycastCamera:sv_getWaypoints(width, height)
    if not sc.minimap_waypoints then return {} end
    
    local offsetX, offsetY, resolutionX, resolutionY = getViewportWH(self, width, height)
    local waypoints = {}
    for id, shape in pairs(sc.minimap_waypoints) do
        local fovX, fovY
        if self.netdata.isometricRender then
            fovX = self.netdata.isometricSizeX / 2
            fovY = self.netdata.isometricSizeY / 2
        else
            local height = self.netdata.currentHeight - self.shape.worldPosition.z
            fovX = calculateCaptureArea(self.netdata.fovX, height)
            fovY = calculateCaptureArea(self.netdata.fovY, height)
        end
        local posdiff = shape.worldPosition - self.shape.worldPosition
        local posX = (posdiff.x - self.netdata.offsetX) / fovX
        local posY = (posdiff.y - self.netdata.offsetY) / fovY

        posX, posY = rotateVector(posX, posY, getCurrentRotation(self) + (math.pi / 2))
        posY = -posY
        posX = (posX + 1) / 2
        posY = (posY + 1) / 2

        if posX >= 0 and posX <= 1 and posY >= 0 and posY <= 1 then
            rc_insert(waypoints, {offsetX + mathRound(posX * (resolutionX - 1)), offsetY + mathRound(posY * (resolutionY - 1)), shape.color})
        end
        sc.yield()
    end
    return waypoints
end

local function defaultWaypointDrawer(display, waypoint)
    local circleSize = math.min(display.getSize()) / 32
    if circleSize < 3 then circleSize = 3 end
    display.fillCircle(waypoint[1], waypoint[2], circleSize, waypoint[3])
end

function RaycastCamera:sv_drawWaypoints(display, waypoints, drawer)
    drawer = drawer or defaultWaypointDrawer
    for _, waypoint in ipairs(waypoints) do
        drawer(display, waypoint)
        sc.yield()
    end
end

function RaycastCamera:position()
    if self.data and self.data.minimap then
        local pos = self.shape.worldPosition
        if self.netdata.worldMode then
            pos = sm.vec3.zero()
        end
        pos.x = pos.x + self.netdata.offsetX
        pos.y = pos.y + self.netdata.offsetY
        pos.z = self.netdata.currentHeight
        --print(self.netdata.offsetX, self.netdata.offsetY, pos)
        return pos
    end
    return self.shape.worldPosition
end

local function rotate_quaternion(q, angle, axis)
    local length = math.sqrt(axis.x^2 + axis.y^2 + axis.z^2)
    local u_x, u_y, u_z = axis.x / length, axis.y / length, axis.z / length
    
    local q_rotation = sm.quat.new(
        math.sin(angle / 2) * u_x,
        math.sin(angle / 2) * u_y,
        math.sin(angle / 2) * u_z,
        math.cos(angle / 2)
    )
    
    return q_rotation * q
end

local downQuat = sm.quat.new(0.707107, 0.707107, 0, 0)
function RaycastCamera:rotation()
    local rotation

    if self.data and self.data.minimap then
        rotation = downQuat
    else
        rotation = self.shape.worldRotation
    end
    
    return rotate_quaternion(rotation, getCurrentRotation(self), rotation * vec3_new(0, 0, 1))
end

function RaycastCamera:calcStartPosition()
    local shape = self.shape
    local position = self:position()
    local rotation = self:rotation()

    if self.data and self.data.minimap then
        return position
    end

    local direction = rotation * vec3_new(0, 0, 1)
    local startPosition = position + direction * 0.25
    if sm.physics.raycast(position, startPosition) then
        startPosition = position
    end
    return startPosition
end

local downDirection = vec3_new(0, 0, -1)
function RaycastCamera:rays(resolutionX, resolutionY, currentPixel, stepM, distance, fovX, fovY, downscale)
    if downscale ~= self.raysCache.downscale or
        fovX ~= self.raysCache.fovX or
        fovY ~= self.raysCache.fovY or
        resolutionX ~= self.raysCache.resolutionX or
        resolutionY ~= self.raysCache.resolutionY or
        stepM ~= self.raysCache.stepM or
        self.netdata.isometricRender ~= self.raysCache.isometricRender or
        self.netdata.isometricSizeX ~= self.raysCache.isometricSizeX or
        self.netdata.isometricSizeY ~= self.raysCache.isometricSizeY or
        self.netdata.ray_mask ~= self.raysCache.ray_mask or
        distance ~= self.raysCache.distance then
        self.raysCache = {}
        self.raysCache.downscale = downscale
        self.raysCache.fovX = fovX
        self.raysCache.fovY = fovY
        self.raysCache.resolutionX = resolutionX
        self.raysCache.resolutionY = resolutionY
        self.raysCache.stepM = stepM
        self.raysCache.distance = distance
        self.raysCache.isometricRender = self.netdata.isometricRender
        self.raysCache.isometricSizeX = self.netdata.isometricSizeX
        self.raysCache.isometricSizeY = self.netdata.isometricSizeY
        self.raysCache.ray_mask = self.netdata.ray_mask
    end

    if self.raysCache[currentPixel] then
        --print("FROM CACHE", currentPixel)
        return rc_multicast(self.raysCache[currentPixel])
    end

    local rays = {}
    if self.netdata.isometricRender then
        local shape = self.shape
        local position = self:position()
        local rotation = rotate_quaternion(downQuat, getCurrentRotation(self) + (math.pi / 2), downQuat * vec3_new(0, 0, 1))
        local startPosition = self:calcStartPosition()

        for i = 0, stepM do
            local pixel = currentPixel + i
            local x = floor(pixel / resolutionY) % resolutionX
            local y = pixel % resolutionY

            local vec = rotation * vec3_new(
                ((resolutionY - 1 - y) / resolutionY - 0.5) * self.netdata.isometricSizeY,
                (x / resolutionX - 0.5) * self.netdata.isometricSizeX,
                0
            )

            rays[i] = {
                type = "ray",
                startPoint = startPosition + vec,
                endPoint = startPosition + vec + downDirection * distance,
                mask = self.netdata.ray_mask
            }
        end
    else
        local shape = self.shape
        local position = self:position()
        local rotation = self:rotation()

        local startPosition = self:calcStartPosition()
        local vec = vec3_new(0, 0, 1)

        for i = 0, stepM do
            local pixel = currentPixel + i
            local x = floor(pixel / resolutionY) % resolutionX
            local y = pixel % resolutionY

            local u = ( x / resolutionX - 0.5 ) * fovX
            local v = ( y / resolutionY - 0.5 ) * fovY

            vec.x = -u
            vec.y = -v
            local direction = rotation * vec

            rays[i] = {
                type = "ray",
                startPoint = startPosition,
                endPoint = position + direction * distance,
                mask = self.netdata.ray_mask
            }
        end
    end

    self.raysCache[currentPixel] = rays
    return rc_multicast(rays)
end

function RaycastCamera:sunRays(resolutionX, resolutionY, currentPixel, distance, results, advancedSettings)
    local shape = self.shape
    local position = self:position()
    local rotation = self:rotation()
    local sunDir = self:getSunDirection(advancedSettings)
    if not sunDir then return end

    local rays = {}
    local raysI = 1
    local out = {}

    local result
    local vecdat
    local startFrom
    for i = 1, #results do
        result = results[i]
        vecdat = result[2]
        if result[1] and vecdat.type ~= "limiter" then
            startFrom = vecdat.pointWorld - (cNormalize(vecdat.pointWorld - vecdat.originWorld) / 32)
            rays[raysI] = {
                type = "ray",
                startPoint = startFrom,
                endPoint = startFrom + (sunDir * distance),
                mask = self.netdata.ray_mask
            }
            out[i] = raysI
            raysI = raysI + 1
        end
    end

    local sunRays = {}
    local rayResult = rc_multicast(rays)
    for i, rayIndex in pairs(out) do
        sunRays[i] = rayResult[rayIndex]
    end
    return sunRays
end

local lampsStatesCache = {}
function RaycastCamera:getLampsData(distance)
    local lampsdata
    for _, shape in ipairs(sm.shape.shapesInSphere(self:position(), distance)) do
        if shape.interactable then
            local cacheState = lampsStatesCache[shape.interactable.id]
            local ctick = sm.game.getCurrentTick()
            if not cacheState or ctick - cacheState[2] > 20 then
                local parents = shape.interactable:getParents()
                local active = #parents == 0
                if not active then
                    for _, parent in ipairs(parents) do
                        if parent.active then
                            active = true
                            break
                        end
                    end
                end
                cacheState = {active, ctick}
                lampsStatesCache[shape.interactable.id] = cacheState
            end
            if cacheState[1] then
                local lampInfo = lamps[tostring(shape.uuid)]
                if lampInfo then
                    lampsdata = lampsdata or {}
                    rc_insert(lampsdata, {shape, lampInfo})
                end
            end
        end
    end
    return lampsdata
end

function RaycastCamera:getSkyState(advancedSettings)
    local time = advancedSettings.constDayLightValue or self.time or 0
    local index = floor(map(time, 0, 1, 1, #skyStates))
    local skyState = skyStates[index] or skyStates[1]
    if not skyState.colorNumber then
        skyState.colorNumber = formatColorToSmallNumber(skyState.color)
    end
    return skyState
end


function RaycastCamera:getSkyColor(advancedSettings)
    return self:getSkyState(advancedSettings).color
end

function RaycastCamera:getSunDirection(advancedSettings)
    return self:getSkyState(advancedSettings).dir
end

function RaycastCamera:getRaydata(successful, raydata, maxdist)
    if not successful then return end

    local rtype = raydata.type
    if rtype == "limiter" then
        return {
            fraction = raydata.fraction,
            distance = raydata.fraction * maxdist,
            type = "limiter"
        }
    elseif rtype == "terrainAsset" then
        return {
            fraction = raydata.fraction,
            distance = raydata.fraction * maxdist,
            normalWorld = raydata.normalWorld,
            color = cached_getGroundColor(raydata.pointWorld, assetMaterialColors, assetsCache) or assetColor,
            type = "asset"
        }
    elseif rtype == "body" then
        local shape = raydata:getShape()
        local tbl =  {
            color = shape.color,
            fraction = raydata.fraction,
            normalWorld = raydata.normalWorld,
            distance = raydata.fraction * maxdist,
            type = "shape"
        }

        if raydata.fraction * maxdist <= 4 then
            tbl.uuid = shape.uuid
        end

        return tbl
    elseif rtype == "character" then
        local character = raydata:getCharacter()
        return {
            color = character.color,
            fraction = raydata.fraction,
            normalWorld = raydata.normalWorld,
            distance = raydata.fraction * maxdist,
            type = "character"
        }
    elseif rtype == "harvestable" then
        local harvestable = raydata:getHarvestable()
        return {
            color = harvestable:getColor(),
            fraction = raydata.fraction,
            normalWorld = raydata.normalWorld,
            distance = raydata.fraction * maxdist,
            type = "harvestable"
        }
    elseif rtype == "lift" then
        local lift = raydata:getLiftData()
        return {
            color = liftColor,
            fraction = raydata.fraction,
            normalWorld = raydata.normalWorld,
            distance = raydata.fraction * maxdist,
            type = "lift"
        }
    elseif rtype == "joint" then
        local joint = raydata:getJoint()
        return {
            color = joint.color,
            fraction = raydata.fraction,
            normalWorld = raydata.normalWorld,
            distance = raydata.fraction * maxdist,
            type = "joint"
        }
    else
        if rtype == "areaTrigger" then
            local triggerData = raydata:getAreaTrigger():getUserData()
            if triggerData then
                if triggerData.water then
                    return {
                        fraction = raydata.fraction,
                        distance = raydata.fraction * maxdist,
                        normalWorld = raydata.normalWorld,
                        color = waterColor,
                        type = "liquid"
                    }
                elseif triggerData.chemical then
                    return {
                        fraction = raydata.fraction,
                        distance = raydata.fraction * maxdist,
                        normalWorld = raydata.normalWorld,
                        color = chemicalColor,
                        type = "liquid"
                    }
                elseif triggerData.oil then
                    return {
                        fraction = raydata.fraction,
                        distance = raydata.fraction * maxdist,
                        normalWorld = raydata.normalWorld,
                        color = oilColor,
                        type = "liquid"
                    }
                end
            end
        end

        return {
            fraction = raydata.fraction,
            distance = raydata.fraction * maxdist,
            normalWorld = raydata.normalWorld,
            color = cached_getGroundColor(raydata.pointWorld) or defaultRayColor,
            type = "terrain"
        }
    end
end

function RaycastCamera:rawRay(xAngle, yAngle, maxdist)
    local position = self:position()
    local rotation = self:rotation()

    if xAngle < -rad_82_5 then
        xAngle = -rad_82_5
    elseif xAngle > rad_82_5 then
        xAngle = rad_82_5
    end

    if yAngle < -rad_82_5 then
        yAngle = -rad_82_5
    elseif yAngle > rad_82_5 then
        yAngle = rad_82_5
    end

    local successful, raydata = rc_raycast(position, position + (rotation * vec3_new(-xAngle, -yAngle, 1)) * maxdist)
    return self:getRaydata(successful, raydata, maxdist)
end

function RaycastCamera:sv_drawAdvanced(displayData, advancedSettings)
    preprocessAdvancedSettings(self, advancedSettings)

    --return self:sv_drawCustom(displayData, drawAdvanced, self:getSkyColor(), displayData.getWidth(), self.time, self:getLampsData(), self:getSkyState())
    local offsetX, offsetY, resolutionX, resolutionY = getViewport(self, displayData)
    local downscale = self.downscale
    local step
    resolutionX, resolutionY, step = downscaleResolution(resolutionX, resolutionY, self.step, downscale)
    checkNextPixel(self, resolutionX, resolutionY)

    local currentPixel = self.nextPixel
    local results = self:rays(resolutionX, resolutionY, currentPixel, step - 1, self.distance, self.fovX, self.fovY, downscale)
    local skyState = self:getSkyState(advancedSettings)
    local globalSunMul = getGlobalSunMul(self, advancedSettings)

    local sunRays, lampsData
    if advancedSettings.shadows then
        sunRays = self:sunRays(resolutionX, resolutionY, currentPixel, self.distance, results, advancedSettings)
    end
    if advancedSettings.lampLighting then
        lampsData = self:getLampsData(self.distance)
    end
    
    for i = 0, step - 1 do
        local res = results[i+1]
        local sunres = sunRays and sunRays[i+1]
        local pixel = currentPixel + i

        local x = floor(pixel / resolutionY) % resolutionX
        local y = pixel % resolutionY
        cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, formatColorStr(drawAdvanced(self, x, y, res, skyState, lampsData, sunres, advancedSettings, globalSunMul, self.distance)))
    end

    self:saveLastInfo(results)
    self.nextPixel = (currentPixel + step) % (resolutionX * resolutionY)
end

function RaycastCamera:sv_drawCustom(fromLastInfo, displayData, drawer, ...)
    local offsetX, offsetY, resolutionX, resolutionY = getViewport(self, displayData)
    local downscale = self.downscale
    local step
    resolutionX, resolutionY, step = downscaleResolution(resolutionX, resolutionY, self.step, downscale)

    if not fromLastInfo then
        checkNextPixel(self, resolutionX, resolutionY)
    end

    local currentPixel, results
    if fromLastInfo then
        local lastInfo = self:getLastInfo()
        if not lastInfo then return end

        currentPixel = lastInfo.position
        results = lastInfo.rays
    else
        currentPixel = self.nextPixel
        results = self:rays(resolutionX, resolutionY, currentPixel, step - 1, self.distance, self.fovX, self.fovY, downscale)
    end

    if displayData.noCameraEncode then
        for i = 0, step - 1 do
            local res = results[i+1]
            local pixel = currentPixel + i
    
            local x = floor(pixel / resolutionY) % resolutionX
            local y = pixel % resolutionY
            local color = drawer(x, y, self:getRaydata(res and res[1], res and res[2], self.distance), ...)
            if color then
                cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, color)
            end
        end
    else
        for i = 0, step - 1 do
            local res = results[i+1]
            local pixel = currentPixel + i
    
            local x = floor(pixel / resolutionY) % resolutionX
            local y = pixel % resolutionY
            local color = drawer(x, y, self:getRaydata(res and res[1], res and res[2], self.distance), ...)
            if color then
                cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, formatColorStr(color, true))
            end
        end
    end

    if not fromLastInfo then
        self:saveLastInfo(results)
        self.nextPixel = (currentPixel + step) % (resolutionX * resolutionY)
    end
end

function RaycastCamera:saveLastInfo(rays)
    self.sv_lastInfo = {
        rays = rays,
        position = self.nextPixel,
        tick = sm.game.getCurrentTick()
    }
end

function RaycastCamera:cl_saveLastInfo(rays, nextPixel)
    self.cl_lastInfo = {
        rays = rays,
        position = nextPixel,
        tick = sm.game.getCurrentTick()
    }
end

function RaycastCamera:getLastInfo()
    if self.sv_lastInfo and self.cl_lastInfo then
        if self.cl_lastInfo.tick > self.sv_lastInfo.tick then
            return self.cl_lastInfo
        end
        return self.sv_lastInfo
    end

    return self.cl_lastInfo or self.sv_lastInfo
end

function RaycastCamera:sv_drawColorWithDepth(displayData, noCollideColor, terrainColor, unitsColor)
    local offsetX, offsetY, resolutionX, resolutionY = getViewport(self, displayData)
    local downscale = self.downscale
    local step
    resolutionX, resolutionY, step = downscaleResolution(resolutionX, resolutionY, self.step, downscale)
    checkNextPixel(self, resolutionX, resolutionY)

    local currentPixel = self.nextPixel
    local results = self:rays(resolutionX, resolutionY, currentPixel, step - 1, self.distance, self.fovX, self.fovY, downscale)

    terrainColor = formatColor(terrainColor or dcwf_def_terrainColor)
    unitsColor = formatColor(unitsColor or dcwf_def_unitsColor)
    
    if displayData.noCameraEncode then
        noCollideColor = formatColor(noCollideColor or dcwf_def_noCollideColor)
        
        for i = 0, step - 1 do
            local res = results[i+1]
            local pixel = currentPixel + i

            local x = floor(pixel / resolutionY) % resolutionX
            local y = pixel % resolutionY
            if res and res[1] then
                local data = res[2]
                local shape = data:getShape()
                local character = data:getCharacter()
                if character then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, unitsColor * (1 - data.fraction))
                elseif shape then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, shape.color * (1 - data.fraction))
                elseif data.type ~= "limiter" then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, terrainColor * (1 - data.fraction))
                else
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, noCollideColor)
                end
            else
                cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, noCollideColor)
            end
        end
    else
        noCollideColor = formatColorStr(noCollideColor or dcwf_def_noCollideColor)
        
        for i = 0, step - 1 do
            local res = results[i+1]
            local pixel = currentPixel + i

            local x = floor(pixel / resolutionY) % resolutionX
            local y = pixel % resolutionY
            if res and res[1] then
                local data = res[2]
                local shape = data:getShape()
                local character = data:getCharacter()
                if character then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, tostring(unitsColor * (1 - data.fraction)))
                elseif shape then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, tostring(shape.color * (1 - data.fraction)))
                elseif data.type ~= "limiter" then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, tostring(terrainColor * (1 - data.fraction)))
                else
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, noCollideColor)
                end
            else
                cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, noCollideColor)
            end
        end
    end

    self:saveLastInfo(results)
    self.nextPixel = (currentPixel + step) % (resolutionX * resolutionY)
end

function RaycastCamera:sv_drawDepth(displayData, baseColor, noCollideColor, unitsColor)
    local offsetX, offsetY, resolutionX, resolutionY = getViewport(self, displayData)
    local downscale = self.downscale
    local step
    resolutionX, resolutionY, step = downscaleResolution(resolutionX, resolutionY, self.step, downscale)
    checkNextPixel(self, resolutionX, resolutionY)

    local currentPixel = self.nextPixel
    local results = self:rays(resolutionX, resolutionY, currentPixel, step - 1, self.distance, self.fovX, self.fovY, downscale)

    unitsColor = formatColor(unitsColor or dd_def_unitsColor)
    baseColor = formatColor(baseColor or dd_def_baseColor)

    if displayData.noCameraEncode then
        noCollideColor = formatColor(noCollideColor or dd_def_noCollideColor)

        for i = 0, step - 1 do
            local res = results[i+1]
            local pixel = currentPixel + i

            local x = floor(pixel / resolutionY) % resolutionX
            local y = pixel % resolutionY
            if res and res[1] then
                local data = res[2]
                local character = data:getCharacter()
                if character then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, unitsColor * (1 - data.fraction))
                elseif data.type ~= "limiter" then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, baseColor * (1 - data.fraction))
                else
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, noCollideColor)
                end
            else
                cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, noCollideColor)
            end
        end
    else
        noCollideColor = formatColorStr(noCollideColor or dd_def_noCollideColor)

        for i = 0, step - 1 do
            local res = results[i+1]
            local pixel = currentPixel + i

            local x = floor(pixel / resolutionY) % resolutionX
            local y = pixel % resolutionY
            if res and res[1] then
                local data = res[2]
                local character = data:getCharacter()
                if character then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, tostring(unitsColor * (1 - data.fraction)))
                elseif data.type ~= "limiter" then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, tostring(baseColor * (1 - data.fraction)))
                else
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, noCollideColor)
                end
            else
                cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, noCollideColor)
            end
        end
    end

    self:saveLastInfo(results)
    self.nextPixel = (currentPixel + step) % (resolutionX * resolutionY)
end

function RaycastCamera:sv_drawColor(displayData, noCollideColor, terrainColor, unitsColor)
    local offsetX, offsetY, resolutionX, resolutionY = getViewport(self, displayData)
    local downscale = self.downscale
    local step
    resolutionX, resolutionY, step = downscaleResolution(resolutionX, resolutionY, self.step, downscale)
    checkNextPixel(self, resolutionX, resolutionY)

    local currentPixel = self.nextPixel
    local results = self:rays(resolutionX, resolutionY, currentPixel, step - 1, self.distance, self.fovX, self.fovY, downscale)

    if displayData.noCameraEncode then
        noCollideColor = formatColor(noCollideColor or dc_def_noCollideColor)
        terrainColor = formatColor(terrainColor or dc_def_terrainColor)
        unitsColor = formatColor(unitsColor or dc_def_unitsColor)

        for i = 0, step - 1 do
            local res = results[i+1]
            local pixel = currentPixel + i

            local x = floor(pixel / resolutionY) % resolutionX
            local y = pixel % resolutionY
            if res and res[1] then
                local data = res[2]
                local shape = data:getShape()
                local character = data:getCharacter()
                if character then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, unitsColor)
                elseif shape then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, shape.color)
                elseif data.type ~= "limiter" then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, terrainColor)
                else
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, noCollideColor)
                end
            else
                cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, noCollideColor)
            end
        end
    else
        noCollideColor = formatColorStr(noCollideColor or dc_def_noCollideColor)
        terrainColor = formatColorStr(terrainColor or dc_def_terrainColor)
        unitsColor = formatColorStr(unitsColor or dc_def_unitsColor)

        for i = 0, step - 1 do
            local res = results[i+1]
            local pixel = currentPixel + i

            local x = floor(pixel / resolutionY) % resolutionX
            local y = pixel % resolutionY
            if res and res[1] then
                local data = res[2]
                local shape = data:getShape()
                local character = data:getCharacter()
                if character then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, unitsColor)
                elseif shape then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, tostring(shape.color))
                elseif data.type ~= "limiter" then
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, terrainColor)
                else
                    cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, noCollideColor)
                end
            else
                cDrawPixel(displayData, downscale, offsetX, offsetY, x, y, noCollideColor)
            end
        end
    end

    self:saveLastInfo(results)
    self.nextPixel = (currentPixel + step) % (resolutionX * resolutionY)
end

function RaycastCamera:server_onCreate()
    self.camApi = self:createData()
    if self.interactable then
        local id = self.interactable:getId()
        sc.camerasDatas[id] = self.camApi
        sc.camerasRefs[id] = self
    end

    self.step = 256
    self.nextPixel = 0
    self.distance = 1024
    self.fovX = rad_60
    self.fovY = rad_60
    self.raysCache = {}
end

local function simpleQuatDif(q1, q2)
    return math.abs(q1.x - q2.x) + math.abs(q1.y - q2.y) + math.abs(q1.z - q2.z) + math.abs(q1.w - q2.w)
end

function RaycastCamera:cacheCheck()
    local pos = self:position()
    local rot = self:rotation()

    if self.oldPos then
        if mathDist(self.oldPos, pos) > 0.01 or simpleQuatDif(rot, self.oldRot) > 0.01 then
            self.raysCache = {}
            self.oldPos = pos
            self.oldRot = rot
        end
    else
        self.oldPos = pos
        self.oldRot = rot
    end
end

function RaycastCamera:sv_dataRequest(_, player)
    self.network:sendToClient(player, "cl_netdata", self.netdata)
end

function RaycastCamera:server_onFixedUpdate()
    self:cacheCheck()

    if self.network and self.netdataSend then
        self.network:sendToClients("cl_netdata", self.netdata)
        self.netdataSend = nil
    end

    if self.interactable then
        local ctick = sm.game.getCurrentTick()
        self.interactable:setActive(self.lightTick and (ctick - self.lightTick < 10) or false)
    end
end

function RaycastCamera.server_onDestroy(self)
    local id = self.interactable:getId()
    sc.camerasDatas[id] = nil
    sc.camerasRefs[id] = nil
end


function RaycastCamera:client_onCreate()
    clientCameras[self.interactable.id] = self
    self.time = sm.render.getOutdoorLighting()
    self.raysCache = {}
    self.netdata = self.netdata or {}

    self.network:sendToServer("sv_dataRequest")
end

function RaycastCamera:client_onDestroy()
    clientCameras[self.interactable.id] = nil
end

function RaycastCamera:client_onFixedUpdate()
    --sm.render.setOutdoorLighting(math.sin(math.rad(sm.game.getCurrentTick() / 15)))
    self.time = sm.render.getOutdoorLighting()
    if not sm.isHost then
        self:cacheCheck()
    end

    self.interactable:setPoseWeight(0, self.interactable:isActive() and 1 or 0)
end

function RaycastCamera:cl_netdata(netdata)
    if sm.isHost then return end
    self.netdata = netdata
end
end
function scmframework_c18373937334ad1c4bf12a37adad61f9() --$CONTENT_DATA/Scripts/reboot.lua
dofile("$CONTENT_DATA/Scripts/Config.lua")
reboot = class()
reboot.maxParentCount = -1
reboot.maxChildCount = -1
reboot.connectionInput = sm.interactable.connectionType.seated + sm.interactable.connectionType.composite + sm.interactable.connectionType.logic
reboot.connectionOutput = sm.interactable.connectionType.composite + sm.interactable.connectionType.logic
reboot.colorNormal = sm.color.new("#8a05a6")
reboot.colorHighlight = sm.color.new("#d50bff")

function reboot:server_onFixedUpdate()
    local active = false
    local rebootFlag = false

    for _, parent in ipairs(self.interactable:getParents()) do
        local publicApi = sc.computersDatas[parent.id]
        if publicApi and publicApi.self and publicApi.self.crashstate then
            if publicApi.self.crashstate.hasException then
                active = true
            end
        else
			local _s_uuid = tostring(parent.shape.uuid)
			if (not (parent:hasSteering() or parent:getType() == "steering" or _s_uuid == "ccaa33b6-e5bb-4edc-9329-b40f6efe2c9e" or _s_uuid == "e627986c-b7dd-4365-8fd8-a0f8707af63d")) and parent:isActive() then
				rebootFlag = true
			end
		end
    end

    for _, child in ipairs(self.interactable:getChildren()) do
        local publicApi = sc.computersDatas[child.id]
        if publicApi and publicApi.self and publicApi.self.crashstate and publicApi.self.crashstate.hasException then
            active = true
            break
        end
    end

    if rebootFlag and not self.oldReboot then
        self:sv_reboot()
    end
    self.oldReboot = rebootFlag

    self.interactable:setActive(active)
end

function reboot:sv_reboot(force)
    local blink

    for _, parent in ipairs(self.interactable:getParents()) do
        local publicApi = sc.computersDatas[parent.id]
        if publicApi then
            if force or (publicApi.self and not publicApi.self.storageData.noSoftwareReboot) then
                publicApi.self.reboot_flag = true
                blink = true
            end
        end
    end

    for _, child in ipairs(self.interactable:getChildren()) do
        local publicApi = sc.computersDatas[child.id]
        if publicApi then
            if force or (publicApi.self and not publicApi.self.storageData.noSoftwareReboot) then
                publicApi.self.reboot_flag = true
                blink = true
            end
        end
    end

    if blink then
        self.network:sendToClients("cl_blink")
    end
end

function reboot:sv_n_reboot()
    self:sv_reboot(true)
end



function reboot:client_onFixedUpdate()
    if self.blick then
        self.blick = nil
    else
        if self.interactable:isActive() and sm.game.getCurrentTick() % 60 >= 30 then
            self.interactable:setUvFrameIndex(7)
        else
            self.interactable:setUvFrameIndex(0)
        end
    end
end

function reboot:client_onInteract(_, state)
    if state then
        self.network:sendToServer("sv_n_reboot")
    end
end

function reboot:cl_blink()
    self.interactable:setUvFrameIndex(6)
    self.blick = true
end
end
function scmframework_7fca9278b63067850de91aa97784be11() --$CONTENT_DATA/Scripts/remade-lua-in-lua/lua/fixer.lua
local function randname()
    local funcname =  "__"
    for i = 1, 16 do
        funcname = funcname .. tostring(math.floor(math.random(0, 9)))
    end
    return funcname
end

function ll_fix(code) --тут фикситься несколько багов
    local fmain = randname()
    local farg = randname()

    return fmain .. " = " .. fmain .. " or function(...) " .. code .. "\n end return " .. fmain .. "(" .. farg .. "())", farg
end

function ll_shorterr(err)
    return tostring(err or "unknown error")

    --[[
    local function a(str)
        return str:gsub("%p", "%%%1")
    end
    err = err:gsub(a("...ripts/remade-lua-in-lua/lua"), "ll")
    err = err:gsub(a("remade-lua-in-lua/lua"), "ll")
    err = err:gsub(a("interpreter.lua"), "i")
    err = err:gsub(a("parser.lua"), "p")
    err = err:gsub(a("scanner.lua"), "s")
    return err
    ]]
end
end
function scmframework_9312751cf5dbbcc6e43585f206dc22a2() --$CONTENT_DATA/Scripts/remade-lua-in-lua/lua/interpreter.lua
--в этом говно было дохера фиксов
--теперь оно более мения юзабельно
--и мения баговоное чем scrapVM

ll_Interpreter = {}

ll_Interpreter.interations = 0
ll_Interpreter.MAX_ITERATIONS = math.huge --I have restrictions not on the number of iterations, but on the execution time
ll_Interpreter.internalData = {}

local function tableToString(t)
    if type(t) ~= 'table' then return tostring(t) end
    local s = "{"

    for k, v in pairs(t) do
        s = s .. tostring(k) .. "=" .. tableToString(v) .. ', '
    end

    s = s:sub(1, #s - 2)

    return s .. "}"
end

local fakenil = {} --кастыль фиксяший сьежающие аргументы

ll_Interpreter.evals = {
    ['chunk'] = function(self, node, environment)
        local eval = __eval
        for _, statement in ipairs(node.statements) do
            --self:evaluate(statement, environment)

            local success, r = pcall(eval, self, statement, environment)

            if not success then
                if type(r) == 'table' then
                    if r.type == 'return_error' then return unpack(r.values) end
                    if r.type == 'break_error' then return end
                end
                error(r)
            end
        end
    end,
    ['block'] = function(self, node, environment)
        local eval = __eval
        for _, statement in ipairs(node.statements) do
            eval(self, statement, environment)
        end
    end,
    ['literal'] = function(self, node)
        return node.value
    end,
    ['assign'] = function(self, node, environment)
        local globals = self:getGlobal(environment)
        if not ll_Interpreter.internalData[globals[node.name]] then --а нехер перезаписывать __internal_yield, крашеры ебаные
            globals[node.name] = self:evaluate(node.value, environment) --Я ЭТУ ХУЙНЮ ЕЛЕ ФИКСАНУЛ!!! ТУТ ВМЕСТО environment ТУДА globals ХАУЯИЛИ
            --ИЗ ИЗ ЗА ЭТОГО ПИЗДЕЦА ВСЕ НЕ ЛЯМБДЫ НЕ ИМЕЛИ ДОСТУПА К ЛОКАЛЬНЫМ ПЕМЕННЫМ ОБЬВЛЕНЫМ ВЫЩЕ
        else
            error("failed to rewrite a mod-protected function", 2)
        end
    end,
    ['function'] = function(self, node, environment)
        return function(...)
            local func_env = self:encloseEnvironment(environment)
            local insert = table.insert

            for _, arg in ipairs(node.arg_names) do
                self:declareInEnv(func_env, arg)
            end

            local args = { ... }

            for i = 1, math.huge do
                if not node.arg_names[i] then break end
                func_env[node.arg_names[i]] = args[i] or fakenil
            end

            local varargs = {}
            if node.varargs then
                local new_args = {}
                local arg_l = #args
                local node_arg_l = #node.arg_names

                if arg_l > node_arg_l then
                    for i = node_arg_l + 1, arg_l do
                        local a = args[i]
                        insert(varargs, a)
                        insert(new_args, a)
                    end
                end
                func_env.arg = new_args
            end
            self:setEnvMeta(func_env, "varargs", varargs)

            return self:evaluate(node.body, func_env)
        end
    end,
    ["declare_local"] = function(self, node, environment)
        local values = self:evaluateExpressionList(node.values, environment)
        local decl = self.declareInEnv

        for _, var_name in ipairs(node.names) do
            decl(self, environment, var_name)
        end

        for i = 1, #node.names do
            local var_name = node.names[i]
            local value = values[i]

            if not ll_Interpreter.internalData[environment[var_name]] then --а нехер перезаписывать __internal_yield, крашеры ебаные
                environment[var_name] = value
            else
                error("failed to rewrite a mod-protected function", 2)
            end
        end
    end,
    ["assign_expr"] = function(self, node, environment)
        local values = self:evaluateExpressionList(node.values, environment)
        local eval = __eval
        local set = self.setInEnv

        for i = 1, #node.exprs do
            local target = node.exprs[i]
            local value = values[i]
            if target.type == "variable" then
                if not ll_Interpreter.internalData[environment[target.name]] then --а нехер перезаписывать __internal_yield, крашеры ебаные
                    set(self, environment, target.name, value)
                else
                    error("failed to rewrite a mod-protected function", 2)
                end
            else -- otherwise it's a get from table
                local table_value = eval(self, target.from, environment)
                local index = eval(self, target.index, environment)

                if not ll_Interpreter.internalData[table_value[index]] then --а нехер перезаписывать __internal_yield, крашеры ебаные
                    table_value[index] = value
                else
                    error("failed to rewrite a mod-protected function", 2)
                end
            end
        end
    end,
    ["get"] = function(self, node, environment)
        local eval = __eval

        local from = eval(self, node.from, environment)
        local index = eval(self, node.index, environment)

        return from[index]
    end,
    ["set"] = function(self, node, environment)
        local eval = __eval

        local in_value = eval(self, node.in_value, environment)
        local value = eval(self, node.value, environment)
        local index = eval(self, node.index, environment)

        if not ll_Interpreter.internalData[in_value[index]] then --а нехер перезаписывать __internal_yield, крашеры ебаные
            in_value[index] = value
        else
            error("failed to rewrite a mod-protected function", 2)
        end
    end,
    ["call"] = function(self, node, environment)
        local eval = __eval

        local callee = eval(self, node.callee, environment)
        local args = {}
        --local insert = table.insert

        for i, arg_node in ipairs(node.args) do --фиксанутые аргументы
            local values = { eval(self, arg_node, environment) }
            for i2, value in ipairs(values) do
                local pos = i + (i2 - 1)
                args[pos] = value
                for i3 = pos + 1, math.huge do
                    if not args[i3] then break end
                    args[i3] = nil
                end
            end
            --args[#args+1] = self:evaluate(arg_node, environment)
        end

        return callee(unpack(args))
    end,
    ["get_call"] = function(self, node, environment)
        local eval = __eval

        local callee = eval(self, node.callee, environment)
        local args = {}
        --local insert = table.insert

        for i, arg_node in ipairs(node.args) do --фиксанутые аргументы
            local values = { eval(self, arg_node, environment) }
            for i2, value in ipairs(values) do
                local pos = i + (i2 - 1)
                args[pos] = value
                for i3 = pos + 1, math.huge do
                    if not args[i3] then break end
                    args[i3] = nil
                end
            end
            --args[#args+1] = self:evaluate(arg_node, environment)
        end

        return callee[node.index](callee, unpack(args))
    end,
    ["variable"] = function(self, node, environment)
        return self:getFromEnv(environment, node.name)
    end,
    ["table"] = function(self, node, environment)
        local eval = __eval

        local tbl = {}
        local insert = table.insert

        local array_idx = 1
        for i, table_field in ipairs(node.fields) do --фиксанутое определения таблицы
            if table_field.array_item then
                local values = { eval(self, table_field.value, environment) }
                for i2, value in ipairs(values) do
                    local pos = i + (i2 - 1)
                    tbl[pos] = value

                    --потому что {1, (функция возврашяюшая несколько значений), 3}
                    --из этой функции только одно(первое значения) должно идти в таблицу(а если после него нечего нет то все)
                    --так это работает в нормальном lua, поэтому тут должно работать так же
                    --а аргументами фикс такой-же
                    for i3 = pos + 1, math.huge do
                        if not tbl[i3] then break end
                        tbl[i3] = nil
                    end
                end
            else
                local key = eval(self, table_field.key, environment)
                local value = eval(self, table_field.value, environment)

                if not ll_Interpreter.internalData[tbl[key]] then --а нехер перезаписывать __internal_yield, крашеры ебаные
                    tbl[key] = value
                else
                    error("failed to rewrite a mod-protected function", 2)
                end
            end
        end

        return tbl
    end,
    ['operation'] = function(self, node, environment)
        local eval = __eval

        local left = eval(self, node.left, environment)

        if node.operator == 'or' then
            if left then
                return left
            else
                return eval(self, node.right, environment)
            end
        elseif node.operator == 'and' then
            if left then
                return eval(self, node.right, environment)
            else
                return left
            end
        end

        local right = eval(self, node.right, environment)

        return self.operations[node.operator](left, right)
    end,
    ["if"] = function(self, node, environment)
        local eval = __eval
        local enclose = __enclose

        for _, clause in ipairs(node.clauses) do
            if eval(self, clause.expr, environment) then
                local new_env = enclose(self, environment)
                eval(self, clause.body, new_env)
                return
            end
        end

        if node.else_body then
            local new_env = enclose(self, environment)
            eval(self, node.else_body, new_env)
        end
    end,
    ["while"] = function(self, node, environment)
        local eval = __eval
        local enclose = __enclose

        while eval(self, node.expr, environment) do
            local new_env = enclose(self, environment)
            --self:evaluate(node.body, new_env)

            local success, r = pcall(eval, self, node.body, new_env)

            if not success then
                if type(r) == 'table' and r.type == 'break_error' then
                    return
                end
                error(r)
            end
        end
    end,
    ["repeat"] = function(self, node, environment)
        local eval = __eval
        local enclose = __enclose

        repeat
            local new_env = enclose(self, environment)
            --self:evaluate(node.body, new_env)

            local success, r = pcall(eval, self, node.body, new_env)

            if not success then
                if type(r) == 'table' and r.type == 'break_error' then
                    return
                end
                error(r)
            end
        until eval(self, node.expr, environment)
    end,
    ["for"] = function(self, node, environment)
        local eval = __eval
        local enclose = __enclose

        local start = eval(self, node.start, environment)
        local end_loop = eval(self, node.end_loop, environment)
        local step = eval(self, node.step, environment)

        local node_body = node.body

        for i = start, end_loop, step do
            local new_env = enclose(self, environment)
            new_env[node.var_name] = i
            --self:evaluate(node.body, new_env)

            local success, r = pcall(eval, self, node_body, new_env)

            if not success then
                if type(r) == 'table' and r.type == 'break_error' then
                    return
                end
                error(r)
            end
        end
    end,
    ["foreach"] = function(self, node, environment)
        local eval = __eval
        local evalList = __eval_list
        local enclose = __enclose
        local min = math.min

        local node_body = node.body

        do
            local f, s, var = unpack(evalList(self, node.expressions, environment))
            while true do
                local vars = { f(s, var) }
                if vars[1] == nil then break end
                var = vars[1]

                local new_env = enclose(self, environment)

                local loop = min(#node.variables, #vars)
                for i = 1, loop do
                    new_env[node.variables[i]] = vars[i]
                end

                --self:evaluate(node.body, new_env)

                local success, r = pcall(eval, self, node_body, new_env)

                if not success then
                    if type(r) == 'table' and r.type == 'break_error' then
                        return
                    end
                    error(r)
                end
            end
        end
    end,
    ["do"] = function(self, node, environment)
        local new_env = self:encloseEnvironment(environment)
        self:evaluate(node.body, new_env)
    end,
    ["return"] = function(self, node, environment)
        error { type = "return_error", values = self:evaluateExpressionList(node.values, environment) }
    end,
    ["break"] = function(self, node, environment)
        error { type = "break_error" }
    end,
    uminus = function(self, node, environment)
        return -(self:evaluate(node.value, environment))
    end,
    ['not'] = function(self, node, environment)
        return not (self:evaluate(node.value, environment))
    end,
    get_length = function(self, node, environment)
        return #self:evaluate(node.value, environment)
    end,
    varargs = function(self, node, environment)
        local varargs = self:getEnvVarargs(environment)
        return unpack(varargs)
    end,
    ['debugdmpenvstack'] = function(self, node, environment)
        --self:dumpEnv(environment)
    end
}

ll_Interpreter.operations = {
    PLUS = function(l, r)
        --assert(type(l) == "number", "attempt to perform arithmetic on a " .. type(l) .. " value (the first aggrumentum)")
        --assert(type(r) == "number", "attempt to perform arithmetic on a " .. type(r) .. " value (the second argument)")
        return l + r
    end,
    MINUS = function(l, r)
        --assert(type(l) == "number", "attempt to perform arithmetic on a " .. type(l) .. " value (the first aggrumentum)")
        --assert(type(r) == "number", "attempt to perform arithmetic on a " .. type(r) .. " value (the second argument)")
        return l - r
    end,
    STAR = function(l, r)
        --assert(type(l) == "number", "attempt to perform arithmetic on a " .. type(l) .. " value (the first aggrumentum)")
        --assert(type(r) == "number", "attempt to perform arithmetic on a " .. type(r) .. " value (the second argument)")
        return l * r
    end,
    SLASH = function(l, r)
        --assert(type(l) == "number", "attempt to perform arithmetic on a " .. type(l) .. " value (the first aggrumentum)")
        --assert(type(r) == "number", "attempt to perform arithmetic on a " .. type(r) .. " value (the second argument)")
        return l / r
    end,
    PRECENTAGE = function(l, r)
        --assert(type(l) == "number", "attempt to perform arithmetic on a " .. type(l) .. " value (the first aggrumentum)")
        --assert(type(r) == "number", "attempt to perform arithmetic on a " .. type(r) .. " value (the second argument)")
        return l % r
    end,
    UP = function(l, r)
        --assert(type(l) == "number", "attempt to perform arithmetic on a " .. type(l) .. " value (the first aggrumentum)")
        --assert(type(r) == "number", "attempt to perform arithmetic on a " .. type(r) .. " value (the second argument)")
        return l ^ r
    end,
    CONCAT = function(l, r)
        return l .. r
    end,
    LESS = function(l, r)
        --assert(type(l) == "number", "attempt to perform arithmetic on a " .. type(l) .. " value (the first aggrumentum)")
        --assert(type(r) == "number", "attempt to perform arithmetic on a " .. type(r) .. " value (the second argument)")
        return l < r
    end,
    LESS_EQUAL = function(l, r)
        --assert(type(l) == "number", "attempt to perform arithmetic on a " .. type(l) .. " value (the first aggrumentum)")
        --assert(type(r) == "number", "attempt to perform arithmetic on a " .. type(r) .. " value (the second argument)")
        return l <= r
    end,
    GREATER = function(l, r)
        --assert(type(l) == "number", "attempt to perform arithmetic on a " .. type(l) .. " value (the first aggrumentum)")
        --assert(type(r) == "number", "attempt to perform arithmetic on a " .. type(r) .. " value (the second argument)")
        return l > r
    end,
    GREATER_EQUAL = function(l, r)
        --assert(type(l) == "number", "attempt to perform arithmetic on a " .. type(l) .. " value (the first aggrumentum)")
        --assert(type(r) == "number", "attempt to perform arithmetic on a " .. type(r) .. " value (the second argument)")
        return l >= r
    end,
    DOUBLE_EQUALS = function(l, r)
        return l == r
    end,
    NOT_EQUAL = function(l, r)
        return l ~= r
    end
}

local globalStep = 0
function ll_Interpreter:evaluate(node, environment)
    local iter = self.interations + 1
    if iter >= self.MAX_ITERATIONS then
        error("Max interation count exeeded")
    end
    self.interations = iter

    if not self.evals[node.type] then
        --error("No evaluator found for node of type '" .. node.type .. "'\n" .. debug.traceback())
        error("No evaluator found for node of type '" .. node.type .. "'")
    end

    --if self.debug then
    --    print(node.type, tableToString(node))
    --end

    if node.tunnel then
        node.tunnel.lastEval = node
    end
    if node.serviceTable then
        if node.serviceTable.yield then
            if globalStep % 2048 == 0 then
                node.serviceTable.yield(node.serviceTable.yieldArg)
                globalStep = 1
            else
                globalStep = globalStep + 1
            end
        end
    end
    return self.evals[node.type](self, node, environment)
end

__eval = ll_Interpreter.evaluate


function ll_Interpreter:evaluateExpressionList(node_values, environment)
    local values = {}
    local insert = table.insert
    local eval = __eval

    for _, val in ipairs(node_values) do
        local returned = { eval(self, val, environment) }
        for _, returned_value in ipairs(returned) do
            insert(values, returned_value)
        end
    end

    return values
end

__eval_list = ll_Interpreter.evaluateExpressionList

function ll_Interpreter:getGlobal(environment)
    local mt = environment.__metatable
    if mt then
        local enclosing = mt.enclosing
        if enclosing then
            return self:getGlobal(enclosing)
        end
    end
    return environment
end

function ll_Interpreter:encloseEnvironment(enclosing)
    local mt = { enclosing = enclosing, declared = {} }
    local new_env = {}
    new_env.__metatable = mt
    return new_env
end

__enclose = ll_Interpreter.encloseEnvironment

function ll_Interpreter:getFromEnv(environment, key)
    if environment[key] == fakenil then
        return nil
    end

    if environment[key] ~= nil then
        return environment[key]
    end

    local mt = environment.__metatable
    if mt then
        local enclosing = mt.enclosing
        if enclosing then
            return self:getFromEnv(enclosing, key)
        end
    end

    return nil
end

function ll_Interpreter:dumpEnv(environment, level)
    local level = level or 0

    print('--- up level ' .. level .. ' ---')
    for k, v in pairs(environment) do
        print(k, v)
    end

    local mt = environment.__metatable
    if mt then
        local enclosing = mt.enclosing
        if enclosing then
            return self:dumpEnv(enclosing, level + 1)
        end
    end
end

function ll_Interpreter:declareInEnv(environment, key)
    local mt = environment.__metatable
    mt.declared[key] = true
    --setmetatable(environment, mt)
end

function ll_Interpreter:setInEnv(environment, key, value)
    if ll_Interpreter.internalData[environment[key]] then --а нехер перезаписывать __internal_yield, крашеры ебаные
        error("failed to rewrite a mod-protected function", 4)
    end

    if environment[key] then
        environment[key] = value
        return
    end

    local mt = environment.__metatable

    if mt and mt.declared and mt.declared[key] then
        environment[key] = value
        return
    end

    if mt then
        local enclosing = mt.enclosing
        if enclosing then
            return self:setInEnv(enclosing, key, value)
        end
    end

    -- reached global env
    environment[key] = value
end

function ll_Interpreter:setEnvMeta(environment, key, value)
    local mt = environment.__metatable or {}
    mt[key] = value
end

function ll_Interpreter:getEnvMeta(environment, key)
    local mt = environment.__metatable or {}
    return mt[key]
end

function ll_Interpreter:getEnvVarargs(environment)
    local mt = environment.__metatable or {}
    local varargs = mt.varargs
    if varargs then return varargs end
    local enclosing = mt.enclosing
    if enclosing then return self:getEnvVarargs(enclosing) end
end

function ll_Interpreter:reset()
    self.interations = 0
end

print("ll_Interpreter loaded")

end
function scmframework_3a82dea42f1b6fa304b0cb8f6302fb6e() --$CONTENT_DATA/Scripts/remade-lua-in-lua/lua/main.lua
local m = {
    Scanner = require("lua.scanner"),
    Parser = require("lua.parser"),
    Interpreter = require("lua.interpreter")
}


---Parses string input and returns a tree
---@param input string
---@return table "Tree representation"
function m:getTree(input)
    local tokens = self.Scanner:scan(input)
    return self.Parser:parse(tokens)
end

---
---Runs a lua string, `environment` should be a table with variables and functions that will be used as the global environment
---
---@param input string
---@param environment table
---@return ...
function m:run(input, environment, ...)
    local tokens = self.Scanner:scan(input)
    local tree = self.Parser:parse(tokens)
    local env = self.Interpreter:encloseEnvironment(environment)
    self.Interpreter:setEnvMeta(env, "varargs", {...})
    env.arg = {...}
    return self.Interpreter:evaluate(tree, env)
end

---
---Runs a lua file, `environment` should be a table with variables and functions that will be used as the global environment
---
---@param file_path string
---@param environment table
---@return ...
function m:dofile(file_path, environment, ...)
    local f = io.open(file_path, "r")
    if not f then error("Failed to load file") end
    local source = f:read("*a")
    f:close()
    return self:run(source, environment, ...)
end

return m
end
function scmframework_e97080104c362851a115b2ad8c6dc241() --$CONTENT_DATA/Scripts/remade-lua-in-lua/lua/parser.lua
ll_Parser = {
    current = 0,
    line = 1,
    tokens = nil,
    
    precedence = {
        ["and"] = {prec=2, assoc='left'},
        ["or"] = {prec=2, assoc='left'},

        LESS = {prec=5, assoc='left'},
        LESS_EQUAL = {prec=5, assoc='left'},
        GREATER = {prec=5, assoc='left'},
        GREATER_EQUAL = {prec=5, assoc='left'},
        DOUBLE_EQUALS = {prec=5, assoc='left'},
        NOT_EQUAL = {prec=5, assoc='left'},

        CONCAT = {prec=10, assoc='left'},

        PLUS = {prec=20, assoc='left'},
        MINUS = {prec=20, assoc='left'},

        STAR = {prec=30, assoc='left'},
        SLASH = {prec=30, assoc='left'},
        PRECENTAGE = {prec=30, assoc='left'},

        UP = {prec=40, assoc='right'}
    }
}


---Parses tokens and returns a tree
---@param tokens table "Array table of tokens"
---@return table "Tree"
function ll_Parser:parse(tokens, chunkname, tunnel, serviceTable)
    self.current = 1
    self.line = 1
    self.tokens = tokens
    self.chunkname = chunkname
    self.tunnel = tunnel
    self.serviceTable = serviceTable

    return self:parseChunk()
end

local function addInfo(self, tbl)
    tbl.line = self.line
    tbl.chunkname = self.chunkname
    tbl.tunnel = self.tunnel
    tbl.serviceTable = self.serviceTable
    return tbl
end

function ll_Parser:parseChunk()
    local statements = {}
    local parsed

    while self:available() do
        parsed = false

        if self:match("return") then
            self:match("SEMICOLON")
            if self:available() then
                local node = addInfo(self, {type="return", values=self:parseExprList()})
                self:match("SEMICOLON")
                if self:available() then error("Return statement must be the last statement in the block") end
                statements[#statements+1] = node
            else
                statements[#statements+1] = addInfo(self, {type="return", values={nil}})
            end
            parsed = true
        end

        if not parsed then
            self.line = self:peek().line
            statements[#statements+1] = self:parseStatement()
        end

        self:match("SEMICOLON")
    end

    return addInfo(self, {type="chunk", statements=statements})
end

function ll_Parser:parseBlock(token_type, ...)
    local token_type = token_type or "end"
    local statements = {}
    local parsed

    while not self:match(token_type, ...) do
        parsed = false

        if self:match("return") then
            self:match("SEMICOLON")
            if not self:tokenOneOf(self:peek(), token_type, ...) then
                local node = addInfo(self, {type="return", values=self:parseExprList()})
                self:match("SEMICOLON")
                if not self:tokenOneOf(self:peek(), token_type, ...) then error("Return statement must be the last statement in the block") end
                statements[#statements+1] = node
            else
                statements[#statements+1] = addInfo(self, {type="return", values={nil}})
            end
            parsed = true
        end

        if self:match("break") then
            self:match("SEMICOLON")
            if not self:tokenOneOf(self:peek(), token_type, ...) then
                error("Break statement must be the last statement in the block")
            else
                statements[#statements+1] = addInfo(self, {type="break"})
            end
            parsed = true
        end

        if not parsed then
            self.line = self:peek().line
            statements[#statements+1] = self:parseStatement()
        end

        self:match("SEMICOLON")
    end

    return addInfo(self, {type="block", statements=statements})
end


function ll_Parser:parseStatement()
    if self:match("do") then return addInfo(self, {type="do", body=self:parseBlock()}) end

    if self:match("debugdmpenvstack") then return addInfo(self, {type="debugdmpenvstack"}) end

    if self:match("while") then
        local expr = self:parseExpr()
        self:consume("do", "Expected 'do' after while")
        return addInfo(self, {type="while", expr=expr, body=self:parseBlock()})
    end

    if self:match("repeat") then
        local body = self:parseBlock('until')
        --self:consume("until", "Expected 'until' after repeat body") --consumed by parseBlock
        local expr = self:parseExpr()
        return addInfo(self, {type="repeat", expr=expr, body=body})
    end

    if self:match("if") then
        local expr = self:parseExpr()
        self:consume("then", "Expected 'then' after if")

        local main_body = self:parseBlock('end', 'elseif', 'else')
        local clauses = {{expr=expr, body=main_body}}
        local else_body = nil

        while self:tokenOneOf(self:prev(), 'elseif', 'else') do
            local ttype = self:prev().type
            local subexpr

            if ttype == 'elseif' then
                subexpr = self:parseExpr()
                self:consume("then", "Expected 'then' after 'elseif'")
            end

            local body = self:parseBlock('end', 'elseif', 'else')
            
            if ttype == 'elseif' then clauses[#clauses+1] = {expr=subexpr, body=body}
            elseif ttype == 'else' then else_body = body end

        end

        return addInfo(self, {type="if", expr=expr, clauses=clauses, else_body=else_body})
    end

    if self:match("for") then

        -- standard for loop
        if self:peek(1).type == "EQUALS" then
            local var_name = self:consume("identifier", "Expected variable name after for").lexeme
            self:consume("EQUALS", "Expected '=' after variable name")
            local start = self:parseExpr()
            self:consume("COMMA", "Expected ',' after for loop start")
            local end_loop = self:parseExpr()

            local step
            if self:match("COMMA") then
                step = self:parseExpr()
            else
                step = addInfo(self, {type="literal", value=1})
            end

            self:consume("do", "Expected 'do' after for loop")

            local body = self:parseBlock()
            return addInfo(self, {type="for", var_name=var_name, start=start, end_loop=end_loop, step=step, body=body})
        end

        -- foreach loop
        local ids = self:parseIdList()
        self:consume("in", "Expected 'in' after for loop variable names")

        local exprs = self:parseExprList()
        self:consume("do", "Expected 'do' after for loop")

        local body = self:parseBlock()
        return addInfo(self, {type="foreach", variables=ids, expressions=exprs, body=body})
    end

    if self:match("function") then
        local func_name = self:parseFunctionName()
        local func_value = self:parseFunctionBody()

        if func_name.method then
            table.insert(func_value.arg_names, 1, "self")
        end

        func_name.node.value = func_value

        return func_name.node
    end

    if self:match("local") then

        if self:match("function") then
            local name = self:consume("identifier", "Expected function name").lexeme
            local func_value = self:parseFunctionBody()

            return addInfo(self, {type="declare_local", names={name}, values={func_value}})
        end

        local idlist = self:parseIdList()
        local init_values

        if self:match("EQUALS") then
            init_values = self:parseExprList()
        else
            init_values = {}
        end

        return addInfo(self, {type="declare_local", names=idlist, values=init_values})

    end


    local func_call = self:parseCall()
        
    if func_call.type == "call" or func_call.type == "get_call" then
        return func_call
    end

    local exprs = {func_call}

    if func_call.type ~= "get" and func_call.type ~= "variable" then
        error("[Line " .. self.line .. "] Expected a statement")
    end
    self:match("COMMA")

    if not self:check("EQUALS") then
        repeat
            local expr = self:parseCall()
            if expr.type ~= "get" and expr.type ~= "variable" then
                error("[Line " .. self.line .. "] Expected a statement")
            end
            exprs[#exprs+1] = expr
        until not self:match("COMMA")
    end

    self:consume("EQUALS", "Expected '=' after variable list")
    local init_values = self:parseExprList()

    return addInfo(self, {type="assign_expr", exprs=exprs, values=init_values})
end

function ll_Parser:parseIdList()
    local names = {}

    repeat
        names[#names+1] = self:consume("identifier", "Expected variable name after ','").lexeme
    until not self:match("COMMA")

    return names
end

function ll_Parser:parseFunctionName()
    local names = {}

    repeat
        names[#names+1] = self:consume("identifier", "Expected variable name after '.'").lexeme
    until not self:match("DOT")

    local method = false
    if self:match("COLON") then
        method = true
        names[#names+1] = self:consume("identifier", "Expected variable name after ':'").lexeme
    end

    if #names == 1 then
        return addInfo(self, {node=addInfo(self, {type="assign", name=names[1]}), method=method})
    end

    local tree = addInfo(self, {type="get", from=addInfo(self, {type="variable", name=names[1]}), index=addInfo(self, {type="literal", value=names[2]})})
    
    if #names > 2 then
        for i=3, #names do
            tree = addInfo(self, {type="get", from=tree, index={type="literal", value=names[i]}})
        end
    end
    return addInfo(self, {node=addInfo(self, {type="set", in_value=tree.from, index=tree.index}), method=method})
end

function ll_Parser:parseExprList()
    local exprs = {}

    repeat
        exprs[#exprs+1] = self:parseExpr()
    until not self:match("COMMA")

    return exprs
end

function ll_Parser:parseExpr()
    return self:parseBinOp(0)
end

function ll_Parser:parseBinOp(min_prec)
    local left = self:parseCall()

    while true do
        if not self:available() then break end
        local op_token = self:peek()
        if not self.precedence[op_token.type] then break end -- not an operator
        local prec_data = self.precedence[op_token.type]
        if prec_data.prec < min_prec then break end -- lower precedence, so break

        -- consume op token
        self.current = self.current + 1

        local next_prec = prec_data.assoc == 'left' and prec_data.prec + 1 or prec_data.prec
        local right = self:parseBinOp(next_prec)

        left = addInfo(self, {type="operation", operator=op_token.type, left=left, right=right})
    end

    return addInfo(self, left)
end


function ll_Parser:parseCall()
    local left = self:parsePrimaryExpr()

    while true do
        if self:match("OPEN_PAREN") then
            left = addInfo(self, {type="call", callee=left, args=self:parseArgs()})

        elseif self:match("OPEN_BRACE") then
            left = addInfo(self, {type="call", callee=left, args={self:parseTableConstructor()}})

        elseif self:match("string") then
            left = addInfo(self, {type="call", callee=left, args={addInfo(self, {type='literal', value=self:prev().literal})}})

        elseif self:match("COLON") then
            local idx = self:consume("identifier", "Expected function name after ':'").lexeme
            self:consume("OPEN_PAREN", "Expected '(' after function name")
            local args = self:parseArgs()
            left = addInfo(self, {type="get_call", callee=left, index=idx, args=args})

        elseif self:match("DOT") then
            local idx = self:consume("identifier", "Expected field name after '.'")
            left = addInfo(self, {type="get", from=left, index=addInfo(self, {type="literal", value=idx.lexeme})})

        elseif self:match("OPEN_SQUARE") then
            local idx = self:parseExpr()
            self:consume("CLOSE_SQUARE", "Expected ']' after indexing expression")
            left = addInfo(self, {type="get", from=left, index=idx})
        else
            break
        end
    end

    return addInfo(self, left)
end

function ll_Parser:parseArgs()
    local args = {}

    if not self:check("CLOSE_PAREN") then
        repeat
            args[#args+1] = self:parseExpr()
        until not self:match("COMMA")
    end

    self:consume("CLOSE_PAREN", "Expected ')' after parameters")
    return args
end

function ll_Parser:parsePrimaryExpr()
    if self:match("nil") then return addInfo(self, {type="literal", value=nil}) end
    if self:match("string") then return addInfo(self, {type="literal", value=self:prev().literal}) end
    if self:match("number") then return addInfo(self, {type="literal", value=self:prev().literal}) end
    if self:match("true") then return addInfo(self, {type="literal", value=true}) end
    if self:match("false") then return addInfo(self, {type="literal", value=false}) end
    if self:match("function") then return self:parseFunctionBody() end
    if self:match("OPEN_BRACE") then return self:parseTableConstructor() end

    if self:match("identifier") then return addInfo(self, {type="variable", name=self:prev().lexeme}) end
    if self:match("OPEN_PAREN") then 
        local expr = self:parseExpr()
        self:consume("CLOSE_PAREN", "Expected ')' after grouping expression")
        return expr
    end

    if self:match("not") then return addInfo(self, {type="not", value=self:parseBinOp(40)}) end
    if self:match("MINUS") then return addInfo(self, {type="uminus", value=self:parseBinOp(40)}) end
    if self:match("HASHTAG") then return addInfo(self, {type="get_length", value=self:parseBinOp(40)}) end
    if self:match("VARARGS") then return addInfo(self, {type="varargs"}) end

    print(self:peek().type)
    error("Expected expression")
end

function ll_Parser:parseFunctionBody()
    self:consume("OPEN_PAREN", "Expected '(' for function declaration")

    local arg_names = {}
    local varargs = false

    if not self:check("CLOSE_PAREN") then
        repeat
            if self:match("VARARGS") then
                varargs = true
                break
            else
                arg_names[#arg_names+1] = self:consume("identifier", "Expected variable name in function parameter definition").lexeme
            end
        until not self:match("COMMA")
    end

    self:consume("CLOSE_PAREN", "Expected ')' after function parameter definition")
    local body = self:parseBlock()
    body.type = 'chunk'

    return addInfo(self, {type="function", arg_names=arg_names, varargs=varargs, body=body})
end

function ll_Parser:parseTableConstructor()
    local fields = {}

    if not self:check("CLOSE_BRACE") then
        while not self:check('CLOSE_BRACE') do
            fields[#fields+1] = self:parseTableField()

            if not self:check('CLOSE_BRACE') then
                self:consumeOneOf("Expected ',' or ';' after table field value", 'COMMA', 'SEMICOLON')
            end
        end
    end

    self:consume("CLOSE_BRACE", "Expected '}' after table constructor")
    
    return addInfo(self, {type="table", fields=fields})
end

function ll_Parser:parseTableField()
    if self:match("VARARGS") then
        return addInfo(self, {array_item=true, value=addInfo(self, {type='varargs'})})
    end

    if self:match("OPEN_SQUARE") then
        local idx = self:parseExpr()
        self:consume("CLOSE_SQUARE", "Expected ']' after table field key")
        self:consume("EQUALS", "Expected '=' after table field key")
        local value = self:parseExpr()
        return {key=idx, value=value}
    end

    if self:peek(1).type == "EQUALS" then
        local idx = self:consume("identifier", "Expected field name").lexeme
        self:consume("EQUALS", "Expected '=' after table field key")
        local value = self:parseExpr()
        return {key=addInfo(self, {type="literal", value=idx}), value=value}
    end

    local value = self:parseExpr()
    return {array_item=true, value=value}
end

function ll_Parser:match(...)
    local types = {...}

    for _, token_type in ipairs(types) do
        if self:check(token_type) then
            self.current = self.current + 1
            return true
        end
    end

    return false
end

function ll_Parser:check(token_type)
    return self:peek().type == token_type
end

function ll_Parser:tokenOneOf(token, ...)
    local types = {...}

    for _, token_type in ipairs(types) do
        if token.type == token_type then
            return true
        end
    end

    return false
end

function ll_Parser:consume(token_type, err)
    if self:check(token_type) then return self:advance() end
    error("[Line " .. self:peek().line .. "] ".. err ..'\n'..self:peek().type) 
end

function ll_Parser:consumeOneOf(err, ...)
    local types = {...}

    for _, token_type in ipairs(types) do
        if self:check(token_type) then return self:advance() end
    end

    error("[Line " .. self:peek().line .. "] ".. err ..'\n'..self:peek().type)
end

function ll_Parser:peek(offset)
    local offset = offset or 0
    if self.current+offset > #self.tokens then return addInfo(self, {type="EOF"}) end
    return self.tokens[self.current+offset]
end

function ll_Parser:prev()
    return self.tokens[self.current-1]
end

function ll_Parser:available()
    return self:peek().type ~= "EOF"
end

function ll_Parser:advance()
    local token = self.tokens[self.current]
    self.current = self.current + 1
    return token
end

print("ll_Parser loaded")
end
function scmframework_d5ddcffc83b5ebb38998c77b1a9537a3() --$CONTENT_DATA/Scripts/remade-lua-in-lua/lua/scanner.lua
ll_Scanner = {
    current = 0,
    start = 0,
    line = 1,
    source = nil,
    tokens = nil,

    character_switch = {
        ['+'] = function(self) self:addToken('PLUS') end,
        ['-'] = function(self)
            if self:match('-') then
                if self:match('[') and self:match('[') then
                    while true do
                        if self:match(']') and self:match(']') then return end
                        if not self:available() then return end
                        self.current = self.current + 1
                    end
                end
                while self:peek() ~= '\n' and self:available() do
                    self.current = self.current + 1
                end
            else
                self:addToken('MINUS')
            end
        end,
        ['*'] = function(self) self:addToken('STAR') end,
        ['/'] = function(self) self:addToken('SLASH') end,
        ['^'] = function(self) self:addToken('UP') end,
        ['%'] = function(self) self:addToken('PRECENTAGE') end,
        ['.'] = function(self) self:addToken(self:match('.') and (self:match('.') and 'VARARGS' or 'CONCAT') or 'DOT') end,
        [','] = function(self) self:addToken('COMMA') end,
        [':'] = function(self) self:addToken('COLON') end,
        [';'] = function(self) self:addToken('SEMICOLON') end,
        ['<'] = function(self) self:addToken(self:match('=') and 'LESS_EQUAL' or 'LESS') end,
        ['>'] = function(self) self:addToken(self:match('=') and 'GREATER_EQUAL' or 'GREATER') end,
        ['='] = function(self) self:addToken(self:match('=') and 'DOUBLE_EQUALS' or 'EQUALS') end,
        ['~'] = function(self) self:addToken(self:match('=') and 'NOT_EQUAL' or 'TILDA') end,
        ['#'] = function(self) self:addToken('HASHTAG') end,
        ['{'] = function(self) self:addToken('OPEN_BRACE') end,
        ['}'] = function(self) self:addToken('CLOSE_BRACE') end,
        ['('] = function(self) self:addToken('OPEN_PAREN') end,
        [')'] = function(self) self:addToken('CLOSE_PAREN') end,
        ['['] = function(self) if self:match('[', '=') then self:scanBigString() else self:addToken('OPEN_SQUARE') end end,
        [']'] = function(self) self:addToken('CLOSE_SQUARE') end,
        ["'"] = function(self) self:scanString("'") end,
        ['"'] = function(self) self:scanString('"') end
    },

    reserved_words = {
        ["if"] = true,
        ["then"] = true,
        ["else"] = true,
        ["elseif"] = true,
        ["local"] = true,
        ["repeat"] = true,
        ["until"] = true,
        ["end"] = true,
        ["function"] = true,
        ["for"] = true,
        ["return"] = true,
        ["break"] = true,
        ["in"] = true,
        ["do"] = true,
        ["while"] = true,
        ["nil"] = true,
        ["and"] = true,
        ["or"] = true,
        ["not"] = true,
        ["true"] = true,
        ["false"] = true,
        ["debugdmpenvstack"] = true
    },

    escaped_chars = {
        ['t'] = '\t',
        ['n'] = '\n',
        ['r'] = '\r',
        ['a'] = '\a',
        ['f'] = '\f',
        ['z'] = '\z',
        ['v'] = '\v',
        ['b'] = '\b',
        ['"'] = "\"",
        ["'"] = "'",
        ['\\'] = '\\'
    }
}


---Scans the string input and returns a list of tokens
---@param input string
---@return table "Array table of tokens"
function ll_Scanner:scan(input)
    self.current = 1
    self.line = 1
    self.source = input
    self.tokens = {}

    while self:available() do
        self.start = self.current
        self:scanToken()
    end

    self:addToken("EOF")

    return self.tokens
end




function ll_Scanner:scanToken()
    local c = self:advance()
    
    if self.character_switch[c] then
        self.character_switch[c](self)    
    elseif c:match("[\r\t ]") then
        return
    elseif c == '\n' then
        self.line = self.line + 1
    elseif self:isAlpha(c) then
        self:scanIdentifier()
    elseif self:isDigit(c) then
        self:scanNumber()
    else
        error("[Line " .. self.line .. "] Unexpected character '" .. c .. "'")
    end
end

---Adds a token to the array
---@param token_type string
---@param literal any
function ll_Scanner:addToken(token_type, literal)
    self.tokens[#self.tokens+1] = {
        type = token_type,
        line = self.line,
        literal = literal,
        lexeme = self.source:sub(self.start, self.current-1)
    }
end



function ll_Scanner:scanIdentifier()
    while self:isAlphaNumeric(self:peek()) and self:available() do
        self.current = self.current + 1
    end

    local lexeme = self.source:sub(self.start, self.current-1)
    local token_type = self.reserved_words[lexeme] and lexeme or "identifier"

    self:addToken(token_type, lexeme)
end

function ll_Scanner:scanNumber()
    -- check if hex
    if self:prev() == '0' and self:match('x', 'X') then
        self:scanHexNumber()
        return
    end

    while self:isDigit(self:peek()) and self:available() do
        self.current = self.current + 1
    end

    if self:match('.') then
        while self:isDigit(self:peek()) and self:available() do
            self.current = self.current + 1
        end
    end

    if self:match('e', 'E') then
        self:match('+', '-')
        while self:isDigit(self:peek()) and self:available() do
            self.current = self.current + 1
        end
    end

    local lexeme = self.source:sub(self.start, self.current-1)
    local num = tonumber(lexeme)

    if not num then
        error("[Line " .. self.line .. "] Failed to parse number '" .. lexeme .. "'")
    end

    self:addToken("number", num)
end

function ll_Scanner:scanHexNumber()
    while self:isHexDigit(self:peek()) and self:available() do
        self.current = self.current + 1
    end

    if self:match('.') then
        while self:isHexDigit(self:peek()) and self:available() do
            self.current = self.current + 1
        end
    end

    if self:match('p', 'P') then
        self:match('+', '-')
        while self:isDigit(self:peek()) and self:available() do
            self.current = self.current + 1
        end
    end

    local lexeme = self.source:sub(self.start, self.current-1)
    local num = tonumber(lexeme)

    if not num then
        error("[Line " .. self.line .. "] Failed to parse number '" .. lexeme .. "'")
    end

    self:addToken("number", num)
end

function ll_Scanner:scanString(closing_char)
    while self:peek() ~= closing_char and self:available() do
        if self:peek() == '\n' then
            error("[Line " .. self.line .. "] New lines aren't allowed in strings")
        end
        if self:peek() == "\\" then
            self.current = self.current + 1
        end
        self.current = self.current + 1
    end

    if not self:available() then
        error("[Line " .. self.line .. "] Unterminated string")
    end

    -- consume closing char
    self.current = self.current + 1
    local lexeme = self.source:sub(self.start+1, self.current-2)

    lexeme = lexeme:gsub("\\[0-9][0-9]?[0-9]?", function(str)
        return string.char(str:sub(2))
    end)

    lexeme = lexeme:gsub("\\.", function(str)
        local c = str:sub(2, 2)
        if self.escaped_chars[c] then
            return self.escaped_chars[c]
        else
            return str
        end
    end)

    self:addToken("string", lexeme)
end

function ll_Scanner:scanBigString()
    local equals = self:prev() == '=' and 1 or 0
    
    while self:match('=') do
        equals = equals + 1
    end

    if equals ~= 0 then
        self:consume('[', "Expected [ to start multiline string")
    end

    while self:peek() ~= ']' and self:available() do
        if self:peek() == "\\" then
            self.current = self.current + 1
        end
        self.current = self.current + 1
    end

    self:advance() -- consume closing ]

    for _=1, equals do
        self:consume('=', "Expected same number of = in the multiline string")
    end

    self:consume(']', "Expected ']' to close multiline string")

    local lexeme = self.source:sub(self.start+2+equals, self.current-(3+equals))
    self:addToken("string", lexeme)
end

function ll_Scanner:isDigit(c)
    return c:match("[0-9]")
end

function ll_Scanner:isHexDigit(c)
    return c:match("[0-9a-fA-F]")
end

function ll_Scanner:isAlpha(c)
    return c:match("[a-zA-Z_]")
end

function ll_Scanner:isAlphaNumeric(c)
    return c:match("[a-zA-Z_0-9]")
end

function ll_Scanner:peek()
    if not self:available() then return '\0' end
    return self.source:sub(self.current, self.current)
end

function ll_Scanner:prev()
    return self.source:sub(self.current-1, self.current-1)
end

function ll_Scanner:consume(c, err)
    if self:peek() == c then return self:advance() end
    error("[Line " .. self.line .. "] " ..err)
end

function ll_Scanner:match(...)
    local chars = {...}
    for _, c in ipairs(chars) do
        if self:peek() == c then
            self.current = self.current + 1
            return true
        end
    end
    
    return false
end


function ll_Scanner:available()
    return self.current <= #self.source
end


function ll_Scanner:advance()
    local c = self.source:sub(self.current, self.current)
    self.current = self.current + 1
    return c
end

print("ll_Scanner loaded")
end
function scmframework_56fe5c554f6932fed71b6b5090c0e96b() --$CONTENT_DATA/Scripts/remade-lua-in-lua/main.lua
local lua = require("lua.main")

-- Custom environment
local env = {
    print = print,
    getmetatable = getmetatable,
    setmetatable = setmetatable,
    type = type,
    pcall = function(f, ...)
        local data = {pcall(f, ...)}
        if not data[1] then
            return false, data[2].error_object
        else
            return unpack(data)
        end
    end,
    error = function(object)
        error {error_object=object}
    end,
    pairs = pairs,
    ipairs = ipairs,
    unpack = unpack,
    io = io,
    table = table,
    string = string,
    tostring = tostring,
    tonumber = tonumber,
    math = math
}

-- Custom require and dofile functions
env._G = env
env.require = function(fpath)
    local fpath = fpath:gsub("%.", "/")
    local f = io.open(fpath .. ".lua", "r")
    local code = f:read("*a")
    f:close()

    local success, ret = pcall(lua.run, lua, code, env)

    if not success then
        error("In file " .. fpath .. ": " .. ret)
    end

    return ret
end

env.dofile = function(fpath)
    local f = io.open(fpath, "r")
    local code = f:read("*a")
    f:close()

    local success, ret = pcall(lua.run, lua, code, env)

    if not success then
        error("In file " .. fpath .. ": " .. ret)
    end

    return ret
end


lua:dofile("test.lua", env)
end
function scmframework_db2bf9ec6cea3da87ff17035de8a77c6() --$CONTENT_DATA/Scripts/remade-scrapVM/LuaVM/LBI.lua
local lua_opcode_types = {
	"ABC",  "ABx", "ABC",  "ABC",
	"ABC",  "ABx", "ABC",  "ABx", 
	"ABC",  "ABC", "ABC",  "ABC",
	"ABC",  "ABC", "ABC",  "ABC",
	"ABC",  "ABC", "ABC",  "ABC",
	"ABC",  "ABC", "AsBx", "ABC",
	"ABC",  "ABC", "ABC",  "ABC",
	"ABC",  "ABC", "ABC",  "AsBx",
	"AsBx", "ABC", "ABC", "ABC",
	"ABx",  "ABC",
}

local lua_opcode_names = {
	"MOVE",     "LOADK",     "LOADBOOL", "LOADNIL",
	"GETUPVAL", "GETGLOBAL", "GETTABLE", "SETGLOBAL",
	"SETUPVAL", "SETTABLE",  "NEWTABLE", "SELF",
	"ADD",      "SUB",       "MUL",      "DIV",
	"MOD",      "POW",       "UNM",      "NOT",
	"LEN",      "CONCAT",    "JMP",      "EQ",
	"LT",       "LE",        "TEST",     "TESTSET",
	"CALL",     "TAILCALL",  "RETURN",   "FORLOOP",
	"FORPREP",  "TFORLOOP",  "SETLIST",  "CLOSE",
	"CLOSURE",  "VARARG"
};

local function get_bits(input, n, n2)
	if n2 then
		local total = 0
		local digitn = 0
		for i = n, n2 do
			total = total + 2^digitn*get_bits(input, i)
			digitn = digitn + 1
		end
		return total
	else
		local pn = 2^(n-1)
		return (input % (pn + pn) >= pn) and 1 or 0
	end
end

local function decode_bytecode(bytecode)
	local index = 1
	local big_endian = false
    local int_size;
    local size_t;

    -- Actual binary decoding functions. Dependant on the bytecode.
    local get_int, get_size_t;

	-- Binary decoding helper functions
	local floorTo = 5 --шоб убрать лютые касяци с числами
	local get_int8, get_int32, get_int64, get_float64, get_string;
	do
		function get_int8()
			local a = bytecode:byte(index, index);
			index = index + 1
			return round(a, floorTo)
		end
		function get_int32()
            local a, b, c, d = bytecode:byte(index, index + 3);
            index = index + 4;
            return round(d*16777216 + c*65536 + b*256 + a, floorTo)
        end
        function get_int64()
            local a = get_int32();
            local b = get_int32();
            return round(b*4294967296 + a, floorTo)
        end
		function get_float64()
			local a = get_int32()
			local b = get_int32()
			return round((-2*get_bits(b, 32)+1)*(2^(get_bits(b, 21, 31)-1023))*
			       ((get_bits(b, 1, 20)*(2^32) + a)/(2^52)+1), floorTo)
		end
		function get_string(len)
			local str;
            if len then
	            str = bytecode:sub(index, index + len - 1);
	            index = index + len;
            else
                len = get_size_t();
	            if len == 0 then return; end
	            str = bytecode:sub(index, index + len - 1);
	            index = index + len;
            end
            return str;
        end
	end

	local function decode_chunk()
		local chunk;
		local instructions = {};
		local constants    = {};
		local prototypes   = {};
		local debug = {
			lines = {};
		};

		chunk = {
			instructions = instructions;
			constants    = constants;
			prototypes   = prototypes;
			debug = debug;
		};

		local num;

		chunk.name       = get_string();-- Function name
		chunk.first_line = get_int();	-- First line
		chunk.last_line  = get_int();	-- Last  line

        if chunk.name then chunk.name = chunk.name:sub(1, -2); end
		
		chunk.upvalues  = get_int8();
		chunk.arguments = get_int8();
		chunk.varg      = get_int8();
		chunk.stack     = get_int8();

        -- TODO: realign lists to 1
		-- Decode instructions
		do
			num = get_int();
			for i = 1, num do
				local instruction = {
					-- opcode = opcode number;
					-- type   = [ABC, ABx, AsBx]
					-- A, B, C, Bx, or sBx depending on type
				};

				local data   = get_int32();
				local opcode = get_bits(data, 1, 6);
				local type   = lua_opcode_types[opcode + 1];

				instruction.opcode = opcode;
				instruction.type   = type;
				
				instruction.A = get_bits(data, 7, 14);
				if type == "ABC" then
					instruction.B = get_bits(data, 24, 32);
					instruction.C = get_bits(data, 15, 23);
				elseif type == "ABx" then
					instruction.Bx = get_bits(data, 15, 32);
				elseif type == "AsBx" then
					instruction.sBx = get_bits(data, 15, 32) - 131071;
				end

				instructions[i] = instruction;
			end
		end

		-- Decode constants
		do
			num = get_int();
			for i = 1, num do
				local constant = {
					-- type = constant type;
					-- data = constant data;
				};
				local type = get_int8();
				constant.type = type;

				if type == 1 then
					constant.data = (get_int8() ~= 0);
				elseif type == 3 then
					constant.data = get_float64();
				elseif type == 4 then
					constant.data = get_string():sub(1, -2);
				end

				constants[i-1] = constant;
			end
		end

		-- Decode Prototypes
		do
			num = get_int();
			for i = 1, num do
				prototypes[i-1] = decode_chunk();
			end
		end

		-- Decode debug info
        -- Not all of which is used yet.
		do
			-- line numbers
			local data = debug.lines
			num = get_int();
			for i = 1, num do
				data[i] = get_int32();
			end

			-- locals
			num = get_int();
			for i = 1, num do
				get_string():sub(1, -2);	-- local name
				get_int32();	-- local start PC
				get_int32();	-- local end   PC
			end

			-- upvalues
			num = get_int();
			for i = 1, num do
				get_string();	-- upvalue name
			end
		end

		return chunk;
	end

	-- Verify bytecode header
	do
		assert(get_string(4) == "\27Lua", "Lua bytecode expected.");
		assert(get_int8() == 0x51, "Only Lua 5.1 is supported.");
		get_int8(); 	-- Oficial bytecode
		big_endian = (get_int8() == 0);
        int_size = get_int8();
        size_t   = get_int8();

        if int_size == 4 then
            get_int = get_int32;
        elseif int_size == 8 then
            get_int = get_int64;
        else
	        -- TODO: refactor errors into table
            error("Unsupported bytecode target platform");
        end

        if size_t == 4 then
            get_size_t = get_int32;
        elseif size_t == 8 then
            get_size_t = get_int64;
        else
            error("Unsupported bytecode target platform");
        end

        assert(get_string(3) == "\4\8\0",
	           "Unsupported bytecode target platform");
	end

	return decode_chunk();
end

local function handle_return(...)
	local c = select("#", ...)
	local t = {...}
	return c, t
end

local function create_wrapper(cache, upvalues, environment)
	local instructions = cache.instructions;
	local constants    = cache.constants;
	local prototypes   = cache.prototypes;
	
	local stack, top
	local IP = 1;	-- instruction pointer
	local vararg, vararg_size 

	local opcode_funcs = {
		[0]  = function(instruction)	-- MOVE
			stack[instruction.A] = stack[instruction.B];
		end,
		[1]  = function(instruction)	-- LOADK
			stack[instruction.A] = constants[instruction.Bx].data;
		end,
		[2]  = function(instruction)	-- LOADBOOL
			stack[instruction.A] = instruction.B ~= 0
			if instruction.C ~= 0 then
				IP = IP + 1
			end
		end,
		[3]  = function(instruction)	-- LOADNIL
			local stack = stack
			for i = instruction.A, instruction.B do
				stack[i] = nil
			end
		end,
		[4] = function(instruction)		-- GETUPVAL
			stack[instruction.A] = upvalues[instruction.B]
		end,
		[5]  = function(instruction)	-- GETGLOBAL
			local key = constants[instruction.Bx].data;
			stack[instruction.A] = environment[key];
		end,
		[6]  = function(instruction)	-- GETTABLE
			local C = instruction.C
			local stack = stack
			C = C > 255 and constants[C-256].data or stack[C]
			stack[instruction.A] = stack[instruction.B][C];
		end,
		[7]  = function(instruction)	-- SETGLOBAL
			local key = constants[instruction.Bx].data;
			environment[key] = stack[instruction.A];
		end,
		[8] = function (instruction)	-- SETUPVAL
			upvalues[instruction.B] = stack[instruction.A]
		end,
		[9] = function (instruction)	-- SETTABLE
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A][B] = C
		end,
		[10] = function (instruction)	-- NEWTABLE
			stack[instruction.A] = {}
		end,
		[11] = function (instruction)	-- SELF
			local A = instruction.A
			local B = instruction.B
			local C = instruction.C
			local stack = stack
			
			B = stack[B]
			C = C > 255 and constants[C-256].data or stack[C]
			
			stack[A+1] = B
			stack[A]   = B[C]
		end,
		[12] = function(instruction)	-- ADD
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A] = B+C;
		end,
		[13] = function(instruction)	-- SUB
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A] = B - C;	
		end,
		[14] = function(instruction)	-- MUL
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A] = B * C;
		end,
		[15] = function(instruction)	--DIV
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A] = B / C;
		end,
		[16] = function(instruction) 	-- MOD
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A] = B % C;		
		end,
		[17] = function(instruction)	-- POW
			local B = instruction.B;
			local C = instruction.C;
			local stack, constants = stack, constants;
			
			B = B > 255 and constants[B-256].data or stack[B];
			C = C > 255 and constants[C-256].data or stack[C];
			
			stack[instruction.A] = B ^ C;		
		end,
		[18] = function(instruction)	-- UNM
			stack[instruction.A] = -stack[instruction.B]
		end,
		[19] = function(instruction)	-- NOT
			stack[instruction.A] = not stack[instruction.B]
		end,
		[20] = function(instruction)	-- LEN
			stack[instruction.A] = #stack[instruction.B]
		end,
		[21] = function(instruction)	-- CONCAT
			local B = instruction.B
			local result = stack[B]
			for i = B+1, instruction.C do
				result = result .. stack[i] 
			end
			stack[instruction.A] = result
		end,
		[22] = function(instruction)	-- JUMP
			IP = IP + instruction.sBx
		end,
		[23] = function(instruction)	-- EQ
			local A = instruction.A
			local B = instruction.B
			local C = instruction.C
			local stack, constants = stack, constants
			
			A = A ~= 0
			B = B > 255 and constants[B-256].data or stack[B]
			C = C > 255 and constants[C-256].data or stack[C]
			if (B == C) ~= A then
				IP = IP + 1
			end
		end,
		[24] = function(instruction)	-- LT
			local A = instruction.A
			local B = instruction.B
			local C = instruction.C
			local stack, constants = stack, constants
			
			A = A ~= 0
			B = B > 255 and constants[B-256].data or stack[B]
			C = C > 255 and constants[C-256].data or stack[C]
			if (B < C) ~= A then
				IP = IP + 1
			end		
		end,
		[25] = function(instruction)	-- LT
			local A = instruction.A
			local B = instruction.B
			local C = instruction.C
			local stack, constants = stack, constants
			
			A = A ~= 0
			B = B > 255 and constants[B-256].data or stack[B]
			C = C > 255 and constants[C-256].data or stack[C]
			if (B <= C) ~= A then
				IP = IP + 1
			end		
		end,
		[26] = function(instruction)	-- TEST
			if (not not stack[instruction.A]) == (instruction.C == 0) then
				IP = IP + 1
			end
		end,
		[27] = function(instruction)	-- TESTSET
			local stack = stack
			local B = stack[instruction.B]
			if (not not B) == (instruction.C == 0) then
				IP = IP + 1
			else
				stack[instruction.A] = B
			end
		end,
		[28] = function(instruction)	-- CALL
			local A = instruction.A;
			local B = instruction.B;
			local C = instruction.C;
			local stack = stack;
			local args, results;
			local limit, loop
			
			args = {};
			if B ~= 1 then
				if B ~= 0 then
					limit = A+B-1;
				else
					limit = top
				end
				
				loop = 0
				for i = A+1, limit do
					loop = loop + 1
					args[loop] = stack[i];
				end
				
				limit, results = handle_return(stack[A](unpack(args, 1, limit-A)))
			else
				limit, results = handle_return(stack[A]())
			end
			
			top = A - 1
		
			if C ~= 1 then
				if C ~= 0 then
					limit = A+C-2;
				else
					limit = limit+A
				end
				
				loop = 0;
				for i = A, limit do
					loop = loop + 1;
					stack[i] = results[loop];
				end
			end
		end,
		[29] = function (instruction)	-- TAILCALL
			local A = instruction.A;
			local B = instruction.B;
			local C = instruction.C;
			local stack = stack;
			local args, results;
			local top, limit, loop = top
			
			args = {};
			if B ~= 1 then
				if B ~= 0 then
					limit = A+B-1;
				else
					limit = top
				end
				
				loop = 0
				for i = A+1, limit do
					loop = loop + 1
					args[#args+1] = stack[i];
				end
				
				results = {stack[A](unpack(args, 1, limit-A))};
			else
				results = {stack[A]()};
			end
			
			return true, results
		end,
		[30] = function(instruction) -- RETURN
			--TODO: CLOSE
			local A = instruction.A;
			local B = instruction.B;
			local stack = stack;
			local limit;
			local loop, output;
						
			if B == 1 then
				return true;
			end
			if B == 0 then
				limit = top
			else
				limit = A + B - 2;
			end
			
			output = {};
			local loop = 0
			for i = A, limit do
				loop = loop + 1
				output[loop] = stack[i];
			end
			return true, output;
		end,
		[31] = function(instruction)	-- FORLOOP
			local A = instruction.A
			local stack = stack
			
			local step = stack[A+2]
			local index = stack[A] + step 
			stack[A] = index
			
			if step > 0 then
				if index <= stack[A+1] then
					IP = IP + instruction.sBx
					stack[A+3] = index
				end
			else
				if index >= stack[A+1] then
					IP = IP + instruction.sBx
					stack[A+3] = index
				end
			end
		end,
		[32] = function(instruction)	-- FORPREP
			local A = instruction.A
			local stack = stack
			
			stack[A] = stack[A] - stack[A+2]
			IP = IP + instruction.sBx 
		end,
		[33] = function(instruction)	-- TFORLOOP
			local A = instruction.A
			local B = instruction.B
			local C = instruction.C
			local stack = stack
			
			local offset = A+2
			local result = {stack[A](stack[A+1], stack[A+2])}
			for i = 1, C do
				stack[offset+i] = result[i]
			end
			
			if stack[A+3] ~= nil then
				stack[A+2] = stack[A+3]
			else
				IP = IP + 1
			end
		end,
		[34] = function(instruction)	-- SETLIST
			local A = instruction.A
			local B = instruction.B
			local C = instruction.C
			local stack = stack

			if C == 0 then
				error("NYI: extended SETLIST")
			else
				local offset = (C - 1) * 50
				local t = stack[A]
				
				if B == 0 then
					B = top
				end
				for i = 1, B do
					t[offset+i] = stack[A+i]	
				end				
			end
		end,
		[35] = function(instruction)	-- CLOSE
			--io.stderr:write("NYI: CLOSE")
			--io.stderr:flush()
		end,
		[36] = function(instruction)	-- CLOSURE
			local proto = prototypes[instruction.Bx]
			local instructions = instructions
			local stack = stack
			
			local indices = {}
			new_upvals = class(nil)
			new_upvals.__index = function(t, k)
				local upval = indices[k]
				return upval.segment[upval.offset]
			end
			new_upvals.__newindex = function(t, k, v)
				local upval = indices[k]
				upval.segment[upval.offset] = v
			end
			new_upvals = new_upvals()

			for i = 1, proto.upvalues do
				local movement = instructions[IP]
				if movement.opcode == 0 then -- MOVE
					indices[i-1] = {segment = stack, offset = movement.B}
				elseif instructions[IP].opcode == 4 then -- GETUPVAL
					indices[i-1] = {segment = upvalues, offset = movement.B}
				end
				IP = IP + 1
			end
			
			local _, func = create_wrapper(proto, new_upvals, environment)
			stack[instruction.A] = func
		end,
		[37] = function(instruction)	-- VARARG
			local A = instruction.A
			local B = instruction.B
			local stack, vararg = stack, vararg
			
			for i = A, A + (B > 0 and B - 1 or vararg_size) do
				stack[i] = vararg[i - A]
			end
		end,
	}
	
	local function loop()
		local instructions = instructions
		local instruction, a, b
		
		while true do
			instruction = instructions[IP];
			IP = IP + 1
			a, b = opcode_funcs[instruction.opcode](instruction);
			if a then
				return b;
			end
		end
	end

	local debugging = {
		get_stack = function()
			return stack;
		end;
		get_IP = function()
			return IP;
		end
	};

	local function func(...)
		local local_stack = {};
		local ghost_stack = {};

		top = -1
		stack = class(nil)
		stack.__index = ghost_stack
		stack.__newindex = function(t, k, v)
			if k > top and v then
				top = k
			end
			ghost_stack[k] = v
		end
		stack = stack()
		local_stack = stack
		
		local args = {...};	
		vararg = {}
		vararg_size = select("#", ...) - 1
		for i = 0, vararg_size do
			local_stack[i] = args[i+1];
			vararg[i] = args[i+1]
		end
		
		IP = 1;
		local a, b = pcall(loop)

		if a then
			if b then
				return unpack(b);
			end
			return;
		else
			--TODO error converting
			local name = cache.name;
			local line = cache.debug.lines[IP];
			local err  = b:gsub("(.-:)", "");
			local output = "";
			
			output = output .. (name and name .. ":" or "");
			output = output .. (line and line .. ":" or "");
			output = output .. b
			--[[
			output = ("%s (Instruction=%s)"):format(output, 
				lua_opcode_names[select(2,debug.getlocal(loop,1, 1)).opcode+1])
			--]]
			error(output, 0);
		end
	end

	return debugging, func;
end

_G.luavm.lbi = {
	load_bytecode = function(bytecode,env)
		local cache = decode_bytecode(bytecode);
		local _, func = create_wrapper(cache, nil, env);
		return func;
	end;

	-- Utilities (Debug, Introspection, Testing, etc)
	utils = {
		decode_bytecode = decode_bytecode;
		create_wrapper = create_wrapper;
		debug_bytecode = function(bytecode)
			local cache = decode_bytecode(bytecode)
			return create_wrapper(cache);
		end;
	};
}
end
function scmframework_06abecad296ed0c8af9bd259b0460eb9() --$CONTENT_DATA/Scripts/remade-scrapVM/LuaVM/LuaK.lua
--[[--------------------------------------------------------------------

  lcode.lua
  Lua 5 code generator in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2007 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * one function manipulate a pointer argument with a simple data type
--   (can't be emulated by a table, ambiguous), now returns that value:
--   luaK:concat(fs, l1, l2)
-- * luaM_growvector uses the faux luaY:growvector, for limit checking
-- * some function parameters changed to boolean, additional code
--   translates boolean back to 1/0 for instruction fields
--
-- Not implemented:
-- * NOTE there is a failed assert in luaK:addk, a porting problem
--
-- Added:
-- * constant MAXSTACK from llimits.h
-- * luaK:ttisnumber(o) (from lobject.h)
-- * luaK:nvalue(o) (from lobject.h)
-- * luaK:setnilvalue(o) (from lobject.h)
-- * luaK:setnvalue(o, x) (from lobject.h)
-- * luaK:setbvalue(o, x) (from lobject.h)
-- * luaK:sethvalue(o, x) (from lobject.h), parameter L deleted
-- * luaK:setsvalue(o, x) (from lobject.h), parameter L deleted
-- * luaK:numadd, luaK:numsub, luaK:nummul, luaK:numdiv, luaK:nummod,
--   luaK:numpow, luaK:numunm, luaK:numisnan (from luaconf.h)
-- * copyexp(e1, e2) added in luaK:posfix to copy expdesc struct
--
-- Changed in 5.1.x:
-- * enum BinOpr has a new entry, OPR_MOD
-- * enum UnOpr has a new entry, OPR_LEN
-- * binopistest, unused in 5.0.x, has been deleted
-- * macro setmultret is new
-- * functions isnumeral, luaK_ret, boolK are new
-- * funcion nilK was named nil_constant in 5.0.x
-- * function interface changed: need_value, patchtestreg, concat
-- * TObject now a TValue
-- * functions luaK_setreturns, luaK_setoneret are new
-- * function luaK:setcallreturns deleted, to be replaced by:
--   luaK:setmultret, luaK:ret, luaK:setreturns, luaK:setoneret
-- * functions constfolding, codearith, codecomp are new
-- * luaK:codebinop has been deleted
-- * function luaK_setlist is new
-- * OPR_MULT renamed to OPR_MUL
----------------------------------------------------------------------]]

-- requires luaP, luaX, luaY
local luaK = {}
local luaP = _G.luavm.luaP
local luaX = _G.luavm.luaX

------------------------------------------------------------------------
-- constants used by code generator
------------------------------------------------------------------------
-- maximum stack for a Lua function
luaK.MAXSTACK = 250  -- (from llimits.h)

--[[--------------------------------------------------------------------
-- other functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- emulation of TValue macros (these are from lobject.h)
-- * TValue is a table since lcode passes references around
-- * tt member field removed, using Lua's type() instead
-- * for setsvalue, sethvalue, parameter L (deleted here) in lobject.h
--   is used in an assert for testing, see checkliveness(g,obj)
------------------------------------------------------------------------
function luaK:ttisnumber(o)
  if o then return type(o.value) == "number" else return false end
end
function luaK:nvalue(o) return o.value end
function luaK:setnilvalue(o) o.value = nil end
function luaK:setsvalue(o, x) o.value = x end
luaK.setnvalue = luaK.setsvalue
luaK.sethvalue = luaK.setsvalue
luaK.setbvalue = luaK.setsvalue

------------------------------------------------------------------------
-- The luai_num* macros define the primitive operations over numbers.
-- * this is not the entire set of primitive operations from luaconf.h
-- * used in luaK:constfolding()
------------------------------------------------------------------------
function luaK:numadd(a, b) return a + b end
function luaK:numsub(a, b) return a - b end
function luaK:nummul(a, b) return a * b end
function luaK:numdiv(a, b) return a / b end
function luaK:nummod(a, b) return a % b end
  -- ((a) - floor((a)/(b))*(b)) /* actual, for reference */
function luaK:numpow(a, b) return a ^ b end
function luaK:numunm(a) return -a end
function luaK:numisnan(a) return not a == a end
  -- a NaN cannot equal another NaN

--[[--------------------------------------------------------------------
-- code generator functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- Marks the end of a patch list. It is an invalid value both as an absolute
-- address, and as a list link (would link an element to itself).
------------------------------------------------------------------------
luaK.NO_JUMP = -1

------------------------------------------------------------------------
-- grep "ORDER OPR" if you change these enums
------------------------------------------------------------------------
luaK.BinOpr = {
  OPR_ADD = 0, OPR_SUB = 1, OPR_MUL = 2, OPR_DIV = 3, OPR_MOD = 4, OPR_POW = 5,
  OPR_CONCAT = 6,
  OPR_NE = 7, OPR_EQ = 8,
  OPR_LT = 9, OPR_LE = 10, OPR_GT = 11, OPR_GE = 12,
  OPR_AND = 13, OPR_OR = 14,
  OPR_NOBINOPR = 15,
}

-- * UnOpr is used by luaK:prefix's op argument, but not directly used
--   because the function receives the symbols as strings, e.g. "OPR_NOT"
luaK.UnOpr = {
  OPR_MINUS = 0, OPR_NOT = 1, OPR_LEN = 2, OPR_NOUNOPR = 3
}

------------------------------------------------------------------------
-- returns the instruction object for given e (expdesc), was a macro
------------------------------------------------------------------------
function luaK:getcode(fs, e)
  return fs.f.code[e.info]
end

------------------------------------------------------------------------
-- codes an instruction with a signed Bx (sBx) field, was a macro
-- * used in luaK:jump(), (lparser) luaY:forbody()
------------------------------------------------------------------------
function luaK:codeAsBx(fs, o, A, sBx)
  return self:codeABx(fs, o, A, sBx + luaP.MAXARG_sBx)
end

------------------------------------------------------------------------
-- set the expdesc e instruction for multiple returns, was a macro
------------------------------------------------------------------------
function luaK:setmultret(fs, e)
  self:setreturns(fs, e, luaY.LUA_MULTRET)
end

------------------------------------------------------------------------
-- there is a jump if patch lists are not identical, was a macro
-- * used in luaK:exp2reg(), luaK:exp2anyreg(), luaK:exp2val()
------------------------------------------------------------------------
function luaK:hasjumps(e)
  return e.t ~= e.f
end

------------------------------------------------------------------------
-- true if the expression is a constant number (for constant folding)
-- * used in constfolding(), infix()
------------------------------------------------------------------------
function luaK:isnumeral(e)
  return e.k == "VKNUM" and e.t == self.NO_JUMP and e.f == self.NO_JUMP
end

------------------------------------------------------------------------
-- codes loading of nil, optimization done if consecutive locations
-- * used in luaK:discharge2reg(), (lparser) luaY:adjust_assign()
------------------------------------------------------------------------
function luaK:_nil(fs, from, n)
  if fs.pc > fs.lasttarget then  -- no jumps to current position?
    if fs.pc == 0 then  -- function start?
      if from >= fs.nactvar then
        return  -- positions are already clean
      end
    else
      local previous = fs.f.code[fs.pc - 1]
      if luaP:GET_OPCODE(previous) == "OP_LOADNIL" then
        local pfrom = luaP:GETARG_A(previous)
        local pto = luaP:GETARG_B(previous)
        if pfrom <= from and from <= pto + 1 then  -- can connect both?
          if from + n - 1 > pto then
            luaP:SETARG_B(previous, from + n - 1)
          end
          return
        end
      end
    end
  end
  self:codeABC(fs, "OP_LOADNIL", from, from + n - 1, 0)  -- else no optimization
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:jump(fs)
  local jpc = fs.jpc  -- save list of jumps to here
  fs.jpc = self.NO_JUMP
  local j = self:codeAsBx(fs, "OP_JMP", 0, self.NO_JUMP)
  j = self:concat(fs, j, jpc)  -- keep them on hold
  return j
end

------------------------------------------------------------------------
-- codes a RETURN instruction
-- * used in luaY:close_func(), luaY:retstat()
------------------------------------------------------------------------
function luaK:ret(fs, first, nret)
  self:codeABC(fs, "OP_RETURN", first, nret + 1, 0)
end

------------------------------------------------------------------------
--
-- * used in luaK:jumponcond(), luaK:codecomp()
------------------------------------------------------------------------
function luaK:condjump(fs, op, A, B, C)
  self:codeABC(fs, op, A, B, C)
  return self:jump(fs)
end

------------------------------------------------------------------------
--
-- * used in luaK:patchlistaux(), luaK:concat()
------------------------------------------------------------------------
function luaK:fixjump(fs, pc, dest)
  local jmp = fs.f.code[pc]
  local offset = dest - (pc + 1)
  assert(dest ~= self.NO_JUMP)
  if math.abs(offset) > luaP.MAXARG_sBx then
    luaX:syntaxerror(fs.ls, "control structure too long")
  end
  luaP:SETARG_sBx(jmp, offset)
end

------------------------------------------------------------------------
-- returns current 'pc' and marks it as a jump target (to avoid wrong
-- optimizations with consecutive instructions not in the same basic block).
-- * used in multiple locations
-- * fs.lasttarget tested only by luaK:_nil() when optimizing OP_LOADNIL
------------------------------------------------------------------------
function luaK:getlabel(fs)
  fs.lasttarget = fs.pc
  return fs.pc
end

------------------------------------------------------------------------
--
-- * used in luaK:need_value(), luaK:removevalues(), luaK:patchlistaux(),
--   luaK:concat()
------------------------------------------------------------------------
function luaK:getjump(fs, pc)
  local offset = luaP:GETARG_sBx(fs.f.code[pc])
  if offset == self.NO_JUMP then  -- point to itself represents end of list
    return self.NO_JUMP  -- end of list
  else
    return (pc + 1) + offset  -- turn offset into absolute position
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:need_value(), luaK:patchtestreg(), luaK:invertjump()
------------------------------------------------------------------------
function luaK:getjumpcontrol(fs, pc)
  local pi = fs.f.code[pc]
  local ppi = fs.f.code[pc - 1]
  if pc >= 1 and luaP:testTMode(luaP:GET_OPCODE(ppi)) ~= 0 then
    return ppi
  else
    return pi
  end
end

------------------------------------------------------------------------
-- check whether list has any jump that do not produce a value
-- (or produce an inverted value)
-- * return value changed to boolean
-- * used only in luaK:exp2reg()
------------------------------------------------------------------------
function luaK:need_value(fs, list)
  while list ~= self.NO_JUMP do
    local i = self:getjumpcontrol(fs, list)
    if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then return true end
    list = self:getjump(fs, list)
  end
  return false  -- not found
end

------------------------------------------------------------------------
--
-- * used in luaK:removevalues(), luaK:patchlistaux()
------------------------------------------------------------------------
function luaK:patchtestreg(fs, node, reg)
  local i = self:getjumpcontrol(fs, node)
  if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
    return false  -- cannot patch other instructions
  end
  if reg ~= luaP.NO_REG and reg ~= luaP:GETARG_B(i) then
    luaP:SETARG_A(i, reg)
  else  -- no register to put value or register already has the value
    -- due to use of a table as i, i cannot be replaced by another table
    -- so the following is required; there is no change to ARG_C
    luaP:SET_OPCODE(i, "OP_TEST")
    local b = luaP:GETARG_B(i)
    luaP:SETARG_A(i, b)
    luaP:SETARG_B(i, 0)
    -- *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i)); /* C */
  end
  return true
end

------------------------------------------------------------------------
--
-- * used only in luaK:codenot()
------------------------------------------------------------------------
function luaK:removevalues(fs, list)
  while list ~= self.NO_JUMP do
    self:patchtestreg(fs, list, luaP.NO_REG)
    list = self:getjump(fs, list)
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:dischargejpc(), luaK:patchlist(), luaK:exp2reg()
------------------------------------------------------------------------
function luaK:patchlistaux(fs, list, vtarget, reg, dtarget)
  while list ~= self.NO_JUMP do
    local _next = self:getjump(fs, list)
    if self:patchtestreg(fs, list, reg) then
      self:fixjump(fs, list, vtarget)
    else
      self:fixjump(fs, list, dtarget)  -- jump to default target
    end
    list = _next
  end
end

------------------------------------------------------------------------
--
-- * used only in luaK:code()
------------------------------------------------------------------------
function luaK:dischargejpc(fs)
  self:patchlistaux(fs, fs.jpc, fs.pc, luaP.NO_REG, fs.pc)
  fs.jpc = self.NO_JUMP
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:whilestat(), luaY:repeatstat(), luaY:forbody()
------------------------------------------------------------------------
function luaK:patchlist(fs, list, target)
  if target == fs.pc then
    self:patchtohere(fs, list)
  else
    assert(target < fs.pc)
    self:patchlistaux(fs, list, target, luaP.NO_REG, target)
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:patchtohere(fs, list)
  self:getlabel(fs)
  fs.jpc = self:concat(fs, fs.jpc, list)
end

------------------------------------------------------------------------
-- * l1 was a pointer, now l1 is returned and callee assigns the value
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:concat(fs, l1, l2)
  if l2 == self.NO_JUMP then return l1
  elseif l1 == self.NO_JUMP then
    return l2
  else
    local list = l1
    local _next = self:getjump(fs, list)
    while _next ~= self.NO_JUMP do  -- find last element
      list = _next
      _next = self:getjump(fs, list)
    end
    self:fixjump(fs, list, l2)
  end
  return l1
end

------------------------------------------------------------------------
--
-- * used in luaK:reserveregs(), (lparser) luaY:forlist()
------------------------------------------------------------------------
function luaK:checkstack(fs, n)
  local newstack = fs.freereg + n
  if newstack > fs.f.maxstacksize then
    if newstack >= self.MAXSTACK then
      luaX:syntaxerror(fs.ls, "function or expression too complex")
    end
    fs.f.maxstacksize = newstack
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:reserveregs(fs, n)
  self:checkstack(fs, n)
  fs.freereg = fs.freereg + n
end

------------------------------------------------------------------------
--
-- * used in luaK:freeexp(), luaK:dischargevars()
------------------------------------------------------------------------
function luaK:freereg(fs, reg)
  if not luaP:ISK(reg) and reg >= fs.nactvar then
    fs.freereg = fs.freereg - 1
    assert(reg == fs.freereg)
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:freeexp(fs, e)
  if e.k == "VNONRELOC" then
    self:freereg(fs, e.info)
  end
end

------------------------------------------------------------------------
-- * TODO NOTE implementation is not 100% correct, since the assert fails
-- * luaH_set, setobj deleted; direct table access used instead
-- * used in luaK:stringK(), luaK:numberK(), luaK:boolK(), luaK:nilK()
------------------------------------------------------------------------
function luaK:addk(fs, k, v)
  local L = fs.L
  local idx = fs.h[k.value]
  --TValue *idx = luaH_set(L, fs->h, k); /* C */
  local f = fs.f
  if self:ttisnumber(idx) then
    --TODO this assert currently FAILS (last tested for 5.0.2)
    --assert(fs.f.k[self:nvalue(idx)] == v)
    --assert(luaO_rawequalObj(&fs->f->k[cast_int(nvalue(idx))], v)); /* C */
    return self:nvalue(idx)
  else -- constant not found; create a new entry
    idx = {}
    self:setnvalue(idx, fs.nk)
    fs.h[k.value] = idx
    -- setnvalue(idx, cast_num(fs->nk)); /* C */
    luaY:growvector(L, f.k, fs.nk, f.sizek, nil,
                    luaP.MAXARG_Bx, "constant table overflow")
    -- loop to initialize empty f.k positions not required
    f.k[fs.nk] = v
    -- setobj(L, &f->k[fs->nk], v); /* C */
    -- luaC_barrier(L, f, v); /* GC */
    local nk = fs.nk
    fs.nk = fs.nk + 1
    return nk
  end

end

------------------------------------------------------------------------
-- creates and sets a string object
-- * used in (lparser) luaY:codestring(), luaY:singlevar()
------------------------------------------------------------------------
function luaK:stringK(fs, s)
  local o = {}  -- TValue
  self:setsvalue(o, s)
  return self:addk(fs, o, o)
end

------------------------------------------------------------------------
-- creates and sets a number object
-- * used in luaK:prefix() for negative (or negation of) numbers
-- * used in (lparser) luaY:simpleexp(), luaY:fornum()
------------------------------------------------------------------------
function luaK:numberK(fs, r)
  local o = {}  -- TValue
  self:setnvalue(o, r)
  return self:addk(fs, o, o)
end

------------------------------------------------------------------------
-- creates and sets a boolean object
-- * used only in luaK:exp2RK()
------------------------------------------------------------------------
function luaK:boolK(fs, b)
  local o = {}  -- TValue
  self:setbvalue(o, b)
  return self:addk(fs, o, o)
end

------------------------------------------------------------------------
-- creates and sets a nil object
-- * used only in luaK:exp2RK()
------------------------------------------------------------------------
function luaK:nilK(fs)
  local k, v = {}, {}  -- TValue
  self:setnilvalue(v)
  -- cannot use nil as key; instead use table itself to represent nil
  self:sethvalue(k, fs.h)
  return self:addk(fs, k, v)
end

------------------------------------------------------------------------
--
-- * used in luaK:setmultret(), (lparser) luaY:adjust_assign()
------------------------------------------------------------------------
function luaK:setreturns(fs, e, nresults)
  if e.k == "VCALL" then  -- expression is an open function call?
    luaP:SETARG_C(self:getcode(fs, e), nresults + 1)
  elseif e.k == "VVARARG" then
    luaP:SETARG_B(self:getcode(fs, e), nresults + 1);
    luaP:SETARG_A(self:getcode(fs, e), fs.freereg);
    luaK:reserveregs(fs, 1)
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:dischargevars(), (lparser) luaY:assignment()
------------------------------------------------------------------------
function luaK:setoneret(fs, e)
  if e.k == "VCALL" then  -- expression is an open function call?
    e.k = "VNONRELOC"
    e.info = luaP:GETARG_A(self:getcode(fs, e))
  elseif e.k == "VVARARG" then
    luaP:SETARG_B(self:getcode(fs, e), 2)
    e.k = "VRELOCABLE"  -- can relocate its simple result
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:dischargevars(fs, e)
  local k = e.k
  if k == "VLOCAL" then
    e.k = "VNONRELOC"
  elseif k == "VUPVAL" then
    e.info = self:codeABC(fs, "OP_GETUPVAL", 0, e.info, 0)
    e.k = "VRELOCABLE"
  elseif k == "VGLOBAL" then
    e.info = self:codeABx(fs, "OP_GETGLOBAL", 0, e.info)
    e.k = "VRELOCABLE"
  elseif k == "VINDEXED" then
    self:freereg(fs, e.aux)
    self:freereg(fs, e.info)
    e.info = self:codeABC(fs, "OP_GETTABLE", 0, e.info, e.aux)
    e.k = "VRELOCABLE"
  elseif k == "VVARARG" or k == "VCALL" then
    self:setoneret(fs, e)
  else
    -- there is one value available (somewhere)
  end
end

------------------------------------------------------------------------
--
-- * used only in luaK:exp2reg()
------------------------------------------------------------------------
function luaK:code_label(fs, A, b, jump)
  self:getlabel(fs)  -- those instructions may be jump targets
  return self:codeABC(fs, "OP_LOADBOOL", A, b, jump)
end

------------------------------------------------------------------------
--
-- * used in luaK:discharge2anyreg(), luaK:exp2reg()
------------------------------------------------------------------------
function luaK:discharge2reg(fs, e, reg)
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VNIL" then
    self:_nil(fs, reg, 1)
  elseif k == "VFALSE" or k == "VTRUE" then
    self:codeABC(fs, "OP_LOADBOOL", reg, (e.k == "VTRUE") and 1 or 0, 0)
  elseif k == "VK" then
    self:codeABx(fs, "OP_LOADK", reg, e.info)
  elseif k == "VKNUM" then
    self:codeABx(fs, "OP_LOADK", reg, self:numberK(fs, e.nval))
  elseif k == "VRELOCABLE" then
    local pc = self:getcode(fs, e)
    luaP:SETARG_A(pc, reg)
  elseif k == "VNONRELOC" then
    if reg ~= e.info then
      self:codeABC(fs, "OP_MOVE", reg, e.info, 0)
    end
  else
    assert(e.k == "VVOID" or e.k == "VJMP")
    return  -- nothing to do...
  end
  e.info = reg
  e.k = "VNONRELOC"
end

------------------------------------------------------------------------
--
-- * used in luaK:jumponcond(), luaK:codenot()
------------------------------------------------------------------------
function luaK:discharge2anyreg(fs, e)
  if e.k ~= "VNONRELOC" then
    self:reserveregs(fs, 1)
    self:discharge2reg(fs, e, fs.freereg - 1)
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:exp2nextreg(), luaK:exp2anyreg(), luaK:storevar()
------------------------------------------------------------------------
function luaK:exp2reg(fs, e, reg)
  self:discharge2reg(fs, e, reg)
  if e.k == "VJMP" then
    e.t = self:concat(fs, e.t, e.info)  -- put this jump in 't' list
  end
  if self:hasjumps(e) then
    local final  -- position after whole expression
    local p_f = self.NO_JUMP  -- position of an eventual LOAD false
    local p_t = self.NO_JUMP  -- position of an eventual LOAD true
    if self:need_value(fs, e.t) or self:need_value(fs, e.f) then
      local fj = (e.k == "VJMP") and self.NO_JUMP or self:jump(fs)
      p_f = self:code_label(fs, reg, 0, 1)
      p_t = self:code_label(fs, reg, 1, 0)
      self:patchtohere(fs, fj)
    end
    final = self:getlabel(fs)
    self:patchlistaux(fs, e.f, final, reg, p_f)
    self:patchlistaux(fs, e.t, final, reg, p_t)
  end
  e.f, e.t = self.NO_JUMP, self.NO_JUMP
  e.info = reg
  e.k = "VNONRELOC"
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:exp2nextreg(fs, e)
  self:dischargevars(fs, e)
  self:freeexp(fs, e)
  self:reserveregs(fs, 1)
  self:exp2reg(fs, e, fs.freereg - 1)
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:exp2anyreg(fs, e)
  self:dischargevars(fs, e)
  if e.k == "VNONRELOC" then
    if not self:hasjumps(e) then  -- exp is already in a register
      return e.info
    end
    if e.info >= fs.nactvar then  -- reg. is not a local?
      self:exp2reg(fs, e, e.info)  -- put value on it
      return e.info
    end
  end
  self:exp2nextreg(fs, e)  -- default
  return e.info
end

------------------------------------------------------------------------
--
-- * used in luaK:exp2RK(), luaK:prefix(), luaK:posfix()
-- * used in (lparser) luaY:yindex()
------------------------------------------------------------------------
function luaK:exp2val(fs, e)
  if self:hasjumps(e) then
    self:exp2anyreg(fs, e)
  else
    self:dischargevars(fs, e)
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:exp2RK(fs, e)
  self:exp2val(fs, e)
  local k = e.k
  if k == "VKNUM" or k == "VTRUE" or k == "VFALSE" or k == "VNIL" then
    if fs.nk <= luaP.MAXINDEXRK then  -- constant fit in RK operand?
      -- converted from a 2-deep ternary operator expression
      if e.k == "VNIL" then
        e.info = self:nilK(fs)
      else
        e.info = (e.k == "VKNUM") and self:numberK(fs, e.nval)
                                  or self:boolK(fs, e.k == "VTRUE")
      end
      e.k = "VK"
      return luaP:RKASK(e.info)
    end
  elseif k == "VK" then
    if e.info <= luaP.MAXINDEXRK then  -- constant fit in argC?
      return luaP:RKASK(e.info)
    end
  else
    -- default
  end
  -- not a constant in the right range: put it in a register
  return self:exp2anyreg(fs, e)
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:assignment(), luaY:localfunc(), luaY:funcstat()
------------------------------------------------------------------------
function luaK:storevar(fs, var, ex)
  local k = var.k
  if k == "VLOCAL" then
    self:freeexp(fs, ex)
    self:exp2reg(fs, ex, var.info)
    return
  elseif k == "VUPVAL" then
    local e = self:exp2anyreg(fs, ex)
    self:codeABC(fs, "OP_SETUPVAL", e, var.info, 0)
  elseif k == "VGLOBAL" then
    local e = self:exp2anyreg(fs, ex)
    self:codeABx(fs, "OP_SETGLOBAL", e, var.info)
  elseif k == "VINDEXED" then
    local e = self:exp2RK(fs, ex)
    self:codeABC(fs, "OP_SETTABLE", var.info, var.aux, e)
  else
    assert(0)  -- invalid var kind to store
  end
  self:freeexp(fs, ex)
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:primaryexp()
------------------------------------------------------------------------
function luaK:_self(fs, e, key)
  self:exp2anyreg(fs, e)
  self:freeexp(fs, e)
  local func = fs.freereg
  self:reserveregs(fs, 2)
  self:codeABC(fs, "OP_SELF", func, e.info, self:exp2RK(fs, key))
  self:freeexp(fs, key)
  e.info = func
  e.k = "VNONRELOC"
end

------------------------------------------------------------------------
--
-- * used in luaK:goiftrue(), luaK:codenot()
------------------------------------------------------------------------
function luaK:invertjump(fs, e)
  local pc = self:getjumpcontrol(fs, e.info)
  assert(luaP:testTMode(luaP:GET_OPCODE(pc)) ~= 0 and
             luaP:GET_OPCODE(pc) ~= "OP_TESTSET" and
             luaP:GET_OPCODE(pc) ~= "OP_TEST")
  luaP:SETARG_A(pc, (luaP:GETARG_A(pc) == 0) and 1 or 0)
end

------------------------------------------------------------------------
--
-- * used in luaK:goiftrue(), luaK:goiffalse()
------------------------------------------------------------------------
function luaK:jumponcond(fs, e, cond)
  if e.k == "VRELOCABLE" then
    local ie = self:getcode(fs, e)
    if luaP:GET_OPCODE(ie) == "OP_NOT" then
      fs.pc = fs.pc - 1  -- remove previous OP_NOT
      return self:condjump(fs, "OP_TEST", luaP:GETARG_B(ie), 0, cond and 0 or 1)
    end
    -- else go through
  end
  self:discharge2anyreg(fs, e)
  self:freeexp(fs, e)
  return self:condjump(fs, "OP_TESTSET", luaP.NO_REG, e.info, cond and 1 or 0)
end

------------------------------------------------------------------------
--
-- * used in luaK:infix(), (lparser) luaY:cond()
------------------------------------------------------------------------
function luaK:goiftrue(fs, e)
  local pc  -- pc of last jump
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VK" or k == "VKNUM" or k == "VTRUE" then
    pc = self.NO_JUMP  -- always true; do nothing
  elseif k == "VFALSE" then
    pc = self:jump(fs)  -- always jump
  elseif k == "VJMP" then
    self:invertjump(fs, e)
    pc = e.info
  else
    pc = self:jumponcond(fs, e, false)
  end
  e.f = self:concat(fs, e.f, pc)  -- insert last jump in `f' list
  self:patchtohere(fs, e.t)
  e.t = self.NO_JUMP
end

------------------------------------------------------------------------
--
-- * used in luaK:infix()
------------------------------------------------------------------------
function luaK:goiffalse(fs, e)
  local pc  -- pc of last jump
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VNIL" or k == "VFALSE"then
    pc = self.NO_JUMP  -- always false; do nothing
  elseif k == "VTRUE" then
    pc = self:jump(fs)  -- always jump
  elseif k == "VJMP" then
    pc = e.info
  else
    pc = self:jumponcond(fs, e, true)
  end
  e.t = self:concat(fs, e.t, pc)  -- insert last jump in `t' list
  self:patchtohere(fs, e.f)
  e.f = self.NO_JUMP
end

------------------------------------------------------------------------
--
-- * used only in luaK:prefix()
------------------------------------------------------------------------
function luaK:codenot(fs, e)
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VNIL" or k == "VFALSE" then
    e.k = "VTRUE"
  elseif k == "VK" or k == "VKNUM" or k == "VTRUE" then
    e.k = "VFALSE"
  elseif k == "VJMP" then
    self:invertjump(fs, e)
  elseif k == "VRELOCABLE" or k == "VNONRELOC" then
    self:discharge2anyreg(fs, e)
    self:freeexp(fs, e)
    e.info = self:codeABC(fs, "OP_NOT", 0, e.info, 0)
    e.k = "VRELOCABLE"
  else
    assert(0)  -- cannot happen
  end
  -- interchange true and false lists
  e.f, e.t = e.t, e.f
  self:removevalues(fs, e.f)
  self:removevalues(fs, e.t)
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:field(), luaY:primaryexp()
------------------------------------------------------------------------
function luaK:indexed(fs, t, k)
  t.aux = self:exp2RK(fs, k)
  t.k = "VINDEXED"
end

------------------------------------------------------------------------
--
-- * used only in luaK:codearith()
------------------------------------------------------------------------
function luaK:constfolding(op, e1, e2)
  local r
  if not self:isnumeral(e1) or not self:isnumeral(e2) then return false end
  local v1 = e1.nval
  local v2 = e2.nval
  if op == "OP_ADD" then
    r = self:numadd(v1, v2)
  elseif op == "OP_SUB" then
    r = self:numsub(v1, v2)
  elseif op == "OP_MUL" then
    r = self:nummul(v1, v2)
  elseif op == "OP_DIV" then
    if v2 == 0 then return false end  -- do not attempt to divide by 0
    r = self:numdiv(v1, v2)
  elseif op == "OP_MOD" then
    if v2 == 0 then return false end  -- do not attempt to divide by 0
    r = self:nummod(v1, v2)
  elseif op == "OP_POW" then
    r = self:numpow(v1, v2)
  elseif op == "OP_UNM" then
    r = self:numunm(v1)
  elseif op == "OP_LEN" then
    return false  -- no constant folding for 'len'
  else
    assert(0)
    r = 0
  end
  if self:numisnan(r) then return false end  -- do not attempt to produce NaN
  e1.nval = r
  return true
end

------------------------------------------------------------------------
--
-- * used in luaK:prefix(), luaK:posfix()
------------------------------------------------------------------------
function luaK:codearith(fs, op, e1, e2)
  if self:constfolding(op, e1, e2) then
    return
  else
    local o2 = (op ~= "OP_UNM" and op ~= "OP_LEN") and self:exp2RK(fs, e2) or 0
    local o1 = self:exp2RK(fs, e1)
    if o1 > o2 then
      self:freeexp(fs, e1)
      self:freeexp(fs, e2)
    else
      self:freeexp(fs, e2)
      self:freeexp(fs, e1)
    end
    e1.info = self:codeABC(fs, op, 0, o1, o2)
    e1.k = "VRELOCABLE"
  end
end

------------------------------------------------------------------------
--
-- * used only in luaK:posfix()
------------------------------------------------------------------------
function luaK:codecomp(fs, op, cond, e1, e2)
  local o1 = self:exp2RK(fs, e1)
  local o2 = self:exp2RK(fs, e2)
  self:freeexp(fs, e2)
  self:freeexp(fs, e1)
  if cond == 0 and op ~= "OP_EQ" then
    -- exchange args to replace by `<' or `<='
    o1, o2 = o2, o1  -- o1 <==> o2
    cond = 1
  end
  e1.info = self:condjump(fs, op, cond, o1, o2)
  e1.k = "VJMP"
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:subexpr()
------------------------------------------------------------------------
function luaK:prefix(fs, op, e)
  local e2 = {}  -- expdesc
  e2.t, e2.f = self.NO_JUMP, self.NO_JUMP
  e2.k = "VKNUM"
  e2.nval = 0
  if op == "OPR_MINUS" then
    if not self:isnumeral(e) then
      self:exp2anyreg(fs, e)  -- cannot operate on non-numeric constants
    end
    self:codearith(fs, "OP_UNM", e, e2)
  elseif op == "OPR_NOT" then
    self:codenot(fs, e)
  elseif op == "OPR_LEN" then
    self:exp2anyreg(fs, e)  -- cannot operate on constants
    self:codearith(fs, "OP_LEN", e, e2)
  else
    assert(0)
  end
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:subexpr()
------------------------------------------------------------------------
function luaK:infix(fs, op, v)
  if op == "OPR_AND" then
    self:goiftrue(fs, v)
  elseif op == "OPR_OR" then
    self:goiffalse(fs, v)
  elseif op == "OPR_CONCAT" then
    self:exp2nextreg(fs, v)  -- operand must be on the 'stack'
  elseif op == "OPR_ADD" or op == "OPR_SUB" or
         op == "OPR_MUL" or op == "OPR_DIV" or
         op == "OPR_MOD" or op == "OPR_POW" then
    if not self:isnumeral(v) then self:exp2RK(fs, v) end
  else
    self:exp2RK(fs, v)
  end
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:subexpr()
------------------------------------------------------------------------
-- table lookups to simplify testing
luaK.arith_op = {
  OPR_ADD = "OP_ADD", OPR_SUB = "OP_SUB", OPR_MUL = "OP_MUL",
  OPR_DIV = "OP_DIV", OPR_MOD = "OP_MOD", OPR_POW = "OP_POW",
}
luaK.comp_op = {
  OPR_EQ = "OP_EQ", OPR_NE = "OP_EQ", OPR_LT = "OP_LT",
  OPR_LE = "OP_LE", OPR_GT = "OP_LT", OPR_GE = "OP_LE",
}
luaK.comp_cond = {
  OPR_EQ = 1, OPR_NE = 0, OPR_LT = 1,
  OPR_LE = 1, OPR_GT = 0, OPR_GE = 0,
}
function luaK:posfix(fs, op, e1, e2)
  -- needed because e1 = e2 doesn't copy values...
  -- * in 5.0.x, only k/info/aux/t/f copied, t for AND, f for OR
  --   but here, all elements are copied for completeness' sake
  local function copyexp(e1, e2)
    e1.k = e2.k
    e1.info = e2.info; e1.aux = e2.aux
    e1.nval = e2.nval
    e1.t = e2.t; e1.f = e2.f
  end
  if op == "OPR_AND" then
    assert(e1.t == self.NO_JUMP)  -- list must be closed
    self:dischargevars(fs, e2)
    e2.f = self:concat(fs, e2.f, e1.f)
    copyexp(e1, e2)
  elseif op == "OPR_OR" then
    assert(e1.f == self.NO_JUMP)  -- list must be closed
    self:dischargevars(fs, e2)
    e2.t = self:concat(fs, e2.t, e1.t)
    copyexp(e1, e2)
  elseif op == "OPR_CONCAT" then
    self:exp2val(fs, e2)
    if e2.k == "VRELOCABLE" and luaP:GET_OPCODE(self:getcode(fs, e2)) == "OP_CONCAT" then
      assert(e1.info == luaP:GETARG_B(self:getcode(fs, e2)) - 1)
      self:freeexp(fs, e1)
      luaP:SETARG_B(self:getcode(fs, e2), e1.info)
      e1.k = "VRELOCABLE"
      e1.info = e2.info
    else
      self:exp2nextreg(fs, e2)  -- operand must be on the 'stack'
      self:codearith(fs, "OP_CONCAT", e1, e2)
    end
  else
    -- the following uses a table lookup in place of conditionals
    local arith = self.arith_op[op]
    if arith then
      self:codearith(fs, arith, e1, e2)
    else
      local comp = self.comp_op[op]
      if comp then
        self:codecomp(fs, comp, self.comp_cond[op], e1, e2)
      else
        assert(0)
      end
    end--if arith
  end--if op
end

------------------------------------------------------------------------
-- adjusts debug information for last instruction written, in order to
-- change the line where item comes into existence
-- * used in (lparser) luaY:funcargs(), luaY:forbody(), luaY:funcstat()
------------------------------------------------------------------------
function luaK:fixline(fs, line)
  fs.f.lineinfo[fs.pc - 1] = line
end

------------------------------------------------------------------------
-- general function to write an instruction into the instruction buffer,
-- sets debug information too
-- * used in luaK:codeABC(), luaK:codeABx()
-- * called directly by (lparser) luaY:whilestat()
------------------------------------------------------------------------
function luaK:code(fs, i, line)
  local f = fs.f
  self:dischargejpc(fs)  -- 'pc' will change
  -- put new instruction in code array
  luaY:growvector(fs.L, f.code, fs.pc, f.sizecode, nil,
                  luaY.MAX_INT, "code size overflow")
  f.code[fs.pc] = i
  -- save corresponding line information
  luaY:growvector(fs.L, f.lineinfo, fs.pc, f.sizelineinfo, nil,
                  luaY.MAX_INT, "code size overflow")
  f.lineinfo[fs.pc] = line
  local pc = fs.pc
  fs.pc = fs.pc + 1
  return pc
end

------------------------------------------------------------------------
-- writes an instruction of type ABC
-- * calls luaK:code()
------------------------------------------------------------------------
function luaK:codeABC(fs, o, a, b, c)
  assert(luaP:getOpMode(o) == luaP.OpMode.iABC)
  assert(luaP:getBMode(o) ~= luaP.OpArgMask.OpArgN or b == 0)
  assert(luaP:getCMode(o) ~= luaP.OpArgMask.OpArgN or c == 0)
  return self:code(fs, luaP:CREATE_ABC(o, a, b, c), fs.ls.lastline)
end

------------------------------------------------------------------------
-- writes an instruction of type ABx
-- * calls luaK:code(), called by luaK:codeAsBx()
------------------------------------------------------------------------
function luaK:codeABx(fs, o, a, bc)
  assert(luaP:getOpMode(o) == luaP.OpMode.iABx or
             luaP:getOpMode(o) == luaP.OpMode.iAsBx)
  assert(luaP:getCMode(o) == luaP.OpArgMask.OpArgN)
  return self:code(fs, luaP:CREATE_ABx(o, a, bc), fs.ls.lastline)
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:closelistfield(), luaY:lastlistfield()
------------------------------------------------------------------------
function luaK:setlist(fs, base, nelems, tostore)
  local c = math.floor((nelems - 1)/luaP.LFIELDS_PER_FLUSH) + 1
  local b = (tostore == luaY.LUA_MULTRET) and 0 or tostore
  assert(tostore ~= 0)
  if c <= luaP.MAXARG_C then
    self:codeABC(fs, "OP_SETLIST", base, b, c)
  else
    self:codeABC(fs, "OP_SETLIST", base, b, 0)
    self:code(fs, luaP:CREATE_Inst(c), fs.ls.lastline)
  end
  fs.freereg = base + 1  -- free registers with list values
end

_G.luavm.luaK = function(a) luaY = a return luaK end
end
function scmframework_cb6eaaa450d2758ceaf82cb60b4d8a49() --$CONTENT_DATA/Scripts/remade-scrapVM/LuaVM/LuaP.lua
--[[--------------------------------------------------------------------

  lopcodes.lua
  Lua 5 virtual machine opcodes in Lua
  This file is part of Yueliang.

  Copyright (c) 2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * an Instruction is a table with OP, A, B, C, Bx elements; this
--   makes the code easy to follow and should allow instruction handling
--   to work with doubles and ints
-- * WARNING luaP:Instruction outputs instructions encoded in little-
--   endian form and field size and positions are hard-coded
--
-- Not implemented:
-- *
--
-- Added:
-- * luaP:CREATE_Inst(c): create an inst from a number (for OP_SETLIST)
-- * luaP:Instruction(i): convert field elements to a 4-char string
-- * luaP:DecodeInst(x): convert 4-char string into field elements
--
-- Changed in 5.1.x:
-- * POS_OP added, instruction field positions changed
-- * some symbol names may have changed, e.g. LUAI_BITSINT
-- * new operators for RK indices: BITRK, ISK(x), INDEXK(r), RKASK(x)
-- * OP_MOD, OP_LEN is new
-- * OP_TEST is now OP_TESTSET, OP_TEST is new
-- * OP_FORLOOP, OP_TFORLOOP adjusted, OP_FORPREP is new
-- * OP_TFORPREP deleted
-- * OP_SETLIST and OP_SETLISTO merged and extended
-- * OP_VARARG is new
-- * many changes to implementation of OpMode data
----------------------------------------------------------------------]]

local luaP = {}

--[[
===========================================================================
  We assume that instructions are unsigned numbers.
  All instructions have an opcode in the first 6 bits.
  Instructions can have the following fields:
        'A' : 8 bits
        'B' : 9 bits
        'C' : 9 bits
        'Bx' : 18 bits ('B' and 'C' together)
        'sBx' : signed Bx

  A signed argument is represented in excess K; that is, the number
  value is the unsigned value minus K. K is exactly the maximum value
  for that argument (so that -max is represented by 0, and +max is
  represented by 2*max), which is half the maximum for the corresponding
  unsigned argument.
===========================================================================
--]]

luaP.OpMode = { iABC = 0, iABx = 1, iAsBx = 2 }  -- basic instruction format

------------------------------------------------------------------------
-- size and position of opcode arguments.
-- * WARNING size and position is hard-coded elsewhere in this script
------------------------------------------------------------------------
luaP.SIZE_C  = 9
luaP.SIZE_B  = 9
luaP.SIZE_Bx = luaP.SIZE_C + luaP.SIZE_B
luaP.SIZE_A  = 8

luaP.SIZE_OP = 6

luaP.POS_OP = 0
luaP.POS_A  = luaP.POS_OP + luaP.SIZE_OP
luaP.POS_C  = luaP.POS_A + luaP.SIZE_A
luaP.POS_B  = luaP.POS_C + luaP.SIZE_C
luaP.POS_Bx = luaP.POS_C

------------------------------------------------------------------------
-- limits for opcode arguments.
-- we use (signed) int to manipulate most arguments,
-- so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
------------------------------------------------------------------------
-- removed "#if SIZE_Bx < BITS_INT-1" test, assume this script is
-- running on a Lua VM with double or int as LUA_NUMBER

luaP.MAXARG_Bx  = math.ldexp(1, luaP.SIZE_Bx) - 1
luaP.MAXARG_sBx = math.floor(luaP.MAXARG_Bx / 2)  -- 'sBx' is signed

luaP.MAXARG_A = math.ldexp(1, luaP.SIZE_A) - 1
luaP.MAXARG_B = math.ldexp(1, luaP.SIZE_B) - 1
luaP.MAXARG_C = math.ldexp(1, luaP.SIZE_C) - 1

-- creates a mask with 'n' 1 bits at position 'p'
-- MASK1(n,p) deleted, not required
-- creates a mask with 'n' 0 bits at position 'p'
-- MASK0(n,p) deleted, not required

--[[--------------------------------------------------------------------
  Visual representation for reference:

   31    |    |     |            0      bit position
    +-----+-----+-----+----------+
    |  B  |  C  |  A  |  Opcode  |      iABC format
    +-----+-----+-----+----------+
    -  9  -  9  -  8  -    6     -      field sizes
    +-----+-----+-----+----------+
    |   [s]Bx   |  A  |  Opcode  |      iABx | iAsBx format
    +-----+-----+-----+----------+

----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- the following macros help to manipulate instructions
-- * changed to a table object representation, very clean compared to
--   the [nightmare] alternatives of using a number or a string
-- * Bx is a separate element from B and C, since there is never a need
--   to split Bx in the parser or code generator
------------------------------------------------------------------------

-- these accept or return opcodes in the form of string names
function luaP:GET_OPCODE(i) return self.ROpCode[i.OP] end
function luaP:SET_OPCODE(i, o) i.OP = self.OpCode[o] end

function luaP:GETARG_A(i) return i.A end
function luaP:SETARG_A(i, u) i.A = u end

function luaP:GETARG_B(i) return i.B end
function luaP:SETARG_B(i, b) i.B = b end

function luaP:GETARG_C(i) return i.C end
function luaP:SETARG_C(i, b) i.C = b end

function luaP:GETARG_Bx(i) return i.Bx end
function luaP:SETARG_Bx(i, b) i.Bx = b end

function luaP:GETARG_sBx(i) return i.Bx - self.MAXARG_sBx end
function luaP:SETARG_sBx(i, b) i.Bx = b + self.MAXARG_sBx end

function luaP:CREATE_ABC(o,a,b,c)
  return {OP = self.OpCode[o], A = a, B = b, C = c}
end

function luaP:CREATE_ABx(o,a,bc)
  return {OP = self.OpCode[o], A = a, Bx = bc}
end

------------------------------------------------------------------------
-- create an instruction from a number (for OP_SETLIST)
------------------------------------------------------------------------
function luaP:CREATE_Inst(c)
  local o = c % 64
  c = (c - o) / 64
  local a = c % 256
  c = (c - a) / 256
  return self:CREATE_ABx(o, a, c)
end

------------------------------------------------------------------------
-- returns a 4-char string little-endian encoded form of an instruction
------------------------------------------------------------------------
function luaP:Instruction(i)
  if i.Bx then
    -- change to OP/A/B/C format
    i.C = i.Bx % 512
    i.B = (i.Bx - i.C) / 512
  end
  local I = i.A * 64 + i.OP
  local c0 = I % 256
  I = i.C * 64 + (I - c0) / 256  -- 6 bits of A left
  local c1 = I % 256
  I = i.B * 128 + (I - c1) / 256  -- 7 bits of C left
  local c2 = I % 256
  local c3 = (I - c2) / 256
  return string.char(c0, c1, c2, c3)
end

------------------------------------------------------------------------
-- decodes a 4-char little-endian string into an instruction struct
------------------------------------------------------------------------
function luaP:DecodeInst(x)
  local byte = string.byte
  local i = {}
  local I = byte(x, 1)
  local op = I % 64
  i.OP = op
  I = byte(x, 2) * 4 + (I - op) / 64  -- 2 bits of c0 left
  local a = I % 256
  i.A = a
  I = byte(x, 3) * 4 + (I - a) / 256  -- 2 bits of c1 left
  local c = I % 512
  i.C = c
  i.B = byte(x, 4) * 2 + (I - c) / 512 -- 1 bits of c2 left
  local opmode = self.OpMode[tonumber(string.sub(self.opmodes[op + 1], 7, 7))]
  if opmode ~= "iABC" then
    i.Bx = i.B * 512 + i.C
  end
  return i
end

------------------------------------------------------------------------
-- Macros to operate RK indices
-- * these use arithmetic instead of bit ops
------------------------------------------------------------------------

-- this bit 1 means constant (0 means register)
luaP.BITRK = math.ldexp(1, luaP.SIZE_B - 1)

-- test whether value is a constant
function luaP:ISK(x) return x >= self.BITRK end

-- gets the index of the constant
function luaP:INDEXK(x) return x - self.BITRK end

luaP.MAXINDEXRK = luaP.BITRK - 1

-- code a constant index as a RK value
function luaP:RKASK(x) return x + self.BITRK end

------------------------------------------------------------------------
-- invalid register that fits in 8 bits
------------------------------------------------------------------------
luaP.NO_REG = luaP.MAXARG_A

------------------------------------------------------------------------
-- R(x) - register
-- Kst(x) - constant (in constant table)
-- RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)
------------------------------------------------------------------------

------------------------------------------------------------------------
-- grep "ORDER OP" if you change these enums
------------------------------------------------------------------------

--[[--------------------------------------------------------------------
Lua virtual machine opcodes (enum OpCode):
------------------------------------------------------------------------
name          args    description
------------------------------------------------------------------------
OP_MOVE       A B     R(A) := R(B)
OP_LOADK      A Bx    R(A) := Kst(Bx)
OP_LOADBOOL   A B C   R(A) := (Bool)B; if (C) pc++
OP_LOADNIL    A B     R(A) := ... := R(B) := nil
OP_GETUPVAL   A B     R(A) := UpValue[B]
OP_GETGLOBAL  A Bx    R(A) := Gbl[Kst(Bx)]
OP_GETTABLE   A B C   R(A) := R(B)[RK(C)]
OP_SETGLOBAL  A Bx    Gbl[Kst(Bx)] := R(A)
OP_SETUPVAL   A B     UpValue[B] := R(A)
OP_SETTABLE   A B C   R(A)[RK(B)] := RK(C)
OP_NEWTABLE   A B C   R(A) := {} (size = B,C)
OP_SELF       A B C   R(A+1) := R(B); R(A) := R(B)[RK(C)]
OP_ADD        A B C   R(A) := RK(B) + RK(C)
OP_SUB        A B C   R(A) := RK(B) - RK(C)
OP_MUL        A B C   R(A) := RK(B) * RK(C)
OP_DIV        A B C   R(A) := RK(B) / RK(C)
OP_MOD        A B C   R(A) := RK(B) % RK(C)
OP_POW        A B C   R(A) := RK(B) ^ RK(C)
OP_UNM        A B     R(A) := -R(B)
OP_NOT        A B     R(A) := not R(B)
OP_LEN        A B     R(A) := length of R(B)
OP_CONCAT     A B C   R(A) := R(B).. ... ..R(C)
OP_JMP        sBx     pc+=sBx
OP_EQ         A B C   if ((RK(B) == RK(C)) ~= A) then pc++
OP_LT         A B C   if ((RK(B) <  RK(C)) ~= A) then pc++
OP_LE         A B C   if ((RK(B) <= RK(C)) ~= A) then pc++
OP_TEST       A C     if not (R(A) <=> C) then pc++
OP_TESTSET    A B C   if (R(B) <=> C) then R(A) := R(B) else pc++
OP_CALL       A B C   R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))
OP_TAILCALL   A B C   return R(A)(R(A+1), ... ,R(A+B-1))
OP_RETURN     A B     return R(A), ... ,R(A+B-2)  (see note)
OP_FORLOOP    A sBx   R(A)+=R(A+2);
                      if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }
OP_FORPREP    A sBx   R(A)-=R(A+2); pc+=sBx
OP_TFORLOOP   A C     R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));
                      if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++
OP_SETLIST    A B C   R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B
OP_CLOSE      A       close all variables in the stack up to (>=) R(A)
OP_CLOSURE    A Bx    R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))
OP_VARARG     A B     R(A), R(A+1), ..., R(A+B-1) = vararg
----------------------------------------------------------------------]]

luaP.opnames = {}  -- opcode names
luaP.OpCode = {}   -- lookup name -> number
luaP.ROpCode = {}  -- lookup number -> name

------------------------------------------------------------------------
-- ORDER OP
------------------------------------------------------------------------
local i = 0
for v in string.gmatch([[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]], "%S+") do
  local n = "OP_"..v
  luaP.opnames[i] = v
  luaP.OpCode[n] = i
  luaP.ROpCode[i] = n
  i = i + 1
end
luaP.NUM_OPCODES = i

--[[
===========================================================================
  Notes:
  (*) In OP_CALL, if (B == 0) then B = top. C is the number of returns - 1,
      and can be 0: OP_CALL then sets 'top' to last_result+1, so
      next open instruction (OP_CALL, OP_RETURN, OP_SETLIST) may use 'top'.
  (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
      set top (like in OP_CALL with C == 0).
  (*) In OP_RETURN, if (B == 0) then return up to 'top'
  (*) In OP_SETLIST, if (B == 0) then B = 'top';
      if (C == 0) then next 'instruction' is real C
  (*) For comparisons, A specifies what condition the test should accept
      (true or false).
  (*) All 'skips' (pc++) assume that next instruction is a jump
===========================================================================
--]]

--[[--------------------------------------------------------------------
  masks for instruction properties. The format is:
  bits 0-1: op mode
  bits 2-3: C arg mode
  bits 4-5: B arg mode
  bit 6: instruction set register A
  bit 7: operator is a test

  for OpArgMask:
  OpArgN - argument is not used
  OpArgU - argument is used
  OpArgR - argument is a register or a jump offset
  OpArgK - argument is a constant or register/constant
----------------------------------------------------------------------]]

-- was enum OpArgMask
luaP.OpArgMask = { OpArgN = 0, OpArgU = 1, OpArgR = 2, OpArgK = 3 }

------------------------------------------------------------------------
-- e.g. to compare with symbols, luaP:getOpMode(...) == luaP.OpCode.iABC
-- * accepts opcode parameter as strings, e.g. "OP_MOVE"
------------------------------------------------------------------------

function luaP:getOpMode(m)
  return self.opmodes[self.OpCode[m]] % 4
end

function luaP:getBMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 16) % 4
end

function luaP:getCMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 4) % 4
end

function luaP:testAMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 64) % 2
end

function luaP:testTMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 128)
end

-- luaP_opnames[] is set above, as the luaP.opnames table

-- number of list items to accumulate before a SETLIST instruction
luaP.LFIELDS_PER_FLUSH = 50

------------------------------------------------------------------------
-- build instruction properties array
-- * deliberately coded to look like the C equivalent
------------------------------------------------------------------------
local function opmode(t, a, b, c, m)
  local luaP = luaP
  return t * 128 + a * 64 +
         luaP.OpArgMask[b] * 16 + luaP.OpArgMask[c] * 4 + luaP.OpMode[m]
end

-- ORDER OP
luaP.opmodes = {
-- T A B C mode opcode
  opmode(0, 1, "OpArgK", "OpArgN", "iABx"),     -- OP_LOADK
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_LOADBOOL
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_LOADNIL
  opmode(0, 1, "OpArgU", "OpArgN", "iABC"),     -- OP_GETUPVAL
  opmode(0, 1, "OpArgK", "OpArgN", "iABx"),     -- OP_GETGLOBAL
  opmode(0, 1, "OpArgR", "OpArgK", "iABC"),     -- OP_GETTABLE
  opmode(0, 0, "OpArgK", "OpArgN", "iABx"),     -- OP_SETGLOBAL
  opmode(0, 0, "OpArgU", "OpArgN", "iABC"),     -- OP_SETUPVAL
  opmode(0, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_SETTABLE
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_NEWTABLE
  opmode(0, 1, "OpArgR", "OpArgK", "iABC"),     -- OP_SELF
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_ADD
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_SUB
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_MUL
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_DIV
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_MOD
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_POW
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_UNM
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_NOT
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_LEN
  opmode(0, 1, "OpArgR", "OpArgR", "iABC"),     -- OP_CONCAT
  opmode(0, 0, "OpArgR", "OpArgN", "iAsBx"),    -- OP_JMP
  opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_EQ
  opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_LT
  opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_LE
  opmode(1, 1, "OpArgR", "OpArgU", "iABC"),     -- OP_TEST
  opmode(1, 1, "OpArgR", "OpArgU", "iABC"),     -- OP_TESTSET
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_CALL
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_TAILCALL
  opmode(0, 0, "OpArgU", "OpArgN", "iABC"),     -- OP_RETURN
  opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),    -- OP_FORLOOP
  opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),    -- OP_FORPREP
  opmode(1, 0, "OpArgN", "OpArgU", "iABC"),     -- OP_TFORLOOP
  opmode(0, 0, "OpArgU", "OpArgU", "iABC"),     -- OP_SETLIST
  opmode(0, 0, "OpArgN", "OpArgN", "iABC"),     -- OP_CLOSE
  opmode(0, 1, "OpArgU", "OpArgN", "iABx"),     -- OP_CLOSURE
  opmode(0, 1, "OpArgU", "OpArgN", "iABC"),     -- OP_VARARG
}
-- an awkward way to set a zero-indexed table...
luaP.opmodes[0] =
  opmode(0, 1, "OpArgR", "OpArgN", "iABC")      -- OP_MOVE

_G.luavm.luaP = luaP
end
function scmframework_781c24f259399ccc46133a49b30d0880() --$CONTENT_DATA/Scripts/remade-scrapVM/LuaVM/LuaU.lua
--[[--------------------------------------------------------------------

  ldump.lua
  Save precompiled Lua chunks
  This file is part of Yueliang.

  Copyright (c) 2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * WARNING! byte order (little endian) and data type sizes for header
--   signature values hard-coded; see luaU:header
-- * chunk writer generators are included, see below
-- * one significant difference is that instructions are still in table
--   form (with OP/A/B/C/Bx fields) and luaP:Instruction() is needed to
--   convert them into 4-char strings
--
-- Not implemented:
-- * DumpVar, DumpMem has been removed
-- * DumpVector folded into folded into DumpDebug, DumpCode
--
-- Added:
-- * for convenience, the following two functions have been added:
--   luaU:make_setS: create a chunk writer that writes to a string
--   luaU:make_setF: create a chunk writer that writes to a file
--   (lua.h contains a typedef for lua_Writer/lua_Chunkwriter, and
--    a Lua-based implementation exists, writer() in lstrlib.c)
-- * luaU:ttype(o) (from lobject.h)
-- * for converting number types to its binary equivalent:
--   luaU:from_double(x): encode double value for writing
--   luaU:from_int(x): encode integer value for writing
--     (error checking is limited for these conversion functions)
--     (double conversion does not support denormals or NaNs)
--
-- Changed in 5.1.x:
-- * the dumper was mostly rewritten in Lua 5.1.x, so notes on the
--   differences between 5.0.x and 5.1.x is limited
-- * LUAC_VERSION bumped to 0x51, LUAC_FORMAT added
-- * developer is expected to adjust LUAC_FORMAT in order to identify
--   non-standard binary chunk formats
-- * header signature code is smaller, has been simplified, and is
--   tested as a single unit; its logic is shared with the undumper
-- * no more endian conversion, invalid endianness mean rejection
-- * opcode field sizes are no longer exposed in the header
-- * code moved to front of a prototype, followed by constants
-- * debug information moved to the end of the binary chunk, and the
--   relevant functions folded into a single function
-- * luaU:dump returns a writer status code
-- * chunk writer now implements status code because dumper uses it
-- * luaU:endianness removed
----------------------------------------------------------------------]]

--requires luaP
local luaU = {}
local luaP = _G.luavm.LuaP

-- mark for precompiled code ('<esc>Lua') (from lua.h)
luaU.LUA_SIGNATURE = "\27Lua"

-- constants used by dumper (from lua.h)
luaU.LUA_TNUMBER  = 3
luaU.LUA_TSTRING  = 4
luaU.LUA_TNIL     = 0
luaU.LUA_TBOOLEAN = 1
luaU.LUA_TNONE    = -1

-- constants for header of binary files (from lundump.h)
luaU.LUAC_VERSION    = 0x51     -- this is Lua 5.1
luaU.LUAC_FORMAT     = 0        -- this is the official format
luaU.LUAC_HEADERSIZE = 12       -- size of header of binary files

--[[--------------------------------------------------------------------
-- Additional functions to handle chunk writing
-- * to use make_setS and make_setF, see test_ldump.lua elsewhere
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- create a chunk writer that writes to a string
-- * returns the writer function and a table containing the string
-- * to get the final result, look in buff.data
------------------------------------------------------------------------
function luaU:make_setS()
  local buff = {}
        buff.data = ""
  local writer =
    function(s, buff)  -- chunk writer
      if not s then return 0 end
      buff.data = buff.data..s
      return 0
    end
  return writer, buff
end

------------------------------------------------------------------------
-- create a chunk writer that writes to a file
-- * returns the writer function and a table containing the file handle
-- * if a nil is passed, then writer should close the open file
------------------------------------------------------------------------

--[[
function luaU:make_setF(filename)
  local buff = {}
        buff.h = io.open(filename, "wb")
  if not buff.h then return nil end
  local writer =
    function(s, buff)  -- chunk writer
      if not buff.h then return 0 end
      if not s then
        if buff.h:close() then return 0 end
      else
        if buff.h:write(s) then return 0 end
      end
      return 1
    end
  return writer, buff
end--]]

------------------------------------------------------------------------
-- works like the lobject.h version except that TObject used in these
-- scripts only has a 'value' field, no 'tt' field (native types used)
------------------------------------------------------------------------
function luaU:ttype(o)
  local tt = type(o.value)
  if tt == "number" then return self.LUA_TNUMBER
  elseif tt == "string" then return self.LUA_TSTRING
  elseif tt == "nil" then return self.LUA_TNIL
  elseif tt == "boolean" then return self.LUA_TBOOLEAN
  else
    return self.LUA_TNONE  -- the rest should not appear
  end
end

-----------------------------------------------------------------------
-- converts a IEEE754 double number to an 8-byte little-endian string
-- * luaU:from_double() and luaU:from_int() are adapted from ChunkBake
-- * supports +/- Infinity, but not denormals or NaNs
-----------------------------------------------------------------------
function luaU:from_double(x)
  local function grab_byte(v)
    local c = v % 256
    return (v - c) / 256, string.char(c)
  end
  local sign = 0
  if x < 0 then sign = 1; x = -x end
  local mantissa, exponent = math.frexp(x)
  if x == 0 then -- zero
    mantissa, exponent = 0, 0
  elseif x == 1/0 then
    mantissa, exponent = 0, 2047
  else
    mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53)
    exponent = exponent + 1022
  end
  local v, byte = "" -- convert to bytes
  x = math.floor(mantissa)
  for i = 1,6 do
    x, byte = grab_byte(x); v = v..byte -- 47:0
  end
  x, byte = grab_byte(exponent * 16 + x); v = v..byte -- 55:48
  x, byte = grab_byte(sign * 128 + x); v = v..byte -- 63:56
  return v
end

-----------------------------------------------------------------------
-- converts a number to a little-endian 32-bit integer string
-- * input value assumed to not overflow, can be signed/unsigned
-----------------------------------------------------------------------
function luaU:from_int(x)
  local v = ""
  x = math.floor(x)
  if x < 0 then x = 4294967296 + x end  -- ULONG_MAX+1
  for i = 1, 4 do
    local c = x % 256
    v = v..string.char(c); x = math.floor(x / 256)
  end
  return v
end

--[[--------------------------------------------------------------------
-- Functions to make a binary chunk
-- * many functions have the size parameter removed, since output is
--   in the form of a string and some sizes are implicit or hard-coded
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- struct DumpState:
--   L  -- lua_State (not used in this script)
--   writer  -- lua_Writer (chunk writer function)
--   data  -- void* (chunk writer context or data already written)
--   strip  -- if true, don't write any debug information
--   status  -- if non-zero, an error has occured
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- dumps a block of bytes
-- * lua_unlock(D.L), lua_lock(D.L) unused
------------------------------------------------------------------------
function luaU:DumpBlock(b, D)
  if D.status == 0 then
    -- lua_unlock(D->L);
    D.status = D.write(b, D.data)
    -- lua_lock(D->L);
  end
end

------------------------------------------------------------------------
-- dumps a char
------------------------------------------------------------------------
function luaU:DumpChar(y, D)
  self:DumpBlock(string.char(y), D)
end

------------------------------------------------------------------------
-- dumps a 32-bit signed or unsigned integer (for int) (hard-coded)
------------------------------------------------------------------------
function luaU:DumpInt(x, D)
  self:DumpBlock(self:from_int(x), D)
end

------------------------------------------------------------------------
-- dumps a lua_Number (hard-coded as a double)
------------------------------------------------------------------------
function luaU:DumpNumber(x, D)
  self:DumpBlock(self:from_double(x), D)
end

------------------------------------------------------------------------
-- dumps a Lua string (size type is hard-coded)
------------------------------------------------------------------------
function luaU:DumpString(s, D)
  if s == nil then
    self:DumpInt(0, D)
  else
    s = s.."\0"  -- include trailing '\0'
    self:DumpInt(#s, D)
    self:DumpBlock(s, D)
  end
end

------------------------------------------------------------------------
-- dumps instruction block from function prototype
------------------------------------------------------------------------
function luaU:DumpCode(f, D)
  local n = f.sizecode
  --was DumpVector
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpBlock(_G.luavm.luaP:Instruction(f.code[i]), D)
  end
end

------------------------------------------------------------------------
-- dump constant pool from function prototype
-- * bvalue(o), nvalue(o) and rawtsvalue(o) macros removed
------------------------------------------------------------------------
function luaU:DumpConstants(f, D)
  local n = f.sizek
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    local o = f.k[i]  -- TValue
    local tt = self:ttype(o)
    self:DumpChar(tt, D)
    if tt == self.LUA_TNIL then
    elseif tt == self.LUA_TBOOLEAN then
      self:DumpChar(o.value and 1 or 0, D)
    elseif tt == self.LUA_TNUMBER then
      self:DumpNumber(o.value, D)
    elseif tt == self.LUA_TSTRING then
      self:DumpString(o.value, D)
    else
      --lua_assert(0)  -- cannot happen
    end
  end
  n = f.sizep
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpFunction(f.p[i], f.source, D)
  end
end

------------------------------------------------------------------------
-- dump debug information
------------------------------------------------------------------------
function luaU:DumpDebug(f, D)
  local n
  n = D.strip and 0 or f.sizelineinfo           -- dump line information
  --was DumpVector
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpInt(f.lineinfo[i], D)
  end
  n = D.strip and 0 or f.sizelocvars            -- dump local information
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpString(f.locvars[i].varname, D)
    self:DumpInt(f.locvars[i].startpc, D)
    self:DumpInt(f.locvars[i].endpc, D)
  end
  n = D.strip and 0 or f.sizeupvalues           -- dump upvalue information
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpString(f.upvalues[i], D)
  end
end

------------------------------------------------------------------------
-- dump child function prototypes from function prototype
------------------------------------------------------------------------
function luaU:DumpFunction(f, p, D)
  local source = f.source
  if source == p or D.strip then source = nil end
  self:DumpString(source, D)
  self:DumpInt(f.lineDefined, D)
  self:DumpInt(f.lastlinedefined, D)
  self:DumpChar(f.nups, D)
  self:DumpChar(f.numparams, D)
  self:DumpChar(f.is_vararg, D)
  self:DumpChar(f.maxstacksize, D)
  self:DumpCode(f, D)
  self:DumpConstants(f, D)
  self:DumpDebug(f, D)
end

------------------------------------------------------------------------
-- dump Lua header section (some sizes hard-coded)
------------------------------------------------------------------------
function luaU:DumpHeader(D)
  local h = self:header()
  assert(#h == self.LUAC_HEADERSIZE) -- fixed buffer now an assert
  self:DumpBlock(h, D)
end

------------------------------------------------------------------------
-- make header (from lundump.c)
-- returns the header string
------------------------------------------------------------------------
function luaU:header()
 local x = 1
 return self.LUA_SIGNATURE..
        string.char(
          self.LUAC_VERSION,
          self.LUAC_FORMAT,
          x,                    -- endianness (1=little)
          4,                    -- sizeof(int)
          4,                    -- sizeof(size_t)
          4,                    -- sizeof(Instruction)
          8,                    -- sizeof(lua_Number)
          0)                    -- is lua_Number integral?
end

------------------------------------------------------------------------
-- dump Lua function as precompiled chunk
-- (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)
-- * w, data are created from make_setS, make_setF
------------------------------------------------------------------------
function luaU:dump(L, f, w, data, strip)
  local D = {}  -- DumpState
  D.L = L
  D.write = w
  D.data = data
  D.strip = strip
  D.status = 0
  self:DumpHeader(D)
  self:DumpFunction(f, nil, D)
  -- added: for a chunk writer writing to a file, this final call with
  -- nil data is to indicate to the writer to close the file
  D.write(nil, D.data)
  return D.status
end

_G.luavm.luaU = luaU
end
function scmframework_318b9203b12a2738d55612693f0eef2f() --$CONTENT_DATA/Scripts/remade-scrapVM/LuaVM/LuaX.lua
--[[--------------------------------------------------------------------

  llex.lua
  Lua lexical analyzer in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * intended to 'imitate' llex.c code; performance is not a concern
-- * tokens are strings; code structure largely retained
-- * deleted stuff (compared to llex.c) are noted, comments retained
-- * nextc() returns the currently read character to simplify coding
--   here; next() in llex.c does not return anything
-- * compatibility code is marked with "--" comments
--
-- Added:
-- * luaX:chunkid (function luaO_chunkid from lobject.c)
-- * luaX:str2d (function luaO_str2d from lobject.c)
-- * luaX.LUA_QS used in luaX:lexerror (from luaconf.h)
-- * luaX.LUA_COMPAT_LSTR in luaX:read_long_string (from luaconf.h)
-- * luaX.MAX_INT used in luaX:inclinenumber (from llimits.h)
--
-- To use the lexer:
-- (1) luaX:init() to initialize the lexer
-- (2) luaX:setinput() to set the input stream to lex
-- (3) call luaX:next() or luaX:luaX:lookahead() to get tokens,
--     until "TK_EOS": luaX:next()
-- * since EOZ is returned as a string, be careful when regexp testing
--
-- Not implemented:
-- * luaX_newstring: not required by this Lua implementation
-- * buffer MAX_SIZET size limit (from llimits.h) test not implemented
--   in the interest of performance
-- * locale-aware number handling is largely redundant as Lua's
--   tonumber() function is already capable of this
--
-- Changed in 5.1.x:
-- * TK_NAME token order moved down
-- * string representation for TK_NAME, TK_NUMBER, TK_STRING changed
-- * token struct renamed to lower case (LS -> ls)
-- * LexState struct: removed nestlevel, added decpoint
-- * error message functions have been greatly simplified
-- * token2string renamed to luaX_tokens, exposed in llex.h
-- * lexer now handles all kinds of newlines, including CRLF
-- * shbang first line handling removed from luaX:setinput;
--   it is now done in lauxlib.c (luaL_loadfile)
-- * next(ls) macro renamed to nextc(ls) due to new luaX_next function
-- * EXTRABUFF and MAXNOCHECK removed due to lexer changes
-- * checkbuffer(ls, len) macro deleted
-- * luaX:read_numeral now has 3 support functions: luaX:trydecpoint,
--   luaX:buffreplace and (luaO_str2d from lobject.c) luaX:str2d
-- * luaX:read_numeral is now more promiscuous in slurping characters;
--   hexadecimal numbers was added, locale-aware decimal points too
-- * luaX:skip_sep is new; used by luaX:read_long_string
-- * luaX:read_long_string handles new-style long blocks, with some
--   optional compatibility code
-- * luaX:llex: parts changed to support new-style long blocks
-- * luaX:llex: readname functionality has been folded in
-- * luaX:llex: removed test for control characters
--
--------------------------------------------------------------------]]

local luaZ = _G.luavm.luaZ

local luaX = {}

-- FIRST_RESERVED is not required as tokens are manipulated as strings
-- TOKEN_LEN deleted; maximum length of a reserved word not needed

------------------------------------------------------------------------
-- "ORDER RESERVED" deleted; enumeration in one place: luaX.RESERVED
------------------------------------------------------------------------

-- terminal symbols denoted by reserved words: TK_AND to TK_WHILE
-- other terminal symbols: TK_NAME to TK_EOS
luaX.RESERVED = [[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]

-- NUM_RESERVED is not required; number of reserved words

--[[--------------------------------------------------------------------
-- Instead of passing seminfo, the Token struct (e.g. ls.t) is passed
-- so that lexer functions can use its table element, ls.t.seminfo
--
-- SemInfo (struct no longer needed, a mixed-type value is used)
--
-- Token (struct of ls.t and ls.lookahead):
--   token  -- token symbol
--   seminfo  -- semantics information
--
-- LexState (struct of ls; ls is initialized by luaX:setinput):
--   current  -- current character (charint)
--   linenumber  -- input line counter
--   lastline  -- line of last token 'consumed'
--   t  -- current token (table: struct Token)
--   lookahead  -- look ahead token (table: struct Token)
--   fs  -- 'FuncState' is private to the parser
--   L -- LuaState
--   z  -- input stream
--   buff  -- buffer for tokens
--   source  -- current source name
--   decpoint -- locale decimal point
--   nestlevel  -- level of nested non-terminals
----------------------------------------------------------------------]]

-- luaX.tokens (was luaX_tokens) is now a hash; see luaX:init

luaX.MAXSRC = 80
luaX.MAX_INT = 2147483645       -- constants from elsewhere (see above)
luaX.LUA_QS = "'%s'"
luaX.LUA_COMPAT_LSTR = 1
--luaX.MAX_SIZET = 4294967293

------------------------------------------------------------------------
-- initialize lexer
-- * original luaX_init has code to create and register token strings
-- * luaX.tokens: TK_* -> token
-- * luaX.enums:  token -> TK_* (used in luaX:llex)
------------------------------------------------------------------------
function luaX:init()
  local tokens, enums = {}, {}
  for v in string.gmatch(self.RESERVED, "[^\n]+") do
    local _, _, tok, str = string.find(v, "(%S+)%s+(%S+)")
    tokens[tok] = str
    enums[str] = tok
  end
  self.tokens = tokens
  self.enums = enums
end

------------------------------------------------------------------------
-- returns a suitably-formatted chunk name or id
-- * from lobject.c, used in llex.c and ldebug.c
-- * the result, out, is returned (was first argument)
------------------------------------------------------------------------
function luaX:chunkid(source, bufflen)
  local out
  local first = string.sub(source, 1, 1)
  if first == "=" then
    out = string.sub(source, 2, bufflen)  -- remove first char
  else  -- out = "source", or "...source"
    if first == "@" then
      source = string.sub(source, 2)  -- skip the '@'
      bufflen = bufflen - #" '...' "
      local l = #source
      out = ""
      if l > bufflen then
        source = string.sub(source, 1 + l - bufflen)  -- get last part of file name
        out = out.."..."
      end
      out = out..source
    else  -- out = [string "string"]
      local len = string.find(source, "[\n\r]")  -- stop at first newline
      len = len and (len - 1) or #source
      bufflen = bufflen - #(" [string \"...\"] ")
      if len > bufflen then len = bufflen end
      out = "[string \""
      if len < #source then  -- must truncate?
        out = out..string.sub(source, 1, len).."..."
      else
        out = out..source
      end
      out = out.."\"]"
    end
  end
  return out
end

--[[--------------------------------------------------------------------
-- Support functions for lexer
-- * all lexer errors eventually reaches lexerror:
     syntaxerror -> lexerror
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- look up token and return keyword if found (also called by parser)
------------------------------------------------------------------------
function luaX:token2str(ls, token)
  if string.sub(token, 1, 3) ~= "TK_" then
    if string.find(token, "%c") then
      return string.format("char(%d)", string.byte(token))
    end
    return token
  else
  end
    return self.tokens[token]
end

------------------------------------------------------------------------
-- throws a lexer error
-- * txtToken has been made local to luaX:lexerror
-- * can't communicate LUA_ERRSYNTAX, so it is unimplemented
------------------------------------------------------------------------
function luaX:lexerror(ls, msg, token)
  local function txtToken(ls, token)
    if token == "TK_NAME" or
       token == "TK_STRING" or
       token == "TK_NUMBER" then
      return ls.buff
    else
      return self:token2str(ls, token)
    end
  end
  local buff = self:chunkid(ls.source, self.MAXSRC)
  local msg = string.format("%s:%d: %s", buff, ls.linenumber, msg)
  if token then
    msg = string.format("%s near "..self.LUA_QS, msg, txtToken(ls, token))
  end
  -- luaD_throw(ls->L, LUA_ERRSYNTAX)
  error(msg)
end

------------------------------------------------------------------------
-- throws a syntax error (mainly called by parser)
-- * ls.t.token has to be set by the function calling luaX:llex
--   (see luaX:next and luaX:lookahead elsewhere in this file)
------------------------------------------------------------------------
function luaX:syntaxerror(ls, msg)
  self:lexerror(ls, msg, ls.t.token)
end

------------------------------------------------------------------------
-- move on to next line
------------------------------------------------------------------------
function luaX:currIsNewline(ls)
  return ls.current == "\n" or ls.current == "\r"
end

function luaX:inclinenumber(ls)
  local old = ls.current
  -- lua_assert(currIsNewline(ls))
  self:nextc(ls)  -- skip '\n' or '\r'
  if self:currIsNewline(ls) and ls.current ~= old then
    self:nextc(ls)  -- skip '\n\r' or '\r\n'
  end
  ls.linenumber = ls.linenumber + 1
  if ls.linenumber >= self.MAX_INT then
    self:syntaxerror(ls, "chunk has too many lines")
  end
end

------------------------------------------------------------------------
-- initializes an input stream for lexing
-- * if ls (the lexer state) is passed as a table, then it is filled in,
--   otherwise it has to be retrieved as a return value
-- * LUA_MINBUFFER not used; buffer handling not required any more
------------------------------------------------------------------------
function luaX:setinput(L, ls, z, source)
  if not ls then ls = {} end  -- create struct
  if not ls.lookahead then ls.lookahead = {} end
  if not ls.t then ls.t = {} end
  ls.decpoint = "."
  ls.L = L
  ls.lookahead.token = "TK_EOS"  -- no look-ahead token
  ls.z = z
  ls.fs = nil
  ls.linenumber = 1
  ls.lastline = 1
  ls.source = source
  self:nextc(ls)  -- read first char
end

--[[--------------------------------------------------------------------
-- LEXICAL ANALYZER
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- checks if current character read is found in the set 'set'
------------------------------------------------------------------------
function luaX:check_next(ls, set)
  if not string.find(set, ls.current, 1, 1) then
    return false
  end
  self:save_and_next(ls)
  return true
end

------------------------------------------------------------------------
-- retrieve next token, checking the lookahead buffer if necessary
-- * note that the macro next(ls) in llex.c is now luaX:nextc
-- * utilized used in lparser.c (various places)
------------------------------------------------------------------------
function luaX:next(ls)
  ls.lastline = ls.linenumber
  if ls.lookahead.token ~= "TK_EOS" then  -- is there a look-ahead token?
    -- this must be copy-by-value
    ls.t.seminfo = ls.lookahead.seminfo  -- use this one
    ls.t.token = ls.lookahead.token
    ls.lookahead.token = "TK_EOS"  -- and discharge it
  else
    ls.t.token = self:llex(ls, ls.t)  -- read next token
  end
end

------------------------------------------------------------------------
-- fill in the lookahead buffer
-- * utilized used in lparser.c:constructor
------------------------------------------------------------------------
function luaX:lookahead(ls)
  -- lua_assert(ls.lookahead.token == "TK_EOS")
  ls.lookahead.token = self:llex(ls, ls.lookahead)
end

------------------------------------------------------------------------
-- gets the next character and returns it
-- * this is the next() macro in llex.c; see notes at the beginning
------------------------------------------------------------------------
function luaX:nextc(ls)
  local c = luaZ:zgetc(ls.z)
  ls.current = c
  return c
end

------------------------------------------------------------------------
-- saves the given character into the token buffer
-- * buffer handling code removed, not used in this implementation
-- * test for maximum token buffer length not used, makes things faster
------------------------------------------------------------------------

function luaX:save(ls, c)
  local buff = ls.buff
  -- if you want to use this, please uncomment luaX.MAX_SIZET further up
  --if #buff > self.MAX_SIZET then
  --  self:lexerror(ls, "lexical element too long")
  --end
  ls.buff = buff..c
end

------------------------------------------------------------------------
-- save current character into token buffer, grabs next character
-- * like luaX:nextc, returns the character read for convenience
------------------------------------------------------------------------
function luaX:save_and_next(ls)
  self:save(ls, ls.current)
  return self:nextc(ls)
end

------------------------------------------------------------------------
-- LUA_NUMBER
-- * luaX:read_numeral is the main lexer function to read a number
-- * luaX:str2d, luaX:buffreplace, luaX:trydecpoint are support functions
------------------------------------------------------------------------

------------------------------------------------------------------------
-- string to number converter (was luaO_str2d from lobject.c)
-- * returns the number, nil if fails (originally returns a boolean)
-- * conversion function originally lua_str2number(s,p), a macro which
--   maps to the strtod() function by default (from luaconf.h)
------------------------------------------------------------------------
function luaX:str2d(s)
  local result = tonumber(s)
  if result then return result end
  -- conversion failed
  if string.lower(string.sub(s, 1, 2)) == "0x" then  -- maybe an hexadecimal constant?
    result = tonumber(s, 16)
    if result then return result end  -- most common case
    -- Was: invalid trailing characters?
    -- In C, this function then skips over trailing spaces.
    -- true is returned if nothing else is found except for spaces.
    -- If there is still something else, then it returns a false.
    -- All this is not necessary using Lua's tonumber.
  end
  return nil
end

------------------------------------------------------------------------
-- single-character replacement, for locale-aware decimal points
------------------------------------------------------------------------
function luaX:buffreplace(ls, from, to)
  local result, buff = "", ls.buff
  for p = 1, #buff do
    local c = string.sub(buff, p, p)
    if c == from then c = to end
    result = result..c
  end
  ls.buff = result
end

------------------------------------------------------------------------
-- Attempt to convert a number by translating '.' decimal points to
-- the decimal point character used by the current locale. This is not
-- needed in Yueliang as Lua's tonumber() is already locale-aware.
-- Instead, the code is here in case the user implements localeconv().
------------------------------------------------------------------------
function luaX:trydecpoint(ls, Token)
  -- format error: try to update decimal point separator
  local old = ls.decpoint
  -- translate the following to Lua if you implement localeconv():
  -- struct lconv *cv = localeconv();
  -- ls->decpoint = (cv ? cv->decimal_point[0] : '.');
  self:buffreplace(ls, old, ls.decpoint)  -- try updated decimal separator
  local seminfo = self:str2d(ls.buff)
  Token.seminfo = seminfo
  if not seminfo then
    -- format error with correct decimal point: no more options
    self:buffreplace(ls, ls.decpoint, ".")  -- undo change (for error message)
    self:lexerror(ls, "malformed number", "TK_NUMBER")
  end
end

------------------------------------------------------------------------
-- main number conversion function
-- * "^%w$" needed in the scan in order to detect "EOZ"
------------------------------------------------------------------------
function luaX:read_numeral(ls, Token)
  -- lua_assert(string.find(ls.current, "%d"))
  repeat
    self:save_and_next(ls)
  until string.find(ls.current, "%D") and ls.current ~= "."
  if self:check_next(ls, "Ee") then  -- 'E'?
    self:check_next(ls, "+-")  -- optional exponent sign
  end
  while string.find(ls.current, "^%w$") or ls.current == "_" do
    self:save_and_next(ls)
  end
  self:buffreplace(ls, ".", ls.decpoint)  -- follow locale for decimal point
  local seminfo = self:str2d(ls.buff)
  Token.seminfo = seminfo
  if not seminfo then  -- format error?
    self:trydecpoint(ls, Token) -- try to update decimal point separator
  end
end

------------------------------------------------------------------------
-- count separators ("=") in a long string delimiter
-- * used by luaX:read_long_string
------------------------------------------------------------------------
function luaX:skip_sep(ls)
  local count = 0
  local s = ls.current
  -- lua_assert(s == "[" or s == "]")
  self:save_and_next(ls)
  while ls.current == "=" do
    self:save_and_next(ls)
    count = count + 1
  end
  return (ls.current == s) and count or (-count) - 1
end

------------------------------------------------------------------------
-- reads a long string or long comment
------------------------------------------------------------------------
function luaX:read_long_string(ls, Token, sep)
  local cont = 0
  self:save_and_next(ls)  -- skip 2nd '['
  if self:currIsNewline(ls) then  -- string starts with a newline?
    self:inclinenumber(ls)  -- skip it
  end
  while true do
    local c = ls.current
    if c == "EOZ" then
      self:lexerror(ls, Token and "unfinished long string" or
                    "unfinished long comment", "TK_EOS")
    elseif c == "[" then
      -- compatibility code start
      if self.LUA_COMPAT_LSTR then
        if self:skip_sep(ls) == sep then
          self:save_and_next(ls)  -- skip 2nd '['
          cont = cont + 1
          -- compatibility code start
          if self.LUA_COMPAT_LSTR == 1 then
            if sep == 0 then
              self:lexerror(ls, "nesting of [[...]] is deprecated", "[")
            end
          end
          -- compatibility code end
        end
      end
      -- compatibility code end
    elseif c == "]" then
      if self:skip_sep(ls) == sep then
        self:save_and_next(ls)  -- skip 2nd ']'
        -- compatibility code start
        if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR == 2 then
          cont = cont - 1
          if sep == 0 and cont >= 0 then break end
        end
        -- compatibility code end
        break
      end
    elseif self:currIsNewline(ls) then
      self:save(ls, "\n")
      self:inclinenumber(ls)
      if not Token then ls.buff = "" end -- avoid wasting space
    else  -- default
      if Token then
        self:save_and_next(ls)
      else
        self:nextc(ls)
      end
    end--if c
  end--while
  if Token then
    local p = 3 + sep
    Token.seminfo = string.sub(ls.buff, p, -p)
  end
end

------------------------------------------------------------------------
-- reads a string
-- * has been restructured significantly compared to the original C code
------------------------------------------------------------------------

function luaX:read_string(ls, del, Token)
  self:save_and_next(ls)
  while ls.current ~= del do
    local c = ls.current
    if c == "EOZ" then
      self:lexerror(ls, "unfinished string", "TK_EOS")
    elseif self:currIsNewline(ls) then
      self:lexerror(ls, "unfinished string", "TK_STRING")
    elseif c == "\\" then
      c = self:nextc(ls)  -- do not save the '\'
      if self:currIsNewline(ls) then  -- go through
        self:save(ls, "\n")
        self:inclinenumber(ls)
      elseif c ~= "EOZ" then -- will raise an error next loop
        -- escapes handling greatly simplified here:
        local i = string.find("abfnrtv", c, 1, 1)
        if i then
          self:save(ls, string.sub("\a\b\f\n\r\t\v", i, i))
          self:nextc(ls)
        elseif not string.find(c, "%d") then
          self:save_and_next(ls)  -- handles \\, \", \', and \?
        else  -- \xxx
          c, i = 0, 0
          repeat
            c = 10 * c + ls.current
            self:nextc(ls)
            i = i + 1
          until i >= 3 or not string.find(ls.current, "%d")
          if c > 255 then  -- UCHAR_MAX
            self:lexerror(ls, "escape sequence too large", "TK_STRING")
          end
          self:save(ls, string.char(c))
        end
      end
    else
      self:save_and_next(ls)
    end--if c
  end--while
  self:save_and_next(ls)  -- skip delimiter
  Token.seminfo = string.sub(ls.buff, 2, -2)
end

------------------------------------------------------------------------
-- main lexer function
------------------------------------------------------------------------
function luaX:llex(ls, Token)
  ls.buff = ""
  while true do
    local c = ls.current
    ----------------------------------------------------------------
    if self:currIsNewline(ls) then
      self:inclinenumber(ls)
    ----------------------------------------------------------------
    elseif c == "-" then
      c = self:nextc(ls)
      if c ~= "-" then return "-" end
      -- else is a comment
      local sep = -1
      if self:nextc(ls) == '[' then
        sep = self:skip_sep(ls)
        ls.buff = ""  -- 'skip_sep' may dirty the buffer
      end
      if sep >= 0 then
        self:read_long_string(ls, nil, sep)  -- long comment
        ls.buff = ""
      else  -- else short comment
        while not self:currIsNewline(ls) and ls.current ~= "EOZ" do
          self:nextc(ls)
        end
      end
    ----------------------------------------------------------------
    elseif c == "[" then
      local sep = self:skip_sep(ls)
      if sep >= 0 then
        self:read_long_string(ls, Token, sep)
        return "TK_STRING"
      elseif sep == -1 then
        return "["
      else
        self:lexerror(ls, "invalid long string delimiter", "TK_STRING")
      end
    ----------------------------------------------------------------
    elseif c == "=" then
      c = self:nextc(ls)
      if c ~= "=" then return "="
      else self:nextc(ls); return "TK_EQ" end
    ----------------------------------------------------------------
    elseif c == "<" then
      c = self:nextc(ls)
      if c ~= "=" then return "<"
      else self:nextc(ls); return "TK_LE" end
    ----------------------------------------------------------------
    elseif c == ">" then
      c = self:nextc(ls)
      if c ~= "=" then return ">"
      else self:nextc(ls); return "TK_GE" end
    ----------------------------------------------------------------
    elseif c == "~" then
      c = self:nextc(ls)
      if c ~= "=" then return "~"
      else self:nextc(ls); return "TK_NE" end
    ----------------------------------------------------------------
    elseif c == "\"" or c == "'" then
      self:read_string(ls, c, Token)
      return "TK_STRING"
    ----------------------------------------------------------------
    elseif c == "." then
      c = self:save_and_next(ls)
      if self:check_next(ls, ".") then
        if self:check_next(ls, ".") then
          return "TK_DOTS"   -- ...
        else return "TK_CONCAT"   -- ..
        end
      elseif not string.find(c, "%d") then
        return "."
      else
        self:read_numeral(ls, Token)
        return "TK_NUMBER"
      end
    ----------------------------------------------------------------
    elseif c == "EOZ" then
      return "TK_EOS"
    ----------------------------------------------------------------
    else  -- default
      if string.find(c, "%s") then
        -- lua_assert(self:currIsNewline(ls))
        self:nextc(ls)
      elseif string.find(c, "%d") then
        self:read_numeral(ls, Token)
        return "TK_NUMBER"
      elseif string.find(c, "[_%a]") then
        -- identifier or reserved word
        repeat
          c = self:save_and_next(ls)
        until c == "EOZ" or not string.find(c, "[_%w]")
        local ts = ls.buff
        local tok = self.enums[ts]
        if tok then return tok end  -- reserved word?
        Token.seminfo = ts
        return "TK_NAME"
      else
        self:nextc(ls)
        return c  -- single-char tokens (+ - / ...)
      end
    ----------------------------------------------------------------
    end--if c
  end--while
end

_G.luavm.luaX = luaX
end
function scmframework_f42282bb6bf20e09a7721853c99ffeef() --$CONTENT_DATA/Scripts/remade-scrapVM/LuaVM/LuaY.lua
--[[--------------------------------------------------------------------

  lparser.lua
  Lua 5 parser in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2007 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * some unused C code that were not converted are kept as comments
-- * LUA_COMPAT_VARARG option changed into a comment block
-- * for value/size specific code added, look for 'NOTE: '
--
-- Not implemented:
-- * luaX_newstring not needed by this Lua implementation
-- * luaG_checkcode() in assert is not currently implemented
--
-- Added:
-- * some constants added from various header files
-- * luaY.LUA_QS used in error_expected, check_match (from luaconf.h)
-- * luaY:LUA_QL needed for error messages (from luaconf.h)
-- * luaY:growvector (from lmem.h) -- skeleton only, limit checking
-- * luaY.SHRT_MAX (from <limits.h>) for registerlocalvar
-- * luaY:newproto (from lfunc.c)
-- * luaY:int2fb (from lobject.c)
-- * NOTE: HASARG_MASK, for implementing a VARARG_HASARG bit operation
-- * NOTE: value-specific code for VARARG_NEEDSARG to replace a bitop
--
-- Changed in 5.1.x:
-- * various code changes are not detailed...
-- * names of constants may have changed, e.g. added a LUAI_ prefix
-- * struct expkind: added VKNUM, VVARARG; VCALL's info changed?
-- * struct expdesc: added nval
-- * struct FuncState: upvalues data type changed to upvaldesc
-- * macro hasmultret is new
-- * function checklimit moved to parser from lexer
-- * functions anchor_token, errorlimit, checknext are new
-- * checknext is new, equivalent to 5.0.x's check, see check too
-- * luaY:next and luaY:lookahead moved to lexer
-- * break keyword no longer skipped in luaY:breakstat
-- * function new_localvarstr replaced by new_localvarliteral
-- * registerlocalvar limits local variables to SHRT_MAX
-- * create_local deleted, new_localvarliteral used instead
-- * constant LUAI_MAXUPVALUES increased to 60
-- * constants MAXPARAMS, LUA_MAXPARSERLEVEL, MAXSTACK removed
-- * function interface changed: singlevaraux, singlevar
-- * enterlevel and leavelevel uses nCcalls to track call depth
-- * added a name argument to main entry function, luaY:parser
-- * function luaY_index changed to yindex
-- * luaY:int2fb()'s table size encoding format has been changed
-- * luaY:log2() no longer needed for table constructors
-- * function code_params deleted, functionality folded in parlist
-- * vararg flags handling (is_vararg) changes; also see VARARG_*
-- * LUA_COMPATUPSYNTAX section for old-style upvalues removed
-- * repeatstat() calls chunk() instead of block()
-- * function interface changed: cond, test_then_block
-- * while statement implementation considerably simplified; MAXEXPWHILE
--   and EXTRAEXP no longer required, no limits to the complexity of a
--   while condition
-- * repeat, forbody statement implementation has major changes,
--   mostly due to new scoping behaviour of local variables
-- * OPR_MULT renamed to OPR_MUL
----------------------------------------------------------------------]]

--requires luaP, luaX, luaK
local luaY = {}
local luaX = _G.luavm.luaX
local luaK = _G.luavm.luaK(luaY)
local luaP = _G.luavm.luaP

--[[--------------------------------------------------------------------
-- Expression descriptor
-- * expkind changed to string constants; luaY:assignment was the only
--   function to use a relational operator with this enumeration
-- VVOID       -- no value
-- VNIL        -- no value
-- VTRUE       -- no value
-- VFALSE      -- no value
-- VK          -- info = index of constant in 'k'
-- VKNUM       -- nval = numerical value
-- VLOCAL      -- info = local register
-- VUPVAL,     -- info = index of upvalue in 'upvalues'
-- VGLOBAL     -- info = index of table; aux = index of global name in 'k'
-- VINDEXED    -- info = table register; aux = index register (or 'k')
-- VJMP        -- info = instruction pc
-- VRELOCABLE  -- info = instruction pc
-- VNONRELOC   -- info = result register
-- VCALL       -- info = instruction pc
-- VVARARG     -- info = instruction pc
} ----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- * expdesc in Lua 5.1.x has a union u and another struct s; this Lua
--   implementation ignores all instances of u and s usage
-- struct expdesc:
--   k  -- (enum: expkind)
--   info, aux -- (int, int)
--   nval -- (lua_Number)
--   t  -- patch list of 'exit when true'
--   f  -- patch list of 'exit when false'
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- struct upvaldesc:
--   k  -- (lu_byte)
--   info -- (lu_byte)
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- state needed to generate code for a given function
-- struct FuncState:
--   f  -- current function header (table: Proto)
--   h  -- table to find (and reuse) elements in 'k' (table: Table)
--   prev  -- enclosing function (table: FuncState)
--   ls  -- lexical state (table: LexState)
--   L  -- copy of the Lua state (table: lua_State)
--   bl  -- chain of current blocks (table: BlockCnt)
--   pc  -- next position to code (equivalent to 'ncode')
--   lasttarget   -- 'pc' of last 'jump target'
--   jpc  -- list of pending jumps to 'pc'
--   freereg  -- first free register
--   nk  -- number of elements in 'k'
--   np  -- number of elements in 'p'
--   nlocvars  -- number of elements in 'locvars'
--   nactvar  -- number of active local variables
--   upvalues[LUAI_MAXUPVALUES]  -- upvalues (table: upvaldesc)
--   actvar[LUAI_MAXVARS]  -- declared-variable stack
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- constants used by parser
-- * picks up duplicate values from luaX if required
------------------------------------------------------------------------

luaY.LUA_QS = luaX.LUA_QS or "'%s'"  -- (from luaconf.h)

luaY.SHRT_MAX = 32767 -- (from <limits.h>)
luaY.LUAI_MAXVARS = 200  -- (luaconf.h)
luaY.LUAI_MAXUPVALUES = 60  -- (luaconf.h)
luaY.MAX_INT = luaX.MAX_INT or 2147483645  -- (from llimits.h)
  -- * INT_MAX-2 for 32-bit systems
luaY.LUAI_MAXCCALLS = 200  -- (from luaconf.h)

luaY.VARARG_HASARG = 1  -- (from lobject.h)
-- NOTE: HASARG_MASK is value-specific
luaY.HASARG_MASK = 2 -- this was added for a bitop in parlist()
luaY.VARARG_ISVARARG = 2
-- NOTE: there is some value-specific code that involves VARARG_NEEDSARG
luaY.VARARG_NEEDSARG = 4

luaY.LUA_MULTRET = -1  -- (lua.h)

--[[--------------------------------------------------------------------
-- other functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- LUA_QL describes how error messages quote program elements.
-- CHANGE it if you want a different appearance. (from luaconf.h)
------------------------------------------------------------------------
function luaY:LUA_QL(x)
  return "'"..x.."'"
end

------------------------------------------------------------------------
-- this is a stripped-down luaM_growvector (from lmem.h) which is a
-- macro based on luaM_growaux (in lmem.c); all the following does is
-- reproduce the size limit checking logic of the original function
-- so that error behaviour is identical; all arguments preserved for
-- convenience, even those which are unused
-- * set the t field to nil, since this originally does a sizeof(t)
-- * size (originally a pointer) is never updated, their final values
--   are set by luaY:close_func(), so overall things should still work
------------------------------------------------------------------------
function luaY:growvector(L, v, nelems, size, t, limit, e)
  if nelems >= limit then
    error(e)  -- was luaG_runerror
  end
end

------------------------------------------------------------------------
-- initialize a new function prototype structure (from lfunc.c)
-- * used only in open_func()
------------------------------------------------------------------------
function luaY:newproto(L)
  local f = {} -- Proto
  -- luaC_link(L, obj2gco(f), LUA_TPROTO); /* GC */
  f.k = {}
  f.sizek = 0
  f.p = {}
  f.sizep = 0
  f.code = {}
  f.sizecode = 0
  f.sizelineinfo = 0
  f.sizeupvalues = 0
  f.nups = 0
  f.upvalues = {}
  f.numparams = 0
  f.is_vararg = 0
  f.maxstacksize = 0
  f.lineinfo = {}
  f.sizelocvars = 0
  f.locvars = {}
  f.lineDefined = 0
  f.lastlinedefined = 0
  f.source = nil
  return f
end

------------------------------------------------------------------------
-- converts an integer to a "floating point byte", represented as
-- (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
-- eeeee != 0 and (xxx) otherwise.
------------------------------------------------------------------------
function luaY:int2fb(x)
  local e = 0  -- exponent
  while x >= 16 do
    x = math.floor((x + 1) / 2)
    e = e + 1
  end
  if x < 8 then
    return x
  else
    return ((e + 1) * 8) + (x - 8)
  end
end

--[[--------------------------------------------------------------------
-- parser functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- true of the kind of expression produces multiple return values
------------------------------------------------------------------------
function luaY:hasmultret(k)
  return k == "VCALL" or k == "VVARARG"
end

------------------------------------------------------------------------
-- convenience function to access active local i, returns entry
------------------------------------------------------------------------
function luaY:getlocvar(fs, i)
  return fs.f.locvars[ fs.actvar[i] ]
end

------------------------------------------------------------------------
-- check a limit, string m provided as an error message
------------------------------------------------------------------------
function luaY:checklimit(fs, v, l, m)
  if v > l then self:errorlimit(fs, l, m) end
end

--[[--------------------------------------------------------------------
-- nodes for block list (list of active blocks)
-- struct BlockCnt:
--   previous  -- chain (table: BlockCnt)
--   breaklist  -- list of jumps out of this loop
--   nactvar  -- # active local variables outside the breakable structure
--   upval  -- true if some variable in the block is an upvalue (boolean)
--   isbreakable  -- true if 'block' is a loop (boolean)
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- prototypes for recursive non-terminal functions
------------------------------------------------------------------------
-- prototypes deleted; not required in Lua

------------------------------------------------------------------------
-- reanchor if last token is has a constant string, see close_func()
-- * used only in close_func()
------------------------------------------------------------------------
function luaY:anchor_token(ls)
  if ls.t.token == "TK_NAME" or ls.t.token == "TK_STRING" then
    -- not relevant to Lua implementation of parser
    -- local ts = ls.t.seminfo
    -- luaX_newstring(ls, getstr(ts), ts->tsv.len); /* C */
  end
end

------------------------------------------------------------------------
-- throws a syntax error if token expected is not there
------------------------------------------------------------------------
function luaY:error_expected(ls, token)
  luaX:syntaxerror(ls,
    string.format(self.LUA_QS.." expected", luaX:token2str(ls, token)))
end

------------------------------------------------------------------------
-- prepares error message for display, for limits exceeded
-- * used only in checklimit()
------------------------------------------------------------------------
function luaY:errorlimit(fs, limit, what)
  local msg = (fs.f.linedefined == 0) and
    string.format("main function has more than %d %s", limit, what) or
    string.format("function at line %d has more than %d %s",
                  fs.f.linedefined, limit, what)
  luaX:lexerror(fs.ls, msg, 0)
end

------------------------------------------------------------------------
-- tests for a token, returns outcome
-- * return value changed to boolean
------------------------------------------------------------------------
function luaY:testnext(ls, c)
  if ls.t.token == c then
    luaX:next(ls)
    return true
  else
    return false
  end
end

------------------------------------------------------------------------
-- check for existence of a token, throws error if not found
------------------------------------------------------------------------
function luaY:check(ls, c)
  if ls.t.token ~= c then
    self:error_expected(ls, c)
  end
end

------------------------------------------------------------------------
-- verify existence of a token, then skip it
------------------------------------------------------------------------
function luaY:checknext(ls, c)
  self:check(ls, c)
  luaX:next(ls)
end

------------------------------------------------------------------------
-- throws error if condition not matched
------------------------------------------------------------------------
function luaY:check_condition(ls, c, msg)
  if not c then luaX:syntaxerror(ls, msg) end
end

------------------------------------------------------------------------
-- verifies token conditions are met or else throw error
------------------------------------------------------------------------
function luaY:check_match(ls, what, who, where)
  if not self:testnext(ls, what) then
    if where == ls.linenumber then
      self:error_expected(ls, what)
    else
      luaX:syntaxerror(ls, string.format(
        self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",
        luaX:token2str(ls, what), luaX:token2str(ls, who), where))
    end
  end
end

------------------------------------------------------------------------
-- expect that token is a name, return the name
------------------------------------------------------------------------
function luaY:str_checkname(ls)
  self:check(ls, "TK_NAME")
  local ts = ls.t.seminfo
  luaX:next(ls)
  return ts
end

------------------------------------------------------------------------
-- initialize a struct expdesc, expression description data structure
------------------------------------------------------------------------
function luaY:init_exp(e, k, i)
  e.f, e.t = luaK.NO_JUMP, luaK.NO_JUMP
  e.k = k
  e.info = i
end

------------------------------------------------------------------------
-- adds given string s in string pool, sets e as VK
------------------------------------------------------------------------
function luaY:codestring(ls, e, s)
  self:init_exp(e, "VK", luaK:stringK(ls.fs, s))
end

------------------------------------------------------------------------
-- consume a name token, adds it to string pool, sets e as VK
------------------------------------------------------------------------
function luaY:checkname(ls, e)
  self:codestring(ls, e, self:str_checkname(ls))
end

------------------------------------------------------------------------
-- creates struct entry for a local variable
-- * used only in new_localvar()
------------------------------------------------------------------------
function luaY:registerlocalvar(ls, varname)
  local fs = ls.fs
  local f = fs.f
  self:growvector(ls.L, f.locvars, fs.nlocvars, f.sizelocvars,
                  nil, self.SHRT_MAX, "too many local variables")
  -- loop to initialize empty f.locvar positions not required
  f.locvars[fs.nlocvars] = {} -- LocVar
  f.locvars[fs.nlocvars].varname = varname
  -- luaC_objbarrier(ls.L, f, varname) /* GC */
  local nlocvars = fs.nlocvars
  fs.nlocvars = fs.nlocvars + 1
  return nlocvars
end

------------------------------------------------------------------------
-- creates a new local variable given a name and an offset from nactvar
-- * used in fornum(), forlist(), parlist(), body()
------------------------------------------------------------------------
function luaY:new_localvarliteral(ls, v, n)
  self:new_localvar(ls, v, n)
end

------------------------------------------------------------------------
-- register a local variable, set in active variable list
------------------------------------------------------------------------
function luaY:new_localvar(ls, name, n)
  local fs = ls.fs
  self:checklimit(fs, fs.nactvar + n + 1, self.LUAI_MAXVARS, "local variables")
  fs.actvar[fs.nactvar + n] = self:registerlocalvar(ls, name)
end

------------------------------------------------------------------------
-- adds nvars number of new local variables, set debug information
------------------------------------------------------------------------
function luaY:adjustlocalvars(ls, nvars)
  local fs = ls.fs
  fs.nactvar = fs.nactvar + nvars
  for i = nvars, 1, -1 do
    self:getlocvar(fs, fs.nactvar - i).startpc = fs.pc
  end
end

------------------------------------------------------------------------
-- removes a number of locals, set debug information
------------------------------------------------------------------------
function luaY:removevars(ls, tolevel)
  local fs = ls.fs
  while fs.nactvar > tolevel do
    fs.nactvar = fs.nactvar - 1
    self:getlocvar(fs, fs.nactvar).endpc = fs.pc
  end
end

------------------------------------------------------------------------
-- returns an existing upvalue index based on the given name, or
-- creates a new upvalue struct entry and returns the new index
-- * used only in singlevaraux()
------------------------------------------------------------------------
function luaY:indexupvalue(fs, name, v)
  local f = fs.f
  for i = 0, f.nups - 1 do
    if fs.upvalues[i].k == v.k and fs.upvalues[i].info == v.info then
      assert(f.upvalues[i] == name)
      return i
    end
  end
  -- new one
  self:checklimit(fs, f.nups + 1, self.LUAI_MAXUPVALUES, "upvalues")
  self:growvector(fs.L, f.upvalues, f.nups, f.sizeupvalues,
                  nil, self.MAX_INT, "")
  -- loop to initialize empty f.upvalues positions not required
  f.upvalues[f.nups] = name
  -- luaC_objbarrier(fs->L, f, name); /* GC */
  assert(v.k == "VLOCAL" or v.k == "VUPVAL")
  -- this is a partial copy; only k & info fields used
  fs.upvalues[f.nups] = { k = v.k, info = v.info }
  local nups = f.nups
  f.nups = f.nups + 1
  return nups
end

------------------------------------------------------------------------
-- search the local variable namespace of the given fs for a match
-- * used only in singlevaraux()
------------------------------------------------------------------------
function luaY:searchvar(fs, n)
  for i = fs.nactvar - 1, 0, -1 do
    if n == self:getlocvar(fs, i).varname then
      return i
    end
  end
  return -1  -- not found
end

------------------------------------------------------------------------
-- * mark upvalue flags in function states up to a given level
-- * used only in singlevaraux()
------------------------------------------------------------------------
function luaY:markupval(fs, level)
  local bl = fs.bl
  while bl and bl.nactvar > level do bl = bl.previous end
  if bl then bl.upval = true end
end

------------------------------------------------------------------------
-- handle locals, globals and upvalues and related processing
-- * search mechanism is recursive, calls itself to search parents
-- * used only in singlevar()
------------------------------------------------------------------------
function luaY:singlevaraux(fs, n, var, base)
  if fs == nil then  -- no more levels?
    self:init_exp(var, "VGLOBAL", luaP.NO_REG)  -- default is global variable
    return "VGLOBAL"
  else
    local v = self:searchvar(fs, n)  -- look up at current level
    if v >= 0 then
      self:init_exp(var, "VLOCAL", v)
      if base == 0 then
        self:markupval(fs, v)  -- local will be used as an upval
      end
      return "VLOCAL"
    else  -- not found at current level; try upper one
      if self:singlevaraux(fs.prev, n, var, 0) == "VGLOBAL" then
        return "VGLOBAL"
      end
      var.info = self:indexupvalue(fs, n, var)  -- else was LOCAL or UPVAL
      var.k = "VUPVAL"  -- upvalue in this level
      return "VUPVAL"
    end--if v
  end--if fs
end

------------------------------------------------------------------------
-- consume a name token, creates a variable (global|local|upvalue)
-- * used in prefixexp(), funcname()
------------------------------------------------------------------------
function luaY:singlevar(ls, var)
  local varname = self:str_checkname(ls)
  local fs = ls.fs
  if self:singlevaraux(fs, varname, var, 1) == "VGLOBAL" then
    var.info = luaK:stringK(fs, varname)  -- info points to global name
  end
end

------------------------------------------------------------------------
-- adjust RHS to match LHS in an assignment
-- * used in assignment(), forlist(), localstat()
------------------------------------------------------------------------
function luaY:adjust_assign(ls, nvars, nexps, e)
  local fs = ls.fs
  local extra = nvars - nexps
  if self:hasmultret(e.k) then
    extra = extra + 1  -- includes call itself
    if extra <= 0 then extra = 0 end
    luaK:setreturns(fs, e, extra)  -- last exp. provides the difference
    if extra > 1 then luaK:reserveregs(fs, extra - 1) end
  else
    if e.k ~= "VVOID" then luaK:exp2nextreg(fs, e) end  -- close last expression
    if extra > 0 then
      local reg = fs.freereg
      luaK:reserveregs(fs, extra)
      luaK:_nil(fs, reg, extra)
    end
  end
end

------------------------------------------------------------------------
-- tracks and limits parsing depth, assert check at end of parsing
------------------------------------------------------------------------
function luaY:enterlevel(ls)
  ls.L.nCcalls = ls.L.nCcalls + 1
  if ls.L.nCcalls > self.LUAI_MAXCCALLS then
    luaX:lexerror(ls, "chunk has too many syntax levels", 0)
  end
end

------------------------------------------------------------------------
-- tracks parsing depth, a pair with luaY:enterlevel()
------------------------------------------------------------------------
function luaY:leavelevel(ls)
  ls.L.nCcalls = ls.L.nCcalls - 1
end

------------------------------------------------------------------------
-- enters a code unit, initializes elements
------------------------------------------------------------------------
function luaY:enterblock(fs, bl, isbreakable)
  bl.breaklist = luaK.NO_JUMP
  bl.isbreakable = isbreakable
  bl.nactvar = fs.nactvar
  bl.upval = false
  bl.previous = fs.bl
  fs.bl = bl
  assert(fs.freereg == fs.nactvar)
end

------------------------------------------------------------------------
-- leaves a code unit, close any upvalues
------------------------------------------------------------------------
function luaY:leaveblock(fs)
  local bl = fs.bl
  fs.bl = bl.previous
  self:removevars(fs.ls, bl.nactvar)
  if bl.upval then
    luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
  end
  -- a block either controls scope or breaks (never both)
  assert(not bl.isbreakable or not bl.upval)
  assert(bl.nactvar == fs.nactvar)
  fs.freereg = fs.nactvar  -- free registers
  luaK:patchtohere(fs, bl.breaklist)
end

------------------------------------------------------------------------
-- implement the instantiation of a function prototype, append list of
-- upvalues after the instantiation instruction
-- * used only in body()
------------------------------------------------------------------------
function luaY:pushclosure(ls, func, v)
  local fs = ls.fs
  local f = fs.f
  self:growvector(ls.L, f.p, fs.np, f.sizep, nil,
                  luaP.MAXARG_Bx, "constant table overflow")
  -- loop to initialize empty f.p positions not required
  f.p[fs.np] = func.f
  fs.np = fs.np + 1
  -- luaC_objbarrier(ls->L, f, func->f); /* C */
  self:init_exp(v, "VRELOCABLE", luaK:codeABx(fs, "OP_CLOSURE", 0, fs.np - 1))
  for i = 0, func.f.nups - 1 do
    local o = (func.upvalues[i].k == "VLOCAL") and "OP_MOVE" or "OP_GETUPVAL"
    luaK:codeABC(fs, o, 0, func.upvalues[i].info, 0)
  end
end

------------------------------------------------------------------------
-- opening of a function
------------------------------------------------------------------------
function luaY:open_func(ls, fs)
  local L = ls.L
  local f = self:newproto(ls.L)
  fs.f = f
  fs.prev = ls.fs  -- linked list of funcstates
  fs.ls = ls
  fs.L = L
  ls.fs = fs
  fs.pc = 0
  fs.lasttarget = -1
  fs.jpc = luaK.NO_JUMP
  fs.freereg = 0
  fs.nk = 0
  fs.np = 0
  fs.nlocvars = 0
  fs.nactvar = 0
  fs.bl = nil
  f.source = ls.source
  f.maxstacksize = 2  -- registers 0/1 are always valid
  fs.h = {}  -- constant table; was luaH_new call
  -- anchor table of constants and prototype (to avoid being collected)
  -- sethvalue2s(L, L->top, fs->h); incr_top(L); /* C */
  -- setptvalue2s(L, L->top, f); incr_top(L);
end

------------------------------------------------------------------------
-- closing of a function
------------------------------------------------------------------------
function luaY:close_func(ls)
  local L = ls.L
  local fs = ls.fs
  local f = fs.f
  self:removevars(ls, 0)
  luaK:ret(fs, 0, 0)  -- final return
  -- luaM_reallocvector deleted for f->code, f->lineinfo, f->k, f->p,
  -- f->locvars, f->upvalues; not required for Lua table arrays
  f.sizecode = fs.pc
  f.sizelineinfo = fs.pc
  f.sizek = fs.nk
  f.sizep = fs.np
  f.sizelocvars = fs.nlocvars
  f.sizeupvalues = f.nups
  --assert(luaG_checkcode(f))  -- currently not implemented
  assert(fs.bl == nil)
  ls.fs = fs.prev
  -- the following is not required for this implementation; kept here
  -- for completeness
  -- L->top -= 2;  /* remove table and prototype from the stack */
  -- last token read was anchored in defunct function; must reanchor it
  if fs then self:anchor_token(ls) end
end

------------------------------------------------------------------------
-- parser initialization function
-- * note additional sub-tables needed for LexState, FuncState
------------------------------------------------------------------------
function luaY:parser(L, z, buff, name)
  local lexstate = {}  -- LexState
        lexstate.t = {}
        lexstate.lookahead = {}
  local funcstate = {}  -- FuncState
        funcstate.upvalues = {}
        funcstate.actvar = {}
  -- the following nCcalls initialization added for convenience
  L.nCcalls = 0
  lexstate.buff = buff
  luaX:setinput(L, lexstate, z, name)
  self:open_func(lexstate, funcstate)
  funcstate.f.is_vararg = self.VARARG_ISVARARG  -- main func. is always vararg
  luaX:next(lexstate)  -- read first token
  self:chunk(lexstate)
  self:check(lexstate, "TK_EOS")
  self:close_func(lexstate)
  assert(funcstate.prev == nil)
  assert(funcstate.f.nups == 0)
  assert(lexstate.fs == nil)
  return funcstate.f
end

--[[--------------------------------------------------------------------
-- GRAMMAR RULES
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- parse a function name suffix, for function call specifications
-- * used in primaryexp(), funcname()
------------------------------------------------------------------------
function luaY:field(ls, v)
  -- field -> ['.' | ':'] NAME
  local fs = ls.fs
  local key = {}  -- expdesc
  luaK:exp2anyreg(fs, v)
  luaX:next(ls)  -- skip the dot or colon
  self:checkname(ls, key)
  luaK:indexed(fs, v, key)
end

------------------------------------------------------------------------
-- parse a table indexing suffix, for constructors, expressions
-- * used in recfield(), primaryexp()
------------------------------------------------------------------------
function luaY:yindex(ls, v)
  -- index -> '[' expr ']'
  luaX:next(ls)  -- skip the '['
  self:expr(ls, v)
  luaK:exp2val(ls.fs, v)
  self:checknext(ls, "]")
end

--[[--------------------------------------------------------------------
-- Rules for Constructors
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- struct ConsControl:
--   v  -- last list item read (table: struct expdesc)
--   t  -- table descriptor (table: struct expdesc)
--   nh  -- total number of 'record' elements
--   na  -- total number of array elements
--   tostore  -- number of array elements pending to be stored
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- parse a table record (hash) field
-- * used in constructor()
------------------------------------------------------------------------
function luaY:recfield(ls, cc)
  -- recfield -> (NAME | '['exp1']') = exp1
  local fs = ls.fs
  local reg = ls.fs.freereg
  local key, val = {}, {}  -- expdesc
  if ls.t.token == "TK_NAME" then
    self:checklimit(fs, cc.nh, self.MAX_INT, "items in a constructor")
    self:checkname(ls, key)
  else  -- ls->t.token == '['
    self:yindex(ls, key)
  end
  cc.nh = cc.nh + 1
  self:checknext(ls, "=")
  local rkkey = luaK:exp2RK(fs, key)
  self:expr(ls, val)
  luaK:codeABC(fs, "OP_SETTABLE", cc.t.info, rkkey, luaK:exp2RK(fs, val))
  fs.freereg = reg  -- free registers
end

------------------------------------------------------------------------
-- emit a set list instruction if enough elements (LFIELDS_PER_FLUSH)
-- * used in constructor()
------------------------------------------------------------------------
function luaY:closelistfield(fs, cc)
  if cc.v.k == "VVOID" then return end  -- there is no list item
  luaK:exp2nextreg(fs, cc.v)
  cc.v.k = "VVOID"
  if cc.tostore == luaP.LFIELDS_PER_FLUSH then
    luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)  -- flush
    cc.tostore = 0  -- no more items pending
  end
end

------------------------------------------------------------------------
-- emit a set list instruction at the end of parsing list constructor
-- * used in constructor()
------------------------------------------------------------------------
function luaY:lastlistfield(fs, cc)
  if cc.tostore == 0 then return end
  if self:hasmultret(cc.v.k) then
    luaK:setmultret(fs, cc.v)
    luaK:setlist(fs, cc.t.info, cc.na, self.LUA_MULTRET)
    cc.na = cc.na - 1  -- do not count last expression (unknown number of elements)
  else
    if cc.v.k ~= "VVOID" then
      luaK:exp2nextreg(fs, cc.v)
    end
    luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
  end
end

------------------------------------------------------------------------
-- parse a table list (array) field
-- * used in constructor()
------------------------------------------------------------------------
function luaY:listfield(ls, cc)
  self:expr(ls, cc.v)
  self:checklimit(ls.fs, cc.na, self.MAX_INT, "items in a constructor")
  cc.na = cc.na + 1
  cc.tostore = cc.tostore + 1
end

------------------------------------------------------------------------
-- parse a table constructor
-- * used in funcargs(), simpleexp()
------------------------------------------------------------------------
function luaY:constructor(ls, t)
  -- constructor -> '{' [ field { fieldsep field } [ fieldsep ] ] '}'
  -- field -> recfield | listfield
  -- fieldsep -> ',' | ';'
  local fs = ls.fs
  local line = ls.linenumber
  local pc = luaK:codeABC(fs, "OP_NEWTABLE", 0, 0, 0)
  local cc = {}  -- ConsControl
        cc.v = {}
  cc.na, cc.nh, cc.tostore = 0, 0, 0
  cc.t = t
  self:init_exp(t, "VRELOCABLE", pc)
  self:init_exp(cc.v, "VVOID", 0)  -- no value (yet)
  luaK:exp2nextreg(ls.fs, t)  -- fix it at stack top (for gc)
  self:checknext(ls, "{")
  repeat
    assert(cc.v.k == "VVOID" or cc.tostore > 0)
    if ls.t.token == "}" then break end
    self:closelistfield(fs, cc)
    local c = ls.t.token

    if c == "TK_NAME" then  -- may be listfields or recfields
      luaX:lookahead(ls)
      if ls.lookahead.token ~= "=" then  -- expression?
        self:listfield(ls, cc)
      else
        self:recfield(ls, cc)
      end
    elseif c == "[" then  -- constructor_item -> recfield
      self:recfield(ls, cc)
    else  -- constructor_part -> listfield
      self:listfield(ls, cc)
    end
  until not self:testnext(ls, ",") and not self:testnext(ls, ";")
  self:check_match(ls, "}", "{", line)
  self:lastlistfield(fs, cc)
  luaP:SETARG_B(fs.f.code[pc], self:int2fb(cc.na)) -- set initial array size
  luaP:SETARG_C(fs.f.code[pc], self:int2fb(cc.nh)) -- set initial table size
end

-- }======================================================================

------------------------------------------------------------------------
-- parse the arguments (parameters) of a function declaration
-- * used in body()
------------------------------------------------------------------------
function luaY:parlist(ls)
  -- parlist -> [ param { ',' param } ]
  local fs = ls.fs
  local f = fs.f
  local nparams = 0
  f.is_vararg = 0
  if ls.t.token ~= ")" then  -- is 'parlist' not empty?
    repeat
      local c = ls.t.token
      if c == "TK_NAME" then  -- param -> NAME
        self:new_localvar(ls, self:str_checkname(ls), nparams)
        nparams = nparams + 1
      elseif c == "TK_DOTS" then  -- param -> `...'
        luaX:next(ls)
-- [[
-- #if defined(LUA_COMPAT_VARARG)
        -- use `arg' as default name
        self:new_localvarliteral(ls, "arg", nparams)
        nparams = nparams + 1
        f.is_vararg = self.VARARG_HASARG + self.VARARG_NEEDSARG
-- #endif
--]]
        f.is_vararg = f.is_vararg + self.VARARG_ISVARARG
      else
        luaX:syntaxerror(ls, "<name> or "..self:LUA_QL("...").." expected")
      end
    until f.is_vararg ~= 0 or not self:testnext(ls, ",")
  end--if
  self:adjustlocalvars(ls, nparams)
  -- NOTE: the following works only when HASARG_MASK is 2!
  f.numparams = fs.nactvar - (f.is_vararg % self.HASARG_MASK)
  luaK:reserveregs(fs, fs.nactvar)  -- reserve register for parameters
end

------------------------------------------------------------------------
-- parse function declaration body
-- * used in simpleexp(), localfunc(), funcstat()
------------------------------------------------------------------------
function luaY:body(ls, e, needself, line)
  -- body ->  '(' parlist ')' chunk END
  local new_fs = {}  -- FuncState
        new_fs.upvalues = {}
        new_fs.actvar = {}
  self:open_func(ls, new_fs)
  new_fs.f.lineDefined = line
  self:checknext(ls, "(")
  if needself then
    self:new_localvarliteral(ls, "self", 0)
    self:adjustlocalvars(ls, 1)
  end
  self:parlist(ls)
  self:checknext(ls, ")")
  self:chunk(ls)
  new_fs.f.lastlinedefined = ls.linenumber
  self:check_match(ls, "TK_END", "TK_FUNCTION", line)
  self:close_func(ls)
  self:pushclosure(ls, new_fs, e)
end

------------------------------------------------------------------------
-- parse a list of comma-separated expressions
-- * used is multiple locations
------------------------------------------------------------------------
function luaY:explist1(ls, v)
  -- explist1 -> expr { ',' expr }
  local n = 1  -- at least one expression
  self:expr(ls, v)
  while self:testnext(ls, ",") do
    luaK:exp2nextreg(ls.fs, v)
    self:expr(ls, v)
    n = n + 1
  end
  return n
end

------------------------------------------------------------------------
-- parse the parameters of a function call
-- * contrast with parlist(), used in function declarations
-- * used in primaryexp()
------------------------------------------------------------------------
function luaY:funcargs(ls, f)
  local fs = ls.fs
  local args = {}  -- expdesc
  local nparams
  local line = ls.linenumber
  local c = ls.t.token
  if c == "(" then  -- funcargs -> '(' [ explist1 ] ')'
    if line ~= ls.lastline then
      luaX:syntaxerror(ls, "ambiguous syntax (function call x new statement)")
    end
    luaX:next(ls)
    if ls.t.token == ")" then  -- arg list is empty?
      args.k = "VVOID"
    else
      self:explist1(ls, args)
      luaK:setmultret(fs, args)
    end
    self:check_match(ls, ")", "(", line)
  elseif c == "{" then  -- funcargs -> constructor
    self:constructor(ls, args)
  elseif c == "TK_STRING" then  -- funcargs -> STRING
    self:codestring(ls, args, ls.t.seminfo)
    luaX:next(ls)  -- must use 'seminfo' before 'next'
  else
    luaX:syntaxerror(ls, "function arguments expected")
    return
  end
  assert(f.k == "VNONRELOC")
  local base = f.info  -- base register for call
  if self:hasmultret(args.k) then
    nparams = self.LUA_MULTRET  -- open call
  else
    if args.k ~= "VVOID" then
      luaK:exp2nextreg(fs, args)  -- close last argument
    end
    nparams = fs.freereg - (base + 1)
  end
  self:init_exp(f, "VCALL", luaK:codeABC(fs, "OP_CALL", base, nparams + 1, 2))
  luaK:fixline(fs, line)
  fs.freereg = base + 1  -- call remove function and arguments and leaves
                         -- (unless changed) one result
end

--[[--------------------------------------------------------------------
-- Expression parsing
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- parses an expression in parentheses or a single variable
-- * used in primaryexp()
------------------------------------------------------------------------
function luaY:prefixexp(ls, v)
  -- prefixexp -> NAME | '(' expr ')'
  local c = ls.t.token
  if c == "(" then
    local line = ls.linenumber
    luaX:next(ls)
    self:expr(ls, v)
    self:check_match(ls, ")", "(", line)
    luaK:dischargevars(ls.fs, v)
  elseif c == "TK_NAME" then
    self:singlevar(ls, v)
  else
    luaX:syntaxerror(ls, "unexpected symbol")
  end--if c
  return
end

------------------------------------------------------------------------
-- parses a prefixexp (an expression in parentheses or a single variable)
-- or a function call specification
-- * used in simpleexp(), assignment(), exprstat()
------------------------------------------------------------------------
function luaY:primaryexp(ls, v)
  -- primaryexp ->
  --    prefixexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs }
  local fs = ls.fs
  self:prefixexp(ls, v)
  while true do
    local c = ls.t.token
    if c == "." then  -- field
      self:field(ls, v)
    elseif c == "[" then  -- '[' exp1 ']'
      local key = {}  -- expdesc
      luaK:exp2anyreg(fs, v)
      self:yindex(ls, key)
      luaK:indexed(fs, v, key)
    elseif c == ":" then  -- ':' NAME funcargs
      local key = {}  -- expdesc
      luaX:next(ls)
      self:checkname(ls, key)
      luaK:_self(fs, v, key)
      self:funcargs(ls, v)
    elseif c == "(" or c == "TK_STRING" or c == "{" then  -- funcargs
      luaK:exp2nextreg(fs, v)
      self:funcargs(ls, v)
    else
      return
    end--if c
  end--while
end

------------------------------------------------------------------------
-- parses general expression types, constants handled here
-- * used in subexpr()
------------------------------------------------------------------------
function luaY:simpleexp(ls, v)
  -- simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | ... |
  --              constructor | FUNCTION body | primaryexp
  local c = ls.t.token
  if c == "TK_NUMBER" then
    self:init_exp(v, "VKNUM", 0)
    v.nval = ls.t.seminfo
  elseif c == "TK_STRING" then
    self:codestring(ls, v, ls.t.seminfo)
  elseif c == "TK_NIL" then
    self:init_exp(v, "VNIL", 0)
  elseif c == "TK_TRUE" then
    self:init_exp(v, "VTRUE", 0)
  elseif c == "TK_FALSE" then
    self:init_exp(v, "VFALSE", 0)
  elseif c == "TK_DOTS" then  -- vararg
    local fs = ls.fs
    self:check_condition(ls, fs.f.is_vararg ~= 0,
                    "cannot use "..self:LUA_QL("...").." outside a vararg function");
    -- NOTE: the following substitutes for a bitop, but is value-specific
    local is_vararg = fs.f.is_vararg
    if is_vararg >= self.VARARG_NEEDSARG then
      fs.f.is_vararg = is_vararg - self.VARARG_NEEDSARG  -- don't need 'arg'
    end
    self:init_exp(v, "VVARARG", luaK:codeABC(fs, "OP_VARARG", 0, 1, 0))
  elseif c == "{" then  -- constructor
    self:constructor(ls, v)
    return
  elseif c == "TK_FUNCTION" then
    luaX:next(ls)
    self:body(ls, v, false, ls.linenumber)
    return
  else
    self:primaryexp(ls, v)
    return
  end--if c
  luaX:next(ls)
end

------------------------------------------------------------------------
-- Translates unary operators tokens if found, otherwise returns
-- OPR_NOUNOPR. getunopr() and getbinopr() are used in subexpr().
-- * used in subexpr()
------------------------------------------------------------------------
function luaY:getunopr(op)
  if op == "TK_NOT" then
    return "OPR_NOT"
  elseif op == "-" then
    return "OPR_MINUS"
  elseif op == "#" then
    return "OPR_LEN"
  else
    return "OPR_NOUNOPR"
  end
end

------------------------------------------------------------------------
-- Translates binary operator tokens if found, otherwise returns
-- OPR_NOBINOPR. Code generation uses OPR_* style tokens.
-- * used in subexpr()
------------------------------------------------------------------------
luaY.getbinopr_table = {
  ["+"] = "OPR_ADD",
  ["-"] = "OPR_SUB",
  ["*"] = "OPR_MUL",
  ["/"] = "OPR_DIV",
  ["%"] = "OPR_MOD",
  ["^"] = "OPR_POW",
  ["TK_CONCAT"] = "OPR_CONCAT",
  ["TK_NE"] = "OPR_NE",
  ["TK_EQ"] = "OPR_EQ",
  ["<"] = "OPR_LT",
  ["TK_LE"] = "OPR_LE",
  [">"] = "OPR_GT",
  ["TK_GE"] = "OPR_GE",
  ["TK_AND"] = "OPR_AND",
  ["TK_OR"] = "OPR_OR",
}
function luaY:getbinopr(op)
  local opr = self.getbinopr_table[op]
  if opr then return opr else return "OPR_NOBINOPR" end
end

------------------------------------------------------------------------
-- the following priority table consists of pairs of left/right values
-- for binary operators (was a static const struct); grep for ORDER OPR
-- * the following struct is replaced:
--   static const struct {
--     lu_byte left;  /* left priority for each binary operator */
--     lu_byte right; /* right priority */
--   } priority[] = {  /* ORDER OPR */
------------------------------------------------------------------------
luaY.priority = {
  {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7}, -- `+' `-' `/' `%'
  {10, 9}, {5, 4},                 -- power and concat (right associative)
  {3, 3}, {3, 3},                  -- equality
  {3, 3}, {3, 3}, {3, 3}, {3, 3},  -- order
  {2, 2}, {1, 1}                   -- logical (and/or)
}

luaY.UNARY_PRIORITY = 8  -- priority for unary operators

------------------------------------------------------------------------
-- Parse subexpressions. Includes handling of unary operators and binary
-- operators. A subexpr is given the rhs priority level of the operator
-- immediately left of it, if any (limit is -1 if none,) and if a binop
-- is found, limit is compared with the lhs priority level of the binop
-- in order to determine which executes first.
------------------------------------------------------------------------

------------------------------------------------------------------------
-- subexpr -> (simpleexp | unop subexpr) { binop subexpr }
-- where 'binop' is any binary operator with a priority higher than 'limit'
-- * for priority lookups with self.priority[], 1=left and 2=right
-- * recursively called
-- * used in expr()
------------------------------------------------------------------------
function luaY:subexpr(ls, v, limit)
  self:enterlevel(ls)
  local uop = self:getunopr(ls.t.token)
  if uop ~= "OPR_NOUNOPR" then
    luaX:next(ls)
    self:subexpr(ls, v, self.UNARY_PRIORITY)
    luaK:prefix(ls.fs, uop, v)
  else
    self:simpleexp(ls, v)
  end
  -- expand while operators have priorities higher than 'limit'
  local op = self:getbinopr(ls.t.token)
  while op ~= "OPR_NOBINOPR" and self.priority[luaK.BinOpr[op] + 1][1] > limit do
    local v2 = {}  -- expdesc
    luaX:next(ls)
    luaK:infix(ls.fs, op, v)
    -- read sub-expression with higher priority
    local nextop = self:subexpr(ls, v2, self.priority[luaK.BinOpr[op] + 1][2])
    luaK:posfix(ls.fs, op, v, v2)
    op = nextop
  end
  self:leavelevel(ls)
  return op  -- return first untreated operator
end

------------------------------------------------------------------------
-- Expression parsing starts here. Function subexpr is entered with the
-- left operator (which is non-existent) priority of -1, which is lower
-- than all actual operators. Expr information is returned in parm v.
-- * used in multiple locations
------------------------------------------------------------------------
function luaY:expr(ls, v)
  self:subexpr(ls, v, 0)
end

-- }====================================================================

--[[--------------------------------------------------------------------
-- Rules for Statements
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- checks next token, used as a look-ahead
-- * returns boolean instead of 0|1
-- * used in retstat(), chunk()
------------------------------------------------------------------------
function luaY:block_follow(token)
  if token == "TK_ELSE" or token == "TK_ELSEIF" or token == "TK_END"
     or token == "TK_UNTIL" or token == "TK_EOS" then
    return true
  else
    return false
  end
end

------------------------------------------------------------------------
-- parse a code block or unit
-- * used in multiple functions
------------------------------------------------------------------------
function luaY:block(ls)
  -- block -> chunk
  local fs = ls.fs
  local bl = {}  -- BlockCnt
  self:enterblock(fs, bl, false)
  self:chunk(ls)
  assert(bl.breaklist == luaK.NO_JUMP)
  self:leaveblock(fs)
end

------------------------------------------------------------------------
-- structure to chain all variables in the left-hand side of an
-- assignment
-- struct LHS_assign:
--   prev  -- (table: struct LHS_assign)
--   v  -- variable (global, local, upvalue, or indexed) (table: expdesc)
------------------------------------------------------------------------

------------------------------------------------------------------------
-- check whether, in an assignment to a local variable, the local variable
-- is needed in a previous assignment (to a table). If so, save original
-- local value in a safe place and use this safe copy in the previous
-- assignment.
-- * used in assignment()
------------------------------------------------------------------------
function luaY:check_conflict(ls, lh, v)
  local fs = ls.fs
  local extra = fs.freereg  -- eventual position to save local variable
  local conflict = false
  while lh do
    if lh.v.k == "VINDEXED" then
      if lh.v.info == v.info then  -- conflict?
        conflict = true
        lh.v.info = extra  -- previous assignment will use safe copy
      end
      if lh.v.aux == v.info then  -- conflict?
        conflict = true
        lh.v.aux = extra  -- previous assignment will use safe copy
      end
    end
    lh = lh.prev
  end
  if conflict then
    luaK:codeABC(fs, "OP_MOVE", fs.freereg, v.info, 0)  -- make copy
    luaK:reserveregs(fs, 1)
  end
end

------------------------------------------------------------------------
-- parse a variable assignment sequence
-- * recursively called
-- * used in exprstat()
------------------------------------------------------------------------
function luaY:assignment(ls, lh, nvars)
  local e = {}  -- expdesc
  -- test was: VLOCAL <= lh->v.k && lh->v.k <= VINDEXED
  local c = lh.v.k
  self:check_condition(ls, c == "VLOCAL" or c == "VUPVAL" or c == "VGLOBAL"
                       or c == "VINDEXED", "syntax error")
  if self:testnext(ls, ",") then  -- assignment -> ',' primaryexp assignment
    local nv = {}  -- LHS_assign
          nv.v = {}
    nv.prev = lh
    self:primaryexp(ls, nv.v)
    if nv.v.k == "VLOCAL" then
      self:check_conflict(ls, lh, nv.v)
    end
    self:checklimit(ls.fs, nvars, self.LUAI_MAXCCALLS - ls.L.nCcalls,
                    "variables in assignment")
    self:assignment(ls, nv, nvars + 1)
  else  -- assignment -> '=' explist1
    self:checknext(ls, "=")
    local nexps = self:explist1(ls, e)
    if nexps ~= nvars then
      self:adjust_assign(ls, nvars, nexps, e)
      if nexps > nvars then
        ls.fs.freereg = ls.fs.freereg - (nexps - nvars)  -- remove extra values
      end
    else
      luaK:setoneret(ls.fs, e)  -- close last expression
      luaK:storevar(ls.fs, lh.v, e)
      return  -- avoid default
    end
  end
  self:init_exp(e, "VNONRELOC", ls.fs.freereg - 1)  -- default assignment
  luaK:storevar(ls.fs, lh.v, e)
end

------------------------------------------------------------------------
-- parse condition in a repeat statement or an if control structure
-- * used in repeatstat(), test_then_block()
------------------------------------------------------------------------
function luaY:cond(ls)
  -- cond -> exp
  local v = {}  -- expdesc
  self:expr(ls, v)  -- read condition
  if v.k == "VNIL" then v.k = "VFALSE" end  -- 'falses' are all equal here
  luaK:goiftrue(ls.fs, v)
  return v.f
end

------------------------------------------------------------------------
-- parse a break statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:breakstat(ls)
  -- stat -> BREAK
  local fs = ls.fs
  local bl = fs.bl
  local upval = false
  while bl and not bl.isbreakable do
    if bl.upval then upval = true end
    bl = bl.previous
  end
  if not bl then
    luaX:syntaxerror(ls, "no loop to break")
  end
  if upval then
    luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
  end
  bl.breaklist = luaK:concat(fs, bl.breaklist, luaK:jump(fs))
end

------------------------------------------------------------------------
-- parse a while-do control structure, body processed by block()
-- * with dynamic array sizes, MAXEXPWHILE + EXTRAEXP limits imposed by
--   the function's implementation can be removed
-- * used in statements()
------------------------------------------------------------------------
function luaY:whilestat(ls, line)
  -- whilestat -> WHILE cond DO block END
  local fs = ls.fs
  local bl = {}  -- BlockCnt
  luaX:next(ls)  -- skip WHILE
  local whileinit = luaK:getlabel(fs)
  local condexit = self:cond(ls)
  self:enterblock(fs, bl, true)
  self:checknext(ls, "TK_DO")
  self:block(ls)
  luaK:patchlist(fs, luaK:jump(fs), whileinit)
  self:check_match(ls, "TK_END", "TK_WHILE", line)
  self:leaveblock(fs)
  luaK:patchtohere(fs, condexit)  -- false conditions finish the loop
end

------------------------------------------------------------------------
-- parse a repeat-until control structure, body parsed by chunk()
-- * used in statements()
------------------------------------------------------------------------
function luaY:repeatstat(ls, line)
  -- repeatstat -> REPEAT block UNTIL cond
  local fs = ls.fs
  local repeat_init = luaK:getlabel(fs)
  local bl1, bl2 = {}, {}  -- BlockCnt
  self:enterblock(fs, bl1, true)  -- loop block
  self:enterblock(fs, bl2, false)  -- scope block
  luaX:next(ls)  -- skip REPEAT
  self:chunk(ls)
  self:check_match(ls, "TK_UNTIL", "TK_REPEAT", line)
  local condexit = self:cond(ls)  -- read condition (inside scope block)
  if not bl2.upval then  -- no upvalues?
    self:leaveblock(fs)  -- finish scope
    luaK:patchlist(ls.fs, condexit, repeat_init)  -- close the loop
  else  -- complete semantics when there are upvalues
    self:breakstat(ls)  -- if condition then break
    luaK:patchtohere(ls.fs, condexit)  -- else...
    self:leaveblock(fs)  -- finish scope...
    luaK:patchlist(ls.fs, luaK:jump(fs), repeat_init)  -- and repeat
  end
  self:leaveblock(fs)  -- finish loop
end

------------------------------------------------------------------------
-- parse the single expressions needed in numerical for loops
-- * used in fornum()
------------------------------------------------------------------------
function luaY:exp1(ls)
  local e = {}  -- expdesc
  self:expr(ls, e)
  local k = e.k
  luaK:exp2nextreg(ls.fs, e)
  return k
end

------------------------------------------------------------------------
-- parse a for loop body for both versions of the for loop
-- * used in fornum(), forlist()
------------------------------------------------------------------------
function luaY:forbody(ls, base, line, nvars, isnum)
  -- forbody -> DO block
  local bl = {}  -- BlockCnt
  local fs = ls.fs
  self:adjustlocalvars(ls, 3)  -- control variables
  self:checknext(ls, "TK_DO")
  local prep = isnum and luaK:codeAsBx(fs, "OP_FORPREP", base, luaK.NO_JUMP)
                     or luaK:jump(fs)
  self:enterblock(fs, bl, false)  -- scope for declared variables
  self:adjustlocalvars(ls, nvars)
  luaK:reserveregs(fs, nvars)
  self:block(ls)
  self:leaveblock(fs)  -- end of scope for declared variables
  luaK:patchtohere(fs, prep)
  local endfor = isnum and luaK:codeAsBx(fs, "OP_FORLOOP", base, luaK.NO_JUMP)
                       or luaK:codeABC(fs, "OP_TFORLOOP", base, 0, nvars)
  luaK:fixline(fs, line)  -- pretend that `OP_FOR' starts the loop
  luaK:patchlist(fs, isnum and endfor or luaK:jump(fs), prep + 1)
end

------------------------------------------------------------------------
-- parse a numerical for loop, calls forbody()
-- * used in forstat()
------------------------------------------------------------------------
function luaY:fornum(ls, varname, line)
  -- fornum -> NAME = exp1,exp1[,exp1] forbody
  local fs = ls.fs
  local base = fs.freereg
  self:new_localvarliteral(ls, "(for index)", 0)
  self:new_localvarliteral(ls, "(for limit)", 1)
  self:new_localvarliteral(ls, "(for step)", 2)
  self:new_localvar(ls, varname, 3)
  self:checknext(ls, '=')
  self:exp1(ls)  -- initial value
  self:checknext(ls, ",")
  self:exp1(ls)  -- limit
  if self:testnext(ls, ",") then
    self:exp1(ls)  -- optional step
  else  -- default step = 1
    luaK:codeABx(fs, "OP_LOADK", fs.freereg, luaK:numberK(fs, 1))
    luaK:reserveregs(fs, 1)
  end
  self:forbody(ls, base, line, 1, true)
end

------------------------------------------------------------------------
-- parse a generic for loop, calls forbody()
-- * used in forstat()
------------------------------------------------------------------------
function luaY:forlist(ls, indexname)
  -- forlist -> NAME {,NAME} IN explist1 forbody
  local fs = ls.fs
  local e = {}  -- expdesc
  local nvars = 0
  local base = fs.freereg
  -- create control variables
  self:new_localvarliteral(ls, "(for generator)", nvars)
  nvars = nvars + 1
  self:new_localvarliteral(ls, "(for state)", nvars)
  nvars = nvars + 1
  self:new_localvarliteral(ls, "(for control)", nvars)
  nvars = nvars + 1
  -- create declared variables
  self:new_localvar(ls, indexname, nvars)
  nvars = nvars + 1
  while self:testnext(ls, ",") do
    self:new_localvar(ls, self:str_checkname(ls), nvars)
    nvars = nvars + 1
  end
  self:checknext(ls, "TK_IN")
  local line = ls.linenumber
  self:adjust_assign(ls, 3, self:explist1(ls, e), e)
  luaK:checkstack(fs, 3)  -- extra space to call generator
  self:forbody(ls, base, line, nvars - 3, false)
end

------------------------------------------------------------------------
-- initial parsing for a for loop, calls fornum() or forlist()
-- * used in statements()
------------------------------------------------------------------------
function luaY:forstat(ls, line)
  -- forstat -> FOR (fornum | forlist) END
  local fs = ls.fs
  local bl = {}  -- BlockCnt
  self:enterblock(fs, bl, true)  -- scope for loop and control variables
  luaX:next(ls)  -- skip `for'
  local varname = self:str_checkname(ls)  -- first variable name
  local c = ls.t.token
  if c == "=" then
    self:fornum(ls, varname, line)
  elseif c == "," or c == "TK_IN" then
    self:forlist(ls, varname)
  else
    luaX:syntaxerror(ls, self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")
  end
  self:check_match(ls, "TK_END", "TK_FOR", line)
  self:leaveblock(fs)  -- loop scope (`break' jumps to this point)
end

------------------------------------------------------------------------
-- parse part of an if control structure, including the condition
-- * used in ifstat()
------------------------------------------------------------------------
function luaY:test_then_block(ls)
  -- test_then_block -> [IF | ELSEIF] cond THEN block
  luaX:next(ls)  -- skip IF or ELSEIF
  local condexit = self:cond(ls)
  self:checknext(ls, "TK_THEN")
  self:block(ls)  -- `then' part
  return condexit
end

------------------------------------------------------------------------
-- parse an if control structure
-- * used in statements()
------------------------------------------------------------------------
function luaY:ifstat(ls, line)
  -- ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
  local fs = ls.fs
  local escapelist = luaK.NO_JUMP
  local flist = self:test_then_block(ls)  -- IF cond THEN block
  while ls.t.token == "TK_ELSEIF" do
    escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
    luaK:patchtohere(fs, flist)
    flist = self:test_then_block(ls)  -- ELSEIF cond THEN block
  end
  if ls.t.token == "TK_ELSE" then
    escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
    luaK:patchtohere(fs, flist)
    luaX:next(ls)  -- skip ELSE (after patch, for correct line info)
    self:block(ls)  -- 'else' part
  else
    escapelist = luaK:concat(fs, escapelist, flist)
  end
  luaK:patchtohere(fs, escapelist)
  self:check_match(ls, "TK_END", "TK_IF", line)
end

------------------------------------------------------------------------
-- parse a local function statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:localfunc(ls)
  local v, b = {}, {}  -- expdesc
  local fs = ls.fs
  self:new_localvar(ls, self:str_checkname(ls), 0)
  self:init_exp(v, "VLOCAL", fs.freereg)
  luaK:reserveregs(fs, 1)
  self:adjustlocalvars(ls, 1)
  self:body(ls, b, false, ls.linenumber)
  luaK:storevar(fs, v, b)
  -- debug information will only see the variable after this point!
  self:getlocvar(fs, fs.nactvar - 1).startpc = fs.pc
end

------------------------------------------------------------------------
-- parse a local variable declaration statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:localstat(ls)
  -- stat -> LOCAL NAME {',' NAME} ['=' explist1]
  local nvars = 0
  local nexps
  local e = {}  -- expdesc
  repeat
    self:new_localvar(ls, self:str_checkname(ls), nvars)
    nvars = nvars + 1
  until not self:testnext(ls, ",")
  if self:testnext(ls, "=") then
    nexps = self:explist1(ls, e)
  else
    e.k = "VVOID"
    nexps = 0
  end
  self:adjust_assign(ls, nvars, nexps, e)
  self:adjustlocalvars(ls, nvars)
end

------------------------------------------------------------------------
-- parse a function name specification
-- * used in funcstat()
------------------------------------------------------------------------
function luaY:funcname(ls, v)
  -- funcname -> NAME {field} [':' NAME]
  local needself = false
  self:singlevar(ls, v)
  while ls.t.token == "." do
    self:field(ls, v)
  end
  if ls.t.token == ":" then
    needself = true
    self:field(ls, v)
  end
  return needself
end

------------------------------------------------------------------------
-- parse a function statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:funcstat(ls, line)
  -- funcstat -> FUNCTION funcname body
  local v, b = {}, {}  -- expdesc
  luaX:next(ls)  -- skip FUNCTION
  local needself = self:funcname(ls, v)
  self:body(ls, b, needself, line)
  luaK:storevar(ls.fs, v, b)
  luaK:fixline(ls.fs, line)  -- definition 'happens' in the first line
end

------------------------------------------------------------------------
-- parse a function call with no returns or an assignment statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:exprstat(ls)
  -- stat -> func | assignment
  local fs = ls.fs
  local v = {}  -- LHS_assign
        v.v = {}
  self:primaryexp(ls, v.v)
  if v.v.k == "VCALL" then  -- stat -> func
    luaP:SETARG_C(luaK:getcode(fs, v.v), 1)  -- call statement uses no results
  else  -- stat -> assignment
    v.prev = nil
    self:assignment(ls, v, 1)
  end
end

------------------------------------------------------------------------
-- parse a return statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:retstat(ls)
  -- stat -> RETURN explist
  local fs = ls.fs
  local e = {}  -- expdesc
  local first, nret  -- registers with returned values
  luaX:next(ls)  -- skip RETURN
  if self:block_follow(ls.t.token) or ls.t.token == ";" then
    first, nret = 0, 0  -- return no values
  else
    nret = self:explist1(ls, e)  -- optional return values
    if self:hasmultret(e.k) then
      luaK:setmultret(fs, e)
      if e.k == "VCALL" and nret == 1 then  -- tail call?
        luaP:SET_OPCODE(luaK:getcode(fs, e), "OP_TAILCALL")
        assert(luaP:GETARG_A(luaK:getcode(fs, e)) == fs.nactvar)
      end
      first = fs.nactvar
      nret = self.LUA_MULTRET  -- return all values
    else
      if nret == 1 then  -- only one single value?
        first = luaK:exp2anyreg(fs, e)
      else
        luaK:exp2nextreg(fs, e)  -- values must go to the 'stack'
        first = fs.nactvar  -- return all 'active' values
        assert(nret == fs.freereg - first)
      end
    end--if
  end--if
  luaK:ret(fs, first, nret)
end

------------------------------------------------------------------------
-- initial parsing for statements, calls a lot of functions
-- * returns boolean instead of 0|1
-- * used in chunk()
------------------------------------------------------------------------
function luaY:statement(ls)
  local line = ls.linenumber  -- may be needed for error messages
  local c = ls.t.token
  if c == "TK_IF" then  -- stat -> ifstat
    self:ifstat(ls, line)
    return false
  elseif c == "TK_WHILE" then  -- stat -> whilestat
    self:whilestat(ls, line)
    return false
  elseif c == "TK_DO" then  -- stat -> DO block END
    luaX:next(ls)  -- skip DO
    self:block(ls)
    self:check_match(ls, "TK_END", "TK_DO", line)
    return false
  elseif c == "TK_FOR" then  -- stat -> forstat
    self:forstat(ls, line)
    return false
  elseif c == "TK_REPEAT" then  -- stat -> repeatstat
    self:repeatstat(ls, line)
    return false
  elseif c == "TK_FUNCTION" then  -- stat -> funcstat
    self:funcstat(ls, line)
    return false
  elseif c == "TK_LOCAL" then  -- stat -> localstat
    luaX:next(ls)  -- skip LOCAL
    if self:testnext(ls, "TK_FUNCTION") then  -- local function?
      self:localfunc(ls)
    else
      self:localstat(ls)
    end
    return false
  elseif c == "TK_RETURN" then  -- stat -> retstat
    self:retstat(ls)
    return true  -- must be last statement
  elseif c == "TK_BREAK" then  -- stat -> breakstat
    luaX:next(ls)  -- skip BREAK
    self:breakstat(ls)
    return true  -- must be last statement
  else
    self:exprstat(ls)
    return false  -- to avoid warnings
  end--if c
end

------------------------------------------------------------------------
-- parse a chunk, which consists of a bunch of statements
-- * used in parser(), body(), block(), repeatstat()
------------------------------------------------------------------------
function luaY:chunk(ls)
  -- chunk -> { stat [';'] }
  local islast = false
  self:enterlevel(ls)
  while not islast and not self:block_follow(ls.t.token) do
    islast = self:statement(ls)
    self:testnext(ls, ";")
    assert(ls.fs.f.maxstacksize >= ls.fs.freereg and
               ls.fs.freereg >= ls.fs.nactvar)
    ls.fs.freereg = ls.fs.nactvar  -- free registers
  end
  self:leavelevel(ls)
end

-- }======================================================================
_G.luavm.luaY = luaY
end
function scmframework_5a7d4a0d7301a43ae5184db80d2ba49b() --$CONTENT_DATA/Scripts/remade-scrapVM/LuaVM/LuaZ.lua
--[[--------------------------------------------------------------------

  lzio.lua
  Lua buffered streams in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * EOZ is implemented as a string, "EOZ"
-- * Format of z structure (ZIO)
--     z.n       -- bytes still unread
--     z.p       -- last read position position in buffer
--     z.reader  -- chunk reader function
--     z.data    -- additional data
-- * Current position, p, is now last read index instead of a pointer
--
-- Not implemented:
-- * luaZ_lookahead: used only in lapi.c:lua_load to detect binary chunk
-- * luaZ_read: used only in lundump.c:ezread to read +1 bytes
-- * luaZ_openspace: dropped; let Lua handle buffers as strings (used in
--   lundump.c:LoadString & lvm.c:luaV_concat)
-- * luaZ buffer macros: dropped; buffers are handled as strings
-- * lauxlib.c:getF reader implementation has an extraline flag to
--   skip over a shbang (#!) line, this is not implemented here
--
-- Added:
-- (both of the following are vaguely adapted from lauxlib.c)
-- * luaZ:make_getS: create Reader from a string
-- * luaZ:make_getF: create Reader that reads from a file
--
-- Changed in 5.1.x:
-- * Chunkreader renamed to Reader (ditto with Chunkwriter)
-- * Zio struct: no more name string, added Lua state for reader
--   (however, Yueliang readers do not require a Lua state)
----------------------------------------------------------------------]]

local luaZ = {}

------------------------------------------------------------------------
-- * reader() should return a string, or nil if nothing else to parse.
--   Additional data can be set only during stream initialization
-- * Readers are handled in lauxlib.c, see luaL_load(file|buffer|string)
-- * LUAL_BUFFERSIZE=BUFSIZ=512 in make_getF() (located in luaconf.h)
-- * Original Reader typedef:
--   const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);
-- * This Lua chunk reader implementation:
--   returns string or nil, no arguments to function
------------------------------------------------------------------------

------------------------------------------------------------------------
-- create a chunk reader from a source string
------------------------------------------------------------------------
function luaZ:make_getS(buff)
  local b = buff
  return function() -- chunk reader anonymous function here
    if not b then return nil end
    local data = b
    b = nil
    return data
  end
end

------------------------------------------------------------------------
-- create a chunk reader from a source file
------------------------------------------------------------------------
--[[
function luaZ:make_getF(filename)
  local LUAL_BUFFERSIZE = 512
  local h = io.open(filename, "r")
  if not h then return nil end
  return function() -- chunk reader anonymous function here
    if not h or io.type(h) == "closed file" then return nil end
    local buff = h:read(LUAL_BUFFERSIZE)
    if not buff then h:close(); h = nil end
    return buff
  end
end
--]]
------------------------------------------------------------------------
-- creates a zio input stream
-- returns the ZIO structure, z
------------------------------------------------------------------------
function luaZ:init(reader, data, name)
  if not reader then return end
  local z = {}
  z.reader = reader
  z.data = data or ""
  z.name = name
  -- set up additional data for reading
  if not data or data == "" then z.n = 0 else z.n = #data end
  z.p = 0
  return z
end

------------------------------------------------------------------------
-- fill up input buffer
------------------------------------------------------------------------
function luaZ:fill(z)
  local buff = z.reader()
  z.data = buff
  if not buff or buff == "" then return "EOZ" end
  z.n, z.p = #buff - 1, 1
  return string.sub(buff, 1, 1)
end

------------------------------------------------------------------------
-- get next character from the input stream
-- * local n, p are used to optimize code generation
------------------------------------------------------------------------
function luaZ:zgetc(z)
  local n, p = z.n, z.p + 1
  if n > 0 then
    z.n, z.p = n - 1, p
    return string.sub(z.data, p, p)
  else
    return self:fill(z)
  end
end

_G.luavm.luaZ = luaZ
end
function scmframework_220977a0d1a94beb92db8eba87381493() --$CONTENT_DATA/Scripts/remade-scrapVM/scrapvm.lua
--_G.luavm = _G.luavm or {}
_G.luavm = {}
dofile './LuaVM/LBI.lua'
dofile './LuaVM/LuaZ.lua'
dofile './LuaVM/LuaX.lua'
dofile './LuaVM/LuaP.lua'
dofile './LuaVM/LuaK.lua'
dofile './LuaVM/LuaY.lua'
dofile './LuaVM/LuaU.lua'
_G.luavm.luaX:init()

function _G.luavm.custom_loadstring(LuaState, str, env)
    local f,writer,buff
    local ran,error=pcall(function()
        local zio = _G.luavm.luaZ:init(_G.luavm.luaZ:make_getS(str), nil)
        if not zio then return error() end
        local func = _G.luavm.luaY:parser(LuaState, zio, nil, "@input")
        writer, buff = _G.luavm.luaU:make_setS()
        _G.luavm.luaU:dump(LuaState, func, writer, buff)
        f = _G.luavm.lbi.load_bytecode(buff.data, env)
    end)
    if ran then
        return f,buff.data
    else
        return nil,error
    end
end

end
function scmframework_107d20666a346d056ed024b86231b64a() --$CONTENT_DATA/Scripts/romdisk.lua
dofile("$CONTENT_DATA/Scripts/Config.lua")
dofile("$CONTENT_DATA/Scripts/FileSystem.lua")
dofile("$CONTENT_DATA/Scripts/base64.lua")

romdisk = class()
romdisk.maxParentCount = 1
romdisk.maxChildCount = 0
romdisk.connectionInput = sm.interactable.connectionType.composite
romdisk.connectionOutput = sm.interactable.connectionType.none
romdisk.colorNormal = sm.color.new(0xbf1996ff)
romdisk.colorHighlight = sm.color.new(0xec1db9ff)
romdisk.componentType = "rom" --absences can cause problems
romdisk.pathStart = "$CONTENT_"
romdisk.pathStart2 = "$GAME_DATA/ROM"
romdisk.pathEnd = ".json"

local function isPathValid1(path)
    return (#path > #romdisk.pathStart and path:sub(1, #romdisk.pathStart) == romdisk.pathStart) or (#path > #romdisk.pathStart2 and path:sub(1, #romdisk.pathStart2) == romdisk.pathStart2)
end

local function isPathValid2(path)
    return path:sub(#path - (#romdisk.pathEnd - 1), #path) == romdisk.pathEnd
end

local function isPathValid(path)
    return isPathValid1(path) and isPathValid2(path)
end

function romdisk:server_onCreate()
    self.resetLagCounter = true

    self.sdata = self.storage:load() or {path = ""}
	self:sv_setData(self.sdata)

    local api
    api = {
        open = function ()
            if isPathValid(self.sdata.path) then
                if self.cache then
                    return self.cache
                end

                local result = sm.json.open(self.sdata.path)
                if self.resetLagCounter then
                    sc.resetLagCounter()
                    self.resetLagCounter = false
                end
                self.cache = result
                return result
            else
                error("the wrong path is specified in the ROM block settings", 2)
            end
        end,
        openFilesystemImage = function()
            if self.cacheFilesystemImage then
                return self.cacheFilesystemImage
            end

            local romsource = api.open()
            local fs = FileSystem.new(math.huge)

            for path, bs64 in pairs(romsource) do
                sc.yield()

                local strs = strSplitNoYield(string, path, {"/"})
                if path:sub(1, 1) == "/" then
                    table.remove(strs, 1)
                end
                if strs[#strs] == "" then
                    table.remove(strs)
                end
                table.remove(strs)

                local pth = "/"
                for _, str in ipairs(strs) do
                    pth = pth .. str
                    print("createFolder", pcall(fs.createFolder, fs, pth))
                    pth = pth .. "/"
                end

                fs:createFile(path)
                fs:writeFile(path, base64.decode(bs64, true))
            end

            fs.maxSize = 0
            self.cacheFilesystemImage = FileSystem.createFilesystemData(self, fs, {}, true)
            return self.cacheFilesystemImage
        end,
        openFilesystemDump = function()
            if self.cacheFilesystemDump then
                return self.cacheFilesystemDump
            end

            local fs = FileSystem.deserialize({jsondata = api.open()})
            fs.maxSize = 0
            self.cacheFilesystemDump = FileSystem.createFilesystemData(self, fs, {}, true)
            return self.cacheFilesystemDump
        end,
        isAvailable = function()
            return isPathValid(self.sdata.path)
        end,
        clearCache = function()
            self:sv_resetCache()
        end
    }

    self.interactable.publicData = {
        sc_component = {
            type = romdisk.componentType,
            api = api
        }
    }
end

function romdisk:sv_setData(data)
	data.path = tostring(data.path or "")
    self.sdata = data
    self.network:sendToClients("cl_setData", self.sdata)
    self.storage:save(self.sdata)
    self.resetLagCounter = true
    self:sv_resetCache()
end

function romdisk:sv_dataRequest(_, player)
    self.network:sendToClient(player, "cl_setData", self.sdata)
end

function romdisk:sv_resetCache()
    self.cache = nil
    self.cacheFilesystemImage = nil
    self.cacheFilesystemDump = nil
end

---------------------

function romdisk:client_onCreate()
	self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/romdisk.layout", false, { backgroundAlpha = 0 })
	self.gui:setTextChangedCallback("Path", "cl_onPathChanged")
	self.gui:setButtonCallback("Save", "cl_onPathChange")

    self.network:sendToServer("sv_dataRequest")
end

function romdisk:cl_onPathChanged(_, data)
	if #data <= 256 then
        if isPathValid1(data) then
            if isPathValid2(data) then
                self.cl_temp_path = data
                self:cl_guiError(nil)
            else
                self:cl_guiError("the path must end at " .. romdisk.pathEnd)
            end
        else
            self:cl_guiError("the path must start with " .. romdisk.pathStart .. " or " .. romdisk.pathStart2)
        end
	else
		self:cl_guiError("path is too long")
	end
end

function romdisk:cl_onPathChange()
    self.csdata.path = self.cl_temp_path
    self.network:sendToServer("sv_setData", self.csdata)
	self.gui:close()
end

function romdisk:client_onInteract(_, state)
	if state and self.csdata then
        self.cl_temp_path = self.csdata.path
        self.gui:setText("Path", tostring(self.cl_temp_path))
	    self:cl_onPathChanged(nil, self.cl_temp_path)
		self.gui:open()
	end
end

function romdisk:cl_guiError(text)
	if text ~= nil then
		self.gui:setVisible("Save", false)
        self.gui:setVisible("Error", true)
		self.gui:setText("Error", text)
	else
		self.gui:setVisible("Save", true)
        self.gui:setVisible("Error", false)
		self.gui:setText("Error", "")
	end
end

function romdisk:cl_setData(data)
    self.csdata = data
end

function romdisk:client_onDestroy()
	self.gui:destroy()
end
end
function scmframework_8207867720b8e889f4d178d7ef3bcc21() --$CONTENT_DATA/Scripts/scmframeworkAPI.lua
scmframework = {
    version = "1.1",
    scomputers = scomputers,
    dofile = scmframework_dofile
}

local hookCallbackSetters = {
    "setButtonCallback",
    "setGridButtonCallback",
    "setGridItemChangedCallback",
    "setGridMouseFocusCallback",
    "setListSelectionCallback",
    "setSliderCallback",
    "setTextAcceptedCallback",
    "setTextChangedCallback"
}

local hookGuiCreators = {
    "createAmmunitionContainerGui",
    "createBagIconGui",
    "createBatteryContainerGui",
    "createBeaconIconGui",
    "createChallengeHUDGui",
    "createChallengeMessageGui",
    "createCharacterCustomizationGui",
    "createChemicalContainerGui",
    "createContainerGui",
    "createCraftBotGui",
    "createDressBotGui",
    "createEngineGui",
    "createFertilizerContainerGui",
    "createGasContainerGui",
    "createGuiFromLayout",
    "createHideoutGui",
    "createLogbookGui",
    "createMechanicStationGui",
    "createNameTagGui",
    "createQuestTrackerGui",
    "createSeatGui",
    "createSeatUpgradeGui",
    "createSeedContainerGui",
    "createSteeringBearingGui",
    "createSurvivalHudGui",
    "createWaterContainerGui",
    "createWaypointIconGui",
    "createWorkbenchGui",
    "createWorldIconGui"
}

----------------------------------------------

local isRealObjectExists_tag = {}

local function loadRealObject(fakeObject)
    local ok, result = pcall(function ()
        if fakeObject.isRealObjectExists == isRealObjectExists_tag then
            return fakeObject.realObject
        end
    end)
    if ok and result then
        return result
    end
    return fakeObject
end

local function getBundle(virtualShape)
    if sm.isServerMode() then
        return virtualShape.sv_bundle or error("failed to get bundle server reference")
    else
        return virtualShape.cl_bundle or error("failed to get bundle client reference")
    end
end

----------------------------------------------

local virtualShapeClass = {}

function virtualShapeClass:interact(character, state)
    if self.self.client_onInteract then
        self.self:client_onInteract(character, state)
    end
end

function virtualShapeClass:tinker(character, state)
    if self.self.client_onTinker then
        self.self:client_onTinker(character, state)
    end
end

function virtualShapeClass:canInteract(character)
    if self.self.client_canInteract then
        return not not self.self:client_canInteract(character)
    end
    return not not self.self.client_onInteract
end

function virtualShapeClass:canTinker(character)
    if self.self.client_canTinker then
        return not not self.self:client_canTinker(character)
    end
    return not not self.self.client_onTinker
end

function virtualShapeClass:createVirtualLink(child)
    local bundle = getBundle(self)
    if not bundle.virtualLinks_childen[self] then bundle.virtualLinks_childen[self] = {} end
    if not bundle.virtualLinks_parents[child] then bundle.virtualLinks_parents[child] = {} end
    table.insert(bundle.virtualLinks_childen[self], child.interactable)
    table.insert(bundle.virtualLinks_parents[child], self.interactable)
end

function virtualShapeClass:setOpenedOutput(openedOutput)
    self.openedOutput = not not openedOutput
end

function virtualShapeClass:setOpenedInput(openedInput)
    self.openedInput = not not openedInput
end

----------------------------------------------

local virtualComputer = {}

function virtualComputer:getEnv()
    return self.self.env
end

function virtualComputer:reboot()
    self.self.reboot_flag = true
end

function virtualComputer:setActive(active)
    self.self.external_active = not not active
end

function virtualComputer:isActive()
    return self.self.isActive
end

----------------------------------------------

local function mt_hook(mt)
	local empty_class = class(mt)
    empty_class.__index = mt.__index
    return empty_class()
end

local function createVirtualNetwork(virtualShape)
    virtualShape.self.network = {}

    virtualShape.self.network.realObject = virtualShape.realSelf.network
    virtualShape.self.network.isRealObjectExists = isRealObjectExists_tag

    function virtualShape.self.network:sendToServer(method, arg)
        if sm.isServerMode() then
            error("Sandbox violation (virtualShape): calling client function from server callback.", 2)
        end
        table.insert(getBundle(virtualShape).sendBuffer, {target="server",arg={method, arg, virtualShape.index}})
    end

    function virtualShape.self.network:sendToClient(player, method, arg)
        if not sm.isServerMode() then
            error("Sandbox violation (virtualShape): calling server function from client callback.", 2)
        end
        table.insert(getBundle(virtualShape).sendBuffer, {player=player,target="client",arg={method, arg, virtualShape.index}})
    end

    function virtualShape.self.network:sendToClients(method, arg)
        if not sm.isServerMode() then
            error("Sandbox violation (virtualShape): calling server function from client callback.", 2)
        end
        table.insert(getBundle(virtualShape).sendBuffer, {target="clients",arg={method, arg, virtualShape.index}})
    end
end

local function createVirtualStorage(virtualShape)
    virtualShape.self.storage = {}

    virtualShape.self.storage.realObject = virtualShape.realSelf.storage
    virtualShape.self.storage.isRealObjectExists = isRealObjectExists_tag

    local realStorageData = virtualShape.realSelf.storage:load()
    if type(realStorageData) ~= "table" then realStorageData = {} end
    realStorageData.virtualStorage = realStorageData.virtualStorage or {}

    function virtualShape.self.storage:load()
        return realStorageData.virtualStorage[virtualShape.index] or virtualShape.defaultStorage
    end

    function virtualShape.self.storage:save(data)
        realStorageData.virtualStorage[virtualShape.index] = data
        virtualShape.realSelf.storage:save(realStorageData)
    end
end

local function hookValue(tbl, key)
    local val = tbl[key]
    if type(val) == "function" then
        return function(_, ...)
            return val(tbl, ...)
        end
    end
    return val
end

local function createVirtualShape(virtualShape)
    local realSelf = virtualShape.realSelf

    virtualShape.shape = mt_hook({
        __index = function(_, key)
            if key == "interactable" then
                return virtualShape.interactable
            end
            return hookValue(realSelf.shape, key)
        end
    })

    virtualShape.shape.realObject = realSelf.shape
    virtualShape.shape.isRealObjectExists = isRealObjectExists_tag

    virtualShape.self.shape = virtualShape.shape
end

local function copyTable(tbl, newtbl)
    for _, v in ipairs(newtbl or {}) do
        table.insert(tbl, v)
    end
end

local function copyTableKV(tbl, newtbl)
    for k, v in pairs(newtbl or {}) do
       tbl[k] = v
    end
end

local function createVirtualInteractable(virtualShape)
    local realSelf = virtualShape.realSelf

    virtualShape.interactable = mt_hook({
        __index = function(_, key)
            if key == "shape" then
                return virtualShape.shape
            elseif key == "body" then
                return realSelf.shape.body
            end
            return hookValue(realSelf.interactable, key)
        end
    })

    virtualShape.interactable.id = math.random(0, 9999999)
    virtualShape.interactable.active = false
    virtualShape.interactable.power = 0
    virtualShape.interactable.type = "scripted"
    virtualShape.interactable.publicData = {}

    virtualShape.interactable.realObject = realSelf.interactable
    virtualShape.interactable.isRealObjectExists = isRealObjectExists_tag

    function virtualShape.interactable:getShape()
        return virtualShape.shape
    end

    function virtualShape.interactable:getBody()
        return virtualShape.shape.body
    end

    function virtualShape.interactable:getType()
        return virtualShape.interactable.type
    end

    function virtualShape.interactable:getId()
        return virtualShape.interactable.id
    end

    function virtualShape.interactable:isActive()
        return virtualShape.interactable.active
    end

    function virtualShape.interactable:setActive(active)
        checkArg(1, active, "boolean")
        virtualShape.interactable.active = active
    end

    function virtualShape.interactable:setPower(power)
        checkArg(1, power, "number")
        virtualShape.interactable.power = power
    end

    function virtualShape.interactable:getPower()
        return virtualShape.interactable.power
    end

    function virtualShape.interactable:setPublicData(publicData)
        virtualShape.interactable.publicData = publicData
    end

    function virtualShape.interactable:getPublicData(publicData)
        return virtualShape.interactable.publicData
    end

    function virtualShape.interactable:getChildren()
        local tbl = {}
        copyTable(tbl, getBundle(virtualShape).virtualLinks_childen[virtualShape])
        if virtualShape.openedOutput then
            copyTable(tbl, realSelf.interactable:getChildren())
        end
        return tbl
    end

    function virtualShape.interactable:getParents()
        local tbl = {}
        copyTable(tbl, getBundle(virtualShape).virtualLinks_parents[virtualShape])
        if virtualShape.openedInput then
            copyTable(tbl, realSelf.interactable:getParents())
        end
        return tbl
    end

    local poseWeight = {}
    function virtualShape.interactable:setPoseWeight(index, value)
        poseWeight[index] = value
    end

    function virtualShape.interactable:getPoseWeight(index)
        return poseWeight[index] or 0
    end

    local uvFrameIndex = 0
    function virtualShape.interactable:setUvFrameIndex(index)
        uvFrameIndex = index
    end

    function virtualShape.interactable:getUvFrameIndex()
        return uvFrameIndex
    end
    
    virtualShape.self.interactable = virtualShape.interactable
end

local function createFakeGui(virtualShape, gui)
    local fake = mt_hook({
        __index = function(_, key)
            return function(_, ...)
                return gui[key](gui, ...)
            end
        end
    })

    for _, callbackSetter in ipairs(hookCallbackSetters) do
        fake[callbackSetter] = function(_, widgetName, callback)
            getBundle(virtualShape).guiCallbacks[widgetName] = {virtualShape, callback}
            return gui[callbackSetter](gui, widgetName, "cl_guiCallback")
        end
    end

    fake.setOnCloseCallback = function(_, callback)
        getBundle(virtualShape).guiCloseCallbacks[virtualShape] = callback
        return gui:setOnCloseCallback("cl_guiCloseCallback")
    end

    return fake
end

local sm_gui = sm.gui
local function loadFakeGui(virtualShape)
    if not virtualShape.fake_gui then
        virtualShape.fake_gui = {}
        for k, v in pairs(sm_gui) do
            virtualShape.fake_gui[k] = v
        end

        for _, guiCreator in ipairs(hookGuiCreators) do
            virtualShape.fake_gui[guiCreator] = function(...)
                return createFakeGui(virtualShape, sm_gui[guiCreator](...))
            end
        end
    end
    return virtualShape.fake_gui
end

local sm_interactable_getChildren = sm.interactable.getChildren
local sm_interactable_getParents = sm.interactable.getParents

local function fake_interactable_getChildren(interactable)
    return interactable:getChildren()
end

local function fake_interactable_getParents(interactable)
    return interactable:getParents()
end

local sm_effect_createEffect = sm.effect.createEffect

local function fake_effect_createEffect(name, target, boneName)
    return sm_effect_createEffect(name, loadRealObject(target), boneName)
end

local sm_exists = sm.exists

local function fake_exists(obj)
    return sm_exists(loadRealObject(obj))
end

local _type = type

local function new_type(val)
    return _type(loadRealObject(val))
end

local function pushBaseEnvHacks()
    sm.interactable.getChildren = fake_interactable_getChildren
    sm.interactable.getParents = fake_interactable_getParents
    sm.effect.createEffect = fake_effect_createEffect
    sm.exists = fake_exists
    type = new_type
end

local function popBaseEnvHacks()
    sm.interactable.getChildren = sm_interactable_getChildren
    sm.interactable.getParents = sm_interactable_getParents
    sm.effect.createEffect = sm_effect_createEffect
    sm.exists = sm_exists
    type = _type
end

local function pushEnvHacks(virtualShape)
    if not sm.isServerMode() then
        sm.gui = loadFakeGui(virtualShape)
    end
    pushBaseEnvHacks()
end

local function popEnvHacks(virtualShape)
    if not sm.isServerMode() then
        sm.gui = sm_gui
    end
    popBaseEnvHacks()
end

local function createVirtualShapeBundle(realSelf, clientMode)
    local prefix = clientMode and "client_" or "server_"
    local bundle = {
        sendBuffer = {},
        virtualShapes = {},
        guiCallbacks = {},
        guiCloseCallbacks = {},
        virtualLinks_childen = {},
        virtualLinks_parents = {}
    }

    local function runMethodWithoutPrefix(virtualShape, method, ...)
        local func = virtualShape.self[method]
        if func then
            pushEnvHacks(virtualShape)
            func(virtualShape.self, ...)
            popEnvHacks(virtualShape)
        end
    end

    local function runMethod(virtualShape, method, ...)
        runMethodWithoutPrefix(virtualShape, prefix .. method, ...)
    end

    function bundle.runMethod(method, ...)
        for _, virtualShape in ipairs(bundle.virtualShapes) do
            runMethod(virtualShape, method, ...)
        end
    end

    local function addBundleToShape(virtualShape, bundle)
        if sm.isServerMode() then
            virtualShape.sv_bundle = bundle
        else
            virtualShape.cl_bundle = bundle
        end
    end

    function bundle.addShape(klass, scriptedData, defaultStorage)
        local index = #bundle.virtualShapes + 1
        if realSelf.clientServerVirtualShapeLink[index] then
            local virtualShape = realSelf.clientServerVirtualShapeLink[index]
            addBundleToShape(virtualShape, bundle)
            table.insert(bundle.virtualShapes, virtualShape)
            runMethod(virtualShape, "onCreate")
            return virtualShape
        else
            local virtualSelf = klass()
            virtualSelf.data = scriptedData

            local virtualShape = {
                class = klass,
                data = scriptedData,
                defaultStorage = defaultStorage,
                self = virtualSelf,
                index = index,
                realSelf = realSelf,
                openedInput = false,
                openedOutput = false
            }

            addBundleToShape(virtualShape, bundle)
    
            for k, v in pairs(virtualShapeClass) do
                virtualShape[k] = v
            end
    
            createVirtualShape(virtualShape)
            createVirtualInteractable(virtualShape)
            createVirtualNetwork(virtualShape)
            createVirtualStorage(virtualShape)
    
            table.insert(bundle.virtualShapes, virtualShape)
            runMethod(virtualShape, "onCreate")
    
            realSelf.clientServerVirtualShapeLink[index] = virtualShape
            return virtualShape
        end
    end

    function bundle.networkCallback(package, player)
        local virtualShape = assert(bundle.virtualShapes[package[3]])
        runMethodWithoutPrefix(virtualShape, package[1], package[2], player)
    end

    function bundle.guiCallback(widgetName, ...)
        local callbackInfo = assert(bundle.guiCallbacks[widgetName])
        runMethodWithoutPrefix(callbackInfo[1], callbackInfo[2], widgetName, ...)
    end

    function bundle.guiCloseCallback(...)
        for virtualShape, callback in pairs(bundle.guiCloseCallbacks) do
            runMethodWithoutPrefix(virtualShape, callback, ...)
        end
    end

    function bundle.getNetwork()
        local _sendBuffer = bundle.sendBuffer
        bundle.sendBuffer = {}
        return _sendBuffer
    end

    function bundle.destroy()
        for _, virtualShape in ipairs(bundle.virtualShapes) do
            runMethod(virtualShape, "onDestroy")
        end
    end

    return bundle
end

----------------------------------------------

scmframework.scmframeworkClass = class()

function scmframework.scmframeworkClass:server_onCreate()
    self.clientServerVirtualShapeLink = self.clientServerVirtualShapeLink or {}
    self.sv_virtualShapeBundle = createVirtualShapeBundle(self, false)

    if self.scmframework_init then
        self:scmframework_init()
    end
end

function scmframework.scmframeworkClass:client_onCreate()
    self.clientServerVirtualShapeLink = self.clientServerVirtualShapeLink or {}
    self.cl_virtualShapeBundle = createVirtualShapeBundle(self, true)

    if self.scmframework_init then
        self:scmframework_init()
    end
end

local function doNetwork(self, sendBuffer)
    for _, rawPackage in ipairs(sendBuffer) do
        if rawPackage.target == "server" then
            self.network:sendToServer("sv_network", rawPackage.arg)
        elseif rawPackage.target == "clients" then
            self.network:sendToClients("cl_network", rawPackage.arg)
        elseif rawPackage.target == "client" then
            self.network:sendToClient(rawPackage.player, "cl_network", rawPackage.arg)
        end
    end
end

function scmframework.scmframeworkClass:server_onFixedUpdate(dt)
    self.sv_virtualShapeBundle.runMethod("onFixedUpdate", dt)
    doNetwork(self, self.sv_virtualShapeBundle.getNetwork())
end

function scmframework.scmframeworkClass:client_onFixedUpdate(dt)
    self.cl_virtualShapeBundle.runMethod("onFixedUpdate", dt)
    doNetwork(self, self.cl_virtualShapeBundle.getNetwork())
end

function scmframework.scmframeworkClass:client_onUpdate(dt)
    self.cl_virtualShapeBundle.runMethod("onUpdate", dt)
end

function scmframework.scmframeworkClass:sv_network(package, player)
    self.sv_virtualShapeBundle.networkCallback(package, player)
end

function scmframework.scmframeworkClass:cl_network(package)
    self.cl_virtualShapeBundle.networkCallback(package)
end

function scmframework.scmframeworkClass:cl_guiCallback(widgetName, ...)
    self.cl_virtualShapeBundle.guiCallback(widgetName, ...)
end

function scmframework.scmframeworkClass:cl_guiCloseCallback(...)
    self.cl_virtualShapeBundle.guiCloseCallback(...)
end

function scmframework.scmframeworkClass:server_onDestroy()
    self.sv_virtualShapeBundle.destroy()
end

function scmframework.scmframeworkClass:client_onDestroy()
    self.cl_virtualShapeBundle.destroy()
end

function scmframework.scmframeworkClass:addVirtualShape(...)
    if sm.isServerMode() then
        return self.sv_virtualShapeBundle.addShape(...)
    else
        return self.cl_virtualShapeBundle.addShape(...)
    end
end

function scmframework.scmframeworkClass:addVirtualComputer(defaultScript, defaultData, alwaysOn, unsafe, localEnvHook)
    checkArg(1, defaultScript, "string", "nil")
    checkArg(2, defaultData, "string", "nil")
    checkArg(3, alwaysOn, "boolean", "nil")
    checkArg(4, unsafe, "boolean", "nil")
    checkArg(5, localEnvHook, "function", "nil")

    local virtualShape = self:addVirtualShape(ScriptableComputer, {
        unsafe = unsafe,
        localEnvHook = localEnvHook
    }, {
        alwaysOn = alwaysOn,

        script = defaultScript or "",
        gsubFix = true,

        userdata = base64.encode(defaultData or ""),
        userdata_bs64 = true
    })
    copyTableKV(virtualShape, virtualComputer)
    return virtualShape
end

function scmframework.scmframeworkClass:addVirtualDisplay(width, height, sizeX, sizeY, zpos)
    checkArg(1, width, "number")
    checkArg(2, height, "number")
    checkArg(3, sizeX, "number")
    checkArg(4, sizeY, "number")
    checkArg(5, zpos, "number", "nil")

    return self:addVirtualShape(AnyDisplay, {
        x = width,
        y = height,
        sizeX = sizeX,
        sizeY = sizeY,
        zpos = zpos or 0
    })
end

function scmframework.scmframeworkClass:addVirtualClassicDisplay(width, height)
    checkArg(1, width, "number")
    checkArg(2, height, "number")

    local boundingBox = self.shape:getBoundingBox()
    return self:addVirtualShape(AnyDisplay, {
        x = width,
        y = height,
        v = 32 * boundingBox.z * 4,
        div = true
    })
end

function scmframework.scmframeworkClass:addVirtualSynthesizer()
    return self:addVirtualShape(synthesizer)
end

function scmframework.scmframeworkClass:addVirtualGps()
    return self:addVirtualShape(gps)
end

----------------------------------------------

pushBaseEnvHacks()
dofile("$CONTENT_DATA/Scripts/Config.lua")
dofile("$CONTENT_DATA/Scripts/ScriptableComputer.lua")
dofile("$CONTENT_DATA/Scripts/synthesizer.lua")
dofile("$CONTENT_DATA/Scripts/gps.lua")
dofile("$CONTENT_DATA/Scripts/Displays/AnyDisplay.lua")
popBaseEnvHacks()

----------------------------------------------

scmframework.defaultSettings = sc.defaultRestrictions
scmframework.unrestrictedSettings = sc.unrestrictedRestrictions

function scmframework.setSComputersSettings(settings)
    sc.setRestrictions(settings)
    sc.saveRestrictions()
end
end
function scmframework_04297dec39508b9ad8f64159c4e7a84d() --$CONTENT_DATA/Scripts/scomputersAPI.lua
local scomputers = {}

local function clientCallcheck(functionName)
	if not sm.isServerMode() then
		sm.log.warning(functionName .. ": must be called from the client's side")
	end
end

function scomputers.addExample(name, code, architecture)
    checkArg(1, name, "string")
    checkArg(2, code, "string")
	checkArg(3, architecture, "string", "nil")
	clientCallcheck("scomputers.addExample")
    addCustomExample(name, code, architecture)
end

function scomputers.addLibrary(name, constructor)
    checkArg(1, name, "string")
    checkArg(2, constructor, "function") --function(self, env):table
    _G["sc_reglib_" .. name] = constructor
end

function scomputers.addEnvHook(envhook)
    checkArg(1, envhook, "function") --function(self, env)
    table.insert(sc.envhooks, envhook)
end

function scomputers.addClEnvHook(envhook)
	checkArg(1, envhook, "function") --function(self, env)
	clientCallcheck("scomputers.addClEnvHook")
	table.insert(sc.cl_envhooks, envhook)
end

function scomputers.require(self, name)
    if name:find("%.") or name:find("%/") or name:find("%\\") then
        error("the library name cannot contain the characters: \"/.\\\"", 2)
    end

    if not self.libcache then self.libcache = {} end
    if self.libcache[name] then return self.libcache[name] end

    --[[
    if dlm and dlm.loadfile then
        --print("loading library", name, "WITH-DLM")

        local lastId = #sc.internal_libs_folders
        for i, folder in ipairs(sc.internal_libs_folders) do
            local code, err = dlm.loadfile(folder .. "/" .. name .. ".lua", _G)
            if type(code) ~= "function" then
                if i == lastId then
                    --error("load error: " .. tostring(err or "unknown"), 2)
                    error("the \"" .. name .. "\" library was not found", 2)
                end
            else
                local result = {pcall(code)}
                if not result[1] or type(result[2]) ~= "table" then
                    error("exec error: " .. tostring(result[2] or "unknown"), 2)
                else
                    self.libcache[name] = result[2]
                    break
                end
            end
        end
    else
        --print("loading library", name, "WITHOUT-DLM")

        if not sc.internal_libs[name] then
            for _, folder in ipairs(sc.internal_libs_folders) do
                if pcall(dofile, folder .. "/" .. name .. ".lua") then
                    break
                end
            end
        end
        if not sc.internal_libs[name] then
            error("the \"" .. name .. "\" library was not found", 2)
        end
        self.libcache[name] = sc.mt_hook({__index = function(_, key)
            return sc.internal_libs[name][key]
        end})
    end
    ]]

    for _, folder in ipairs(sc.internal_libs_folders) do
        pcall(dofile, folder .. "/" .. name .. ".lua")
    end
    local libraryLoader = _G["sc_reglib_" .. name]
    if not libraryLoader then
        error("the \"" .. name .. "\" library was not found", 2)
    end
    self.libcache[name] = libraryLoader(self, self.env)
    return self.libcache[name] or error("the \"" .. name .. "\" library was not found", 2)
end

function scomputers.realIsComputerConnected(interactable)
    for _, interactable2 in ipairs(interactable:getParents()) do
        if sc.allComputersIds[interactable2.id] then
            return true
        end
    end

    for _, interactable2 in ipairs(interactable:getChildren()) do
        if sc.allComputersIds[interactable2.id] then
            return true
        end
    end

    return false
end

function scomputers.isComputerConnected(interactable)
    if sc.restrictions and sc.restrictions.disCompCheck then
        return true
    end

    return scomputers.realIsComputerConnected(interactable)
end

function scomputers.addChaffObject(position, id, mass)
    local chaffObject = {
        position = sm.vec3.new(position.x, position.y, position.z),
        move = sm.vec3.new(
            math.random(-50, 50) / 40 / 100,
            math.random(-50, 50) / 40 / 100,
            math.random(-350, -250) / 40 / 100
        ),
        id = id,
        mass = mass
    }

    if sm.isServerMode() then
        table.insert(sc.sv_chaff_objects, chaffObject)
    else
        table.insert(sc.cl_chaff_objects, chaffObject)
    end
end

function scomputers.base64_encode(data)
    return base64.encode(data, true)
end

function scomputers.base64_decode(data)
    return base64.decode(data, true)
end

function scomputers.sha256_bin(data)
    return sha256.sha256bin(data, true)
end

function scomputers.sha256_hex(data)
    return sha256.sha256hex(data, true)
end

function scomputers.md5_bin(data)
    return md5.sum(data, true)
end

function scomputers.md5_hex(data)
    return md5.sumhexa(data, true)
end

_G.scomputers = scomputers

if not __SCMFRAMEWORK then
    sm.scomputers = scomputers
end
end
function scmframework_6e4f4c7f3939b5bf095c4c18f2f110af() --$CONTENT_DATA/Scripts/ScriptableComputer.lua
dofile("$CONTENT_DATA/Scripts/Config.lua")
dofile("$CONTENT_DATA/Scripts/syntax.lua")

ScriptableComputer = class()

ScriptableComputer.maxParentCount = -1
ScriptableComputer.maxChildCount = -1
ScriptableComputer.connectionInput = sm.interactable.connectionType.composite + sm.interactable.connectionType.logic + sm.interactable.connectionType.power
ScriptableComputer.connectionOutput = sm.interactable.connectionType.composite + sm.interactable.connectionType.logic + sm.interactable.connectionType.power
ScriptableComputer.colorNormal = sm.color.new(0x1a8e15ff)
ScriptableComputer.colorHighlight = sm.color.new(0x23eb1aff)

ScriptableComputer.UV_NON_ACTIVE = 0
ScriptableComputer.UV_ACTIVE_OFFSET = 6
ScriptableComputer.UV_HAS_ERROR = 10
ScriptableComputer.UV_HAS_DISABLED = 9

ScriptableComputer.maxcodesize = 64 * 1024
ScriptableComputer.maxPromptsize = 16 * 1024
ScriptableComputer.maxEncryptMessageSize = 16 * 1024
ScriptableComputer.max_patience = 4
ScriptableComputer.shortTraceback = 4 --сокрашения traceback на определенное количетсво линий
ScriptableComputer.longOperationMsg = "too long without yielding"
ScriptableComputer.oftenLongOperationMsg = "too long without yielding"
ScriptableComputer.lagMsg = "too long without yielding"
ScriptableComputer.maxCodeSizeStr = "the maximum code size is 64KB"

ScriptableComputer.ledUuid = sm.uuid.new("94c8b309-b6fb-40f8-90bb-b5c3ac28bacd")
ScriptableComputer.encryptCode_warn = "code encryption is enabled on the computer, the code cannot be changed"
ScriptableComputer.stub = "--this computer was saved using SComputers (fork of ScriptableComputer) download: https://steamcommunity.com/sharedfiles/filedetails/?id=2949350596\nif not a then for _,v in ipairs(getDisplays())do v.clear('0A3EE2')v.drawText(1,1,'need','EEEEEE')v.drawText(1,8,'SComputers!','EEEEEE')v.flush()end a=1 end print(\"this computer was saved using SComputers (fork of ScriptableComputer)\\n#0088ffdownload:#ffffff https://steamcommunity.com/sharedfiles/filedetails/?id=2949350596\")"
ScriptableComputer.notsavedButton = "notsaved"
ScriptableComputer.onStartCpuTime = (1 / 40) * 160
ScriptableComputer.yieldName = "__internal_yield_2f78dcac_8f2b_4785_99e1_a3bbb1ac0410"
ScriptableComputer.architectureNotSupportedEncrypt = "the architecture does not support code encryption"

local maxTickPrintLen = 1024 * 4
local function constrainPrint(str)
    return str:sub(#str - (maxTickPrintLen - 1), #str)
end

----------------------- yield -----------------------

function ScriptableComputer:cl_getMaxCpuTime()
    local time = self.localScriptMode.cpulimit or sc.restrictions.cpu
    if time == -1 then
        return math.huge
    end
    return time
end

local os_clock = os.clock
function ScriptableComputer:cl_init_yield()
    self.cl_startTickTime = os_clock()
end

function ScriptableComputer:cl_yield()
    local maxcputime = self:cl_getMaxCpuTime()
    if os_clock() - self.cl_startTickTime > maxcputime then
        error(ScriptableComputer.longOperationMsg, 3)
    end
end


function ScriptableComputer:sv_init_yield()
    self.sv_startTickTime = os_clock()
end

local sv_yield_counter = 0
function ScriptableComputer:sv_yield()
    if sv_yield_counter >= 256 then
        sv_yield_counter = 0
        
        local maxcputime = self:cl_getMaxCpuTime()
        if self.wait and maxcputime < ScriptableComputer.onStartCpuTime then
            maxcputime = ScriptableComputer.onStartCpuTime
        end
        local execTime = os_clock() - self.sv_startTickTime
        if execTime > maxcputime then
            if self.longExecution >= 2 then
                if self.sv_patience <= 0 then
                    self.crashstate.hasException = true
                    self.crashstate.exceptionMsg = ScriptableComputer.oftenLongOperationMsg
                    self.storageData.noSoftwareReboot = true
                    self:sv_formatException()
                    error(ScriptableComputer.oftenLongOperationMsg, 3)
                else
                    self.sv_startTickTime = os_clock() --if an error occurs in the application program of the operating system, the OS should be able to handle the error
                    self.sv_patience = self.sv_patience - 1
                    error(ScriptableComputer.longOperationMsg, 3)
                end
            else
                self.longExecution = self.longExecution + 1 --sometimes it is allowed to do "long execution" in order to have time to load the program resources
                self.sv_startTickTime = os_clock()
            end
        end
    else
        sv_yield_counter = sv_yield_counter + 1
    end
end

----------------------- SERVER -----------------------

function ScriptableComputer:loadScript()
    self.scriptFunc = nil

    if not self.env then
        self.crashstate.exceptionMsg = "env is missing"
        self.crashstate.hasException = true
        self:sv_formatException()
        return
    end

    if not self.storageData.script then
        self.crashstate.exceptionMsg = "script string is missing"
        self.crashstate.hasException = true
        self:sv_formatException()
        return
    end

    --local text = self.storageData.script:gsub("%[NL%]", "\n")
    local code, err
    local chunkName = "=" .. (self.computerTag or "code")
    if self.storageData.encryptedCode then
        if self.architecture then
            if self.architecture.loadEncrypted then
                code, err = self.architecture.loadEncrypted(self, self.storageData.encryptedCode, chunkName, self.env)
            else
                code, err = nil, "the architecture does not support loading encrypted code"
            end
        else
            code, err = encryptVM.load(self, self.storageData.encryptedCode, self.env)
        end
    else
        if self.architecture then
            if self.architecture.load then
                code, err = self.architecture.load(self, self.storageData.script, chunkName, self.env)
            else
                code, err = nil, "the architecture does not support code loading"
            end
        else
            code, err = safe_load_code(self, self.storageData.script, chunkName, "t", self.env)
        end
    end
    if code then
        self.scriptFunc = code
        self.crashstate.exceptionMsg = nil
        self.crashstate.hasException = false
    else
        self.scriptFunc = nil
        self.crashstate.exceptionMsg = err
        self.crashstate.hasException = true
    end
    self:sv_formatException()
end

function ScriptableComputer:forceUpdateWriters()
    for k, v in pairs(self.interactable:getParents(sm.interactable.connectionType.composite)) do
        local writer = sc.writersRefs[v:getId()] 
        if writer then
            writer:server_updateComputerRegisterValue()
        end
    end
end

function ScriptableComputer:forceUpdateReaders()
    for k, v in pairs(self.interactable:getChildren(sm.interactable.connectionType.composite)) do
        local reader = sc.readersRefs[v:getId()] 
        if reader then
            reader:sv_update()
        end
    end
end

function ScriptableComputer:updateSharedData()
    if self.interactable then
        sc.computersDatas[self.interactable:getId()] = self.publicTable
        self:forceUpdateWriters()
    end
end

function SCArchitecture_reg(name, tbl)
    sc.architectures[name] = nil
    tbl.name = tbl.name or name
    SCArchitecture = tbl
end

local function loadArchitecture(self, key)
    if self.data and self.data.architectureName then
        self[key] = sc.architectures[self.data.architectureName]
        if not self[key] and self.data.architecturePath then
            dofile(self.data.architecturePath)
            sc.architectures[self.data.architectureName] = sc.architectures[self.data.architectureName] or SCArchitecture
            self[key] = sc.architectures[self.data.architectureName]
            SCArchitecture = nil
        end
        if not self[key] then
            self.failed = true
            error("failed to load architecture")
        end
    end
    --self[key] = {}
end


function ScriptableComputer:server_onCreate(constData)
    ------init

    self.realself = self
    loadArchitecture(self, "architecture")
    if self.architecture then
        self.sv_examples = loadExamples(self.architecture.examplesPath, self.architecture.name)
    else
        self.sv_examples = loadExamples()
    end

    sc.computersCount = sc.computersCount + 1

    sc.init()
    sc.xEngineClear()

    self.computerTag = "computer_" .. tostring(math.floor(self.shape and self.shape.id or self.tool.id))

    ------ram

    self.usedRam = 0

    ------cdata
    self.defaultData = self.data or {}
    if constData then
        self.cdata = constData
    else
        self.cdata = self.data or {}
    end

    if not self.cdata.ram then --not implemented yet
        self.cdata.ram = 4 * 1024 * 1024 --4MB
    end

    ------data
    local data = self.storage:load()
    if data then
        self.storageData = data
        self.storageData.crashstate = nil

        if not self.storageData.gsubFix then
            self.storageData.script = self.storageData.script:gsub("%[NL%]", "\n")
            self.storageData.gsubFix = true
        end

        if self.storageData.stub then
            local _, bs64 = unpack(strSplit(string, self.storageData.script, "\n--"))
            self.storageData.script = bs64
        else
            self.storageData.stub = true
        end

        if self.storageData.codeInBase64 then
            self.storageData.script = base64.decode(self.storageData.script)
        else
            self.storageData.codeInBase64 = true
        end
    else
        self.storageData = {
            script = self.sv_examples.load(self.architecture and self.architecture.defaultExample or "template") or "",
            gsubFix = true,
            codeInBase64 = true,
            stub = true
        }

        if self.cdata.unsafe then
            self.storageData.invisible = true
        end
    end
    
    ------env settings

    self.envSettings = {vcomponents = {}}
    if self.cdata and self.cdata.fsSize then
        if self.storageData.fsData then
            self.fs = FileSystem.deserialize(self.storageData.fsData)
        else
            self.fs = FileSystem.new(math.floor(self.cdata.fsSize))
        end
        self.envSettings.vcomponents.disk = {FileSystem.createSelfData(self)}
    end
    
    if self.fs then
        fsmanager_init(self)
    end

    ------init

    self.crashstate = {}
    self.hostonly = not not self.cdata.unsafe

    self.sv_patience = ScriptableComputer.max_patience
    self.lagScore = 0
    self.skipped = 0
    self.uptime = 0
    self.computerTick = 0
    self.wait = 40 * 5 --5 секунды после спавна компа максимальное время выполнения кода будет 160 для того чтобы пролаг от спавна не крашнул комп
    self.longExecution = 0
    self.xEnginesDestroy = {}
    self.currentOutputActive = false
    self.currentOutputPower = 0

    self:sv_reset()
    self:sv_reboot()

    self.old_sum = tableChecksum(self.storageData, "fsData")
end

local newline = string.byte("\n")
local tab = string.byte("\t")
function ScriptableComputer:sv_formatException()
    for k, v in pairs(self.crashstate) do
        if k ~= "hasException" and k ~= "exceptionMsg" then
            self.crashstate[k] = nil
        end
    end

    self.crashstate.hasException = not not self.crashstate.hasException
    if self.crashstate.hasException then
        local str = tostring(self.crashstate.exceptionMsg or "Unknown error"):sub(1, 1024)
        local newstr = {}
        for i = 1, #str do
            local b = str:byte(i)
            if (b >= 32 and b <= 126) or b == newline then
                table.insert(newstr, string.char(b))
            elseif b == tab then
                table.insert(newstr, "   ")
            end
        end
        self.crashstate.exceptionMsg = table.concat(newstr)
        if #self.crashstate.exceptionMsg == 0 then
            self.crashstate.exceptionMsg = "Unknown error"
        end
    else
        self.crashstate.exceptionMsg = nil
    end

    self:sv_updateException()
end

function ScriptableComputer:sv_free()
    self.freeFlag = self.freeFlag or 2
end

function ScriptableComputer:sv_realFree()
    for _, destroy in ipairs(self.xEnginesDestroy) do
        destroy()
    end
    self.xEnginesDestroy = {}
end

function ScriptableComputer:server_onDestroy()
    if self.failed then
        return
    end

    sc.computersCount = sc.computersCount - 1

    self:sv_disableComponentApi()
    self:sv_realFree()

    if self.interactable then
        sc.computersDatas[self.interactable:getId()] = nil
    end
end

function ScriptableComputer:server_onFixedUpdate()
    if self.failed then
        return
    end

    self.interactable:setActive(self.currentOutputActive)
    self.interactable:setPower(self.currentOutputPower)

    self:sv_createLocalScriptMode()

    local connectedComponents = {}
    for _, interactable in ipairs(self.interactable:getParents()) do
        connectedComponents[interactable.id] = true
    end
    for _, interactable in ipairs(self.interactable:getChildren()) do
        connectedComponents[interactable.id] = true
    end
    for interactableId in pairs(self.componentCache) do
        if not connectedComponents[interactableId] then
            self.componentCache[interactableId] = nil
        end
    end

    local ctick = sm.game.getCurrentTick()
    if sc.needScreenSend() then
        if self.printMsg then
            self.network:sendToClients("cl_chatMessage", constrainPrint(table.concat(self.printMsg, "#ffffff\n")))
            self.printMsg = nil
        end

        if self.alertMsg then
            self.network:sendToClients("cl_alertMessage", constrainPrint(table.concat(self.alertMsg, "#ffffff\n")))
            self.alertMsg = nil
        end

        if self.logMsg then
            self.network:sendToClients("cl_logMessage", constrainPrint(table.concat(self.logMsg, "#ffffff\n")))
            self.logMsg = nil
        end
    end

    if ctick % (3 * 40) == 0 then
        self.sv_patience = ScriptableComputer.max_patience
        self.longExecution = 0
    end
    
    if self.freeFlag then
        self.freeFlag = self.freeFlag - 1
        if self.freeFlag < 0 then
            self:sv_realFree()
            self.freeFlag = nil
        end
    end

    if self.new_code then
        self:sv_updateScript(self.new_code, nil, true)
        self.new_code = nil
    end

    if self.new_ecode then
        self:sv_setEncryptedCode(self.new_ecode, self.new_ecode_msg)
        self.new_ecode = nil
        self.new_ecode_msg = nil
    end

    if self.encrypt_flag then
        self:sv_local_encryptCode(true, self.encrypt_msg)
        self.encrypt_flag = nil
        self.encrypt_msg = nil
    end

    if self.reboot_flag or self.software_reboot_flag or sc.rebootAll then
        self:sv_reboot(self.reboot_flag or self.software_reboot_flag, not self.reboot_flag)
        self.reboot_flag = nil
        self.software_reboot_flag = nil
    end

    local sendTable = self:sv_genTable()
    local sendSum = tableChecksum(sendTable)
    if sendSum ~= self.old_sendSum then
        --self.network:sendToClients("cl_getParam", sendTable)
        self:sv_onDataRequired()
        self.old_sendSum = sendSum
    end
    
    if #self.clientInvokes > 0 then
        for _, data in ipairs(self.clientInvokes) do
            if data.player then
                local player
                if type(data.player) == "string" then
                    for _, lplayer in ipairs(sm.player.getAllPlayers()) do
                        if lplayer.name == data.player then
                            player = lplayer
                            break
                        end
                    end
                else
                    player = data.player
                end

                if player then
                    self.network:sendToClient(player, "cl_invokeScript", data)
                end
            else
                self.network:sendToClients("cl_invokeScript", data)
            end
        end
        self.clientInvokes = {}
    end

    if self.interactable then
        self.old_publicData = self.interactable.publicData
        if self.customcomponent_flag then
            self:sv_disableComponentApi(true)
            if self.customcomponent_name and self.customcomponent_api then
                self.interactable.publicData = {
                    sc_component = {
                        type = self.customcomponent_name,
                        api = self.customcomponent_api
                    }
                }
            end
            self.customcomponent_flag = nil
        end
    end

    local activeNow = not not (self.storageData.alwaysOn or self.storageData.active_button or self.external_active)
    if self.interactable and not activeNow then
        for k, inter in pairs(self.interactable:getParents(sm.interactable.connectionType.logic)) do
            if inter:isActive() then
                activeNow = true
                break
            end
        end
    end

    --------------------------------------------------------power control

    if self.wait then
        self.lagScore = 0
        self.wait = self.wait - 1
        if self.wait <= 0 then
            self.wait = nil
        end
    end
    
    if not self.crashstate.hasException and not self.freeFlag then
        if not activeNow and self.isActive then
            self:sv_execute(true) --последняя итерация после отключения входа, чтобы отлавить выключения
            self:sv_disableComponentApi()
            self.uptime = 0
            self.computerTick = 0
        end
        
        if activeNow and not self.isActive then
            self:sv_reboot()
        end

        if activeNow then
            local dropFreq = 0
            if sc.restrictions.adrop then
                if sc.deltaTime >= (1 / 15) then
                    dropFreq = 8
                elseif sc.deltaTime >= (1 / 25) then
                    dropFreq = 4
                elseif sc.deltaTime >= (1 / 30) then
                    dropFreq = 2
                end
            end
            dropFreq = dropFreq + math.floor(self.lagScore / 10)
            if self.lagScore >= 50 then
                dropFreq = dropFreq * 2
            end
            if dropFreq == 1 then dropFreq = 2 end
            if dropFreq == 0 or self.cdata.unsafe or ctick % dropFreq == 0 then
                self:sv_execute()
                self.skipped = 0
            else
                self.skipped = self.skipped + 1
            end
            self.uptime = self.uptime + 1
        end
    end
    if activeNow ~= self.isActive then
        self.network:sendToClients("cl_setActive", activeNow)
    end
    self.isActive = activeNow

    self:sv_formatException()
    if self.crashstate.hasException ~= self.oldhasException or
    self.crashstate.exceptionMsg ~= self.oldexceptionMsg then
        self.oldhasException = self.crashstate.hasException
        self.oldexceptionMsg = self.crashstate.exceptionMsg
        self:sv_sendException()
    end

    --------------------------------------------------------data control

    if sc.needSaveData() then
        if self.changed then
            self.storageData.fsData = self.fs:serialize()
            self.changed = nil
    
            self.saveContent = true
        end

        local sum = tableChecksum(self.storageData, "fsData")
        if self.saveContent or self.old_sum ~= sum then
            local newtbl = sc.deepcopy(self.storageData)
            newtbl.script = ScriptableComputer.stub .. "\n--" .. base64.encode(newtbl.script)
            self.storage:save(newtbl)

            self.saveContent = nil
            self.old_sum = sum
        end
    end

    --------------------------------------------------------lagScore control

    if self.lagScore > 0 then
        self.lagScore = self.lagScore - 1
        if self.lagScore < 0 then
            self.lagScore = 0
        end
    end
end

function ScriptableComputer:sv_createLocalScriptMode()
    self.localScriptMode = {
        scriptMode = sc.restrictions.scriptMode,
        allowChat = sc.restrictions.allowChat
    }

    if self.cdata.unsafe then
        self.localScriptMode.scriptMode = "unsafe"
        self.localScriptMode.allowChat  = true
    end

    if self.cdata.cpulimit then
        self.localScriptMode.cpulimit = self.cdata.cpulimit
    end
end

function ScriptableComputer:sv_genTable()
    local tbl = {
        restrictions = sc.restrictions,
        script = self.storageData.script,
        __lock = self.storageData.__lock,
        alwaysOn = self.storageData.alwaysOn,
        invisible = self.storageData.invisible,
        fs = not not self.fs,
        scriptMode = self.localScriptMode.scriptMode,
        vm = sc.restrictions.vm,
        allowChat = self.localScriptMode.allowChat,
        hasException = self.crashstate.hasException,
        computersAllow = _G.computersAllow,
        localScriptMode = self.localScriptMode,
        hostonly = self.hostonly,
        dislogs = self.storageData.dislogs,
        encryptCode = self.storageData.encryptCode
    }

    if self.storageData.__lock then
        tbl.script = nil
    end

    return tbl
end

function ScriptableComputer:sv_n_reboot()
    self:sv_reboot(true)
end

function ScriptableComputer:sv_disableComponentApi(notRemoveFlags)
    if not self.interactable then return end
    if not notRemoveFlags then
        self.customcomponent_flag = nil
        self.customcomponent_name = nil
        self.customcomponent_api = nil
    end

    if self.old_publicData and self.old_publicData.sc_component and self.old_publicData.sc_component.api then
        for key, value in pairs(self.old_publicData.sc_component.api) do
            self.old_publicData.sc_component.api[key] = nil
        end
        self.old_publicData.sc_component.api[-1] = true
        self.old_publicData.sc_component.api = nil
        self.old_publicData.sc_component.name = nil
        self.old_publicData.sc_component = nil
        if sm.exists(self.interactable) then
            self.interactable.publicData = {}
        end
    end
end

function ScriptableComputer:sv_updateException()
    for k, v in pairs(self.publicTable.public.crashstate) do
        self.publicTable.public.crashstate[k] = nil
    end
    for k, v in pairs(self.crashstate) do
        self.publicTable.public.crashstate[k] = v
    end
end

function ScriptableComputer:sv_createEnv(fromProcessLibrary, isolation)
    local env
    if self.localScriptMode.scriptMode == "unsafe" then
        env = createUnsafeEnv(self, self.envSettings, fromProcessLibrary, isolation)
    else
        env = createSafeEnv(self, self.envSettings, fromProcessLibrary, isolation)
    end

    if self.localScriptMode.scriptMode == "safe_with_open" then
        env.sm.json.open = sm.json.open
    end

    return env
end

function ScriptableComputer:sv_reset()
    self:sv_createLocalScriptMode()
    self.clientInvokes = {}
    self.componentCache = {}
    self.luastate = {}
    self.libcache = {}
    self.registers = {}
    self.uptime = 0
    self.xEngine_instanceLimit = 2
    self.computerTick = 0
    self.env = self:sv_createEnv()
    self.publicTable = {
        public = {
            registers = self.registers,
            env = self.env,
            crashstate = {}
        },
        self = self
    }
    self.storageData.noSoftwareReboot = nil
    self.th = nil
    self.sleepTime = nil
    self:sv_updateException()
    self:updateSharedData()
end

function ScriptableComputer:sv_reboot(force, not_execute)
    local fromException = self.crashstate.hasException
    if force and self.crashstate.hasException then
        self.crashstate.hasException = nil
        self.crashstate.exceptionMsg = nil
        self:sv_sendException()
    end

    if self.crashstate.hasException then
        return
    end

    self.crashstate.hasException = nil
    self.crashstate.exceptionMsg = nil
    self.oldhasException = nil
    self.oldexceptionMsg = nil
    self:sv_updateException()

    if self.isActive and not not_execute and not fromException then
        self:sv_execute(true) --последняя итерация после отключения входа, чтобы отлавить выключения
    end

    ----------------------------

    self:sv_reset()
    self:loadScript()
    self:sv_disableComponentApi()
    self.network:sendToClients("cl_clear")
    self:sv_formatException()

    self.printMsg = nil
    self.alertMsg = nil
    self.logMsg = nil
    self.rebootId = tostring(sm.uuid.new())
end

local function drawSmile(display, x, y, sizeX, sizeY)
    local strokeSize = math.floor(sizeX / 16)
    if strokeSize <= 1 then
        strokeSize = 1
    end
    display.fillRect(x, y, sizeX, sizeY, 0x000000)
    display.drawRect(x, y, sizeX, sizeY, 0xffffff, strokeSize)

    x = x + (strokeSize * 2)
    y = y + (strokeSize * 2)
    sizeX = sizeX - (strokeSize * 4)
    sizeY = sizeY - (strokeSize * 4)

    local pointSizeX, pointSizeY = math.floor(sizeX / 6), math.floor(sizeY / 6)
    local function drawPoint(lx, ly)
        display.fillRect(x + (lx * pointSizeX), y + (ly * pointSizeY), pointSizeX, pointSizeY, 0x00ff00)
    end

    drawPoint(0, 0)
    drawPoint(0, 1)
    drawPoint(5, 0)
    drawPoint(5, 1)
    drawPoint(2, 3)
    drawPoint(3, 3)
    drawPoint(1, 4)
    drawPoint(4, 4)
end

local function printException(self)
    local msg = self.crashstate.exceptionMsg

    local graphic = scomputers.require(self, "graphic")
    local fonts = scomputers.require(self, "fonts")
    for _, display in ipairs(sc.getComponents(self, "display", self.envSettings)) do
        local rotation = display.getRotation()
        display.reset()
        display.setRotation(rotation)
        display.clear(0x2f4d95)
        local fontScaleX, fontScaleY = display.getFontScale()
        local width, height = display.getSize()

        if width >= 128 then
            local oldTextSpacing = display.getTextSpacing()
            local smileSize = height / 8
            local objOffset = math.max(height / 60, 1)

            -- draw smile and title
            drawSmile(display, objOffset, objOffset, smileSize, smileSize)

            display.setFont(fonts.lgc_5x5)
            local origFontSizeX = display.getFontWidth()
            local title = "CRASH!"
            local posX = objOffset + smileSize + objOffset
            display.setFontSize(smileSize, smileSize)
            display.setTextSpacing(math.max(1, math.floor(smileSize / origFontSizeX)))
            display.drawText(posX, objOffset, title)

            -- draw border line
            local borderSizeY = math.max(1, math.ceil(height / 120))
            local textPadding = width / 32
            local textSizeX = width - (textPadding * 2)
            display.fillRect(textPadding, smileSize + (objOffset * 2), textSizeX, borderSizeY, 0xffffff)

            -- draw error text
            if width >= 640 then
                display.setFont(fonts.arial_72)
                display.setFontScale(1, 1)
                local fontScale = width / display.getFontWidth() / 35
                display.setFontScale(fontScale, fontScale)
                display.setTextSpacing(0)
            else 
                display.setFont(nil)
                display.setFontScale(1, 1)
                display.setTextSpacing(1)
            end

            graphic.textBox(display, textPadding, borderSizeY + smileSize + (objOffset * 3), textSizeX, height - (textPadding * 2),
                makeErrorColor(msg),
                0xffffff,
                false,
                false,
                display.getFontHeight() / 5,
                true,
                canvasAPI.utf8,
                true
            )
            
            display.setFont(nil)
            display.setTextSpacing(oldTextSpacing)
            display.setFontScale(fontScaleX, fontScaleY)
        else
            local textPadding = 1
            if width == 64 then
                textPadding = 2
            end
            drawSmile(display, textPadding, textPadding, width - (textPadding * 2), height - (textPadding * 2))
        end

        display.flush()
    end

    for _, terminal in ipairs(sc.getComponents(self, "terminal", self.envSettings)) do
        terminal.write("--------------------------------------- computer crashed with error ----------------------------------------\n")
        terminal.write(makeErrorColor(formatBeforeGui(msg)))
        terminal.write("\n-----------------------------------------------------------------------------------------------------------------------\n")
    end
end

function ScriptableComputer:sv_printException()
    if self.crashstate.hasException and self.env and not self.env._disableBsod then
        local ok, err = pcall(printException, self)
        if not ok then
            sm.log.error("failed to print error: ", err)
        end
    end
end

function ScriptableComputer:sv_sendException()
    self:sv_formatException()
    if self.crashstate.hasException then
        self:sv_free()
        self:sv_disableComponentApi()
        sm.log.error("computer crashed", self.crashstate.exceptionMsg)
        self.network:sendToClients("cl_onComputerException", {self.crashstate.exceptionMsg, self.computerTag})
    else
        self.network:sendToClients("cl_onComputerException")
    end
    self:sv_printException()
end

function ScriptableComputer:sv_execute(endtick, onStartCall)
    if self.scriptFunc and _G.computersAllow then
        local onStartExists = false
        if self.env and self.env.onStart then
            onStartExists = true
        end

        if self.sleepTime then
            self.sleepTime = self.sleepTime - 1
            if self.sleepTime <= 0 then
                self.sleepTime = nil
            else
                return
            end
        end

        tweaks()
        self:forceUpdateWriters()
        sc.lastComputer = self
        local startExecTime = os.clock()

        if not self.env then
            self.crashstate.hasException = true
            self.crashstate.exceptionMsg = "Unknown error"
            self:sv_formatException()
            sc.lastComputer = nil
            unTweaks()
            return
        end

        if endtick then
            self.env._endtick = true
            self:sv_free()
        end

        --if sc.restrictions.vm == "luaInLua" then
        --    ll_Interpreter:reset()
        --end
        
        local func, arg
        if onStartCall then
            func = self.env.onStart
        else
            if self.env._endtick and self.env._enableCallbacks and self.env.onStop then
                func = self.env.onStop
            elseif self.env._enableCallbacks then
                func = self.env.onTick or function() end
                pcall(function()
                    arg = self.env.getDeltaTimeTps() * (self.env.getSkippedTicks() + 1)
                end)
            elseif self.env.callback_loop then
                func = self.env.callback_loop
            else
                func = self.scriptFunc
            end
        end
        
        --[[
        local coroutine = sc.getApi("coroutine")
    if coroutine and coroutine.fixed then]]
        
        self:sv_init_yield()
        local ran, err
        if sc.coroutineFixed() then
            local coroutine = sc.getApi("coroutine")
            if not self.th or func ~= self.oldFunc or coroutine.status(self.th) == "dead" then
                if type(func) == "table" then
                    self.th = coroutine.create(func[3])
                else
                    self.th = coroutine.create(func)
                end
                self.oldFunc = func
            end
            ran, err = coroutine.resume(self.th)
            if ran then
                local t = type(err)
                if t == "number" then
                    err = math.floor(err + 0.5)
                    if err < 1 then err = 1 end
                    self.sleepTime = err
                end
            end
        elseif not self.architecture or not self.architecture.withoutTrackback then
            ran, err = smartCall(self.scriptFunc, func, arg)
        else
            ran, err = pcall(func, arg)
        end
        do
            local lok, lerr = pcall(function(self) self:sv_yield() end, self) --кастыль с лямбдой НУЖЕН для правильного разположения ошибки
            if not lok and not err then
                self.crashstate.hasException = true
                self.crashstate.exceptionMsg = lerr
                self:sv_formatException()
            end
        end

        if self.crashstate.hasException then
            sc.lastComputer = nil
            self:forceUpdateReaders()
            unTweaks()
            return
        end

        if ran and self.lagScore > 100 then
            self.lagScore = 0
            self.crashstate.hasException = true
            self.crashstate.exceptionMsg = ScriptableComputer.lagMsg
            self.storageData.noSoftwareReboot = true
            self:sv_formatException()
        end
        
        if not ran then
            if sc.restrictions.vm == "luaInLua" then
                err = ll_shorterr(err)
            end

            self.crashstate.hasException = true
            self.crashstate.exceptionMsg = err
            self:sv_formatException()
            
            local errFunc, detectReboot
            if self.env._enableCallbacks then
                detectReboot = true
                errFunc = self.env.onError
            else
                errFunc = self.env.callback_error
            end
            if errFunc then
                self:sv_init_yield()
                local ran, err = smartCall(self.scriptFunc, errFunc, err)
                if not ran then
                    sm.log.error("error in the error handler", err)
                elseif err and detectReboot and not self.storageData.noSoftwareReboot then
                    self.software_reboot_flag = true
                end
            end
        end

        sc.addLagScore((os.clock() - startExecTime) * sc.clockLagMul)
        sc.lastComputer = nil
        self:forceUpdateReaders()
        unTweaks()

        if not self.crashstate.hasException and not onStartExists and self.env and self.env._enableCallbacks and self.env.onStart then
            self:sv_execute(false, true)
        end

        if not onStartCall then
            self.computerTick = self.computerTick + 1
        end
    end
end

function ScriptableComputer:sv_updateData(data)
    if self.storageData.__lock then
        return
    end

    data.restrictions = nil
    data.fs = nil
    data.scriptMode = nil
    data.vm = nil
    data.allowChat = nil
    data.hasException = nil
    data.computersAllow = nil
    data.localScriptMode = nil
    data.hostonly = nil
    data.encryptCode = nil

    for key, value in pairs(data) do --чтобы не перетереть ключи которых нет на клиенте(по этому тут цикл а не просто присвоения)
        self.storageData[key] = value
    end
end

function ScriptableComputer:sv_local_encryptCode(state, message)
    if state then
        local ok, result
        if self.architecture then
            if self.architecture.encrypt then
                ok, result = self.architecture.encrypt(self, self.storageData.script)
            else
                ok, result = false, ScriptableComputer.architectureNotSupportedEncrypt
            end
        else
            ok, result = pcall(encryptVM.compile, self, self.storageData.script)
        end
        if ok then
            if message then
                message = message:sub(1, ScriptableComputer.maxEncryptMessageSize)
            end
            if message == "" then message = nil end
            message = "THIS CODE WAS ENCRYPTED" .. (message and ("\n" .. message) or "")
            message = message:sub(1, ScriptableComputer.maxcodesize)
            self.storageData.encryptedCode = result
            self.storageData.encryptCode = true
            self.network:sendToClients("cl_getParam", self:sv_genTable())
            self:sv_updateScript(message, nil, true)
        else
            self.network:sendToClients("cl_internal_alertMessage", "failed to encrypt code: " .. tostring(result or "unknown error"))
        end
    else
        self.storageData.encryptedCode = nil
        self.storageData.encryptCode = false
        self.network:sendToClients("cl_getParam", self:sv_genTable())
        self:sv_updateScript("", nil, true)
    end
    self:sv_updateTmpdata()
end

function ScriptableComputer:sv_setEncryptedCode(ecode, message)
    if message then
        message = message:sub(1, ScriptableComputer.maxEncryptMessageSize)
    end
    if message == "" then message = nil end
    message = "THIS CODE WAS ENCRYPTED" .. (message and ("\n" .. message) or "")
    message = message:sub(1, ScriptableComputer.maxcodesize)
    self.storageData.encryptedCode = ecode
    self.storageData.encryptCode = true
    self.network:sendToClients("cl_getParam", self:sv_genTable())
    self:sv_updateScript(message, nil, true)
    self:sv_updateTmpdata()
end

function ScriptableComputer:sv_encryptCode(data)
    self:sv_local_encryptCode(data[1], data[2])
    self:sv_reboot(true)
end

------------network
function ScriptableComputer:sv_updateScript(data, caller, notReboot)
    if caller and (self.storageData.__lock or self:needBlockCall(caller)) then
        return
    end

    if not data or #data > ScriptableComputer.maxcodesize then
        if caller then
            self.network:sendToClient(caller, "cl_internal_alertMessage", ScriptableComputer.maxCodeSizeStr)
        end
        return false
    end

    self.storageData.script = data
    if not notReboot then
        self:sv_reboot(true)
    end

    for _, player in ipairs(sm.player.getAllPlayers()) do
        if not caller or player ~= caller then
            if not self.storageData.__lock then
                self.network:sendToClient(player, "cl_updateScript", self.storageData.script)
            else
                self.network:sendToClient(player, "cl_updateScript")
            end
        end
    end

    return true
end


function ScriptableComputer:sv_updateTmpdata(player)
    local cltmp = {}
    if self.storageData.encryptCode then
        cltmp.encryptVM_version = encryptVM.version(self, self.storageData.encryptedCode)
    end

    if player then
        self.network:sendToClient(player, "cl_updateTmpdata", cltmp)
    else
        self.network:sendToClients("cl_updateTmpdata", cltmp)
    end
end

function ScriptableComputer:sv_onDataRequired(_, client)
    local players
    if client then
        players = {client}
    else
        players = sm.player.getAllPlayers()
    end
    
    for index, lclient in ipairs(players) do
        if not self:needBlockCall(lclient) then
            if client then
                if not self.storageData.__lock then
                    self.network:sendToClient(lclient, "cl_updateScript", self.storageData.script)
                else
                    self.network:sendToClient(lclient, "cl_updateScript")
                end
            end

            self.network:sendToClient(lclient, "cl_getParam", self:sv_genTable())
            self.network:sendToClient(lclient, "cl_setActive", self.isActive)
            self:sv_updateTmpdata(lclient)
        end

        if self.cdata.arduino then
            self.network:sendToClient(lclient, "cl_createEffect")
        end
    end
end

function ScriptableComputer:sv_invokeScript(data)
    local script, args = unpack(data)
    
    local code, err = safe_load_code(self, script, "=server_invoke", "t", self.env)
    if not code then
        sm.log.error("server invoke syntax error: " .. (err or "Unknown error"))
        return
    end

    self:sv_init_yield()

    tweaks()
    sc.lastComputer = self
    local ran, err = pcall(code, unpack(args))
    sc.lastComputer = nil
    unTweaks()

    if not ran then
        sm.log.error("server invoke error: " .. (err or "Unknown error"))
    end
end

function ScriptableComputer:needBlockCall(caller)
    if self.hostonly and caller.id ~= vnetwork.host.id then
        return true
    end
end

----------------------- CLIENT -----------------------

function ScriptableComputer:client_onCreate()
    self.defaultData = self.data or {}
    
    loadArchitecture(self, "cl_architecture")
    if self.cl_architecture then
        self.cl_examples = loadExamples(self.cl_architecture.examplesPath, self.cl_architecture.name)
    else
        self.cl_examples = loadExamples()
    end

    self.network:sendToServer("sv_onDataRequired")
    self.last_script = ""
    self.exampleSearch = ""
    self.consoleLog = {}
    self.consoleLog_afterTraceback = {}
    self.serverInvokes = {}
    self.cltmp = {}
    sc.allComputers[self] = true
    if self.interactable then
        sc.allComputersIds[self.interactable.id] = true
    end

    self.encryptCode_toggle_func = function (message)
        self.network:sendToServer("sv_encryptCode", {not self.cStorageData.encryptCode, message})
    end
end

function ScriptableComputer:client_onFixedUpdate(dt)
    sc.deltaTimeTps = dt

    if not self.cStorageData then return end

    if self.textEditor then
        if sm.game.getCurrentTick() % 10 == 0 then
            self.newText = self.newText or self.last_script
            local newText = self.textEditor()
            if newText ~= self.newText then
                self.last_script = newText
                self.newText = newText
                self:cl_rawSetText(newText)
                self:cl_onSaveScript()
            elseif self.last_script ~= newText then
                self.textEditor(true)
                self.textEditor = nil
            end
        end
    else
        self.newText = nil
    end

    if #self.serverInvokes > 0 then
        for _, data in ipairs(self.serverInvokes) do
            self.network:sendToServer("sv_invokeScript", data)
        end
        self.serverInvokes = {}
    end

    if self.saveAcceptGui then
        if sm.exists(self.saveAcceptGui) then
            if not self.saveAcceptGui:isActive() then
                self.saveAcceptGui:open()
            end
        else
            self.saveAcceptGui = nil
        end
    end

    if self.acceptCheckDelay then
        self.acceptCheckDelay = self.acceptCheckDelay - 1
        if self.acceptCheckDelay <= 0 then
            self.acceptCheckDelay = nil
        end
    end
    if self.guiOpened and not self.gui:isActive() and not self.acceptCheckDelay then
        self.guiOpened = nil
        local script = self.cStorageData.script or self.old_script
        if script ~= self.last_script then
            self:cl_saveAccept()
        end
    end

    if self.gui and self.gui:isActive() then
        if _g_saveBind and not self.saveBindState then
            self:cl_onSaveScript()
        end
        self.saveBindState = _g_saveBind
    else
        self.saveBindState = nil
    end

    if self.aiGen then
        local str, ok = self.aiGen()
        if str then
            self:cl_setText(str)
            if not self.gui:isActive() then
                self:cl_onSaveScript()
            end
            if ok then
                self:cl_internal_alertMessage("code generation is complete!")
            else
                self:cl_internal_alertMessage("something went wrong...")
            end
            self.aiGen = nil
        end
    end

    if not sm.isHost and self.cStorageData.hostonly and self.interact then
        self:cl_internal_alertMessage("#ff0000only the host can open unsafe-computer")
        self.interact = nil
        self.flag1 = nil
        self.flag2 = nil
    end

    if self.interactable then
        local uvpos
        local isActive = self.interactable:isActive()
        if isActive then
            uvpos = ScriptableComputer.UV_NON_ACTIVE + ScriptableComputer.UV_ACTIVE_OFFSET
        else
            uvpos = ScriptableComputer.UV_NON_ACTIVE
        end

        if self.cStorageData.hasException or not self.cStorageData.computersAllow then
            local uv = ScriptableComputer.UV_HAS_ERROR
            if not self.cStorageData.computersAllow then
                uv = ScriptableComputer.UV_HAS_DISABLED
            end

            local blk = (sm.game.getCurrentTick() % 60 >= 30)
            self.interactable:setUvFrameIndex(blk and uv or uvpos)
            if self.led_eff then
                self.led_eff:setParameter("color", sm.color.new(1, 0, 0))
                if blk then
                    if not self.led_eff:isPlaying() then
                        self.led_eff:start()
                    end
                else
                    self.led_eff:stop()
                end
            end
        else
            self.interactable:setUvFrameIndex(uvpos)
            if self.led_eff then
                self.led_eff:setParameter("color", sm.color.new(0, 1, 0))
                if isActive then
                    if not self.led_eff:isPlaying() then
                        self.led_eff:start()
                    end
                else
                    self.led_eff:stop()
                end
            end
        end

        if self.pwr_eff then
            if self.clIsActive then
                if not self.pwr_eff:isPlaying() then
                    self.pwr_eff:start()
                end
            else
                self.pwr_eff:stop()
            end
        end
    end


    if self.gui and self.tmpData then
        if not self.gui:isActive() and self.tmpDataUpdated then
            self.cStorageData.__lock = self.tmpData.__lock

            self.network:sendToServer("sv_updateData", self.cStorageData)
            self.tmpDataUpdated = nil
        end

        if sc.restrictions then
            local localTag = ""
            if self.cStorageData.encryptCode or sc.restrictions.scriptMode ~= self.cStorageData.scriptMode or (not sc.restrictions.allowChat) ~= (not self.cStorageData.allowChat) then
                local vmname = self.cStorageData.encryptCode and ("encryptVM_" .. (self.cltmp.encryptVM_version or "unknown")) or self.cStorageData.vm
                localTag = localTag .. "   (Local Script Mode: " .. vmname .. "-" .. self.cStorageData.scriptMode .. "-" .. (self.cStorageData.allowChat and "printON" or "printOFF") .. ")"
            end
            self.gui:setText("scrMode", "Script Mode: " .. self.cStorageData.vm .. "-" .. sc.restrictions.scriptMode .. "-" .. (sc.restrictions.allowChat and "printON" or "printOFF") .. localTag)
        end
        
        self.gui:setButtonState("alwaysOn", self.cStorageData.alwaysOn)
        self.gui:setButtonState("editLock", self.tmpData.__lock)
        self.gui:setButtonState("invisible", self.cStorageData.invisible)
        self.gui:setButtonState("dislogs", self.cStorageData.dislogs)
        self.gui:setButtonState("encryptCode", self.cStorageData.encryptCode)

        --self.gui:setButtonState("notsaved", self.cStorageData.script ~= string.gsub(self.last_code, "\n", "%[NL%]"))
        local script = self.cStorageData.script or self.old_script
        self.notSaved = script ~= self.last_script
        self.gui:setButtonState(ScriptableComputer.notsavedButton, self.notSaved)
    end

    if self.interact and not self.flag1 and not self.flag2 then
        self.interact = nil

        self:cl_createGUI()
        --self.gui:setText("lastMessage", "")

        if not self.cStorageData.computersAllow then
            self:cl_internal_alertMessage("computers are disabled in this game session")
        end

        if self.cStorageData.__lock then
            self:cl_internal_alertMessage("this computer is locked")
            return
        end

        self:cl_rawSetText(self.last_script)
        self:cl_guiOpen()
    end

    if self.openTimer then
        self.openTimer = self.openTimer - 1
        if self.openTimer <= 0 then
            self:cl_rawSetText(self.last_script)
            self:cl_guiOpen()
            self.openTimer = nil
        end
    end
end

function ScriptableComputer:cl_updateTmpdata(data)
    self.cltmp = data
end

function ScriptableComputer:client_onUpdate(dt)
    sc.deltaTime = dt
end

function ScriptableComputer.client_onDestroy(self)
    if self.gui then
        self.gui:destroy()
    end
    if self.textEditor then
        self.textEditor(true)
    end
    sc.allComputers[self] = nil
    if self.interactable then
        sc.allComputersIds[self.interactable.id] = nil
    end
end

function ScriptableComputer.client_onInteract(self, _, state)
    if state then
        self.lastFontScale = self.lastFontScale or localStorage.current.fontScale
        if self.lastFontScale ~= localStorage.current.fontScale then
            self:cl_recreateGui()
        end
        self.lastFontScale = localStorage.current.fontScale

        self:cl_createGUI()
        --[[
        if not self.updateExamplesFlag then
            updateExamples(self)
            self.updateExamplesFlag = true
        end
        ]]
        self.network:sendToServer("sv_onDataRequired", sm.localPlayer.getPlayer())

        self.tmpData = {}
        for key, value in pairs(self.cStorageData) do
            self.tmpData[key] = value
        end

        self.flag1 = true
        self.flag2 = true
        self.interact = true
    end
end

function ScriptableComputer:cl_createEffect()
    if not self.pwr_eff then
        self.pwr_eff = sm.effect.createEffect(sc.getEffectName(), self.interactable)
        self.led_eff = sm.effect.createEffect(sc.getEffectName(), self.interactable)

        self.pwr_eff:setParameter("color", sm.color.new(1, 0, 0))

        self.pwr_eff:setParameter("uuid", ScriptableComputer.ledUuid)
        self.led_eff:setParameter("uuid", ScriptableComputer.ledUuid)

        self.pwr_eff:setScale(sm.vec3.new(0.03, 0.02, 0.01))
        self.led_eff:setScale(sm.vec3.new(0.03, 0.02, 0.01))

        self.pwr_eff:setOffsetPosition(sm.vec3.new(0.27, 0.095, -0.11))
        self.led_eff:setOffsetPosition(sm.vec3.new(-0.03, 0.15, -0.11))
    end
end

function ScriptableComputer:cl_setActive(isActive)
    self.clIsActive = isActive
end

------------gui
function ScriptableComputer:cl_createGUI()
    if self.gui then return end

    local path = "$CONTENT_DATA/Gui/Layouts/ComputerMenu"
    if localStorage.current.fontScale == 0 then
        path = path .. "_verySmallFont"
    elseif localStorage.current.fontScale == 1 then
        path = path .. "_smallFont"
    elseif localStorage.current.fontScale == 3 then
        path = path .. "_bigFont"
    end
    
    self.gui = sm.gui.createGuiFromLayout(path .. ".layout", false)
    self.gui:setButtonCallback("ScriptSave", "cl_onSaveScript")
    self.gui:setButtonCallback("CloseGui", "cl_closeGui")
    self.gui:setTextChangedCallback("ScriptData", "cl_onScriptDataChanged")
    self.gui:setTextChangedCallback("search", "cl_onSearchChanged")
    self.gui:setButtonCallback("openStorage", "cl_openStorage")
    self:cl_consoleUpdate()

    self.gui:setButtonCallback("alwaysOn", "cl_onCheckbox")
    self.gui:setButtonCallback("editLock", "cl_onCheckbox")
    self.gui:setButtonCallback("invisible", "cl_onCheckbox")
    self.gui:setButtonCallback("dislogs", "cl_onCheckbox")
    self.gui:setButtonCallback("encryptCode", "cl_onCheckbox")
    
    self.gui:setButtonCallback("reboot", "cl_reboot")
    self.gui:setButtonCallback("formatCode", "cl_formatCode")

    self.gui:setButtonCallback("externEditor", "cl_externEditor")
    --self.gui:setButtonCallback("externEditor", "cl_ai")
    self.gui:setButtonCallback("ai", "cl_ai")

    self.gui:setButtonCallback("palette", "cl_palette")
    self.gui:setButtonCallback("fontScale", "cl_fontScale")

    self.gui:setVisible("ai", false)
    --self.gui:setVisible("externEditor", false)

    self.gui:setButtonCallback("exmpload", "cl_onExample")
    self.gui:setTextChangedCallback("exmpnum", "cl_onExample")

    self:cl_updateExamplesList()

    if self.cl_architecture then
        self.gui:setText("Title", self.cl_architecture.computerTitle or "computer")
    else
        self.gui:setText("Title", "lua computer")
    end
end

function ScriptableComputer:cl_palette()
    localStorage.current.palette = (localStorage.current.palette + 1) % localStorage.paletteCount
    localStorage.save()
    self:cl_rawSetText(self.last_script)
end

function ScriptableComputer:cl_recreateGui()
    if self.gui then
        self:cl_closeGui()
        self.gui:destroy()
        self.gui = nil
    end
    self:cl_createGUI()
    self.gui:setText("search", self.exampleSearch)
    self.gui:setText("exmpnum", self.lastExampleStr or "")
    --updateExamples(self, self.exampleSearch)
    self.gui:setVisible("openStorage", not not self.cStorageData.fs)
    self:cl_rawSetText(self.last_script)
    self:cl_guiOpen()
end

function ScriptableComputer:cl_guiOpen()
    self.guiOpened = true
    if self.cStorageData and self.cStorageData.fs then
        self.gui:setVisible("openStorage", true)
    else
        self.gui:setVisible("openStorage", false)
    end
    self.gui:open()
end

function ScriptableComputer:cl_updateExamplesList()
    self.gui:setText("exmplist", self.cl_examples.getList(self.exampleSearch))
end

function ScriptableComputer:cl_onSearchChanged(_, text)
    self.exampleSearch = text
    self:cl_updateExamplesList()
    --updateExamples(self, self.exampleSearch)
end

function ScriptableComputer:cl_fontScale()
    localStorage.current.fontScale = (localStorage.current.fontScale + 1) % localStorage.fontScaleCount
    localStorage.save()
    self:cl_recreateGui()
    self.acceptCheckDelay = 4
end

function ScriptableComputer:cl_openStorage()
    if self.cStorageData.__lock then
        self:cl_internal_alertMessage("this computer is locked")
        return
    end

    if not self.cStorageData.fs then
        self:cl_internal_alertMessage("this computer is not contain internal storage")
        return
    end

    self:cl_closeGui()
    fsmanager_init(self)
    fsmanager_open(self)
end

function ScriptableComputer:cl_reboot()
    self.network:sendToServer("sv_n_reboot")
end

function ScriptableComputer:cl_formatCode()
    if not self.cl_architecture then
        self.last_script = syntax_format(self.last_script)
        self:cl_rawSetText(self.last_script)
    elseif self.cl_architecture.formatCode then
        self.last_script = self.cl_architecture.formatCode(self, self.last_script)
        self:cl_rawSetText(self.last_script)
    else
        self:cl_internal_alertMessage("the architecture does not support code formatting")
    end
end

function ScriptableComputer:cl_onCheckbox(widgetName)
    if widgetName == "alwaysOn" then
        self.cStorageData.alwaysOn = not self.cStorageData.alwaysOn
        self.network:sendToServer("sv_updateData", self.cStorageData)
    elseif widgetName == "editLock" then
        self.tmpData.__lock = not self.tmpData.__lock
        self.tmpDataUpdated = true
        self.network:sendToServer("sv_updateData", self.cStorageData)
    elseif widgetName == "invisible" then
        self.cStorageData.invisible = not self.cStorageData.invisible
        self.network:sendToServer("sv_updateData", self.cStorageData)
    elseif widgetName == "dislogs" then
        self.cStorageData.dislogs = not self.cStorageData.dislogs
        self.network:sendToServer("sv_updateData", self.cStorageData)
    elseif widgetName == "encryptCode" then
        if self.cStorageData.encryptCode then
            self:cl_accept("are you sure you want to disable code encryption? THE CODE WILL BE ERASED FROM THE COMPUTER!", self.encryptCode_toggle_func)
        elseif not self.cl_architecture or self.cl_architecture.encrypt then
            if self.notSaved then
                self:cl_internal_alertMessage("to encrypt the code, first save or rollback the changes")
            else
                self:cl_messageAccept("are you sure you want to enable code encryption? YOU WON'T BE ABLE TO EXTRACT THE CODE ANYMORE!", self.encryptCode_toggle_func)
            end
        else
            self:cl_internal_alertMessage(ScriptableComputer.architectureNotSupportedEncrypt)
        end
    end
end

function ScriptableComputer.cl_onScriptDataChanged(self, widgetName, data)
    --self.oldtext = data
    local oldLast_script = self.last_script
    self.last_script = formatAfterGui(data)
    if (#self.last_script > #oldLast_script and self.last_script:sub(1, #oldLast_script) == oldLast_script) or
    (#self.last_script < #oldLast_script and oldLast_script:sub(1, #self.last_script) == self.last_script) then
        self:cl_rawSetText(self.last_script)
    end
    self:cl_updateLinesNumbers()
end

function ScriptableComputer:cl_realSave()
    self.network:sendToServer("sv_updateScript", self.last_script)
end

function ScriptableComputer.cl_onSaveScript(self)
    --self.gui:setText("ExceptionData", "No errors")

    if self.cStorageData.encryptCode then
        self:cl_internal_alertMessage(ScriptableComputer.encryptCode_warn)
        return
    end

    if #self.last_script > ScriptableComputer.maxcodesize then
        self:cl_internal_alertMessage(ScriptableComputer.maxCodeSizeStr)
        --self.network:sendToServer("sv_updateScript")
    else
        self:cl_realSave()
    end
end

function ScriptableComputer:cl_closeGui()
    self.gui:close()
end

------------network
function ScriptableComputer:cl_invokeScript(tbl)
    local script, isSafe, args, rebootId = unpack(tbl)
    --script = script:gsub("%[NL%]", "\n")

    local env
    if self.client_env and isSafe == self.client_env_isSafe and rebootId == self.client_env_rebootId then
        env = self.client_env
    else
        env = createClientEnv(self)
        self.client_env = env
        self.client_env_isSafe = isSafe
        self.client_env_rebootId = rebootId
    end
    
    --if self.cStorageData.restrictions.vm == "luaInLua" then
    --    ll_Interpreter:reset()
    --end

    local code, err = safe_load_code(self, script, "=client_invoke", "t", env)
    if not code then
        sm.log.error("client invoke syntax error: " .. (err or "Unknown error"))
        return
    end

    self:cl_init_yield()

    tweaks()
    sc.lastComputer = self
    local ran, err = pcall(code, unpack(args))
    sc.lastComputer = nil
    unTweaks()

    if not ran then
        sm.log.error("client invoke error: " .. (err or "Unknown error"))
    end
end

function ScriptableComputer:cl_clear()
    self.client_env = nil
    self.client_env_isSafe = nil
    self.client_env_rebootId = nil
    self.consoleLog = {}
    self.consoleLog_afterTraceback = {}
    self:cl_consoleUpdate()
end

function ScriptableComputer:cl_onComputerException(data)
    self:cl_createGUI()

    data = data or {}
    local msg, computerTag = data[1], data[2]
    local oldErrorLine = self.errorLine

    self.currentError = nil
    self.errorLine = nil
    if msg then
        self.currentError = msg
        if self.cl_architecture then
            if self.cl_architecture.findErrorLine then
                self.errorLine = self.cl_architecture.findErrorLine(self, msg, computerTag)
            end
        else
            self.errorLine = parseErrorLine(msg, computerTag)
        end
    end
    self:cl_consoleUpdate()

    if oldErrorLine ~= self.errorLine then
        self:cl_rawSetText(self.last_script)
    end
end

function ScriptableComputer:cl_consoleUpdate()
    if not self.gui then
        return
    end
    local err = table.concat(self.consoleLog, "#ffffff\n")
    if self.currentError then
        if #self.consoleLog > 0 then
            err = err .. "\n#ffffff"
        end
        err = err .. makeErrorColor(formatBeforeGui(self.currentError))
    end
    if #self.consoleLog_afterTraceback > 0 then
        err = err .. "\n#ffffff" .. table.concat(self.consoleLog_afterTraceback, "#ffffff\n")
    end
    self.gui:setText("ExceptionData", err)
end

function ScriptableComputer:cl_getParam(data)
    self.flag2 = nil
    self.cStorageData = data
    --self.gui:setVisible("openStorage", not not self.cStorageData.fs)

    if sm.isHost then return end
    self.localScriptMode = data.localScriptMode
end

function ScriptableComputer:cl_updateScript(code)
    self.flag1 = nil

    if code then
        if self.cStorageData then
            self.cStorageData.script = code
        end
        self.last_script = code
        self.old_script = code

        self:cl_createGUI()
        if self.gui:isActive() then
            self:cl_rawSetText(code)
        end
    end
end

function ScriptableComputer:cl_onExample(widgetName, text)
    if widgetName == "exmpnum" then
        self.lastExampleStr = text
        return
    elseif widgetName == "exmpload" then
        local example = self.lastExampleStr and self.cl_examples.load(self.lastExampleStr)
        if example then
            self:cl_setText(example)
        else
            self:cl_internal_alertMessage("failed to load an example")
        end
    end
end

function ScriptableComputer:cl_chatMessage(msg)
    --msg = msg:gsub("%[NL%]", "\n")
    --sm.gui.chatMessage("[SComputers]: " .. msg)
    sm.gui.chatMessage(msg)
end

function ScriptableComputer:cl_alertMessage(msg)
    --msg = msg:gsub("%[NL%]", "\n")
    sm.gui.displayAlertText(msg, 4)
end

function ScriptableComputer:cl_logMessage(msg)
    table.insert(self.consoleLog, msg)
    if #self.consoleLog > 150 then
        table.remove(self.consoleLog, 1)
    end
    self:cl_consoleUpdate()
end

function ScriptableComputer:cl_logMessageAfterTrace(msg)
    if not self.currentError then
        self:cl_logMessage(msg)
        return
    end

    table.insert(self.consoleLog_afterTraceback, msg)
    if #self.consoleLog_afterTraceback > 150 then
        table.remove(self.consoleLog_afterTraceback, 1)
    end
    self:cl_consoleUpdate()
end

function ScriptableComputer:cl_internal_alertMessage(msg)
    --msg = msg:gsub("%[NL%]", "\n")
    self:cl_createGUI()
    --self.gui:setText("lastMessage", msg)
    sm.gui.displayAlertText(msg)
    self:cl_logMessageAfterTrace("#008cd6MESSAGE: " .. msg)
end

function ScriptableComputer:cl_setText(code)
    self.last_script = code
    self:cl_rawSetText(code)
end

local lnChar = string.byte("\n")
function ScriptableComputer:cl_updateLinesNumbers()
    local strs = {}
    local linesCount = #self.last_script > 0 and 1 or 0
    for i = 1, #self.last_script do
        if self.last_script:byte(i) == lnChar then
            linesCount = linesCount + 1
        end
    end
    for i = 1, linesCount do
        if self.errorLine == i then
            table.insert(strs, "#ff0000" .. tostring(i))
        else
            table.insert(strs, "#ffffff" .. tostring(i))
        end
    end
    table.insert(strs, "")
    local str = table.concat(strs, "\n")
    self.gui:setText("linesNumbers", str:sub(1, #str - 1))
end

function ScriptableComputer:cl_rawSetText(code)
    self:cl_updateLinesNumbers()

    if self.cStorageData.encryptCode then
        self.gui:setText("ScriptData", formatBeforeGui(code))
        return
    end
    
    if self.cl_architecture then
        if self.cl_architecture.syntaxHighlight then
            self.gui:setText("ScriptData", self.cl_architecture.syntaxHighlight(self, code, self.errorLine))
        else
            self.gui:setText("ScriptData", formatBeforeGui(code))
        end
    else
        self.gui:setText("ScriptData", syntax_make(formatBeforeGui(code), self.errorLine))
    end
end

function ScriptableComputer:cl_externEditor()
    if self.cStorageData.encryptCode then
        self:cl_internal_alertMessage(ScriptableComputer.encryptCode_warn)
        return
    end

    if self.textEditor then
        self.textEditor(true)
        self.textEditor = nil
    end
    
    if better and better.isAvailable() then
        if not self.cl_architecture or self.cl_architecture.editorExtension == "lua" then
            self.textEditor = better.textEditor_lua(self.last_script)
        else
            self.textEditor = better.textEditor_txt(self.last_script)
        end
    else
        self:cl_internal_alertMessage("for the external editor, you need a betterAPI")
    end
end

function ScriptableComputer:cl_ai()
    if self.cStorageData.encryptCode then
        self:cl_internal_alertMessage(ScriptableComputer.encryptCode_warn)
        return
    end
    
    if self.aiGen then return end
    if ai_codeGen then
        if #self.last_script > ScriptableComputer.maxPromptsize then
            self:cl_internal_alertMessage("the maximum prompt size is 16KB")
        else
            self:cl_internal_alertMessage("please wait...")
            self.aiGen = ai_codeGen(self.last_script)
        end
    else
        self:cl_internal_alertMessage("for the AI code-gen to work, you need a betterAPI")
    end
end

function ScriptableComputer:cl_accept(text, func)
    self.acceptMessage = nil
    if not self.acceptGui then
        self.acceptGui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/PopUp_YN.layout", false)
        self.acceptGui:setButtonCallback("Yes", "cl_g_accept")
        self.acceptGui:setButtonCallback("No", "cl_g_naccept")
    end
    self.acceptGui:setText("Title", "confirmation action")
    self.acceptGui:setText("Message", text)
    self.acceptGui:open()
    self:cl_closeGui()
    self.acceptFunction = func
end

function ScriptableComputer:cl_messageAccept(text, func)
    self.acceptMessage = ""
    if not self.messageAcceptGui then
        self.messageAcceptGui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/PopUp_YNM.layout", false)
        self.messageAcceptGui:setTextChangedCallback("UserMessage", "cl_g_message")
        self.messageAcceptGui:setButtonCallback("Yes", "cl_g_message_accept")
        self.messageAcceptGui:setButtonCallback("No", "cl_g_message_naccept")
    end
    self.messageAcceptGui:setText("Title", "confirmation action")
    self.messageAcceptGui:setText("Message", text)
    self.messageAcceptGui:setText("UserMessage", "")
    self.messageAcceptGui:open()
    self:cl_closeGui()
    self.acceptFunction = func
end

function ScriptableComputer:cl_g_message(_, text)
    self.acceptMessage = text
end

function ScriptableComputer:cl_g_message_accept()
    self.acceptFunction(self.acceptMessage)
    self.messageAcceptGui:close()
    self.openTimer = 2
end

function ScriptableComputer:cl_g_message_naccept()
    self.messageAcceptGui:close()
    self.openTimer = 2
end

function ScriptableComputer:cl_g_accept()
    self.acceptFunction()
    self.acceptGui:close()
    self.openTimer = 2
end

function ScriptableComputer:cl_g_naccept()
    self.acceptGui:close()
    self.openTimer = 2
end

function ScriptableComputer:cl_saveAccept()
    if self.cStorageData.encryptCode then
        return
    end
    if not self.saveAcceptGui then
        self.saveAcceptGui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/PopUp_YNC.layout", false)
        self.saveAcceptGui:setButtonCallback("Yes", "cl_g_saveAccept_Yes")
        self.saveAcceptGui:setButtonCallback("No", "cl_g_saveAccept_No")
        self.saveAcceptGui:setButtonCallback("Cancel", "cl_g_saveAccept_Cancel")
    end
    self.saveAcceptGui:setText("Title", "save changes?")
    self.saveAcceptGui:setText("Message", "you are trying to close the code editor, but you have unsaved changes")
    self.saveAcceptGui:open()
    self:cl_closeGui()
end

function ScriptableComputer:cl_g_saveAccept_Yes()
    self:cl_realSave()
    self.saveAcceptGui:close()
    self.saveAcceptGui:destroy()
    self.saveAcceptGui = nil
end

function ScriptableComputer:cl_g_saveAccept_No()
    self.saveAcceptGui:close()
    self.saveAcceptGui:destroy()
    self.saveAcceptGui = nil
end

function ScriptableComputer:cl_g_saveAccept_Cancel()
    self.saveAcceptGui:close()
    self.saveAcceptGui:destroy()
    self.saveAcceptGui = nil
    self.openTimer = 2
end
end
function scmframework_2901e4aabc087f59dd0446b335059c9b() --$CONTENT_DATA/Scripts/sha256.lua
sha256 = {}

local preproc, initH256, digestblock, str2hexa, num2s
local function a(b,c,d,...)b=b%2^32;c=c%2^32;local e=(b%0x00000002>=0x00000001 and c%0x00000002>=0x00000001 and 0x00000001 or 0)+(b%0x00000004>=0x00000002 and c%0x00000004>=0x00000002 and 0x00000002 or 0)+(b%0x00000008>=0x00000004 and c%0x00000008>=0x00000004 and 0x00000004 or 0)+(b%0x00000010>=0x00000008 and c%0x00000010>=0x00000008 and 0x00000008 or 0)+(b%0x00000020>=0x00000010 and c%0x00000020>=0x00000010 and 0x00000010 or 0)+(b%0x00000040>=0x00000020 and c%0x00000040>=0x00000020 and 0x00000020 or 0)+(b%0x00000080>=0x00000040 and c%0x00000080>=0x00000040 and 0x00000040 or 0)+(b%0x00000100>=0x00000080 and c%0x00000100>=0x00000080 and 0x00000080 or 0)+(b%0x00000200>=0x00000100 and c%0x00000200>=0x00000100 and 0x00000100 or 0)+(b%0x00000400>=0x00000200 and c%0x00000400>=0x00000200 and 0x00000200 or 0)+(b%0x00000800>=0x00000400 and c%0x00000800>=0x00000400 and 0x00000400 or 0)+(b%0x00001000>=0x00000800 and c%0x00001000>=0x00000800 and 0x00000800 or 0)+(b%0x00002000>=0x00001000 and c%0x00002000>=0x00001000 and 0x00001000 or 0)+(b%0x00004000>=0x00002000 and c%0x00004000>=0x00002000 and 0x00002000 or 0)+(b%0x00008000>=0x00004000 and c%0x00008000>=0x00004000 and 0x00004000 or 0)+(b%0x00010000>=0x00008000 and c%0x00010000>=0x00008000 and 0x00008000 or 0)+(b%0x00020000>=0x00010000 and c%0x00020000>=0x00010000 and 0x00010000 or 0)+(b%0x00040000>=0x00020000 and c%0x00040000>=0x00020000 and 0x00020000 or 0)+(b%0x00080000>=0x00040000 and c%0x00080000>=0x00040000 and 0x00040000 or 0)+(b%0x00100000>=0x00080000 and c%0x00100000>=0x00080000 and 0x00080000 or 0)+(b%0x00200000>=0x00100000 and c%0x00200000>=0x00100000 and 0x00100000 or 0)+(b%0x00400000>=0x00200000 and c%0x00400000>=0x00200000 and 0x00200000 or 0)+(b%0x00800000>=0x00400000 and c%0x00800000>=0x00400000 and 0x00400000 or 0)+(b%0x01000000>=0x00800000 and c%0x01000000>=0x00800000 and 0x00800000 or 0)+(b%0x02000000>=0x01000000 and c%0x02000000>=0x01000000 and 0x01000000 or 0)+(b%0x04000000>=0x02000000 and c%0x04000000>=0x02000000 and 0x02000000 or 0)+(b%0x08000000>=0x04000000 and c%0x08000000>=0x04000000 and 0x04000000 or 0)+(b%0x10000000>=0x08000000 and c%0x10000000>=0x08000000 and 0x08000000 or 0)+(b%0x20000000>=0x10000000 and c%0x20000000>=0x10000000 and 0x10000000 or 0)+(b%0x40000000>=0x20000000 and c%0x40000000>=0x20000000 and 0x20000000 or 0)+(b%0x80000000>=0x40000000 and c%0x80000000>=0x40000000 and 0x40000000 or 0)+(b>=0x80000000 and c>=0x80000000 and 0x80000000 or 0)return d and a(e,d,...)or e end;local function f(b,c,d,...)local e=(b%0x00000002>=0x00000001~=(c%0x00000002>=0x00000001)and 0x00000001 or 0)+(b%0x00000004>=0x00000002~=(c%0x00000004>=0x00000002)and 0x00000002 or 0)+(b%0x00000008>=0x00000004~=(c%0x00000008>=0x00000004)and 0x00000004 or 0)+(b%0x00000010>=0x00000008~=(c%0x00000010>=0x00000008)and 0x00000008 or 0)+(b%0x00000020>=0x00000010~=(c%0x00000020>=0x00000010)and 0x00000010 or 0)+(b%0x00000040>=0x00000020~=(c%0x00000040>=0x00000020)and 0x00000020 or 0)+(b%0x00000080>=0x00000040~=(c%0x00000080>=0x00000040)and 0x00000040 or 0)+(b%0x00000100>=0x00000080~=(c%0x00000100>=0x00000080)and 0x00000080 or 0)+(b%0x00000200>=0x00000100~=(c%0x00000200>=0x00000100)and 0x00000100 or 0)+(b%0x00000400>=0x00000200~=(c%0x00000400>=0x00000200)and 0x00000200 or 0)+(b%0x00000800>=0x00000400~=(c%0x00000800>=0x00000400)and 0x00000400 or 0)+(b%0x00001000>=0x00000800~=(c%0x00001000>=0x00000800)and 0x00000800 or 0)+(b%0x00002000>=0x00001000~=(c%0x00002000>=0x00001000)and 0x00001000 or 0)+(b%0x00004000>=0x00002000~=(c%0x00004000>=0x00002000)and 0x00002000 or 0)+(b%0x00008000>=0x00004000~=(c%0x00008000>=0x00004000)and 0x00004000 or 0)+(b%0x00010000>=0x00008000~=(c%0x00010000>=0x00008000)and 0x00008000 or 0)+(b%0x00020000>=0x00010000~=(c%0x00020000>=0x00010000)and 0x00010000 or 0)+(b%0x00040000>=0x00020000~=(c%0x00040000>=0x00020000)and 0x00020000 or 0)+(b%0x00080000>=0x00040000~=(c%0x00080000>=0x00040000)and 0x00040000 or 0)+(b%0x00100000>=0x00080000~=(c%0x00100000>=0x00080000)and 0x00080000 or 0)+(b%0x00200000>=0x00100000~=(c%0x00200000>=0x00100000)and 0x00100000 or 0)+(b%0x00400000>=0x00200000~=(c%0x00400000>=0x00200000)and 0x00200000 or 0)+(b%0x00800000>=0x00400000~=(c%0x00800000>=0x00400000)and 0x00400000 or 0)+(b%0x01000000>=0x00800000~=(c%0x01000000>=0x00800000)and 0x00800000 or 0)+(b%0x02000000>=0x01000000~=(c%0x02000000>=0x01000000)and 0x01000000 or 0)+(b%0x04000000>=0x02000000~=(c%0x04000000>=0x02000000)and 0x02000000 or 0)+(b%0x08000000>=0x04000000~=(c%0x08000000>=0x04000000)and 0x04000000 or 0)+(b%0x10000000>=0x08000000~=(c%0x10000000>=0x08000000)and 0x08000000 or 0)+(b%0x20000000>=0x10000000~=(c%0x20000000>=0x10000000)and 0x10000000 or 0)+(b%0x40000000>=0x20000000~=(c%0x40000000>=0x20000000)and 0x20000000 or 0)+(b%0x80000000>=0x40000000~=(c%0x80000000>=0x40000000)and 0x40000000 or 0)+(b>=0x80000000~=(c>=0x80000000)and 0x80000000 or 0)return d and f(e,d,...)or e end;local function g(h)return 4294967295-h end;local function i(h,j)h=h%2^32;local k=h/2^j;return k-k%1 end;local function l(h,j)h=h%2^32;local k=h/2^j;local m=k%1;return k-m+m*2^32 end;local n={0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2}function str2hexa(o)local p=string.gsub(o,".",function(q)return string.format("%02x",string.byte(q))end)return p end;function num2s(r,s)local o=""for t=1,s do local u=r%256;o=string.char(u)..o;r=(r-u)/256 end;return o end;local function v(o,t)local s=0;for t=t,t+3 do s=s*256+string.byte(o,t)end;return s end;function preproc(w,x)local y=64-(x+1+8)%64;x=num2s(8*x,8)w=w.."\128"..string.rep("\0",y)..x;return w end;function initH256(z)z[1]=0x6a09e667;z[2]=0xbb67ae85;z[3]=0x3c6ef372;z[4]=0xa54ff53a;z[5]=0x510e527f;z[6]=0x9b05688c;z[7]=0x1f83d9ab;z[8]=0x5be0cd19;return z end;function digestblock(w,t,z)local A={}for B=1,16 do A[B]=v(w,t+(B-1)*4)end;for B=17,64 do local C=A[B-15]local D=f(l(C,7),l(C,18),i(C,3))C=A[B-2]local E=f(l(C,17),l(C,19),i(C,10))A[B]=A[B-16]+D+A[B-7]+E end;local F,G,q,H,I,J,K,p=z[1],z[2],z[3],z[4],z[5],z[6],z[7],z[8]for t=1,64 do local D=f(l(F,2),l(F,13),l(F,22))local L=f(a(F,G),a(F,q),a(G,q))local M=D+L;local E=f(l(I,6),l(I,11),l(I,25))local N=f(a(I,J),a(g(I),K))local O=p+E+N+n[t]+A[t]p,K,J,I,H,q,G,F=K,J,I,H+O,q,G,F,O+M end;z[1]=(z[1]+F)%2^32;z[2]=(z[2]+G)%2^32;z[3]=(z[3]+q)%2^32;z[4]=(z[4]+H)%2^32;z[5]=(z[5]+I)%2^32;z[6]=(z[6]+J)%2^32;z[7]=(z[7]+K)%2^32;z[8]=(z[8]+p)%2^32 end

function sha256.sha256bin(msg, needYield)
    if better and better.algorithm then
        return better.algorithm.sha256_binary(msg)
    end

    local function yield()
        if needYield then
            sc.smartYield()
        end
    end

    msg = preproc(msg, #msg)
    local H = initH256({})
    for i = 1, #msg, 64 do yield() digestblock(msg, i, H) end
    return num2s(H[1], 4) .. num2s(H[2], 4) .. num2s(H[3], 4) .. num2s(H[4], 4) .. num2s(H[5], 4) .. num2s(H[6], 4) .. num2s(H[7], 4) .. num2s(H[8], 4)
end

function sha256.sha256hex(msg, needYield)
    if better and better.algorithm then
        return better.algorithm.sha256_text(msg)
    end

    return str2hexa(sha256.sha256bin(msg, needYield))
end
end
function scmframework_f439912b5440aaa6b6fa7f92942ed147() --$CONTENT_DATA/Scripts/StepperMotor.lua
dofile '$CONTENT_DATA/Scripts/Config.lua'

StepperMotor = class(nil)

StepperMotor.maxParentCount = -1
StepperMotor.maxChildCount = 16
StepperMotor.connectionInput = sm.interactable.connectionType.composite + sm.interactable.connectionType.electricity
StepperMotor.connectionOutput = sm.interactable.connectionType.bearing
StepperMotor.colorNormal = sm.color.new(0x9f6213ff)
StepperMotor.colorHighlight = sm.color.new(0xde881bff)
StepperMotor.componentType = "motor"

--StepperMotor.nonActiveImpulse = 0.25
StepperMotor.nonActiveImpulse = 0
StepperMotor.chargeAdditions = 4000000

-- SERVER --

function StepperMotor:sv_resourcesLimit()
	return self.data and self.data.survival and sc.restrictions.resourceConsumption
end

function StepperMotor.server_createData(self)
	return {
		getVelocity = function () return self.velocity end,
		setVelocity = function (v)
		    if type(v) == "number" then
				self.velocity = sm.util.clamp(v, -self.mVelocity, self.mVelocity)
			else
				error("Value must be number")
			end
		end,
		getStrength = function () return self.maxImpulse end,
		setStrength = function (v)
		    if type(v) == "number" then
				self.maxImpulse = sm.util.clamp(v, 0, self.mImpulse)
			else
				error("Value must be number")
			end
		end,
		getAngle = function () return self.angle end,
		setAngle = function (v)
			if type(v) == "number" or type(v) == "nil" then
				self.angle = v and sm.util.clamp(v, -3.402e+38, 3.402e+38) or nil
			else
				error("Value must be number or nil")
			end
		end,
		isActive = function () return self.isActive end,
		setActive = function (v) 
			if type(v) == "boolean" then
				self.isActive = v
			elseif type(v) == "number" then
				self.isActive = v > 0
			else
				error("Type must be boolean or number")
			end
		end,

		getAvailableBatteries = function ()
			return self:sv_resourcesLimit() and (self.batteries or 0) or math.huge
		end,
		getCharge = function ()
			return self.sdata.energy
		end,
		getChargeDelta = function ()
			return self.chargeDelta
		end,
		isWorkAvailable = function ()
			if self:sv_resourcesLimit() then
				if self.sdata.energy > 0 then
					return true
				end

				if self.batteries and self.batteries > 0 then
					return true
				end

				return false
			end
			return true
		end,
		getBearingsCount = function ()
			return self.bearingsCount or 0
		end,

		maxStrength = function ()
			return self.mImpulse
		end,
		maxVelocity = function ()
			return self.mVelocity
		end,
		getChargeAdditions = function ()
			return StepperMotor.chargeAdditions
		end,
		setSoundType = function (num)
			checkArg(1, num, "number")
			self.soundtype = num
		end,
		getSoundType = function ()
			return self.soundtype
		end,
		getBearingAngle = function(i)
			local angle = (self.bearingList[i] or error("incorrect index of bearing", 2)).angle
			return -angle
		end
	}
end

function StepperMotor:sv_getBearingData()
	self.bearingList = self.interactable:getBearings()
	self.bearingsCount = #self.bearingList
end

function StepperMotor.server_onCreate(self)
	self.chargeDelta = 0
	
	self.soundtype = 1
	self.mVelocity = 10000
	self.mImpulse = 10000000
	self.sdata = self.storage:load() or {energy = 0, label = ""}
	self:sv_setData(self.sdata)
	if self.data and self.data.survival then
		self.mVelocity = self.data.v or 10
		self.mImpulse = self.data.i or 10
	else
		self.isCreative = true
	end

	self.velocity = 0
	self.maxImpulse = 0
	self.angle = nil
	self.isActive = false
	self.wasActive = false
	self:sv_getBearingData()

	sc.motorsDatas[self.interactable:getId()] = self:server_createData()

	sc.creativeCheck(self, self.isCreative)
end

function StepperMotor:sv_setData(data)
	data.label = tostring(data.label or "")
    self.sdata = data
	self.interactable.publicData = {
        label = self.sdata.label
    }
    self.network:sendToClients("cl_setData", self.sdata)
    self.storage:save(self.sdata)
end

function StepperMotor.server_onDestroy(self)
	sc.motorsDatas[self.interactable:getId()] = nil
end

function StepperMotor.server_onFixedUpdate(self, dt)
	self:sv_getBearingData()

	--------------------------------------------------------

	local container
	for _, parent in ipairs(self.interactable:getParents()) do
		if parent:hasOutputType(sm.interactable.connectionType.electricity) then
			container = parent:getContainer(0)
			break
		end
	end

	self.batteries = self:sv_mathCount()
	self.chargeDelta = 0

	--------------------------------------------------------

	local active = self.isActive
	if active and self.sdata.energy <= 0 and self:sv_resourcesLimit() then
		self:sv_removeItem()
		if self.sdata.energy <= 0 then
			active = nil
		end
	end

	if active then
		if self.angle == nil then
			for k, v in pairs(self.interactable:getBearings()) do
				v:setMotorVelocity(self.velocity, self.maxImpulse)
			end
		else
			for k, v in pairs(self.interactable:getBearings()) do
				v:setTargetAngle(self.angle, self.velocity, self.maxImpulse)
			end
		end

		if self.maxImpulse > 0 then
			for k, v in pairs(self.interactable:getBearings()) do
				self.chargeDelta = self.chargeDelta + math.abs(v:getAppliedImpulse())				
			end
			self.sdata.energy = self.sdata.energy - self.chargeDelta
		end
	elseif self.wasActive then
		for k, v in pairs(self.interactable:getBearings()) do
			v:setMotorVelocity(0, StepperMotor.nonActiveImpulse)
		end
	end
	self.wasActive = active

	if self.sdata.energy < 0 then
		self.sdata.energy = 0
	end

	local rpm = math.min(1, math.abs(self.velocity) / 100)
	local load = (self.chargeDelta / self.maxImpulse) / (self.bearingsCount or 0)
	if self.old_active ~= active or
	rpm ~= self.old_rpm or
	load ~= self.old_load or
	self.soundtype ~= self.old_type then
		if active and self.soundtype ~= 0 then
			local lload, lrpm = load, rpm
			if self.soundtype == 1 then
				lrpm = lload
			end
			self.network:sendToClients("cl_setEffectParams", {
				rpm = lrpm,
				load = lload,
				soundtype = self.soundtype
			})
		else
			self.network:sendToClients("cl_setEffectParams")
		end
	end
	self.old_active = active
	self.old_rpm = rpm
	self.old_load = load
	self.old_type = self.soundtype

	sc.creativeCheck(self, self.isCreative)

	if sc.needSaveData() and self.sdata.energy ~= self.oldEnergy then
		self.storage:save(self.sdata)
		self.oldEnergy = self.sdata.energy
	end
end

function StepperMotor:sv_removeItem()
	for _, parent in ipairs(self.interactable:getParents()) do
        if parent:hasOutputType(sm.interactable.connectionType.electricity) then
			local container = parent:getContainer(0)
			if sm.container.canSpend(container, obj_consumable_battery, 1) then
				sm.container.beginTransaction()
				sm.container.spend(container, obj_consumable_battery, 1, true)
				if sm.container.endTransaction() then
					self.sdata.energy = self.sdata.energy + StepperMotor.chargeAdditions
					break
				end
			end
		end
	end
end

function StepperMotor:sv_mathCount()
    local count = 0
    for _, parent in ipairs(self.interactable:getParents()) do
        if parent:hasOutputType(sm.interactable.connectionType.electricity) then
            local container = parent:getContainer(0)
            for i = 0, container.size - 1 do
                count = count + (container:getItem(i).quantity)
            end
		end
	end
    return count
end

function StepperMotor:sv_dataRequest(_, player)
    self.network:sendToClient(player, "cl_setData", self.sdata)
end


-- CLIENT --

function StepperMotor:client_onCreate()
	self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/MotorLabel.layout", false, { backgroundAlpha = 0 })
	self.gui:setTextChangedCallback("Label", "cl_onLabelChanged")
	self.gui:setButtonCallback("Save", "cl_onLabelChange")

	self.network:sendToServer("sv_dataRequest")
end

function StepperMotor:cl_onLabelChanged(_, data)
	if #data <= 32 then
		self.cl_temp_label = data
        self:cl_guiError(nil)
	else
		self:cl_guiError("label is too long")
	end
end

function StepperMotor:cl_onLabelChange()
    self.csdata.label = self.cl_temp_label
    self.network:sendToServer("sv_setData", self.csdata)
	self.gui:close()
end

function StepperMotor:client_onInteract(_, state)
	if state and self.csdata then
        self.cl_temp_label = self.csdata.label
        self.gui:setText("Label", tostring(self.cl_temp_label))
	    self:cl_guiError(nil)
		self.gui:open()
	end
end

function StepperMotor:cl_guiError(text)
	if text ~= nil then
		self.gui:setVisible("Save", false)
        self.gui:setVisible("Error", true)
		self.gui:setText("Error", text)
	else
		self.gui:setVisible("Save", true)
        self.gui:setVisible("Error", false)
		self.gui:setText("Error", "")
	end
end

function StepperMotor:cl_setData(data)
    self.csdata = data
end

function StepperMotor:client_onDestroy()
	self.gui:destroy()
end

function StepperMotor:cl_setEffectParams(tbl)
	if tbl then
		if tbl.soundtype ~= self.cl_oldSoundType then
			if self.effect then
				self.effect:setAutoPlay(false)
				self.effect:stop()
				self.effect:destroy()
				self.effect = nil
			end
			self.cl_oldSoundType = tbl.soundtype
		end

		if not self.effect then
			if tbl.soundtype == 1 or tbl.soundtype == 3 then
				self.effect = sm.effect.createEffect("ElectricEngine - Level 2", self.interactable)
			elseif tbl.soundtype == 2 then
				self.effect = sm.effect.createEffect("GasEngine - Level 3", self.interactable)
			end
			
			if self.effect then
				self.effect:setAutoPlay(true)
				self.effect:start()
			end
		end

		if self.effect then
			self.effect:setParameter("rpm", tbl.rpm)
			self.effect:setParameter("load", tbl.load)
		end
	else
		if self.effect then
			self.effect:setAutoPlay(false)
			self.effect:stop()
			self.effect:destroy()
			self.effect = nil
		end
	end
end
end
function scmframework_1141fd9d7172c1d3a0e336191030b478() --$CONTENT_DATA/Scripts/syntax.lua
local palettes = {
    {
        mainColor = "#8ee4ff",
        functionColor = "#f5d689",
        commentColor = "#1ca800",
        stringColor = "#e39a2d",
        numberColor = "#6FCE54",
        
        keywords = {
            ["true"] = "#0d8ef7",
            ["false"] = "#0d8ef7",
            ["nil"] = "#0d8ef7",
            ["local"] = "#0d8ef7",
        
            ["until"] = "#C456BD",
            ["repeat"] = "#C456BD",
            ["while"] = "#C456BD",
            ["for"] = "#C456BD",
            ["if"] = "#C456BD",
            ["in"] = "#C456BD",
            ["then"] = "#C456BD",
            ["end"] = "#C456BD",
            ["else"] = "#C456BD",
            ["elseif"] = "#C456BD",
            ["do"] = "#C456BD",
            ["function"] = "#C456BD",
            ["return"] = "#C456BD",
            ["or"] = "#C456BD",
            ["and"] = "#C456BD",
            ["not"] = "#C456BD",

            ["+"] = "#ffffff",
            ["*"] = "#ffffff",
            ["/"] = "#ffffff",
            ["-"] = "#ffffff",
            ["^"] = "#ffffff"
        },
        
        bracketsColors = {
            "#d2cc29",
            "#C456BD",
            "#0d8ef7"
        },
        
        afterDotColors = {
            "#0c9beb",
            "#2ad163",
            "#c9d12a"
        }
    },
    {
        mainColor = "#fcfa90",
        functionColor = "#ee9c6a",
        commentColor = "#6aa300",
        stringColor = "#e39a2d",
        numberColor = "#d5ff1f",
        
        keywords = {
            ["true"] = "#d76600",
            ["false"] = "#d76600",
            ["nil"] = "#d76600",
            ["local"] = "#d76600",
        
            ["until"] = "#e8ae17",
            ["repeat"] = "#e8ae17",
            ["while"] = "#e8ae17",
            ["for"] = "#e8ae17",
            ["if"] = "#e8ae17",
            ["in"] = "#e8ae17",
            ["then"] = "#e8ae17",
            ["end"] = "#e8ae17",
            ["else"] = "#e8ae17",
            ["elseif"] = "#e8ae17",
            ["do"] = "#e8ae17",
            ["function"] = "#e8ae17",
            ["return"] = "#e8ae17",
            ["or"] = "#e8ae17",
            ["and"] = "#e8ae17",
            ["not"] = "#e8ae17",

            ["+"] = "#ffffff",
            ["*"] = "#ffffff",
            ["/"] = "#ffffff",
            ["-"] = "#ffffff",
            ["^"] = "#ffffff"
        },
        
        bracketsColors = {
            "#ff541e",
            "#d18606",
            "#cdd106"
        },
        
        afterDotColors = {
            "#d14a06",
            "#d18306",
            "#d1bd06"
        }
    },
    {
        mainColor = "#ffffff",
        functionColor = "#88d914",
        commentColor = "#00ee00",
        stringColor = "#eab600",
        numberColor = "#00ff00",
        
        keywords = {
            ["true"] = "#4aff6a",
            ["false"] = "#4aff6a",
            ["nil"] = "#4aff6a",
            ["local"] = "#ff4a8e",
        
            ["until"] = "#eb00de",
            ["repeat"] = "#eb00de",
            ["while"] = "#eb00de",
            ["for"] = "#eb00de",
            ["if"] = "#eb00de",
            ["in"] = "#eb00de",
            ["then"] = "#eb00de",
            ["end"] = "#eb00de",
            ["else"] = "#eb00de",
            ["elseif"] = "#eb00de",
            ["do"] = "#eb00de",
            ["function"] = "#eb00de",
            ["return"] = "#eb00de",
            ["or"] = "#eb00de",
            ["and"] = "#eb00de",
            ["not"] = "#eb00de",

            ["+"] = "#ff8f00",
            ["*"] = "#ff8f00",
            ["/"] = "#ff8f00",
            ["-"] = "#ff8f00",
            ["^"] = "#ff8f00"
        },
        
        bracketsColors = {
            "#ffffff",
            "#44ff44",
            "#ff2222"
        },
        
        afterDotColors = {
            "#3de2ff",
            "#02f546",
            "#e9f502"
        }
    },
    {
        mainColor = "#96ffb2",
        functionColor = "#0cb856",
        commentColor = "#01a305",
        stringColor = "#0088ff",
        numberColor = "#00f4ff",
        
        keywords = {
            ["true"] = "#f0ca02",
            ["false"] = "#f0ca02",
            ["nil"] = "#f0ca02",
            ["local"] = "#f0ca02",
        
            ["until"] = "#9bd100",
            ["repeat"] = "#9bd100",
            ["while"] = "#9bd100",
            ["for"] = "#9bd100",
            ["if"] = "#9bd100",
            ["in"] = "#9bd100",
            ["then"] = "#9bd100",
            ["end"] = "#9bd100",
            ["else"] = "#9bd100",
            ["elseif"] = "#9bd100",
            ["do"] = "#9bd100",
            ["function"] = "#9bd100",
            ["return"] = "#9bd100",
            ["or"] = "#9bd100",
            ["and"] = "#9bd100",
            ["not"] = "#9bd100",

            ["+"] = "#ffffff",
            ["*"] = "#ffffff",
            ["/"] = "#ffffff",
            ["-"] = "#ffffff",
            ["^"] = "#ffffff"
        },
        
        bracketsColors = {
            "#02f068",
            "#02f090",
            "#02f0cc"
        },
        
        afterDotColors = {
            "#0cff00",
            "#daf002",
            "#f0b802"
        }
    },
    {
        noHighlight = true
    }
}

local orig_backslash = "\\"
local magic_backslash = "¦"

local parsedLinesCache = {}
local function parseLine(str)
    local paletteIndex = localStorage.current.palette
    if not parsedLinesCache[paletteIndex] then
        parsedLinesCache[paletteIndex] = {}
    end
    if parsedLinesCache[paletteIndex][str] then
        return parsedLinesCache[paletteIndex][str]
    end
    local lst = {}
    local oldChrType
    local force
    local forceDisable
    for i = 1, utf8.len(str) do
        local chr = utf8.sub(str, i, i)
        local nextChr = utf8.sub(str, i + 1, i + 1)

        local chrType
        if chr >= "0" and chr <= "9" then
            if oldChrType ~= 2 and nextChr ~= "x" then
                chrType = 1
            else
                chrType = 2
            end
        elseif (chr >= "A" and chr <= "Z") or (chr >= "a" and chr <= "z") or chr == "_" then
            chrType = 2
        elseif chr == "-" then
            chrType = 5
        elseif chr == "." or chr == ":" then
            chrType = 7
        elseif forceDisable and forceDisable[chr] then
            force = nil
        end

        if force then
            chrType = force
        elseif chr == "#" then
            force = 6
            forceDisable = {[" "] = true, ["\""] = true, ["'"] = true}
            chrType = force
        end            

        if not chrType or oldChrType ~= chrType or #lst == 0 then
            table.insert(lst, {})
            oldChrType = chrType
        end

        table.insert(lst[#lst], chr)
    end
    for i, v in ipairs(lst) do
        lst[i] = table.concat(v)
    end
    parsedLinesCache[paletteIndex][str] = lst
    return lst
end

function syntax_make(code, errorLine, yieldActive, customPalette)
    local bracketsValue = 0
    local currentPalette = palettes[customPalette or (localStorage.current.palette + 1)] or palettes[1]

    local _strSplit
    if yieldActive then
        _strSplit = strSplit
    else
        _strSplit = strSplitNoYield
    end

    local newstr = {}
    local gcomment
    for posY, str in ipairs(_strSplit(string, code, {"\n"})) do
        if posY == errorLine then
            if posY > 1 then
                table.insert(newstr, "\n")
            end
            local parts = parseLine(str)
            for lstrI, lstr in ipairs(parts) do
                if lstr ~= "" then
                    table.insert(newstr, "#ff0000")
                    table.insert(newstr, lstr)
                end
            end
        elseif not currentPalette.noHighlight then
            if posY > 1 then
                table.insert(newstr, "\n")
            end
            local lcomment = false
            local lostr = false
            local lostr2 = false
            local prev
            local parts = parseLine(str)
            local dotValue = 0
            local dotExists = false
            for lstrI, lstr in ipairs(parts) do
                if lstr ~= "" then
                    local lcolor
    
                    if lstr:sub(1, 2) == "--" then
                        lcomment = true
                    elseif lstr == "[" and parts[lstrI+1] == "[" then
                        gcomment = lcomment and currentPalette.commentColor or currentPalette.stringColor
                    end
    
                    local isStr = lostr or lostr2
                    if lstr == "\"" then
                        if not lostr2 then
                            lostr = not lostr
                        end
                    elseif lstr == "'" then
                        if not lostr then
                            lostr2 = not lostr2
                        end
                    elseif lstr == "." or lstr == ":" then
                        dotValue = dotValue + 1
                        if dotValue > #currentPalette.afterDotColors then
                            dotValue = 1
                        end
                        dotExists = true
                    end

                    if lstr == " " or lstr == "(" or lstr == "{" or lstr == "[" or lstr == "\"" or lstr == "'" then
                        dotExists = false
                        dotValue = 0
                    end
    
                    if lcomment or gcomment then
                        lcolor = gcomment or currentPalette.commentColor
                    elseif lostr or lostr2 or isStr then
                        lcolor = currentPalette.stringColor
                    elseif tonumber(lstr) then
                        lcolor = currentPalette.numberColor
                    elseif currentPalette.functionColor and parts[lstrI+1] == "(" then
                        lcolor = currentPalette.functionColor
                    else
                        lcolor = currentPalette.keywords[lstr]
                        if not lcolor and dotExists then
                            lcolor = currentPalette.afterDotColors[dotValue]
                        end
                        lcolor = lcolor or currentPalette.mainColor
                    end
    
                    if not lcomment and not gcomment then
                        if lstr == "(" or lstr == "[" or lstr == "{" then
                            bracketsValue = bracketsValue + 1
                            if bracketsValue > #currentPalette.bracketsColors then
                                bracketsValue = 1
                            end
                            lcolor = currentPalette.bracketsColors[bracketsValue] or currentPalette.bracketsColors[1]
                        elseif lstr == ")" or lstr == "]" or lstr == "}" then
                            lcolor = currentPalette.bracketsColors[bracketsValue] or currentPalette.bracketsColors[1]
                            bracketsValue = bracketsValue - 1
                            if bracketsValue < 1 then
                                bracketsValue = #currentPalette.bracketsColors
                            end
                        end
                    end
                    
                    if lstr == "]" and prev == "]" then
                        gcomment = false
                    end
    
                    table.insert(newstr, lcolor)
                    table.insert(newstr, lstr)
                    prev = lstr
                end
            end
        else
            if posY > 1 then
                table.insert(newstr, "\n")
            end
            table.insert(newstr, "#ffffff")
            table.insert(newstr, str)
        end
    end
    return table.concat(newstr)
end

local upFindTokens = {
    "function"
}

local upTokens = {
    "local function",
    "do",
    "while",
    "for",
    "if",
    "repeat"
}

local downTokens = {
    "end",
    "until",
}

local localDownTokens = {
    "else",
    "elseif",
}

local function isToken(str, token)
    if str:sub(1, #token) == token then
        return true
    elseif str:sub(#str - (#token - 1), #str) == token then
        return true
    end
end

function syntax_format(code, yieldActive)
    local tab = "    "
    local tabLevel = 0
    local newCode = {}
    local _strSplit
    if yieldActive then
        _strSplit = strSplit
    else
        _strSplit = strSplitNoYield
    end
    for _, str in ipairs(_strSplit(string, code, {"\n"})) do
        if #newCode > 0 then
            table.insert(newCode, "\n")
        end

        local newStr = {}
        local chrAdded = false
        for i = 1, #str do
            local char = str:sub(i, i)
            if (char ~= " " and char ~= "\t") or chrAdded then
                chrAdded = true
                table.insert(newStr, char)
            end
        end
        for i = 1, #newStr do
            if newStr[#newStr] == " " or newStr[#newStr] == "\t" then
                table.remove(newStr, #newStr)
            end
        end
        newStr = table.concat(newStr)
        if newStr:sub(1, 2) ~= "--" then
            local returnLevel = false
            local findedDownToken = false
            if tabLevel > 0 then
                for i, token in ipairs(localDownTokens) do
                    if isToken(newStr, token) then
                        tabLevel = tabLevel - 1
                        returnLevel = true
                        findedDownToken = true
                        break
                    end
                end

                if not returnLevel then
                    for i, token in ipairs(downTokens) do
                        if isToken(newStr, token) then
                            tabLevel = tabLevel - 1
                            findedDownToken = true
                            break
                        end
                    end
                end
            end

            local findedUpToken = false
            for i, token in ipairs(upTokens) do
                if isToken(newStr, token) then
                    findedUpToken = true
                    break
                end
            end

            if not findedUpToken then
                for i, token in ipairs(upFindTokens) do
                    if newStr:find(token) then
                        findedUpToken = true
                        break
                    end
                end
            end

            if findedDownToken and findedUpToken then
                tabLevel = tabLevel + 1
                findedUpToken = false
            end

            if tabLevel > 0 then
                table.insert(newCode, string.rep(tab, tabLevel))
            end

            if returnLevel or findedUpToken then
                tabLevel = tabLevel + 1
            end
        elseif tabLevel > 0 then
            table.insert(newCode, string.rep(tab, tabLevel))
        end
        table.insert(newCode, newStr)
    end
    return table.concat(newCode)
end
end
function scmframework_dcdea34430ca01e3dc0c002bcdf53a3f() --$CONTENT_DATA/Scripts/synthesizer.lua
dofile("$CONTENT_DATA/Scripts/Config.lua")
synthesizer = class()
synthesizer.maxParentCount = 1
synthesizer.maxChildCount = 0
synthesizer.connectionInput = sm.interactable.connectionType.composite
synthesizer.colorNormal = sm.color.new(   0x006e93ff)
synthesizer.colorHighlight = sm.color.new(0x00beffff)
synthesizer.poseWeightCount = 1
synthesizer.componentType = "synthesizer"
synthesizer.minBetterAPI = 44

local _, defaultSamplesList = pcall(sm.json.open, "$CONTENT_DATA/ROM/defaultSamples/list.json")
if type(defaultSamplesList) ~= "table" then
    defaultSamplesList = {}
end
sc.changePrefixesInList(defaultSamplesList)

local maxBeeps = 32
local maxLoops = 32
local maxSamples = 32

local loopsList = {"chapter2_alarm", "elevator_music", "GasEngine - Scrap"}
for i = 1, 5 do
    table.insert(loopsList, "ElectricEngine - Level " .. i)
    table.insert(loopsList, "GasEngine - Level " .. i)
end

local function checkNum(num)
    if num < 1 or num > maxLoops or num % 1 ~= 0 then
        error("invalid cycle number", 3)
    end
end

local function checkSampleNum(num)
    if num < 1 or num > maxSamples or num % 1 ~= 0 then
        error("invalid samples number", 3)
    end
end

--[[
local function formatParams(data)
    local tbl = {}
    tbl.load = data.load
    tbl.rpm = data.rpm
    tbl.gas = data.gas
    if type(tbl.load) ~= "number" then tbl.load = nil end
    if type(tbl.rpm) ~= "number" then tbl.rpm = nil end
    if type(tbl.gas) ~= "number" then tbl.gas = nil end
    return tbl
end
]]

local function tableInsert(tbl, dat)
    for i = 1, math.huge do
        if not tbl[i] then
            tbl[i] = dat
            return i
        end
    end
end

local function soundId()
    return math.random(-2147483648, 2147483647)
end

function synthesizer:server_onCreate()
    self.loopData = {}
    self.flushLoops = true

    local api
    api = {
        -- new sound api
        hornBeep = function(pitch, duration)
            checkArg(1, pitch, "number")
            checkArg(2, duration, "number", "nil")

            if pitch < 0 then pitch = 0 end
            if pitch > 1 then pitch = 1 end

            if duration then
                if duration < 0 then duration = 0 end
                duration = math.floor(duration)
            end

            if not self.newBeeps then self.newBeeps = {} end
            local id = soundId()
            if #self.newBeeps < maxBeeps then
                table.insert(self.newBeeps, {0, id, 0, pitch, duration})
            end
            return id
        end,
        ballBeep = function(velocity, duration)
            checkArg(1, velocity, "number")
            checkArg(2, duration, "number", "nil")

            if duration then
                if duration < 0 then duration = 0 end
                duration = math.floor(duration)
            end

            if not self.newBeeps then self.newBeeps = {} end
            local id = soundId()
            if #self.newBeeps < maxBeeps then
                table.insert(self.newBeeps, {0, id, 10, velocity, duration})
            end
            return id
        end,
        toteBeep = function(device, note, duration)
            checkArg(1, device, "number")
            checkArg(2, note, "number")
            checkArg(3, duration, "number", "nil")

            if note < 0 then note = 0 end
            if note > 24 then note = 24 end

            if duration then
                if duration < 0 then duration = 0 end
                duration = math.floor(duration)
            end

            if not self.newBeeps then self.newBeeps = {} end
            local id = soundId()
            if #self.newBeeps < maxBeeps then
                local pitch
                if device == 10 then
                    pitch = (note + 1) * 2
                else
                    pitch = note / 24
                end
                table.insert(self.newBeeps, {0, id, device, pitch, duration})
            end
            return id
        end,
        sampleBeep = function(sample, volume, speed, pitch, rate, startpos, endpos)
            checkArg(1, sample, "number")
            checkArg(2, volume, "number", "nil")
            checkArg(3, speed, "number", "nil")
            checkArg(4, pitch, "number", "nil")
            checkArg(5, rate, "number", "nil")
            checkArg(6, startpos, "number", "nil")
            checkArg(7, endpos, "number", "nil")

            if not self.newBeeps then self.newBeeps = {} end
            local id = soundId()
            if #self.newBeeps < maxBeeps then
                table.insert(self.newBeeps, {1, id, sample, volume or 1, speed or 1, pitch or 0, rate or 1, startpos or 0, endpos or math.huge})
            end
            return id
        end,
        alarmBeep = function(index)
            checkArg(1, index, "number")

            if not self.newBeeps then self.newBeeps = {} end
            local id = soundId()
            if #self.newBeeps < maxBeeps then
                table.insert(self.newBeeps, {2, id, index})
            end
            return id
        end,
        waveBeep = function(wave, volume, freq, duration)
            checkArg(1, wave, "number", "nil")
            checkArg(2, volume, "number", "nil")
            checkArg(3, freq, "number", "nil")
            checkArg(4, duration, "number", "nil")

            if not self.newBeeps then self.newBeeps = {} end
            local id = soundId()
            if #self.newBeeps < maxBeeps then
                table.insert(self.newBeeps, {3, id, wave or 0, volume or 1, freq or 1000, duration or math.huge})
            end
            return id
        end,
        stopBeep = function(id)
            checkArg(1, id, "number")

            if not self.newBeepsStop then self.newBeepsStop = {} end
            self.newBeepsStop[id] = true
        end,

        -- sound api
        clear = function ()
            self.beeps = nil
        end,
        flush = function ()
            self.flushFlag = true
        end,
        flushWithStop = function ()
            if not self.beeps then self.beeps = {} end
            self.flushFlag = true
            self.stopOther = true
        end,
        flushWithBind = function()
            if not self.beeps then self.beeps = {} end
            self.flushFlag = true
            self.bindOther = true
        end,
        delBeep = function (index)
            if self.beeps then
                self.beeps[index] = nil
            end
        end,
        addBeep = function (device, pitch, volume, duration)
            checkArg(1, device, "number", "nil")
            checkArg(2, pitch, "number", "nil")
            checkArg(3, volume, "number", "nil")
            checkArg(4, duration, "number", "nil")

            if not self.beeps then self.beeps = {} end
            if #self.beeps < maxBeeps then
                return tableInsert(self.beeps, {
                    device,
                    pitch,
                    volume,
                    duration
                })
            end
        end,
        stop = function ()
            self.stopFlag = true
        end,

        -- loop api
        getMaxLoopsCount = function()
            return maxLoops
        end,
        getLoopsWhilelist = function()
            return sc.advDeepcopy(loopsList)
        end,
        startLoop = function(number, loopname, params)
            checkArg(1, number, "number")
            checkArg(2, loopname, "string")
            checkArg(3, params, "table", "nil")
            checkNum(number)
            for i, v in ipairs(loopsList) do
                if v == loopname then
                    self.loopData[number] = {loopname, params}
                    self.flushLoops = true
                    return
                end
            end
            error("unknown loop effect", 2)
        end,
        stopLoop = function(number)
            checkArg(1, number, "number")
            checkNum(number)
            self.loopData[number] = nil
            self.flushLoops = true
        end,
        stopLoops = function()
            self.loopData = {}
            self.flushLoops = true
        end,
        setLoopParams = function(number, params)
            checkArg(1, number, "number")
            checkArg(2, params, "table")
            checkNum(number)
            if not self.loopData[number] then
                error("the loop effect number " .. math.floor(number) .. " is not running", 2)
            end
            self.loopData[number][2] = params
            if not self.flushParams then self.flushParams = {} end
            self.flushParams[number] = params
        end,

        -- sample api
        getMaxSamplesCount = function()
            return maxSamples
        end,
        getDefaultSamplesList = function()
            local list = {}
            for k, v in pairs(defaultSamplesList) do
                table.insert(list, k)
            end
            table.sort(list)
            return list
        end,
        stopSamples = function()
            self.stopAllSamples = true
        end,
        loadSampleFromTTS = function(slot, text)
            checkArg(1, slot, "number")
            checkArg(2, text, "string")
            checkSampleNum(slot)
            
            if not self.loadSamples then
                self.loadSamples = {}
            end

            self.loadSamples[slot] = {"tts", sm.game.getCurrentTick(), text}

            if self.samplesParams then
                self.samplesParams[slot] = nil
                self.sendSampleParams = true
            end
        end,
        loadSampleFromURL = function(slot, url)
            checkArg(1, slot, "number")
            checkArg(2, url, "string")
            checkSampleNum(slot)
            
            if not self.loadSamples then
                self.loadSamples = {}
            end

            self.loadSamples[slot] = {"url", sm.game.getCurrentTick(), url}

            if self.samplesParams then
                self.samplesParams[slot] = nil
                self.sendSampleParams = true
            end
        end,
        loadSampleFromBlueprint = function(slot, uuid, steamid, filename)
            checkArg(1, slot, "number")
            checkArg(2, uuid, "string")
            checkArg(3, steamid, "string", "nil")
            checkArg(4, filename, "string")

            if not self.loadSamples then
                self.loadSamples = {}
            end

            self.loadSamples[slot] = {"blueprint", sm.game.getCurrentTick(), uuid, steamid, filename}

            if self.samplesParams then
                self.samplesParams[slot] = nil
                self.sendSampleParams = true
            end
        end,
        loadSampleFromSComputers = function(slot, name)
            checkArg(1, slot, "number")
            checkArg(2, name, "string")

            if not self.loadSamples then
                self.loadSamples = {}
            end

            self.loadSamples[slot] = {"file", sm.game.getCurrentTick(), defaultSamplesList[name] or error("there is no sample with this name", 2)}

            if self.samplesParams then
                self.samplesParams[slot] = nil
                self.sendSampleParams = true
            end
        end,
        startSample = function(slot)
            checkArg(1, slot, "number")
            checkSampleNum(slot)

            if not self.samplesActions then
                self.samplesActions = {}
            end

            if not self.samplesActions[slot] then
                self.samplesActions[slot] = {}
            end

            table.insert(self.samplesActions[slot], 1)
        end,
        stopSample = function(slot)
            checkArg(1, slot, "number")
            checkSampleNum(slot)

            if not self.samplesActions then
                self.samplesActions = {}
            end

            if not self.samplesActions[slot] then
                self.samplesActions[slot] = {}
            end

            table.insert(self.samplesActions[slot], 2)
        end,
        pauseSample = function(slot)
            checkArg(1, slot, "number")
            checkSampleNum(slot)

            if not self.samplesActions then
                self.samplesActions = {}
            end

            if not self.samplesActions[slot] then
                self.samplesActions[slot] = {}
            end

            table.insert(self.samplesActions[slot], 3)
        end,
        loopSample = function(slot, state)
            checkArg(1, slot, "number")
            checkArg(2, state, "boolean")
            checkSampleNum(slot)

            if not self.samplesActions then
                self.samplesActions = {}
            end

            if not self.samplesActions[slot] then
                self.samplesActions[slot] = {}
            end

            table.insert(self.samplesActions[slot], state and 4 or 5)
        end,
        setSampleVolume = function(slot, volume)
            checkArg(1, slot, "number")
            checkArg(2, volume, "number")
            checkSampleNum(slot)

            if not self.samplesParams then
                self.samplesParams = {}
            end

            if not self.samplesParams[slot] then
                self.samplesParams[slot] = {}
            end

            if volume < 0 then volume = 0 end
            if volume > 3 then volume = 3 end
            self.samplesParams[slot].volume = volume
            self.sendSampleParams = true
        end,
        setSampleRate = function(slot, rate)
            checkArg(1, slot, "number")
            checkArg(2, rate, "number")
            checkSampleNum(slot)

            if not self.samplesParams then
                self.samplesParams = {}
            end

            if not self.samplesParams[slot] then
                self.samplesParams[slot] = {}
            end

            self.samplesParams[slot].rate = rate
            self.sendSampleParams = true
        end,
        setSamplePitch = function(slot, pitch)
            checkArg(1, slot, "number")
            checkArg(2, pitch, "number")
            checkSampleNum(slot)

            if not self.samplesParams then
                self.samplesParams = {}
            end

            if not self.samplesParams[slot] then
                self.samplesParams[slot] = {}
            end

            self.samplesParams[slot].pitch = pitch
            self.sendSampleParams = true
        end,
        setSampleSpeed = function(slot, speed)
            checkArg(1, slot, "number")
            checkArg(2, speed, "number")
            checkSampleNum(slot)

            if not self.samplesParams then
                self.samplesParams = {}
            end

            if not self.samplesParams[slot] then
                self.samplesParams[slot] = {}
            end

            self.samplesParams[slot].speed = speed
            self.sendSampleParams = true
        end
    }
    api.getLoopsCount = api.getMaxLoopsCount

    sc.synthesizerDatas[self.interactable.id] = api
end

function synthesizer:server_onDestroy()
    sc.synthesizerDatas[self.interactable.id] = nil
end

function synthesizer:server_onFixedUpdate()
    if self.stopFlag then
        self.network:sendToClients("cl_stop")
        self.stopFlag = nil
    end
    
    if self.flushFlag then
        if self.beeps then
            self.beeps.stopOther = self.stopOther
            self.beeps.bindOther = self.bindOther
            self.network:sendToClients("cl_upload", self.beeps)
        end

        self.flushFlag = nil
        self.stopOther = nil
        self.bindOther = nil
    end

    if self.flushLoops then
        self:sv_flushLoops()
        self.flushLoops = nil
    end

    if self.flushParams then
        self.network:sendToClients("cl_flushParams", self.flushParams)
        self.flushParams = nil
    end

    if self.loadSamples then
        self.network:sendToClients("cl_loadSamples", self.loadSamples)
        self.loadSamples = nil
    end

    if self.sendSampleParams then
        self.network:sendToClients("cl_samplesParams", self.samplesParams)
        self.sendSampleParams = nil
    end

    if self.samplesActions then
        self.network:sendToClients("cl_samplesActions", self.samplesActions)
        self.samplesActions = nil
    end

    if self.newBeeps then
        if self.newBeepsStop then
            for i = #self.newBeeps, 1, -1 do
                local newBeep = self.newBeeps[i]
                local id = newBeep[2]
                if self.newBeepsStop[id] then
                    table.remove(self.newBeeps, i)
                    self.newBeepsStop[id] = nil
                end
            end
        end

        self.network:sendToClients("cl_newBeeps", self.newBeeps)
        self.newBeeps = nil
    end

    if self.newBeepsStop then
        for _ in pairs(self.newBeepsStop) do --i only send it if the table is not empty
            self.network:sendToClients("cl_newBeepsStop", self.newBeepsStop)
            break
        end
        self.newBeepsStop = nil
    end

    if self.stopAllSamples then
        self.network:sendToClients("cl_stopAllSamples")
        self.stopAllSamples = nil
    end
end

function synthesizer:sv_flushLoops(_, caller)
    if caller then
        self.network:sendToClient(caller, "cl_flushLoops", self.loopData)
        if self.samplesParams then
            self.network:sendToClient(caller, "cl_samplesParams", self.samplesParams)
        end
    else
        self.network:sendToClients("cl_flushLoops", self.loopData)
        if self.samplesParams then
            self.network:sendToClients("cl_samplesParams", self.samplesParams)
        end
    end
end




function synthesizer:client_onCreate()
    self.effects = {}
    self.effectsCache = {}
    self.currentLoops = {}
    self.oldEffectsName = {}
    self.loadedSamples = {}
    self._loadedSamples = {}
    self.runnedSamplesInfo = {}
    self.runnedSamplesData = {}
    self.loopSamplesData = {}
    self.paramsSamplesData = {}
    self.newBeepsEffects = {}
    self.destroyDelay = {}
    if better and better.audio.createFromFile then
        self.defaultWaves = {
            better.audio.createFromFile(defaultSamplesList.wave_sine),
            better.audio.createFromFile(defaultSamplesList.wave_square),
            better.audio.createFromFile(defaultSamplesList.wave_sawtooth),
            better.audio.createFromFile(defaultSamplesList.wave_triangle)
        }
    else
        self.defaultWaves = {}
    end
    self.network:sendToServer("sv_flushLoops")
end

function synthesizer:cl_newBeepsStop(newBeepsStop)
    for i = #self.newBeepsEffects, 1, -1 do
        local effectData = self.newBeepsEffects[i]
        if not newBeepsStop or newBeepsStop[effectData.id] then
            if effectData.type == 0 then
                effectData.effect:stop()
                effectData.effect:destroy()
                table.remove(self.newBeepsEffects, i)
            elseif effectData.type == 1 then
                effectData.audio:destroy()
                table.remove(self.newBeepsEffects, i)
            end
        end
    end
end

function synthesizer:cl_newBeeps(newBeeps)
    for _, newBeep in ipairs(newBeeps) do
        if #self.newBeepsEffects >= maxBeeps then
            break
        end

        local effectData = {}
        local effectValid = false
        if newBeep[1] == 0 then
            effectData.type = 0
            effectData.timer = newBeep[5] or math.huge
            effectData.id = newBeep[2]

            if newBeep[3] == 0 then
                effectData.effect = sm.effect.createEffect("Horn - Honk", self.interactable)
            else
                effectData.effect = sm.effect.createEffect(sc.getSoundEffectName("tote" .. newBeep[3]), self.interactable)
            end

            effectData.effect:setParameter(newBeep[3] == 10 and "velocity_max_50" or "pitch", newBeep[4])
            effectData.effect:start()

            effectValid = true
        elseif newBeep[1] == 1 then
            effectData.type = 1
            effectData.id = newBeep[2]
            effectData.deadline = newBeep[9]

            local baseAudio = self.loadedSamples[newBeep[3]]
            if baseAudio and better and better.audio.fork then
                effectData.audio = baseAudio:fork()
                if effectData.audio then
                    effectData.audio:setVolume(newBeep[4])
                    effectData.audio:setPitch(newBeep[6])
                    effectData.audio:setSpeed(newBeep[5])
                    effectData.audio:setRate(newBeep[7])
                    if newBeep[8] ~= 0 then
                        effectData.audio:setPosition(newBeep[8])
                    end
                    self:cl_updateSpatialSound(effectData.audio)
                    effectData.audio:start()
                    effectValid = true
                end
            end
        elseif newBeep[1] == 2 then
            effectData.type = 0
            effectData.timer = math.huge
            effectData.id = newBeep[2]
            effectData.effect = sm.effect.createEffect("chapter2_alarm", self.interactable)
            effectData.effect:setParameter("alarm", newBeep[3])
            effectData.effect:start()
            effectValid = true
        elseif newBeep[1] == 3 then
            effectData.type = 1
            effectData.id = newBeep[2]
            effectData.timer = newBeep[6]
            effectData.volume = newBeep[4]

            local baseAudio = self.defaultWaves[newBeep[3] + 1]
            if baseAudio and better and better.audio.fork then
                effectData.audio = baseAudio:fork()
                if effectData.audio then
                    effectData.audio:setSpeed(newBeep[5] / 1000)
                    effectData.audio:setLoop(true)
                    self:cl_updateSpatialSound(effectData.audio)
                    effectData.audio:start()
                    effectValid = true
                end
            end
        end

        if effectValid then
            table.insert(self.newBeepsEffects, effectData)
        end
    end
end

function synthesizer:cl_loadSamples(loadSamples)
    if not better or better.version < synthesizer.minBetterAPI then
        return
    end
    
    for slot, loadAction in pairs(loadSamples) do
        if self._loadedSamples[slot] ~= loadAction[2] then
            self._loadedSamples[slot] = nil

            if self.loadedSamples[slot] then
                self.loadedSamples[slot]:destroy()
                self.loadedSamples[slot] = nil
            end

            self.paramsSamplesData[slot] = {}
            self.runnedSamplesInfo[slot] = nil
            self.runnedSamplesData[slot] = nil
            self.loopSamplesData[slot] = nil

            local ok, audioOrErr = false, nil
            if loadAction[1] == "url" then
                ok, audioOrErr = pcall(better.audio.createFromUrl, loadAction[3])
                if not ok then
                    print("error in better.audio.createFromFile (load from url): ", audioOrErr)
                end
            elseif loadAction[1] == "tts" then
                ok = true
                audioOrErr = better.tts.textToSpeech(loadAction[3])
            elseif loadAction[1] == "blueprint" then
                ok, audioOrErr = pcall(better.registrationBlueprint, loadAction[3], loadAction[4])
                if ok then
                    ok, audioOrErr = pcall(better.audio.createFromFile, "$CONTENT_" .. loadAction[3] .. "/" .. loadAction[5])
                    if not ok then
                        print("error in better.audio.createFromFile (load from blueprint): ", audioOrErr)
                    end
                else
                    print("error in better.registrationBlueprint: ", audioOrErr)
                end
            elseif loadAction[1] == "file" then
                ok, audioOrErr = pcall(better.audio.createFromFile, loadAction[3])
            end

            if ok then
                audioOrErr:update()
                self.loadedSamples[slot] = audioOrErr
                self._loadedSamples[slot] = loadAction[2]
            end
        end
    end
end

function synthesizer:cl_updateSpatialSound(audio)
    audio:updateSpatialSound(sm.camera.getPosition(), {{self.shape.worldPosition, 25}}, sm.camera.getDirection())
end

function synthesizer:cl_applySampleParameters(slot)
    if self.runnedSamplesData[slot] then
        local params = self.paramsSamplesData[slot]
        local audio = self.loadedSamples[slot]
        audio:setVolume(params.volume or 1)
        if better.audio.setSpeed then
            audio:setSpeed(params.speed or 1)
        end
        if better.audio.setRate then
            audio:setRate(params.rate or 1)
        end
        if better.audio.setPitch then
            audio:setPitch(params.pitch or 0)
        end
        self:cl_updateSpatialSound(audio)
        audio:update()
    end
end

function synthesizer:cl_samplesActions(samplesActions)
    for slot, actions in pairs(samplesActions) do
        local audio = self.loadedSamples[slot]
        if audio then
            for _, action in ipairs(actions) do
                if action == 1 then
                    self.runnedSamplesInfo[slot] = 80
                    self.runnedSamplesData[slot] = true
                    self:cl_applySampleParameters(slot)
                    audio:start()
                elseif action == 2 then
                    audio:stop()
                    self.runnedSamplesInfo[slot] = nil
                    self.runnedSamplesData[slot] = false
                elseif action == 3 then
                    audio:pause()
                    self.runnedSamplesInfo[slot] = nil
                    self.runnedSamplesData[slot] = false
                elseif action == 4 then
                    audio:setLoop(true)
                    self.loopSamplesData[slot] = true
                elseif action == 5 then
                    audio:setLoop(false)
                    self.loopSamplesData[slot] = false
                end
            end
        end
    end
end

function synthesizer:cl_samplesParams(samplesParams)
    for slot, params in pairs(samplesParams) do
        for k, v in pairs(params) do
            if not self.paramsSamplesData[slot] then
                self.paramsSamplesData[slot] = {}
            end
            self.paramsSamplesData[slot][k] = v 
        end
    end
end

function synthesizer:cl_stopAllSamples()
    for slot = 1, maxSamples do
        local audio = self.loadedSamples[slot]
        if audio then
            audio:stop()
            self.runnedSamplesInfo[slot] = nil
            self.runnedSamplesData[slot] = false
        end
    end
end

function synthesizer:client_onDestroy()
    for _, data in ipairs(self.effects) do
        for i, v in ipairs(data.effects) do
            v:stop()
            v:destroy()
        end
    end

    self:cl_newBeepsStop()

    for _, effect in pairs(self.currentLoops) do
        effect:destroy()
    end

    for _, audio in pairs(self.loadedSamples) do
        audio:destroy()
    end
end

function synthesizer:cl_flushParams(data)
    for i, ldat in pairs(data) do
        if self.currentLoops[i] then
            for k, v in pairs(ldat) do
                self.currentLoops[i]:setParameter(k, v)
            end
        end
    end
end

function synthesizer:cl_flushLoops(data)
    local alt = {}
    for i, effect in pairs(self.currentLoops) do
        if not data[i] or self.oldEffectsName[i] ~= data[i][1] then
            effect:destroy()
            self.currentLoops[i] = nil
            self.oldEffectsName[i] = nil
        else
            alt[i] = effect
        end
    end

    for i, ldat in pairs(data) do
        local effect = alt[i] or sm.effect.createEffect(ldat[1], self.interactable)
        for k, v in pairs(ldat[2] or {}) do
            effect:setParameter(k, v)
        end
        if effect:isDone() then
            effect:setAutoPlay(true)
            effect:start()
        end
        self.currentLoops[i] = effect
        self.oldEffectsName[i] = ldat[1]
    end
end

function synthesizer:client_onFixedUpdate()
    if better then
        better.tick()
    end

    local num = (#self.effects > 0 or #self.newBeepsEffects > 0) and 1 or 0
    if num == 0 then
        for _, effect in pairs(self.currentLoops) do
            num = 1
            break
        end
    end

    for k, v in pairs(self.runnedSamplesInfo) do
        num = 1
        self.runnedSamplesInfo[k] = self.runnedSamplesInfo[k] - 1
        if self.runnedSamplesInfo[k] <= 0 then
            self.runnedSamplesInfo[k] = nil
        end
    end

    if num == 0 and better and better.audio and better.audio.getState then
        for _, audio in pairs(self.loadedSamples) do
            local playState = audio:getState()
            if playState == 1 or playState == 3 then
                num = 1
            end
        end
    end

    --[[
    if num == 0 then
        for k, v in pairs(self.loopSamplesData) do
            if v then
                num = 1
                break
            end
        end
    end
    ]]

    local ctick = sm.game.getCurrentTick()
    for audio, deadline in pairs(self.destroyDelay) do
        if ctick > deadline then
            audio:destroy()
            self.destroyDelay[audio]= nil 
        end
    end

    for i = #self.newBeepsEffects, 1, -1 do
        num = 1
        local effectData = self.newBeepsEffects[i]
        if effectData.type == 0 then
            effectData.timer = effectData.timer - 1
            if effectData.timer < 0 or not effectData.effect:isPlaying() then
                effectData.effect:stop()
                effectData.effect:destroy()
                table.remove(self.newBeepsEffects, i)
            end
        elseif effectData.type == 1 then
            local playState = effectData.audio:getState()
            if (effectData.deadline and effectData.audio:getPosition() >= effectData.deadline) or (playState ~= 1 and playState ~= 3) then
                effectData.audio:destroy()
                table.remove(self.newBeepsEffects, i)
            else
                self:cl_updateSpatialSound(effectData.audio)
                if effectData.volume then
                    effectData.audio:setVolume(effectData.volume)
                    effectData.audio:update()
                end
                if effectData.timer then
                    effectData.timer = effectData.timer - 1
                    if effectData.timer < 0 then
                        effectData.audio:setVolume(0)
                        self.destroyDelay[effectData.audio] = ctick + 5
                        table.remove(self.newBeepsEffects, i)
                    end
                end
            end
        end
    end

    if better and better.audio then
        for slot in pairs(self.loadedSamples) do
            self:cl_applySampleParameters(slot)
        end
    end

    for i = #self.effects, 1, -1 do
        local data = self.effects[i]
        if data[4] then
            if data[4] <= 0 then
                for i, v in ipairs(data.effects) do
                    if sm.exists(v) then
                        v:stop()
                        table.insert(self.effectsCache[data[1]], v)
                    end
                end
                table.remove(self.effects, i)
            end
            data[4] = data[4] - 1
        elseif not data.effects[1]:isPlaying() then
            for i, v in ipairs(data.effects) do
                if sm.exists(v) then
                    v:stop()
                    table.insert(self.effectsCache[data[1]], v)
                end
            end
            table.remove(self.effects, i)
        end
    end

    if not self.pose then self.pose = 0 end
    self.pose = self.pose + ((num - self.pose) * 0.3)
    self.interactable:setPoseWeight(0, sm.util.clamp(self.pose, 0.01, 0.7))
end

function synthesizer:cl_stop()
    for _, data in ipairs(self.effects) do
        for i, v in ipairs(data.effects) do
            v:stop()
            table.insert(self.effectsCache[data[1]], v)
        end
    end
    self.effects = {}

    self:cl_newBeepsStop()
end

function synthesizer:cl_upload(datas)
    local stopList = {}

    if datas.stopOther then
        for _, data in ipairs(self.effects) do
            for i, v in ipairs(data.effects) do
                stopList[v.id] = v
                table.insert(self.effectsCache[data[1]], v)
            end
        end
        self.effects = {}
    elseif datas.bindOther then
        for _, data in pairs(datas) do
            if type(data) == "table" then
                for i = #self.effects, 1, -1 do
                    local data2 = self.effects[i]
                    if data2[1] == data[1] then
                        for i, v in ipairs(data2.effects) do
                            stopList[v.id] = v
                            table.insert(self.effectsCache[data2[1]], v)
                        end
                        table.remove(self.effects, i)
                    end
                end
            end
        end
    end

    for _, data in pairs(datas) do
        if type(data) == "table" then
            data[1] = data[1] or 0

            if not self.effectsCache[data[1]] then
                self.effectsCache[data[1]] = {}
            end

            if not data.effects then
                data.effects = {}
            end

            for i = 1, math.floor(sm.util.clamp((data[3] or 0.1) * 10, 0, 10) + 0.5) do
                local effect
                if self.effectsCache[data[1]] and #self.effectsCache[data[1]] > 0 then
                    effect = table.remove(self.effectsCache[data[1]])
                else
                    if data[1] == 0 then
                        effect = sm.effect.createEffect("Horn - Honk", self.interactable)
                    else
                        effect = sm.effect.createEffect(sc.getSoundEffectName("tote" .. data[1]), self.interactable)
                    end
                end
                
                if effect then
                    effect:setParameter("pitch", data[2] or 0.5)
                    if not effect:isPlaying() then
                        effect:start()
                    end
                    
                    stopList[effect.id] = nil
                    table.insert(data.effects, effect)
                end
            end

            table.insert(self.effects, data)
        end
    end

    for id, effect in pairs(stopList) do
        effect:stop()
    end
end
end
function scmframework_c6c764601bf2db86150896cf89aeb825() --$CONTENT_DATA/Scripts/terminal.lua
terminal = class()
terminal.maxParentCount = -1
terminal.maxChildCount = 0
terminal.connectionInput = sm.interactable.connectionType.composite + sm.interactable.connectionType.seated
terminal.connectionOutput = sm.interactable.connectionType.none
terminal.colorNormal = sm.color.new(0x7F7F7Fff)
terminal.colorHighlight = sm.color.new(0xFFFFFFff)
terminal.componentType = "terminal" --absences can cause problems
terminal.outputLimit = 1024 * 64

function terminal:server_onCreate()
    self.syntax = false

    self.interactable.publicData = {
        sc_component = {
            type = terminal.componentType,
            api = {
                read = function()
                    local text = self.ctext
                    self.ctext = nil
                    return text
                end,
                clear = function ()
                    self.writes = nil
                    self.clear = true
                end,
                write = function (str)
                    if not self.writes then self.writes = {} end
                    table.insert(self.writes, "#ffffff" .. tostring(str))
                end,
                setSyntax = function(syntax)
                    checkArg(1, syntax, "boolean")
                    self.syntax = syntax
                    self.flushSyntaxEnable = true
                end,
                isSyntax = function()
                    return self.syntax
                end
            }
        }
    }
end

function terminal:server_onFixedUpdate()
	if sc.needScreenSend() then self.allow_update = true end

    if self.allow_update and (self.clear or self.writes) then
        if self.clear then
            self.network:sendToClients("cl_clr")
            self.clear = nil
        end

        if self.writes then
            self.network:sendToClients("cl_log", self.writes)
            self.writes = nil
        end

        self.allow_update = nil
    end

    if self.flushSyntaxEnable then
        self.network:sendToClients("cl_setSyntaxEnable", self.syntax)
        self.flushSyntaxEnable = nil
    end
end

function terminal:sv_text(text)
    self.ctext = text
end

-------------------------------------------

function terminal:client_onCreate()
    self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/terminal.layout", false)
    self.gui:setButtonCallback("send", "cl_send")
    self.gui:setButtonCallback("up", "cl_up")
    self.gui:setButtonCallback("down", "cl_down")
    self.gui:setTextAcceptedCallback("text", "cl_send")
    self.gui:setTextChangedCallback("text", "cl_edit")

    self.lastdata = ""
    self.cltext = ""
    self.log = ""
    self.history = {}
end

function terminal:client_onFixedUpdate()
    if self.cl_syntax then
        if localStorage.current.palette ~= self.palette then
            self.needUpdateSyntax = true
            self.palette = localStorage.current.palette
        end
    end

    if better and better.isAvailable() then
        local upButton = better.keyboard.isKey(better.keyboard.keys.arrow_u)
        local downButton = better.keyboard.isKey(better.keyboard.keys.arrow_d)

        if upButton and not self.upButton then
            self.upDelay = 5 --why is there a delay? Otherwise, the cursor would sometimes end up at the beginning of the line instead of the end
            self.downDelay = nil
        end

        if downButton and not self.downButton then
            self.upDelay = nil
            self.downDelay = 5
        end

        self.upButton = upButton
        self.downButton = downButton

        if self.upDelay then
            self.upDelay = self.upDelay - 1
            if self.upDelay <= 0 then
                self:cl_up()
                self.upDelay = nil
            end
        end

        if self.downDelay then
            self.downDelay = self.downDelay - 1
            if self.downDelay <= 0 then
                self:cl_down()
                self.downDelay = nil
            end
        end
    end
end

function terminal:client_onInteract(_, state)
    if state then
        if self.needUpdateSyntax then
            self.gui:setText("text", syntax_make(formatBeforeGui(self.cltext)))
            self.needUpdateSyntax = nil
        end
        self.palette = localStorage.current.palette
        self.gui:open()
    end
end

function terminal:cl_setSyntaxEnable(syntax)
    self.cl_syntax = syntax
end

function terminal:cl_edit(_, text)
    self.cltext = formatAfterGui(text)
    self.actualText = self.cltext
    self.historyIndex = nil

    if self.cl_syntax then
        if (#self.cltext > #self.lastdata and self.cltext:sub(1, #self.lastdata) == self.lastdata) or
        (#self.cltext < #self.lastdata and self.lastdata:sub(1, #self.cltext) == self.cltext) then
            self.gui:setText("text", syntax_make(formatBeforeGui(self.cltext)))
            self.needUpdateSyntax = nil
        else
            self.needUpdateSyntax = true
        end
    end
    self.lastdata = self.cltext
end

function terminal:cl_log(log)
    for index, text in ipairs(log) do
        local beepFind = text:find("%" .. string.char(7))
        if beepFind then
            sm.audio.play("Horn", self.shape.worldPosition)
            text = text:sub(1, beepFind - 1) .. text:sub(beepFind + 1, #text)
        end
        self.log = self.log .. text
    end
    self.log = self.log:sub(math.max(1, #self.log - terminal.outputLimit), #self.log)
    self.gui:setText("log", self.log)
end

function terminal:cl_clr()
    self.log = ""
    self.gui:setText("log", self.log)
end

function terminal:cl_send()
    self.gui:setText("text", "")
    if self.history[#self.history] ~= self.cltext and self.cltext ~= "" then
        table.insert(self.history, self.cltext)
    end
    self.network:sendToServer("sv_text", self.cltext)
    self.cltext = ""
    self.actualText = nil
    self.historyIndex = nil
end

function terminal:cl_up()
    if self.historyIndex then
        self.historyIndex = self.historyIndex - 1
        if self.historyIndex < 1 then
            self.historyIndex = 1
        end
    else
        self.historyIndex = #self.history
        if self.historyIndex == 0 then
            self.historyIndex = nil
            return
        end
    end
    self.cltext = self.history[self.historyIndex]
    self:cl_updText()
end

function terminal:cl_down()
    if self.historyIndex then
        self.historyIndex = self.historyIndex + 1
        if self.historyIndex > #self.history then
            self.historyIndex = nil
            self.cltext = self.actualText or ""
        else
            self.cltext = self.history[self.historyIndex]
        end
        self:cl_updText()
    end
end

function terminal:cl_updText()
    self.lastdata = self.cltext
    if self.cl_syntax then
        self.gui:setText("text", syntax_make(formatBeforeGui(self.cltext)))
    else
        self.gui:setText("text", formatBeforeGui(self.cltext))
    end
end
end
function scmframework_03b4a6a7f568bad6e67fc466898bb9c0() --$CONTENT_DATA/Scripts/Tools/PermissionTool.lua
dofile "$CONTENT_DATA/Scripts/Config.lua"

PermissionTool = class(nil)

function PermissionTool.isHost()
    return sm.localPlayer.getPlayer():getId() == 1
end

function PermissionTool.server_deleteOther(self)
    --я адаптировал код под несколько тулов одновременно
    --[[
    local survival = self.data and self.data.survival
    if not survival then
        local uuid = self.shape.uuid
        local id = self.shape:getId()
        
        for i, body in ipairs(sm.body.getAllBodies()) do
            for i2, shape in ipairs(body:getShapes()) do
                if shape.uuid == uuid and shape:getId() ~= id then
                    shape:destroyShape()
                end
            end
        end
    end
    ]]
end

function PermissionTool.server_onCreate(self)
    sc.init()
    self:server_deleteOther()
end

function PermissionTool.server_onNewSettings(self, data, client)
    local settings = data[1]
    local ssettings = self:server_getSettings()

    if _G.disablePermissionTool then
        return
    end
    if ssettings.adminOnly then
        if client:getId() ~= 1 then
            return
        end
    end
    for k, v in pairs(settings) do
        ssettings[k] = v
    end

    _G.computersAllow = data[2].enable
    sc.saveRestrictions()

    self.network:sendToClients("client_onNewSettings", self:server_getSettingsPack())
end

function PermissionTool.server_onSettingsRequired(self, data, client)
    self.network:sendToClient(client, "client_onNewSettings", self:server_getSettingsPack())
end

function PermissionTool.server_getSettingsPack(self)
    return {sc.restrictions, {enable = not not _G.computersAllow}}
end

function PermissionTool.server_getSettings(self)
    return sc.restrictions
end

function PermissionTool:server_onFixedUpdate()
    if sc.restrictionsUpdated or _G.updateToolSettings then
        self.network:sendToClients("client_onNewSettings", self:server_getSettingsPack())
        _G.updateToolSettings = nil
    end
end

function PermissionTool:server_onDestroy()
end

function PermissionTool:sv_rebootAll()
    sc.rebootAll = true
end

--------------------------------------------------------------

function PermissionTool.client_onCreate(self)
    if self.tool and not self.tool:isLocal() then return end

    self.network:sendToServer("server_onSettingsRequired")
    self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/PermissionTool.layout", false)
    self.gui:setButtonCallback("ScriptModeButton", "client_onScriptModeButtonPressed")
    self.gui:setButtonCallback("AdminOnlyButton", "client_onAdminOnlyButtonPressed")
    self.gui:setButtonCallback("lua", "client_onLuaVmPress")
    self.gui:setButtonCallback("messages", "client_onChatPress")
    self.gui:setButtonCallback("rend", "client_onRendPress")
    self.gui:setButtonCallback("opt", "client_onOptPress")
    self.gui:setButtonCallback("optSpeed", "client_onOptSPress")
    self.gui:setButtonCallback("rays", "client_onRaysPress")
    self.gui:setButtonCallback("rst", "client_onRstPress")
    self.gui:setButtonCallback("CE", "client_onComputersEnabled")
    self.gui:setButtonCallback("cpu", "client_onCpuPress")
    self.gui:setButtonCallback("allowDist", "client_onAllowDist")
    self.gui:setButtonCallback("srv", "client_onSrvPress")
    self.gui:setButtonCallback("unrestrictedSettings", "client_onUnrestrictedSettingsPress")
    self.gui:setButtonCallback("saving", "client_onSavingPress")
    self.gui:setButtonCallback("maxDisplays", "client_onMaxDisplaysPress")
    self.gui:setButtonCallback("disCompCheck", "client_onDisCompCheckPress")
    self.gui:setButtonCallback("ibridge", "client_onIbridgePress")
    self.gui:setButtonCallback("adrop", "client_onAdropPress")
    self.gui:setButtonCallback("acreative", "client_onACreativePress")
    self.gui:setButtonCallback("disableCallLimit", "client_disableCallLimit")
    self.gui:setButtonCallback("lagDetector", "client_lagDetector")
    self.gui:setButtonCallback("screenRate", "client_screenRate")
    self.gui:setButtonCallback("hostrender", "client_hostrender")
    self.gui:setButtonCallback("resourceConsumption", "client_resourceConsumption")
    self.gui:setButtonCallback("disableSplash", "client_disableSplash")
    self.gui:setVisible("admin", false)
    --self.gui:setButtonCallback("DisplaysAtLagsButton", "client_onDisplayAtLagsButtonPressed")

    self.gui:setButtonCallback("ApplyButton", "client_onApplyButtonPressed")

    _G.serverTempSettings = {}
    _G.serverSettings = sc.deepcopy(sc.defaultRestrictions)

    self.currentSettings = sc.deepcopy(_G.serverSettings)
    self.tempSettings = sc.deepcopy(_G.serverTempSettings)
end

function PermissionTool.client_onDestroy(self)
    if not self.gui then return end
    self.gui:close()
    self.gui:destroy()
    self.gui = nil
end

function PermissionTool.client_onInteract(self, char, state)
    if _G.disablePermissionTool then
        return
    end

    if state then
        self.rebootAll_cl_flag = nil
        self:cl_guiOpen()
    end
end

function PermissionTool:client_canInteract(character)
    if _G.disablePermissionTool then
        sm.gui.setInteractionText("", "#ff0000Permission Tool was disabled by the administrator", "")
        sm.gui.setInteractionText("", "", "")
        return false
    end

    return true
end

function PermissionTool.client_onNewSettings(self, data)
    local settings = data[1]
    _G.serverTempSettings = data[2]

    if settings.optSpeed then
        settings.optSpeed = round(settings.optSpeed, 1)
    end
    _G.serverSettings = settings
end

function PermissionTool.cl_guiOpen(self)
    self.tempSettings = sc.deepcopy(_G.serverTempSettings)
    self.currentSettings = sc.deepcopy(_G.serverSettings)
    self:cl_guiUpdateButtons()
    self.gui:open()
end

function PermissionTool:client_onFixedUpdate()
    if self.tool and not self.tool:isLocal() then return end

    self:cl_guiUpdateButtons()

    --print(sm.player.getAllPlayers()[1].character.direction)
end

local scriptModeTitles = {
    ["safe"] = "safe",
    ["safe_with_open"] = "safe (with sm.json.open)",
    ["unsafe"] = "unsafe"
}

function PermissionTool.cl_guiUpdateButtons(self)
    self.gui:setText("ScriptModeButton", "Script Mode: " .. (scriptModeTitles[self.currentSettings.scriptMode] or self.currentSettings.scriptMode))
    self.gui:setText("AdminOnlyButton", "Admin Only(Changes To Settings): " .. (self.currentSettings.adminOnly and "true" or "false") )
    self.gui:setText("messages", "Allow Chat/Alert/Debug Messages: " .. tostring(self.currentSettings.allowChat or false))
    self.gui:setText("rend", "Display Render Distance: " .. tostring(self.currentSettings.rend))
    self.gui:setText("optSpeed", "Optimize On Distance Speed: " .. tostring(self.currentSettings.optSpeed or "disable"))
    self.gui:setText("rays", "Raycast Render Check: " .. tostring(self.currentSettings.rays == 0 and "disable" or self.currentSettings.rays))
    self.gui:setText("CE", "Computers Enabled in This Session: " .. tostring(self.tempSettings.enable))
    self.gui:setText("allowDist", "Allow Render At Distance: " .. tostring(self.currentSettings.allowDist))
    self.gui:setText("saving", "Saving Content Once Per: " .. (self.currentSettings.saving == 0 and "immediately" or tostring(self.currentSettings.saving) .. "-tick"))
    self.gui:setText("maxDisplays", "Max Display Resolution: " .. tostring(self.currentSettings.maxDisplays))
    self.gui:setText("disCompCheck", "Disable Connect Check: " .. tostring(self.currentSettings.disCompCheck))
    self.gui:setText("ibridge", "Allow Internet-Bridge: " .. tostring(self.currentSettings.ibridge))
    self.gui:setText("adrop", "Drop Freq At Lags: " .. tostring(self.currentSettings.adrop))
    self.gui:setText("acreative", "Allow Creative-Components: " .. tostring(self.currentSettings.acreative))
    self.gui:setText("disableCallLimit", "Disable Call Limit: " .. tostring(self.currentSettings.disableCallLimit))
    self.gui:setText("resourceConsumption", "Resource Consumption: " .. tostring(self.currentSettings.resourceConsumption))
    self.gui:setText("disableSplash", "Disable Splash: " .. tostring(self.currentSettings.disableSplash) .. (self.currentSettings.disableSplash and " (dangerous)" or ""))

    if type(self.currentSettings.lagDetector) == "number" then
        self.gui:setText("lagDetector", "Anti-Lag: " .. tostring(round(self.currentSettings.lagDetector, 3)))
    else
        self.gui:setText("lagDetector", "Anti-Lag: false")
    end
    if self.currentSettings.screenRate == -1 then
        self.gui:setText("screenRate", "Screen Rate: auto")
    elseif self.currentSettings.screenRate == -2 then
        self.gui:setText("screenRate", "Screen Rate: auto (slow)")
    elseif self.currentSettings.screenRate == 1 then
        self.gui:setText("screenRate", "Screen Rate: full")
    elseif self.currentSettings.screenRate == 2 then
        self.gui:setText("screenRate", "Screen Rate: half")
    elseif self.currentSettings.screenRate == 4 then
        self.gui:setText("screenRate", "Screen Rate: quatre")
    elseif self.currentSettings.screenRate == 8 then
        self.gui:setText("screenRate", "Screen Rate: eighth")
    elseif self.currentSettings.screenRate == 40 then
        self.gui:setText("screenRate", "Screen Rate: static")
    else
        self.gui:setText("screenRate", "Screen Rate: " .. tostring(self.currentSettings.screenRate))
    end
    self.gui:setText("hostrender", "Rendering Displays On Host: " .. tostring(self.currentSettings.hostrender))
    
    if self.currentSettings.vm == "luaInLua" then
        self.gui:setText("lua", "LuaVM: LuaInLua (remade)")
    else
        self.gui:setText("lua", "LuaVM: " .. self.currentSettings.vm)
    end


    local onetick = 1 / 40
    local cputimename = "unknown"
    local altTitle
    local cpu = self.currentSettings.cpu
    cpu = round(cpu, 5)
    if cpu == onetick / 2 then
        cputimename = "half tick"
    elseif cpu == -1 then
        altTitle = "unlimited (dangerous)"
    else
        cputimename = tostring(math.floor((cpu * 40) + 0.5)) .. " tick"
    end
    if altTitle then
        self.gui:setText("cpu", "Maximum CPU Time: " .. altTitle)
    else
        self.gui:setText("cpu", "Maximum CPU Time: " .. tostring(cpu) .. " (" .. cputimename .. ")")
    end
    --self.gui:setText("DisplaysAtLagsButton", "DisplaysAtLags: " .. (self.currentSettings.displaysAtLagsMode == "draw" and "Draw" or "Skip"))

    
    
    local survival = self.data and self.data.survival
    self.gui:setVisible("ScriptModeButton", not survival or self.currentSettings.scriptMode ~= "safe")
    --self.gui:setVisible("messages", not survival or self.currentSettings.allowChat)
    self.gui:setVisible("disCompCheck", not survival or self.currentSettings.disCompCheck)
    self.gui:setVisible("AdminOnlyButton", not survival or not self.currentSettings.adminOnly)
    self.gui:setVisible("acreative", not survival or self.currentSettings.acreative)
    self.gui:setVisible("disableCallLimit", not survival or self.currentSettings.disableCallLimit)
    self.gui:setVisible("resourceConsumption", not survival or not self.currentSettings.resourceConsumption)
    self.gui:setVisible("unrestrictedSettings", not survival)

    if not self:client_canChangeSettings() then
        self.gui:setVisible("ApplyButton", false)
    elseif self.currentSettings.vm == "fullLuaEnv" then
        self.gui:setVisible("ApplyButton", not not a)
    elseif self.currentSettings.vm == "hsandbox" then
        self.gui:setVisible("ApplyButton", not not _HENV)
    elseif self.currentSettings.vm == "luaVM" then
        self.gui:setVisible("ApplyButton", not not (vm and vm.lua52))
    elseif self.currentSettings.vm == "betterAPI" then
        self.gui:setVisible("ApplyButton", not not (better and better.loadstring))
    elseif self.currentSettings.vm == "dlm" then
        self.gui:setVisible("ApplyButton", not not (not better and dlm and dlm.loadstring))
    elseif self.currentSettings.vm == "advancedExecuter" then
        self.gui:setVisible("ApplyButton", not not sm.advancedExecuter)
    else
        self.gui:setVisible("ApplyButton", true)
    end
end

function PermissionTool.client_canChangeSettings(self)
    return not _G.serverSettings.adminOnly or PermissionTool.isHost()
end

function PermissionTool.client_cheatAllow(self)
    return not not _G.allowToggleCheat
end

------------------------- BUTTONS

local noCheatMessage = "#ff0000you can't enable cheats, enter into the chat to unlock: /cl_scomputers_cheat"

function PermissionTool:client_disableSplash()
    if not self:client_canChangeSettings() then return end

    self.currentSettings.disableSplash = not self.currentSettings.disableSplash
end

function PermissionTool:client_resourceConsumption()
    if not self:client_canChangeSettings() then return end

    self.currentSettings.resourceConsumption = not self.currentSettings.resourceConsumption
end

function PermissionTool:client_onCpuPress()
    if not self:client_canChangeSettings() then return end

    local onetick = 1 / 40
    self.currentSettings.cpu = round(self.currentSettings.cpu, 5)
    if self.currentSettings.cpu == onetick / 2 then
        self.currentSettings.cpu = onetick
    elseif self.currentSettings.cpu == -1 then
        self.currentSettings.cpu = onetick / 2
    elseif self.currentSettings.cpu == onetick * 5 then
        self.currentSettings.cpu = onetick * 10
    elseif self.currentSettings.cpu == onetick * 10 then
        self.currentSettings.cpu = onetick * 15
    elseif self.currentSettings.cpu == onetick * 15 then
        self.currentSettings.cpu = onetick * 20
    elseif self.currentSettings.cpu == onetick * 20 then
        self.currentSettings.cpu = onetick * 25
    elseif self.currentSettings.cpu == onetick * 25 then
        self.currentSettings.cpu = onetick * 30
    elseif self.currentSettings.cpu == onetick * 30 then
        self.currentSettings.cpu = onetick * 40
    else
        self.currentSettings.cpu = self.currentSettings.cpu + onetick
        if self.currentSettings.cpu > onetick * 40 then
            self.currentSettings.cpu = -1
        end
    end
    self.currentSettings.cpu = round(self.currentSettings.cpu, 5)
end

function PermissionTool.client_onScriptModeButtonPressed(self)
    if not self:client_canChangeSettings() then return end
    local isSafe = self.currentSettings.scriptMode == "safe"
    if not self:client_cheatAllow() and isSafe then
        sm.gui.chatMessage(noCheatMessage)
        return
    end

    if self.currentSettings.scriptMode == "safe" then
        self.currentSettings.scriptMode = "safe_with_open"
    elseif self.currentSettings.scriptMode == "safe_with_open" then
        self.currentSettings.scriptMode = "unsafe"
    else
        self.currentSettings.scriptMode = "safe"
    end
    self.rebootAll_cl_flag = true
end

function PermissionTool:client_onChatPress()
    if not self:client_canChangeSettings() then return end
    --[[
    if not self:client_cheatAllow() and not self.currentSettings.allowChat then
        sm.gui.chatMessage(noCheatMessage)
        return
    end
    ]]

    self.currentSettings.allowChat = not self.currentSettings.allowChat
end

function PermissionTool:client_onDisCompCheckPress()
    if not self:client_canChangeSettings() then return end
    if not self:client_cheatAllow() and not self.currentSettings.disCompCheck then
        sm.gui.chatMessage(noCheatMessage)
        return
    end

    self.currentSettings.disCompCheck = not self.currentSettings.disCompCheck
end

function PermissionTool:client_onAdropPress()
    if not self:client_canChangeSettings() then return end

    self.currentSettings.adrop = not self.currentSettings.adrop
end

function PermissionTool:client_onIbridgePress()
    if not self:client_canChangeSettings() then return end

    self.currentSettings.ibridge = not self.currentSettings.ibridge
end

function PermissionTool:client_onSavingPress()
    if not self:client_canChangeSettings() then return end

    self.currentSettings.saving = self.currentSettings.saving + 10
    if self.currentSettings.saving > 80 then
        self.currentSettings.saving = 0
    end
end

--local rates = {-1, -2, 1, 2, 4, 8}
local rates = {-1, 1, 2, 4, 40}
function PermissionTool:client_screenRate()
    if not self:client_canChangeSettings() then return end
    
    local currentIndex
    for index, value in ipairs(rates) do
        if value == self.currentSettings.screenRate then
            currentIndex = index
        end
    end
    if currentIndex then
        currentIndex = currentIndex + 1
        if currentIndex > #rates then
            currentIndex = 1
        end
    end
    self.currentSettings.screenRate = rates[currentIndex or 1]
end

function PermissionTool:client_onMaxDisplaysPress()
    if not self:client_canChangeSettings() then return end

    if self.currentSettings.maxDisplays == 0 then
        self.currentSettings.maxDisplays = 16
    else
        self.currentSettings.maxDisplays = self.currentSettings.maxDisplays * 2
    end
    if self.currentSettings.maxDisplays > 4096 then
        self.currentSettings.maxDisplays = 0
    end
end

function PermissionTool:client_onComputersEnabled()
    if not self:client_canChangeSettings() then return end

    self.tempSettings.enable = not self.tempSettings.enable
end

function PermissionTool:client_onAllowDist()
    if not self:client_canChangeSettings() then return end

    self.currentSettings.allowDist = not self.currentSettings.allowDist
end

function PermissionTool:client_disableCallLimit()
    if not self:client_canChangeSettings() then return end
    if not self:client_cheatAllow() and not self.currentSettings.disableCallLimit then
        sm.gui.chatMessage(noCheatMessage)
        return
    end

    self.currentSettings.disableCallLimit = not self.currentSettings.disableCallLimit
end

function PermissionTool:client_lagDetector()
    if not self:client_canChangeSettings() then return end

    if self.currentSettings.lagDetector == 0.5 then
        self.currentSettings.lagDetector = 0.75
    elseif self.currentSettings.lagDetector == 0.75 then
        self.currentSettings.lagDetector = 1
    elseif self.currentSettings.lagDetector == 1 then
        self.currentSettings.lagDetector = 1.5
    elseif self.currentSettings.lagDetector == 1.5 then
        self.currentSettings.lagDetector = 2
    elseif self.currentSettings.lagDetector == 2 then
        self.currentSettings.lagDetector = 2.5
    elseif self.currentSettings.lagDetector == 2.5 then
        self.currentSettings.lagDetector = 3
    else
        if type(self.currentSettings.lagDetector) ~= "number" then
            self.currentSettings.lagDetector = 0
        end
        self.currentSettings.lagDetector = round(self.currentSettings.lagDetector, 3)
    
        self.currentSettings.lagDetector = self.currentSettings.lagDetector + 0.1
        if self.currentSettings.lagDetector > 3 then
            self.currentSettings.lagDetector = false
        end
    end
end

function PermissionTool:client_hostrender()
    if not self:client_canChangeSettings() then return end

    self.currentSettings.hostrender = not self.currentSettings.hostrender
end

function PermissionTool.client_onLuaVmPress(self)
    if not self:client_canChangeSettings() then return end

    --local vms = {"luaInLua", "scrapVM", "advancedExecuter", "dlm", "fullLuaEnv", "hsandbox"}
    --local vms = {"luaInLua", "betterAPI", "dlm", "fullLuaEnv"}
    local vms = {"FiOne_lua", "betterAPI"}
    
    local currentIndex
    for index, value in ipairs(vms) do
        if value == self.currentSettings.vm then
            currentIndex = index
        end
    end
    if currentIndex then
        currentIndex = currentIndex + 1
        if currentIndex > #vms then
            currentIndex = 1
        end
    end
    self.currentSettings.vm = vms[currentIndex or 1]

    self.rebootAll_cl_flag = true
end

function PermissionTool:client_onRendPress()
    if not self:client_canChangeSettings() then return end

    self.currentSettings.rend = self.currentSettings.rend + 5
    if self.currentSettings.rend > 40 then
        self.currentSettings.rend = 5
    end
end

function PermissionTool:client_onOptSPress()
    if not self:client_canChangeSettings() then return end

    if not self.currentSettings.optSpeed then
        self.currentSettings.optSpeed = 0
    end
    self.currentSettings.optSpeed = self.currentSettings.optSpeed + 0.1
    if self.currentSettings.optSpeed > 5 then
        self.currentSettings.optSpeed = false
    else
        self.currentSettings.optSpeed = round(self.currentSettings.optSpeed, 1)
    end
end

local function setSettings(self, settings)
    if not self:client_canChangeSettings() then return end

    self.rebootAll_cl_flag = true
    local oldSettings = sc.restrictions
    sc.setRestrictions(settings)
    self.currentSettings = sc.restrictions
    sc.restrictions = oldSettings

    if self.data and self.data.survival then
        self.currentSettings.acreative = false
    end
end

function PermissionTool:client_onSrvPress()
    setSettings(self, sc.forServerRestrictions)
end

function PermissionTool:client_onUnrestrictedSettingsPress()
    setSettings(self, sc.unrestrictedRestrictions)
end

function PermissionTool:client_onRstPress()
    setSettings(self, sc.defaultRestrictions)
end

function PermissionTool:client_onRaysPress()
    if not self:client_canChangeSettings() then return end

    if self.currentSettings.rays == 0 then
        self.currentSettings.rays = 16
    elseif self.currentSettings.rays == 16 then
        self.currentSettings.rays = 32
    elseif self.currentSettings.rays == 32 then
        self.currentSettings.rays = 64
    elseif self.currentSettings.rays == 64 then
        self.currentSettings.rays = 128
    else
        self.currentSettings.rays = 0
    end
end

function PermissionTool.client_onAdminOnlyButtonPressed(self)
    if not PermissionTool.isHost() then return end -- clients can block theirselves

    if not self:client_cheatAllow() and self.currentSettings.adminOnly then
        sm.gui.chatMessage(noCheatMessage)
        return
    end

    self.currentSettings.adminOnly = not self.currentSettings.adminOnly
end

function PermissionTool:client_onACreativePress()
    if not self:client_canChangeSettings() then return end

    --[[
    if not self.currentSettings.acreative and sm.game.getLimitedInventory() then
        sm.gui.chatMessage("#ff0000you cannot allow the use of creative items in survival")
        return
    end
    ]]

    self.currentSettings.acreative = not self.currentSettings.acreative
end

--[[function PermissionTool.client_onDisplayAtLagsButtonPressed(self)
    if not self:client_canChangeSettings() then return end

    self.currentSettings.displaysAtLagsMode = self.currentSettings.displaysAtLagsMode == "draw" and "skip" or "draw"

    self.gui:setText("DisplaysAtLagsButton", "DisplaysAtLags: " .. (self.currentSettings.displaysAtLagsMode == "draw" and "Draw" or "Skip"))
end]]

function PermissionTool.client_onApplyButtonPressed(self)
    self.network:sendToServer("server_onNewSettings", {self.currentSettings, self.tempSettings})
    self.gui:close()


    if self.rebootAll_cl_flag then
        self.rebootAll_cl_flag = nil
        self.network:sendToServer("sv_rebootAll")
    end
end

----------------- tool support

function PermissionTool:client_onEquippedUpdate(primaryState, secondaryState)
    if self.tool and not self.tool:isLocal() then return end
    
    if primaryState == sm.tool.interactState.start then
        self:client_onInteract(nil, true)
    end

    return true, true
end
end
function scmframework_780ee5e7442ff61957f6dc296fd6d932() --$CONTENT_DATA/Scripts/Tools/servicetool.lua
--dofile("$CONTENT_DATA/Scripts/externAddonAPI.lua")
servicetool = class()
servicetool.instance = nil

local noWarnings = true
local noCheatCommand = true
local noSafeCommand = true

local function checkInstance(self)
    servicetool.instance = servicetool.instance or self
    return servicetool.instance ~= self
end

local function loadBackground(self)
    if sc.background then return end
    sc.background = {}

    dofile("$CONTENT_DATA/Scripts/chaff_task.lua")

    for name, task in pairs(sc.background) do
        function task.sendToClients(...)
            self.network:sendToClients("cl_bg_callback", {name = name, ...})
        end
    end
end

local function background_sv(self)
    for name, task in pairs(sc.background) do
        task:server()
    end
end

local function background_cl(self)
    for name, task in pairs(sc.background) do
        task:client()
    end
end

function servicetool:cl_bg_callback(args)
    sc.background[args.name].clientCallback(unpack(args))
end

------------------------------------------------------------------

local newClients = {}
local function updateClients(self)
    local currentClients = {}
    for _, player in ipairs(sm.player.getAllPlayers()) do
        currentClients[player.id] = true
        if not newClients[player.id] then
            self.network:sendToClient(player, "cl_n_onCreate", sc.version)
            newClients[player.id] = true
        end
    end
    for id in pairs(newClients) do
        if not currentClients[id] then
            newClients[id] = nil
        end
    end
end

function servicetool:server_onCreate()
    if checkInstance(self) then
        return
    end

    dofile("$CONTENT_DATA/Scripts/Config.lua")
    loadBackground(self)
    sc.init()
    sc.warningsCheck()
    self.sendRestrictions = true

    if sc.enableByDefault then
        _G.computersAllow = true
        _G.updateToolSettings = true
    end

    self.xengineClearTimeout = 40 * 5

    updateClients(self)
end

function servicetool:server_onFixedUpdate()
    if checkInstance(self) then
        return
    end

    updateClients(self)

    if self._restrictionsUpdated then
        sc.restrictionsUpdated = nil
        self._restrictionsUpdated = nil
    end
    if sc.restrictionsUpdated then
        self._restrictionsUpdated = true
    end

    if self._rebootAll then
        sc.rebootAll = nil
        self._rebootAll = nil
    end
    if sc.rebootAll then
        self._rebootAll = true
    end
    
    if sc.restrictionsUpdated or self.sendRestrictions then
        self.network:sendToClients("cl_restrictions", sc.restrictions)
        self.sendRestrictions = nil
    end

    --local forceSend = sm.game.getCurrentTick() % (40 * 60 * 60) == 0
    --if sc.restrictionsUpdated or (sc.shutdownFlag and sm.game.getCurrentTick() % (5 * 40) == 0) then
        --self:sv_print_vulnerabilities()
    --end

    if sc.shutdownFlag and sm.game.getCurrentTick() % (5 * 40) == 0 then
        self:sv_print_vulnerabilities()
    end
    
    if self.scAllow then
        sc.setRestrictions(sc.originalRestrictions)
        sc.saveRestrictions()

        self.scAllow = nil
    end

    if self.xengineClearTimeout then
        self.xengineClearTimeout = self.xengineClearTimeout - 1
        if self.xengineClearTimeout < 0 then
            sc.xEngineClear()
            self.xengineClearTimeout = nil
        end
    end

    --[[
    if sm.game.getCurrentTick() % 10 == 0 then
        for _, player in ipairs(sm.player.getAllPlayers()) do
            local inv = player:getInventory()

            sm.container.beginTransaction()
            sm.container.collectToSlot(inv, 3, sm.uuid.new("3d37b254-dbaa-4be2-9a0d-ce1e24315c08"), 1)
            sm.container.endTransaction()
        end
    end
    ]]

    background_sv(self)
end

function servicetool:sv_print_vulnerabilities()
    local vulnerabilities = {}

    if not noWarnings then
        if not sc.restrictions.adminOnly then
            table.insert(vulnerabilities, "any player can change the configuration of the mod(adminOnly: false)")
        end
        if sc.restrictions.allowChat then
            table.insert(vulnerabilities, "computers can output messages to chat(printON)")
        end
        if sc.restrictions.scriptMode ~= "safe" then
            table.insert(vulnerabilities, "computers can control the game(unsafe mode)")
        end
        if sc.restrictions.disCompCheck then
            table.insert(vulnerabilities, "component connectivity check is disabled")
        end
        if sc.restrictions.disableCallLimit then
            table.insert(vulnerabilities, "call limits are disabled, this allows you to burden some SComputers mechanics")
        end
    end

    if sc.shutdownFlag then
        vulnerabilities.shutdown = true
    end
    
    self.network:sendToClients("cl_print_vulnerabilities", vulnerabilities)
end

function servicetool:sv_createGui()
    self.network:sendToClients("cl_createGui")
end

function servicetool:sv_dataRequest()
    self.sendRestrictions = true
end

function servicetool:sv_dataRequest2()
    self.network:sendToClients("cl_onDataResponse", {sc.treesPainted})
end

function servicetool:sv_cheat(data)
    self.network:sendToClient(data.player, "cl_cheat")
end

function servicetool:sv_safe(data)
    local isHost = data.player == vnetwork.host
    if not sc.restrictions.adminOnly or isHost then
        if not noCheatCommand then
            self.network:sendToClients("cl_disToggleCheat")
        end
        if isHost then -- clients can block theirselves
            sc.restrictions.adminOnly = true
        end
        sc.restrictions.allowChat = false
        sc.restrictions.scriptMode = "safe"
        sc.restrictions.disCompCheck = false
        sc.restrictions.disableCallLimit = false

        sc.saveRestrictions()
        sc.rebootAll = true
        self.network:sendToClient(data.player, "cl_safe")
    else
        self.network:sendToClient(data.player, "cl_noPermission")
    end
end

function servicetool:sv_version(data)
    self.network:sendToClient(data.player, "cl_version")
end

------------------------------------------------------------------

function servicetool:cl_previewToChat()
    sm.gui.chatMessage("#ffad30Thank you for using SComputers :)#ffffff")
    --sm.gui.chatMessage("#f03c02be sure to read the documentation#ffffff: https://scrapmechanictools.com/modapis/SComputers/Info")
    sm.gui.chatMessage("#ff3030>> be sure to read the documentation:\n#ffffffhttps://igorkll.github.io/SComputers")
    sm.gui.chatMessage("#309eff>> SComputers discord server:\n#ffffffhttps://discord.gg/uJrsmUjaMG")
    if not better then
        sm.gui.chatMessage("#f2ea05>> to improve the performance of the displays, it is recommended to install this:\n#ffffffhttps://igorkll.github.io/betterAPI")
    end
    --sm.gui.chatMessage("current documentation is \"temporary\"") permanent link for the invitation: 
    --sm.gui.chatMessage("because the scrapmechanictool site has closed")
end

function servicetool:cl_n_onCreate(version)
    if checkInstance(self) then
        return
    end
    self.clientToolInited = true
    
    dofile("$CONTENT_DATA/Scripts/Config.lua")
    loadBackground(self)

    if sc.isSplashEnabled() then
        self:cl_createGui()
        if not sm.isHost then
            self:cl_previewToChat()
        end
    else
        self:cl_allow()
    end
    
    self.network:sendToServer("sv_dataRequest")
    self.timeout = 40

    if noCheatCommand then
        _G.allowToggleCheat = true
    end

    if version ~= sc.version then
        sm.gui.chatMessage("#ff0000DIFFERENT VERSIONS OF SComputers ON THE CLIENT AND SERVER SIDE!!!")
        sm.gui.chatMessage("#ff8800RE-SUBSCRIBE TO THE MOD: #ffffffhttps://steamcommunity.com/sharedfiles/filedetails/?id=2949350596")
    end
end

function servicetool:cl_onDataResponse(data)
    for _, dat in pairs(data[1]) do
        if sm.exists(dat[1]) then
            dat[1]:setColor(dat[2])
        end
    end
end

function servicetool:client_onFixedUpdate(dt)
    if not self.clientToolInited or checkInstance(self) then
        return
    end

    if better and better.isAvailable() then
        local key1 = better.keyboard.isKey(better.keyboard.keys.ctrl_l)
        local key2 = better.keyboard.isKey(better.keyboard.keys.s)
        _g_saveBind = key1 and key2
    end

    sc.deltaTimeTps = dt

    local computerExists = sc.computersCount > 0
    if computerExists and ((computerExists and not self.old_computerExists) or sm.game.getCurrentTick() % (60 * 40 * 5) == 0) then
        self:cl_print_vulnerabilities({}, true)
    end
    self.old_computerExists = computerExists

    if self.gui and not self.gui:isActive() then
        self.gui:open()
    end

    if self.timeout then
        if self.timeout <= 0 then
            self.network:sendToServer("sv_dataRequest2")
            self.timeout = nil
        else
            self.timeout = self.timeout - 1
        end
    end

    --[[
    if _G.tcCache and sm.game.getCurrentTick() % (40 * 16) == 0 then
        local size = 0
        --[[
        local types = {}
        for dat in pairs(_G.tcCache) do
            size = size + 1
            local t = type(dat)
            if not types[t] then types[t] = 0 end
            types[t] = types[t] + 1
        end
        ] ]
        for dat in pairs(_G.tcCache) do
            size = size + 1
            if size > 1024 * 4 then
                print("clearing tableChecksum cache...")
                print("current size", size)
                --[[
                print("types:")
                for t, count in pairs(types) do
                    print(tostring(t) .. "-" .. tostring(count))
                end
                ] ]
    
                for key in pairs(_G.tcCache) do
                    _G.tcCache[key] = nil
                    if size < 256 then
                        break
                    end
                end
                
                break
            end
        end
    end
    ]]

    if better then
        better.tick()
    end

    background_cl(self)

    --updateExternAPI()
end

function servicetool:cl_disToggleCheat()
    _G.allowToggleCheat = false
end

function servicetool:cl_print_vulnerabilities(vulnerabilities, regularFlag)
    local oldVulnerabilitiesCount
    if not regularFlag then
        if not noWarnings then
            if _G.allowToggleCheat then
                table.insert(vulnerabilities, "you can activate cheats (which may lead to accidental activation)")
            end
        end

        oldVulnerabilitiesCount = #vulnerabilities
        for _, warning in ipairs(warnings) do
            table.insert(vulnerabilities, warning)
        end
    end

    for _, warning in ipairs(regularWarnings) do
        table.insert(vulnerabilities, warning)
    end

    if #vulnerabilities > 0 then
        sm.gui.chatMessage("#ff0000warnings from the SComputers:#ffffff")
        for index, value in ipairs(vulnerabilities) do
            sm.gui.chatMessage(tostring(index) .. ". " .. value)
        end

        if oldVulnerabilitiesCount and not noSafeCommand and oldVulnerabilitiesCount > 0 then
            sm.gui.chatMessage("#ffff00the host can enter /sv_scomputers_safe to automatically bring security back to normal#ffffff")
        end
    end

    if vulnerabilities.shutdown then
        sc.shutdown()
    end
end

local function scomputersUI(self)
    self.gui = sm.gui.createGuiFromLayout("$CONTENT_DATA/Gui/Layouts/allow.layout", false)
    self.gui:setButtonCallback("yes", "cl_allow")
    --self.gui:setButtonCallback("sc", "cl_scAllow")
    self.gui:setButtonCallback("no", "cl_notAllow")
end

function servicetool:cl_createGui()
    if not sm.isHost then return end
    --[[ fuck the human autopilot
    self.gui = sm.gui.createGuiFromLayout("$GAME_DATA/Gui/Layouts/PopUp/PopUp_YN.layout", false)
    self.gui:setText("Title", "SComputers")
    self.gui:setText("Message", "Allow computers to work in this gaming session?\nIf you have a computer that breaks the game, turn off the computers and put it away.\nTo open this menu, type the command: /computers")
    self.gui:setButtonCallback("Yes", "cl_allow")
    self.gui:setButtonCallback("No", "cl_notAllow")
    ]]
    scomputersUI(self)
end

function servicetool:cl_scAllow()
    self.gui:close()
    self.gui:destroy()

    self.gui = sm.gui.createGuiFromLayout("$GAME_DATA/Gui/Layouts/PopUp/PopUp_YN.layout", false)
    self.gui:setText("Title", "SComputers")
    self.gui:setText("Message", "do you really want to apply this preset settings?")
    self.gui:setButtonCallback("Yes", "cl_scAllow2")
    self.gui:setButtonCallback("No", "cl_notAllow2")
end

function servicetool:cl_scAllow2()
    self.scAllow = true
    self:cl_allow()
end

function servicetool:cl_notAllow2()
    self.gui:close()
    self.gui:destroy()

    scomputersUI(self)
end

function servicetool:cl_allow()
    print("SComputers ALLOWED")

    if not self.vul_printed then
        self.network:sendToServer("sv_print_vulnerabilities")
        self.vul_printed = true
    end
    
    _G.computersAllow = true
    _G.updateToolSettings = true
    if self.gui then
        self.gui:close()
        self.gui:destroy()
        self.gui = nil
    end
    
    self:cl_previewToChat()
end

function servicetool:cl_notAllow()
    print("SComputers NOT-ALLOWED")
    
    if not self.vul_printed then
        self.network:sendToServer("sv_print_vulnerabilities")
        self.vul_printed = true
    end

    _G.computersAllow = nil
    _G.updateToolSettings = true
    if self.gui then
        self.gui:close()
        self.gui:destroy()
        self.gui = nil
    end

    self:cl_previewToChat()
end

function servicetool:client_onUpdate(dt)
    sc.deltaTime = dt
end

function servicetool:cl_restrictions(data)
    if sm.isHost then return end
    sc.restrictions = data
end

function servicetool:cl_noPermission()
    sm.gui.chatMessage("#ff0000you don't have rights to use this command")
end

function servicetool:cl_safe()
    sm.gui.chatMessage("#00ff00SComputers settings are now safe to use")
end

function servicetool:cl_cheat()
    if not _G.allowToggleCheat and sm.game.getLimitedInventory() then
        sm.gui.chatMessage("#ff0000it is impossible to enable cheats in survival")
        return
    end

    _G.allowToggleCheat = not _G.allowToggleCheat
    if _G.allowToggleCheat then
        sm.gui.chatMessage("#ffff00now you can activate cheats")
    else
        sm.gui.chatMessage("#00ff00you can no longer activate cheats")
    end
end

function servicetool:cl_version()
    sm.gui.displayAlertText("version: " .. tostring(sc.version))
end

------------------------------------------------------------------

--[[
for k, v in pairs(servicetool) do
    if type(v) == "function" then
        servicetool[k] = function(self, ...)
            if checkInstance(self) then return end
            return v(self, ...)
        end
    end
end
]]

if not commandsBind then
    local added
    local oldBindCommand = sm.game.bindChatCommand
    local function bindCommandHook(command, params, callback, help)
        oldBindCommand(command, params, callback, help)
        if not added then
            if not sc.noCommands then
                if sm.isHost then
                    oldBindCommand("/computers", {}, "cl_onChatCommand", "opens the SComputers configuration menu")
                end
                if not noCheatCommand then
                    oldBindCommand("/cl_scomputers_cheat", {}, "cl_onChatCommand", "enables/disables cheat-buttons in the \"Creative Permission-tool\"")
                end
                --oldBindCommand("/cl_scomputers_version", {}, "cl_onChatCommand", "show scomputers version")
                if not noSafeCommand then
                    oldBindCommand("/sv_scomputers_safe", {}, "cl_onChatCommand", "returns SComputers parameters to safe")
                end
            end

            added = true
        end
    end
    sm.game.bindChatCommand = bindCommandHook

    --------------------------------------------

    local oldWorldEvent = sm.event.sendToWorld
    local function worldEventHook(world, callback, params)
        if params then
            if params[1] == "/computers" then
                sm.event.sendToTool(servicetool.instance.tool, "sv_createGui")
                return
            elseif params[1] == "/cl_scomputers_cheat" then
                sm.event.sendToTool(servicetool.instance.tool, "sv_cheat", {player = params.player})
                return
            elseif params[1] == "/sv_scomputers_safe" then
                sm.event.sendToTool(servicetool.instance.tool, "sv_safe", {player = params.player})
                return
            elseif params[1] == "/cl_scomputers_version" then
                sm.event.sendToTool(servicetool.instance.tool, "sv_version", {player = params.player})
                return
            end
        end

        oldWorldEvent(world, callback, params)
    end
    sm.event.sendToWorld = worldEventHook

    --------------------------------------------

    commandsBind = true
end
end
function scmframework_d34ad47c35dba37099733e8a82e47709() --$CONTENT_DATA/Scripts/Tools/stylus.lua
local rend = {"$CONTENT_DATA/Tools/Renderables/stylus.rend"}

stylus = class()
sm.tool.preloadRenderables(rend)

function stylus:client_onEquippedUpdate(primaryState, secondaryState)
    if primaryState == sm.tool.interactState.start then
        _G.stylus_left = true
    end
    if primaryState == sm.tool.interactState.stop then
        _G.stylus_left = nil
    end

    if secondaryState == sm.tool.interactState.start then
        _G.stylus_right = true
    end
    if secondaryState == sm.tool.interactState.stop then
        _G.stylus_right = nil
    end

    self.tool:updateFpAnimation("connecttool_use_connect", 1, 1)
    return true, true
end

function stylus:client_onEquip()
    self.tool:setTpRenderables(rend)
    self.tool:setFpRenderables(rend)

    _G.stylus_left = nil
    _G.stylus_right = nil
end

function stylus:client_onUnequip()
    _G.stylus_left = nil
    _G.stylus_right = nil
end

function stylus:client_onDestroy()
    _G.stylus_left = nil
    _G.stylus_right = nil
end
end
function scmframework_0f94f1cc2212bba7e07192158f350aad() --$CONTENT_DATA/Scripts/Tools/tablet.lua
if not ScriptableComputer then
    dofile("$CONTENT_DATA/Scripts/ScriptableComputer.lua")
end
--dofile("$CONTENT_DATA/Scripts/Displays/DisplayBase.lua")

local rend = {"$CONTENT_DATA/Tools/Renderables/tablet.rend"}
tablet = class(ScriptableComputer)
sm.tool.preloadRenderables(rend)

---------------------------------------------------------------

function tablet.doQuat(x, y, z, w)
    local sin = math.sin(w / 2)
    return sm.quat.new(sin * x, sin * y, sin * z, math.cos(w / 2))
end

function tablet.eilToQuat(vec)
    return tablet.doQuat(1, 0, 0, vec.x) * tablet.doQuat(0, 1, 0, vec.y) * tablet.doQuat(0, 0, 1, vec.z)
end

---------------------------------------------------------------

function tablet:server_onCreate()
    ScriptableComputer.server_onCreate(self)

    self.player = self.tool:getOwner()
    self.character = self.player.character

    self.display = self.display or sc.display.createDisplay(self, self.data.screenX, self.data.screenY, self.data.screenV)
	sc.display.server_init(self.display)
    self.envSettings.vcomponents.display = {sc.display.server_createData(self.display)}
end

function tablet:server_onDestroy()
    ScriptableComputer.server_onDestroy(self)

    sc.display.server_destroy(self.display)
end

function tablet:server_onFixedUpdate(dt)
    self.player = self.tool:getOwner()
    self.character = self.player.character

    sc.display.server_update(self.display, dt)
    ScriptableComputer.server_onFixedUpdate(self)
end

function tablet:sv_toggle()
    self.storageData.active_button = not self.storageData.active_button
    self.network:sendToClient(self.player, "cl_alertMessage", self.storageData.active_button and "power on" or "power off")
end

---------------------------------------------------------------

function tablet:client_onCreate()
    if self.tool:isLocal() then
        self.player = self.tool:getOwner()
        self.character = self.player.character
        

        self.display = self.display or sc.display.createDisplay(self, self.data.screenX, self.data.screenY, self.data.screenV)
        self:cl_resetData()
    	sc.display.client_init(self.display)
    end
    ScriptableComputer.client_onCreate(self)
end

function tablet:client_onToggle()
    self.network:sendToServer("sv_toggle")
end

function tablet:client_onReload()
    ScriptableComputer.client_onInteract(self, nil, true)
    return true
end

function tablet:client_onEquippedUpdate(primaryState, secondaryState)
    if not self.tool:isLocal() then return end

    if primaryState == sm.tool.interactState.start then
        self.display.tablet_left = true
    end
    if primaryState == sm.tool.interactState.stop then
        self.display.tablet_left = nil
    end

    if secondaryState == sm.tool.interactState.start then
        self.display.tablet_right = true
    end
    if secondaryState == sm.tool.interactState.stop then
        self.display.tablet_right = nil
    end

    local dx, dy = sm.localPlayer.getMouseDelta()
    dx = dx * self.data.screenX * 0.8
    --dy = dy * self.data.screenX * 0.8
    --dx = math.floor(dx + 0.5)
    --dy = math.floor(dy + 0.5)
    self.display.tablet_posX = self.display.tablet_posX - dx
    --self.display.tablet_posY = self.display.tablet_posY - dy
    self.display.tablet_posY = self.data.screenX * constrain((0.18 - self.character.direction.z) * 1.2, 0, 1)
    if self.display.tablet_posX < 0 then self.display.tablet_posX = 0 end
    if self.display.tablet_posY < 0 then self.display.tablet_posY = 0 end
    if math.ceil(self.display.tablet_posX) >= self.display.width then self.display.tablet_posX = self.display.width - 1 end
    if math.ceil(self.display.tablet_posY) >= self.display.height then self.display.tablet_posY = self.display.height - 1 end


    --self.tool:updateFpAnimation("handbook_use_idle", 1, (math.sin(sm.game.getCurrentTick() * 0.05) * 0.02) + 0.5)
    return true, true
end

function tablet:client_onEquip()
    if not self.tool:isLocal() then return end

    self:cl_resetData()
    self.display.tablet_posX = self.display.width / 2
    self.display.tablet_posY = 0

    --self.tool:setTpRenderables(rend)
    --self.tool:setFpRenderables(rend)

    --self.direction = sm.localPlayer.getDirection()
end

function tablet:client_onUnequip()
    if not self.tool:isLocal() then return end
    self:cl_resetData()
end

function tablet:client_onDestroy()
    ScriptableComputer.client_onDestroy(self)

    if self.display then
        self:cl_resetData()
        sc.display.client_destroy(self.display)
        sc.display.client_update(self.display)
    end
end

function tablet.client_onFixedUpdate(self, dt)
    ScriptableComputer.client_onFixedUpdate(self, dt)
    if self.tool:isLocal() then
    	sc.display.client_update(self.display, dt)
    end
end

function tablet:cl_resetData()
    self.display.tablet_left = nil
    self.display.tablet_right = nil
    
    self.display.tablet_posX = nil
    self.display.tablet_posY = nil
end





function tablet.client_onReceiveDrawStack(self, stack)
	sc.display.client_drawStack(self.display, stack)
end

function tablet.client_onInteract(self, character, state)
	sc.display.client_onInteract(self.display, character, state)
end

function tablet.client_canInteract(self, character)
	return sc.display.client_canInteract(self.display, character)
end

function tablet.client_canTinker(self, character)
	return sc.display.client_canTinker(self.display, character)
end

function tablet.client_onTinker(self, character, state)
	sc.display.client_onTinker(self.display, character, state)
end

function tablet.client_onDataResponse(self, data)
	sc.display.client_onDataResponse(self.display, data)
end

function tablet.server_recvPress(self, p, client)
	sc.display.server_recvPress(self.display, p, client)
end

function tablet.server_onDataRequired(self, client)
	sc.display.server_onDataRequired(self.display, client)
end

---------------------------------------------------------------

function tablet:cl_onExample(...)
    ScriptableComputer.cl_onExample(self, ...)
end
end
function scmframework_bd1aa7abb1e0e113c2ffd25077cb84c8() --$CONTENT_DATA/Scripts/Tools/wasd_autotool.lua
wasd_autotool = class()

function wasd_autotool:server_onFixedUpdate()
    local player = self.tool:getOwner()
    local seat = player.character:getLockingInteractable()

    if seat and seat:getSeatCharacter().id == player.character.id then
        if not self.enabled then
            self.network:sendToClient(player, "cl_enable")    
            self.enabled = true
        end
    elseif self.enabled then
        self.network:sendToClient(player, "cl_disable")    
        self.enabled = false
    end
end

function wasd_autotool:sv_response(info, player)
    sc.wasdInfo[player.character.id] = sc.wasdInfo[player.character.id] or {}
    local wasdInfo = sc.wasdInfo[player.character.id]
    local tick = sm.game.getCurrentTick() + 1

    if info == 1 then
        wasdInfo.button_q = tick
    elseif info == 2 then
        wasdInfo.button_r = tick
    elseif info == 3 then
        wasdInfo.mouse_l = true
    elseif info == 4 then
        wasdInfo.mouse_l = false
    elseif info == 5 then
        wasdInfo.mouse_r = true
    elseif info == 6 then
        wasdInfo.mouse_r = false
    elseif info == 7 then
        wasdInfo.mouse_c = true
    elseif info == 8 then
        wasdInfo.mouse_c = false
    end
end

----------------------------------------------------------

local isBetter = better and better.isAvailable()
local mouseApiAvailable = isBetter and pcall(better.mouse.isLeft)
local keyboardApiAvailable = isBetter and pcall(better.keyboard.isKey, 0)

local old_q_state = false
local old_r_state = false
local old_mouse_l_state = false
local old_mouse_c_state = false
local old_mouse_r_state = false

function wasd_autotool:client_onFixedUpdate()
    if isBetter then
        local left = better.mouse.isLeft()
        local center = better.mouse.isCenter()
        local right = better.mouse.isRight()

        local q_state = better.keyboard.isKey(better.keyboard.keys.q)
        local r_state = better.keyboard.isKey(better.keyboard.keys.r)

        if self.tool:getOwner().character:getLockingInteractable() then
            if mouseApiAvailable then
                if left ~= old_mouse_l_state then
                    if left then
                        self.network:sendToServer("sv_response", 3)
                    else
                        self.network:sendToServer("sv_response", 4)
                    end
                end
                old_mouse_l_state = left
                
                if center ~= old_mouse_c_state then
                    if center then
                        self.network:sendToServer("sv_response", 7)
                    else
                        self.network:sendToServer("sv_response", 8)
                    end
                end
                old_mouse_c_state = center

                if right ~= old_mouse_r_state then
                    if right then
                        self.network:sendToServer("sv_response", 5)
                    else
                        self.network:sendToServer("sv_response", 6)
                    end
                end
                old_mouse_r_state = right
            end

            if keyboardApiAvailable then
                local q_pulse = q_state and not old_q_state
                old_q_state = q_state
            
                if q_pulse then
                    self.network:sendToServer("sv_response", 1)
                end
                
                local r_pulse = r_state and not old_r_state
                old_r_state = r_state

                if r_pulse then
                    self.network:sendToServer("sv_response", 2)
                end
            end
        end
    end
end

function wasd_autotool:client_onEquippedUpdate(primaryState, secondaryState)
    if mouseApiAvailable then
        return true, true
    end

    if self.tool:isLocal() then
        if primaryState == sm.tool.interactState.start then
            self.network:sendToServer("sv_response", 3)
        elseif primaryState == sm.tool.interactState.stop then
            self.network:sendToServer("sv_response", 4)
        end
        
        if secondaryState == sm.tool.interactState.start then
            self.network:sendToServer("sv_response", 5)
        elseif secondaryState == sm.tool.interactState.stop then
            self.network:sendToServer("sv_response", 6)
        end
    end

    return true, true
end

function wasd_autotool:client_onToggle()
    if keyboardApiAvailable then
        return true
    end

    if self.tool:getOwner().character:getLockingInteractable() then
        self.network:sendToServer("sv_response", 1)
    end

    return true
end

function wasd_autotool:client_onReload()
    if keyboardApiAvailable then
        return true
    end

    if self.tool:getOwner().character:getLockingInteractable() then
        self.network:sendToServer("sv_response", 2)
    end

    return true
end

function wasd_autotool:cl_enable()
    self.equipped = true
    sm.tool.forceTool(self.tool)
end

function wasd_autotool:cl_disable()
    self.equipped = false
    sm.tool.forceTool(nil)
end
end
function scmframework_1f729f6927987520451f300001340d3e() --$CONTENT_DATA/Scripts/vnetwork.lua
vnetwork = {}

function vnetwork.init()
    if vnetwork.host then return end

    local hid = math.huge
    for i, player in ipairs(sm.player.getAllPlayers()) do
        if player.id < hid then
            hid = player.id
            vnetwork.host = player
        end
    end
    if not vnetwork.host then
        error("vnetwork problem!!!")
        return
    end

    print("vnetwork.init()")
end

function vnetwork.sendToClient(self, player, method, data)
    --self.network:sendToClient(player, method, data)
    --do return end

    if player.id == vnetwork.host.id then
        self.sendData = data
        self.network:sendToClient(player, method)
    else
        self.network:sendToClient(player, method, data)
    end
end

function vnetwork.sendToClients(self, method, data, maxdist, whitelist)
    for i, player in ipairs(sm.player.getAllPlayers()) do
        if not whitelist or whitelist[player.id] then
            local worldPosition
            if self.shape then
                worldPosition = self.shape.worldPosition
            elseif self.tool then
                worldPosition = self.tool:getOwner().character.worldPosition
            end
            if not worldPosition or not maxdist or mathDist(worldPosition, player.character.worldPosition) <= maxdist then
                vnetwork.sendToClient(self, player, method, data)
            end
        end
    end
end

function vnetwork.sendToServer(self, method, data)
    self.network:sendToServer(method, data)
end
end
function scmframework_fbf2e6de1c77ebae429f532f567e9ce8() --$CONTENT_DATA/Scripts/warnings.lua
warnings = {}
regularWarnings = {}

if better then
    if not better.version or better.version < sc.actualBetterAPI or (canvasAPI and better.version < canvasAPI.actualBetterAPI) then
        table.insert(warnings, "#FF0000WARNING#FFFFFF: you have an outdated version of the betterAPI \"" .. (better.version or "unknown") .. "\" installed. currently, the current version is \"" .. sc.actualBetterAPI .. "\". please update betterAPI: https://steamcommunity.com/sharedfiles/filedetails/?id=3177944610")
    end
else
    --table.insert(warnings, "#FF0000WARNING#FFFFFF: the betterAPI is not installed, the mod will use the LUA virtual machine, which may cause the code to malfunction.\nit is recommended to install betterAPI: https://steamcommunity.com/sharedfiles/filedetails/?id=3177944610")
end

--[[
dofile("$CONTENT_DATA/Scripts/loadCanvas.lua")
if not canvasAPI then
    table.insert(regularWarnings, "#FF0000WARNING#FFFFFF: for some reason, you did not download the display framework automatically, the displays will not work until you manually download: https://steamcommunity.com/sharedfiles/filedetails/?id=3202981462")
elseif canvasAPI.version ~= sc.actualCanvasVersion then
    print("CANVAS VERSION", canvasAPI.version)
    print("ACTUAL CANVAS", sc.actualCanvasVersion)
    table.insert(regularWarnings, "#FF0000WARNING#FFFFFF: the version of the canvas api and SComputers do not match. the displays may not work. please re-subscribe to canvas api and SComputers. if you are not subscribed to the canvas api, then subscribe, then unsubscribe and subscribe again:\ncanvas-api: https://steamcommunity.com/sharedfiles/filedetails/?id=3202981462\nSComputers: https://steamcommunity.com/sharedfiles/filedetails/?id=2949350596")
end
]]

function sc.warningsCheck()
    if _checked then return end
    _checked = true

    local origBlockUuid = sm.uuid.new("41d7c8b2-e2de-4c29-b842-5efd8af37ae6") --old screen pixel uuid
    if pcall(sm.shape.createPart, origBlockUuid, sm.vec3.new(0, 0, 10000)) then
        table.insert(warnings, "#FF0000CRITICAL ERROR#FFFFFF: SComputers conflicts with ScriptableComputer or another fork of ScriptableComputer!!!! URGENTLY REMOVE ALL OTHER COMPUTER MODS FROM YOUR WORLD, OTHERWISE SCOMPUTERS WILL NOT WORK")
        sc.shutdownFlag = true
    end
end
end
function scmframework_f46c296f247de9ae24605f6937abcddf() --$CONTENT_DATA/Scripts/wasd.lua
dofile("$CONTENT_DATA/Scripts/Config.lua")
wasd = class()
wasd.maxParentCount = 1
wasd.maxChildCount = 1
wasd.connectionInput = sm.interactable.connectionType.power
wasd.connectionOutput = sm.interactable.connectionType.composite
wasd.colorNormal = sm.color.new("#007355")
wasd.colorHighlight = sm.color.new("#00e4aa")
wasd.componentType = "wasd"

local function getWasdInfo(self)
	local parent = self.interactable:getSingleParent()
	if parent then
		local seated = parent:getSeatCharacter()
		if seated then
			local wasdInfo = sc.wasdInfo[seated.id]
			if wasdInfo then
				return wasdInfo
			end
		end
	end
end

function wasd:server_onCreate()
    self.interactable.publicData = {
        sc_component = {
            type = wasd.componentType,
            api = {
                isSeated = function ()
                    return not not self.seated
                end,
                isW = function ()
                    return not not self.W
                end,
                isS = function ()
                    return not not self.S
                end,
                isA = function ()
                    return not not self.A
                end,
                isD = function ()
                    return not not self.D
                end,
                getADvalue = function ()
                    return self.AD or 0
                end,
                getWSvalue = function ()
                    return self.WS or 0
                end,

				isMouseL = function()
					local wasdInfo = getWasdInfo(self)
					return not not (wasdInfo and wasdInfo.mouse_l)
				end,
				isMouseC = function()
					local wasdInfo = getWasdInfo(self)
					return not not (wasdInfo and wasdInfo.mouse_c)
				end,
				isMouseR = function()
					local wasdInfo = getWasdInfo(self)
					return not not (wasdInfo and wasdInfo.mouse_r)
				end,
				isQ = function()
					local wasdInfo = getWasdInfo(self)
					return not not (wasdInfo and wasdInfo.button_q == sm.game.getCurrentTick())
				end,
				isR = function()
					local wasdInfo = getWasdInfo(self)
					return not not (wasdInfo and wasdInfo.button_r == sm.game.getCurrentTick())
				end
            }
        }
    }
end

function wasd:server_onFixedUpdate()
    local parent = self.interactable:getSingleParent()
    if parent then
        self.WS = parent:getPower()
        self.seated = parent:isActive()

		if not self.seated and self._oldSeated then
			sc.wasdInfo[self._oldSeated] = {}
		end

		local seated = parent:getSeatCharacter()
		self._oldSeated = seated and seated.id or self._oldSeated
    else
        self.seated = false
    end
    if not self.seated then
        self.WS = 0
    end
    self.W = self.WS > 0
    self.S = self.WS < 0

    if self.seated ~= self.old_active then
        self.old_active = self.seated
        self.network:sendToClients("cl_setActive", self.old_active)
    end
end

function wasd:sv_dataRequest()
    self.old_active = nil
end

function wasd:client_onCreate()
    self.network:sendToServer("sv_dataRequest")
end

function wasd:client_onFixedUpdate()
    if sm.isHost then
        local ADValue =  0
        local count = 0
        local seated = false
        for k, v in pairs(self.interactable:getParents()) do
            if v:isActive() then
                seated = true
            end
            local _s_uuid = tostring(v:getShape():getShapeUuid())
            if v:getType() == "steering" or _s_uuid == "ccaa33b6-e5bb-4edc-9329-b40f6efe2c9e" or _s_uuid == "e627986c-b7dd-4365-8fd8-a0f8707af63d" then
                ADValue = ADValue + (v:getPoseWeight(0) - 0.5) * 2
                count = count + 1
            elseif v:hasSteering() then
                ADValue = ADValue + v:getSteeringAngle()
                count = count + 1
            else
                ADValue = ADValue + v:getPower()
                count = count + 1
            end
        end
        if count > 0 then
            ADValue = constrain(ADValue / count, -1, 1)
        end

        if not seated then
            ADValue = 0
        end
        self.AD = ADValue
        self.A = ADValue < 0
        self.D = ADValue > 0
    end
end

function wasd:cl_setActive(active)
    self.interactable:setUvFrameIndex(active and 6 or 0)
end
end

dofile("$CONTENT_DATA/Scripts/scmframeworkAPI.lua")
end
--scmframework is a SComputers-based framework for creating scripts for mods
--this file was generated automatically. You can find the utility for generating it in the SComputers files in the directory: USER/documentation/scmframework
--to run the build, run the script in luajit on Windows and specify the path to the SComputers Scripts folder as an argument
--this framework is an official part of SComputers and is freely distributed
--you can embed it in your mods and use it in your scripts when saving this text
--the author's web page: https://igorkll.github.io/logichub/
--SComputers documentation: https://igorkll.github.io/SComputers/
--SComputers in steam: https://steamcommunity.com/sharedfiles/filedetails/?id=2949350596

--The MIT License (MIT)
--Copyright © 2025 BananaPen
--
--Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
--
--The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
--
--THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
